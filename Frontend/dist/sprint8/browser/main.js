var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a3, b3) => {
  for (var prop in b3 ||= {})
    if (__hasOwnProp.call(b3, prop))
      __defNormalProp(a3, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a3, prop, b3[prop]);
    }
  return a3;
};
var __spreadProps = (a3, b3) => __defProps(a3, __getOwnPropDescs(b3));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var step = (x4) => x4.done ? resolve(x4.value) : Promise.resolve(x4.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/mapbox-gl/dist/mapbox-gl.js
var require_mapbox_gl = __commonJS({
  "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
    "use strict";
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.mapboxgl = factory());
    })(exports, function() {
      "use strict";
      var shared, worker, mapboxgl2;
      function define2(_3, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
          var sharedChunk = {};
          shared(sharedChunk);
          mapboxgl2 = chunk(sharedChunk);
          if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
            mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define2(["exports"], function(t3) {
        "use strict";
        var e3 = "3.4.0";
        let r3;
        const n2 = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
          if (null == r3) {
            const t4 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
            try {
              r3 = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t4;
            } catch (e4) {
              r3 = t4;
            }
          }
          return r3;
        }, get API_TILEJSON_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
        }, get API_SPRITE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
        }, get API_FONTS_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
        }, get API_STYLE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
        }, get API_CDN_URL_REGEX() {
          return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
        }, get EVENTS_URL() {
          if (!n2.API_URL) return null;
          try {
            const t4 = new URL(n2.API_URL);
            return "api.mapbox.cn" === t4.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t4.hostname ? "https://events.mapbox.com/events/v2" : null;
          } catch (t4) {
            return null;
          }
        }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf" };
        function i3(t4) {
          return n2.API_URL_REGEX.test(t4);
        }
        function s3(t4) {
          return 0 === t4.indexOf("mapbox:");
        }
        function a3(t4) {
          return n2.API_CDN_URL_REGEX.test(t4);
        }
        function o2(t4) {
          return n2.API_SPRITE_REGEX.test(t4);
        }
        function l3(t4) {
          return n2.API_STYLE_REGEX.test(t4) && !o2(t4);
        }
        const u4 = { create: "create", load: "load", fullLoad: "fullLoad" };
        function c3(t4) {
          const e4 = t4.name.split("?")[0];
          return a3(e4) && e4.includes("mapbox-gl.js") ? "javascript" : a3(e4) && e4.includes("mapbox-gl.css") ? "css" : function(t5) {
            return n2.API_FONTS_REGEX.test(t5);
          }(e4) ? "fontRange" : o2(e4) ? "sprite" : l3(e4) ? "style" : function(t5) {
            return n2.API_TILEJSON_REGEX.test(t5);
          }(e4) ? "tilejson" : "other";
        }
        function h3(t4) {
          return t4 && t4.__esModule && Object.prototype.hasOwnProperty.call(t4, "default") ? t4.default : t4;
        }
        var p3 = {}, f3 = {};
        Object.defineProperty(f3, "__esModule", { value: true }), f3.setMatrixArrayType = function(t4) {
          f3.ARRAY_TYPE = m3 = t4;
        }, f3.toRadian = function(t4) {
          return t4 * g4;
        }, f3.equals = function(t4, e4) {
          return Math.abs(t4 - e4) <= d2 * Math.max(1, Math.abs(t4), Math.abs(e4));
        }, f3.RANDOM = f3.ARRAY_TYPE = f3.EPSILON = void 0;
        var d2 = 1e-6;
        f3.EPSILON = d2;
        var m3 = "undefined" != typeof Float32Array ? Float32Array : Array;
        f3.ARRAY_TYPE = m3;
        var y3 = Math.random;
        f3.RANDOM = y3;
        var g4 = Math.PI / 180;
        Math.hypot || (Math.hypot = function() {
          for (var t4 = 0, e4 = arguments.length; e4--; ) t4 += arguments[e4] * arguments[e4];
          return Math.sqrt(t4);
        });
        var x4 = {};
        function b3(t4) {
          return b3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
            return typeof t5;
          } : function(t5) {
            return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
          }, b3(t4);
        }
        Object.defineProperty(x4, "__esModule", { value: true }), x4.create = function() {
          var t4 = new v3.ARRAY_TYPE(4);
          return v3.ARRAY_TYPE != Float32Array && (t4[1] = 0, t4[2] = 0), t4[0] = 1, t4[3] = 1, t4;
        }, x4.clone = function(t4) {
          var e4 = new v3.ARRAY_TYPE(4);
          return e4[0] = t4[0], e4[1] = t4[1], e4[2] = t4[2], e4[3] = t4[3], e4;
        }, x4.copy = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[3], t4;
        }, x4.identity = function(t4) {
          return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 1, t4;
        }, x4.fromValues = function(t4, e4, r4, n3) {
          var i4 = new v3.ARRAY_TYPE(4);
          return i4[0] = t4, i4[1] = e4, i4[2] = r4, i4[3] = n3, i4;
        }, x4.set = function(t4, e4, r4, n3, i4) {
          return t4[0] = e4, t4[1] = r4, t4[2] = n3, t4[3] = i4, t4;
        }, x4.transpose = function(t4, e4) {
          if (t4 === e4) {
            var r4 = e4[1];
            t4[1] = e4[2], t4[2] = r4;
          } else t4[0] = e4[0], t4[1] = e4[2], t4[2] = e4[1], t4[3] = e4[3];
          return t4;
        }, x4.invert = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = r4 * s4 - i4 * n3;
          return a4 ? (t4[0] = s4 * (a4 = 1 / a4), t4[1] = -n3 * a4, t4[2] = -i4 * a4, t4[3] = r4 * a4, t4) : null;
        }, x4.adjoint = function(t4, e4) {
          var r4 = e4[0];
          return t4[0] = e4[3], t4[1] = -e4[1], t4[2] = -e4[2], t4[3] = r4, t4;
        }, x4.determinant = function(t4) {
          return t4[0] * t4[3] - t4[2] * t4[1];
        }, x4.multiply = w4, x4.rotate = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = Math.sin(r4), l4 = Math.cos(r4);
          return t4[0] = n3 * l4 + s4 * o3, t4[1] = i4 * l4 + a4 * o3, t4[2] = n3 * -o3 + s4 * l4, t4[3] = i4 * -o3 + a4 * l4, t4;
        }, x4.scale = function(t4, e4, r4) {
          var n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = r4[0], o3 = r4[1];
          return t4[0] = e4[0] * a4, t4[1] = n3 * a4, t4[2] = i4 * o3, t4[3] = s4 * o3, t4;
        }, x4.fromRotation = function(t4, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t4[0] = n3, t4[1] = r4, t4[2] = -r4, t4[3] = n3, t4;
        }, x4.fromScaling = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = 0, t4[2] = 0, t4[3] = e4[1], t4;
        }, x4.str = function(t4) {
          return "mat2(" + t4[0] + ", " + t4[1] + ", " + t4[2] + ", " + t4[3] + ")";
        }, x4.frob = function(t4) {
          return Math.hypot(t4[0], t4[1], t4[2], t4[3]);
        }, x4.LDU = function(t4, e4, r4, n3) {
          return t4[2] = n3[2] / n3[0], r4[0] = n3[0], r4[1] = n3[1], r4[3] = n3[3] - t4[2] * r4[1], [t4, e4, r4];
        }, x4.add = function(t4, e4, r4) {
          return t4[0] = e4[0] + r4[0], t4[1] = e4[1] + r4[1], t4[2] = e4[2] + r4[2], t4[3] = e4[3] + r4[3], t4;
        }, x4.subtract = M2, x4.exactEquals = function(t4, e4) {
          return t4[0] === e4[0] && t4[1] === e4[1] && t4[2] === e4[2] && t4[3] === e4[3];
        }, x4.equals = function(t4, e4) {
          var r4 = t4[0], n3 = t4[1], i4 = t4[2], s4 = t4[3], a4 = e4[0], o3 = e4[1], l4 = e4[2], u5 = e4[3];
          return Math.abs(r4 - a4) <= v3.EPSILON * Math.max(1, Math.abs(r4), Math.abs(a4)) && Math.abs(n3 - o3) <= v3.EPSILON * Math.max(1, Math.abs(n3), Math.abs(o3)) && Math.abs(i4 - l4) <= v3.EPSILON * Math.max(1, Math.abs(i4), Math.abs(l4)) && Math.abs(s4 - u5) <= v3.EPSILON * Math.max(1, Math.abs(s4), Math.abs(u5));
        }, x4.multiplyScalar = function(t4, e4, r4) {
          return t4[0] = e4[0] * r4, t4[1] = e4[1] * r4, t4[2] = e4[2] * r4, t4[3] = e4[3] * r4, t4;
        }, x4.multiplyScalarAndAdd = function(t4, e4, r4, n3) {
          return t4[0] = e4[0] + r4[0] * n3, t4[1] = e4[1] + r4[1] * n3, t4[2] = e4[2] + r4[2] * n3, t4[3] = e4[3] + r4[3] * n3, t4;
        }, x4.sub = x4.mul = void 0;
        var v3 = function(t4, e4) {
          if (t4 && t4.__esModule) return t4;
          if (null === t4 || "object" !== b3(t4) && "function" != typeof t4) return { default: t4 };
          var r4 = _3(void 0);
          if (r4 && r4.has(t4)) return r4.get(t4);
          var n3 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t4) if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t4, s4)) {
            var a4 = i4 ? Object.getOwnPropertyDescriptor(t4, s4) : null;
            a4 && (a4.get || a4.set) ? Object.defineProperty(n3, s4, a4) : n3[s4] = t4[s4];
          }
          return n3.default = t4, r4 && r4.set(t4, n3), n3;
        }(f3);
        function _3(t4) {
          if ("function" != typeof WeakMap) return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (_3 = function(t5) {
            return t5 ? r4 : e4;
          })(t4);
        }
        function w4(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = r4[0], l4 = r4[1], u5 = r4[2], c4 = r4[3];
          return t4[0] = n3 * o3 + s4 * l4, t4[1] = i4 * o3 + a4 * l4, t4[2] = n3 * u5 + s4 * c4, t4[3] = i4 * u5 + a4 * c4, t4;
        }
        function M2(t4, e4, r4) {
          return t4[0] = e4[0] - r4[0], t4[1] = e4[1] - r4[1], t4[2] = e4[2] - r4[2], t4[3] = e4[3] - r4[3], t4;
        }
        x4.mul = w4, x4.sub = M2;
        var A3 = {};
        function S2(t4) {
          return S2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
            return typeof t5;
          } : function(t5) {
            return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
          }, S2(t4);
        }
        Object.defineProperty(A3, "__esModule", { value: true }), A3.create = function() {
          var t4 = new I3.ARRAY_TYPE(6);
          return I3.ARRAY_TYPE != Float32Array && (t4[1] = 0, t4[2] = 0, t4[4] = 0, t4[5] = 0), t4[0] = 1, t4[3] = 1, t4;
        }, A3.clone = function(t4) {
          var e4 = new I3.ARRAY_TYPE(6);
          return e4[0] = t4[0], e4[1] = t4[1], e4[2] = t4[2], e4[3] = t4[3], e4[4] = t4[4], e4[5] = t4[5], e4;
        }, A3.copy = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[3], t4[4] = e4[4], t4[5] = e4[5], t4;
        }, A3.identity = function(t4) {
          return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 1, t4[4] = 0, t4[5] = 0, t4;
        }, A3.fromValues = function(t4, e4, r4, n3, i4, s4) {
          var a4 = new I3.ARRAY_TYPE(6);
          return a4[0] = t4, a4[1] = e4, a4[2] = r4, a4[3] = n3, a4[4] = i4, a4[5] = s4, a4;
        }, A3.set = function(t4, e4, r4, n3, i4, s4, a4) {
          return t4[0] = e4, t4[1] = r4, t4[2] = n3, t4[3] = i4, t4[4] = s4, t4[5] = a4, t4;
        }, A3.invert = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = e4[4], o3 = e4[5], l4 = r4 * s4 - n3 * i4;
          return l4 ? (t4[0] = s4 * (l4 = 1 / l4), t4[1] = -n3 * l4, t4[2] = -i4 * l4, t4[3] = r4 * l4, t4[4] = (i4 * o3 - s4 * a4) * l4, t4[5] = (n3 * a4 - r4 * o3) * l4, t4) : null;
        }, A3.determinant = function(t4) {
          return t4[0] * t4[3] - t4[1] * t4[2];
        }, A3.multiply = P3, A3.rotate = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = Math.sin(r4), c4 = Math.cos(r4);
          return t4[0] = n3 * c4 + s4 * u5, t4[1] = i4 * c4 + a4 * u5, t4[2] = n3 * -u5 + s4 * c4, t4[3] = i4 * -u5 + a4 * c4, t4[4] = o3, t4[5] = l4, t4;
        }, A3.scale = function(t4, e4, r4) {
          var n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = e4[4], o3 = e4[5], l4 = r4[0], u5 = r4[1];
          return t4[0] = e4[0] * l4, t4[1] = n3 * l4, t4[2] = i4 * u5, t4[3] = s4 * u5, t4[4] = a4, t4[5] = o3, t4;
        }, A3.translate = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = r4[0], c4 = r4[1];
          return t4[0] = n3, t4[1] = i4, t4[2] = s4, t4[3] = a4, t4[4] = n3 * u5 + s4 * c4 + o3, t4[5] = i4 * u5 + a4 * c4 + l4, t4;
        }, A3.fromRotation = function(t4, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t4[0] = n3, t4[1] = r4, t4[2] = -r4, t4[3] = n3, t4[4] = 0, t4[5] = 0, t4;
        }, A3.fromScaling = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = 0, t4[2] = 0, t4[3] = e4[1], t4[4] = 0, t4[5] = 0, t4;
        }, A3.fromTranslation = function(t4, e4) {
          return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 1, t4[4] = e4[0], t4[5] = e4[1], t4;
        }, A3.str = function(t4) {
          return "mat2d(" + t4[0] + ", " + t4[1] + ", " + t4[2] + ", " + t4[3] + ", " + t4[4] + ", " + t4[5] + ")";
        }, A3.frob = function(t4) {
          return Math.hypot(t4[0], t4[1], t4[2], t4[3], t4[4], t4[5], 1);
        }, A3.add = function(t4, e4, r4) {
          return t4[0] = e4[0] + r4[0], t4[1] = e4[1] + r4[1], t4[2] = e4[2] + r4[2], t4[3] = e4[3] + r4[3], t4[4] = e4[4] + r4[4], t4[5] = e4[5] + r4[5], t4;
        }, A3.subtract = E2, A3.multiplyScalar = function(t4, e4, r4) {
          return t4[0] = e4[0] * r4, t4[1] = e4[1] * r4, t4[2] = e4[2] * r4, t4[3] = e4[3] * r4, t4[4] = e4[4] * r4, t4[5] = e4[5] * r4, t4;
        }, A3.multiplyScalarAndAdd = function(t4, e4, r4, n3) {
          return t4[0] = e4[0] + r4[0] * n3, t4[1] = e4[1] + r4[1] * n3, t4[2] = e4[2] + r4[2] * n3, t4[3] = e4[3] + r4[3] * n3, t4[4] = e4[4] + r4[4] * n3, t4[5] = e4[5] + r4[5] * n3, t4;
        }, A3.exactEquals = function(t4, e4) {
          return t4[0] === e4[0] && t4[1] === e4[1] && t4[2] === e4[2] && t4[3] === e4[3] && t4[4] === e4[4] && t4[5] === e4[5];
        }, A3.equals = function(t4, e4) {
          var r4 = t4[0], n3 = t4[1], i4 = t4[2], s4 = t4[3], a4 = t4[4], o3 = t4[5], l4 = e4[0], u5 = e4[1], c4 = e4[2], h4 = e4[3], p4 = e4[4], f4 = e4[5];
          return Math.abs(r4 - l4) <= I3.EPSILON * Math.max(1, Math.abs(r4), Math.abs(l4)) && Math.abs(n3 - u5) <= I3.EPSILON * Math.max(1, Math.abs(n3), Math.abs(u5)) && Math.abs(i4 - c4) <= I3.EPSILON * Math.max(1, Math.abs(i4), Math.abs(c4)) && Math.abs(s4 - h4) <= I3.EPSILON * Math.max(1, Math.abs(s4), Math.abs(h4)) && Math.abs(a4 - p4) <= I3.EPSILON * Math.max(1, Math.abs(a4), Math.abs(p4)) && Math.abs(o3 - f4) <= I3.EPSILON * Math.max(1, Math.abs(o3), Math.abs(f4));
        }, A3.sub = A3.mul = void 0;
        var I3 = function(t4, e4) {
          if (t4 && t4.__esModule) return t4;
          if (null === t4 || "object" !== S2(t4) && "function" != typeof t4) return { default: t4 };
          var r4 = k3(void 0);
          if (r4 && r4.has(t4)) return r4.get(t4);
          var n3 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t4) if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t4, s4)) {
            var a4 = i4 ? Object.getOwnPropertyDescriptor(t4, s4) : null;
            a4 && (a4.get || a4.set) ? Object.defineProperty(n3, s4, a4) : n3[s4] = t4[s4];
          }
          return n3.default = t4, r4 && r4.set(t4, n3), n3;
        }(f3);
        function k3(t4) {
          if ("function" != typeof WeakMap) return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (k3 = function(t5) {
            return t5 ? r4 : e4;
          })(t4);
        }
        function P3(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = r4[0], c4 = r4[1], h4 = r4[2], p4 = r4[3], f4 = r4[4], d3 = r4[5];
          return t4[0] = n3 * u5 + s4 * c4, t4[1] = i4 * u5 + a4 * c4, t4[2] = n3 * h4 + s4 * p4, t4[3] = i4 * h4 + a4 * p4, t4[4] = n3 * f4 + s4 * d3 + o3, t4[5] = i4 * f4 + a4 * d3 + l4, t4;
        }
        function E2(t4, e4, r4) {
          return t4[0] = e4[0] - r4[0], t4[1] = e4[1] - r4[1], t4[2] = e4[2] - r4[2], t4[3] = e4[3] - r4[3], t4[4] = e4[4] - r4[4], t4[5] = e4[5] - r4[5], t4;
        }
        A3.mul = P3, A3.sub = E2;
        var z3 = {};
        function T4(t4) {
          return T4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
            return typeof t5;
          } : function(t5) {
            return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
          }, T4(t4);
        }
        Object.defineProperty(z3, "__esModule", { value: true }), z3.create = function() {
          var t4 = new B3.ARRAY_TYPE(9);
          return B3.ARRAY_TYPE != Float32Array && (t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[5] = 0, t4[6] = 0, t4[7] = 0), t4[0] = 1, t4[4] = 1, t4[8] = 1, t4;
        }, z3.fromMat4 = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[4], t4[4] = e4[5], t4[5] = e4[6], t4[6] = e4[8], t4[7] = e4[9], t4[8] = e4[10], t4;
        }, z3.clone = function(t4) {
          var e4 = new B3.ARRAY_TYPE(9);
          return e4[0] = t4[0], e4[1] = t4[1], e4[2] = t4[2], e4[3] = t4[3], e4[4] = t4[4], e4[5] = t4[5], e4[6] = t4[6], e4[7] = t4[7], e4[8] = t4[8], e4;
        }, z3.copy = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[3], t4[4] = e4[4], t4[5] = e4[5], t4[6] = e4[6], t4[7] = e4[7], t4[8] = e4[8], t4;
        }, z3.fromValues = function(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
          var u5 = new B3.ARRAY_TYPE(9);
          return u5[0] = t4, u5[1] = e4, u5[2] = r4, u5[3] = n3, u5[4] = i4, u5[5] = s4, u5[6] = a4, u5[7] = o3, u5[8] = l4, u5;
        }, z3.set = function(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5) {
          return t4[0] = e4, t4[1] = r4, t4[2] = n3, t4[3] = i4, t4[4] = s4, t4[5] = a4, t4[6] = o3, t4[7] = l4, t4[8] = u5, t4;
        }, z3.identity = function(t4) {
          return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 1, t4[5] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 1, t4;
        }, z3.transpose = function(t4, e4) {
          if (t4 === e4) {
            var r4 = e4[1], n3 = e4[2], i4 = e4[5];
            t4[1] = e4[3], t4[2] = e4[6], t4[3] = r4, t4[5] = e4[7], t4[6] = n3, t4[7] = i4;
          } else t4[0] = e4[0], t4[1] = e4[3], t4[2] = e4[6], t4[3] = e4[1], t4[4] = e4[4], t4[5] = e4[7], t4[6] = e4[2], t4[7] = e4[5], t4[8] = e4[8];
          return t4;
        }, z3.invert = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = e4[4], o3 = e4[5], l4 = e4[6], u5 = e4[7], c4 = e4[8], h4 = c4 * a4 - o3 * u5, p4 = -c4 * s4 + o3 * l4, f4 = u5 * s4 - a4 * l4, d3 = r4 * h4 + n3 * p4 + i4 * f4;
          return d3 ? (t4[0] = h4 * (d3 = 1 / d3), t4[1] = (-c4 * n3 + i4 * u5) * d3, t4[2] = (o3 * n3 - i4 * a4) * d3, t4[3] = p4 * d3, t4[4] = (c4 * r4 - i4 * l4) * d3, t4[5] = (-o3 * r4 + i4 * s4) * d3, t4[6] = f4 * d3, t4[7] = (-u5 * r4 + n3 * l4) * d3, t4[8] = (a4 * r4 - n3 * s4) * d3, t4) : null;
        }, z3.adjoint = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = e4[4], o3 = e4[5], l4 = e4[6], u5 = e4[7], c4 = e4[8];
          return t4[0] = a4 * c4 - o3 * u5, t4[1] = i4 * u5 - n3 * c4, t4[2] = n3 * o3 - i4 * a4, t4[3] = o3 * l4 - s4 * c4, t4[4] = r4 * c4 - i4 * l4, t4[5] = i4 * s4 - r4 * o3, t4[6] = s4 * u5 - a4 * l4, t4[7] = n3 * l4 - r4 * u5, t4[8] = r4 * a4 - n3 * s4, t4;
        }, z3.determinant = function(t4) {
          var e4 = t4[3], r4 = t4[4], n3 = t4[5], i4 = t4[6], s4 = t4[7], a4 = t4[8];
          return t4[0] * (a4 * r4 - n3 * s4) + t4[1] * (-a4 * e4 + n3 * i4) + t4[2] * (s4 * e4 - r4 * i4);
        }, z3.multiply = R, z3.translate = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = e4[6], c4 = e4[7], h4 = e4[8], p4 = r4[0], f4 = r4[1];
          return t4[0] = n3, t4[1] = i4, t4[2] = s4, t4[3] = a4, t4[4] = o3, t4[5] = l4, t4[6] = p4 * n3 + f4 * a4 + u5, t4[7] = p4 * i4 + f4 * o3 + c4, t4[8] = p4 * s4 + f4 * l4 + h4, t4;
        }, z3.rotate = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = e4[6], c4 = e4[7], h4 = e4[8], p4 = Math.sin(r4), f4 = Math.cos(r4);
          return t4[0] = f4 * n3 + p4 * a4, t4[1] = f4 * i4 + p4 * o3, t4[2] = f4 * s4 + p4 * l4, t4[3] = f4 * a4 - p4 * n3, t4[4] = f4 * o3 - p4 * i4, t4[5] = f4 * l4 - p4 * s4, t4[6] = u5, t4[7] = c4, t4[8] = h4, t4;
        }, z3.scale = function(t4, e4, r4) {
          var n3 = r4[0], i4 = r4[1];
          return t4[0] = n3 * e4[0], t4[1] = n3 * e4[1], t4[2] = n3 * e4[2], t4[3] = i4 * e4[3], t4[4] = i4 * e4[4], t4[5] = i4 * e4[5], t4[6] = e4[6], t4[7] = e4[7], t4[8] = e4[8], t4;
        }, z3.fromTranslation = function(t4, e4) {
          return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 1, t4[5] = 0, t4[6] = e4[0], t4[7] = e4[1], t4[8] = 1, t4;
        }, z3.fromRotation = function(t4, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t4[0] = n3, t4[1] = r4, t4[2] = 0, t4[3] = -r4, t4[4] = n3, t4[5] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 1, t4;
        }, z3.fromScaling = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = e4[1], t4[5] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 1, t4;
        }, z3.fromMat2d = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4[2] = 0, t4[3] = e4[2], t4[4] = e4[3], t4[5] = 0, t4[6] = e4[4], t4[7] = e4[5], t4[8] = 1, t4;
        }, z3.fromQuat = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = r4 + r4, o3 = n3 + n3, l4 = i4 + i4, u5 = r4 * a4, c4 = n3 * a4, h4 = n3 * o3, p4 = i4 * a4, f4 = i4 * o3, d3 = i4 * l4, m4 = s4 * a4, y4 = s4 * o3, g5 = s4 * l4;
          return t4[0] = 1 - h4 - d3, t4[3] = c4 - g5, t4[6] = p4 + y4, t4[1] = c4 + g5, t4[4] = 1 - u5 - d3, t4[7] = f4 - m4, t4[2] = p4 - y4, t4[5] = f4 + m4, t4[8] = 1 - u5 - h4, t4;
        }, z3.normalFromMat4 = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = e4[4], o3 = e4[5], l4 = e4[6], u5 = e4[7], c4 = e4[8], h4 = e4[9], p4 = e4[10], f4 = e4[11], d3 = e4[12], m4 = e4[13], y4 = e4[14], g5 = e4[15], x5 = r4 * o3 - n3 * a4, b4 = r4 * l4 - i4 * a4, v4 = r4 * u5 - s4 * a4, _4 = n3 * l4 - i4 * o3, w5 = n3 * u5 - s4 * o3, M3 = i4 * u5 - s4 * l4, A4 = c4 * m4 - h4 * d3, S3 = c4 * y4 - p4 * d3, I4 = c4 * g5 - f4 * d3, k4 = h4 * y4 - p4 * m4, P4 = h4 * g5 - f4 * m4, E3 = p4 * g5 - f4 * y4, z4 = x5 * E3 - b4 * P4 + v4 * k4 + _4 * I4 - w5 * S3 + M3 * A4;
          return z4 ? (t4[0] = (o3 * E3 - l4 * P4 + u5 * k4) * (z4 = 1 / z4), t4[1] = (l4 * I4 - a4 * E3 - u5 * S3) * z4, t4[2] = (a4 * P4 - o3 * I4 + u5 * A4) * z4, t4[3] = (i4 * P4 - n3 * E3 - s4 * k4) * z4, t4[4] = (r4 * E3 - i4 * I4 + s4 * S3) * z4, t4[5] = (n3 * I4 - r4 * P4 - s4 * A4) * z4, t4[6] = (m4 * M3 - y4 * w5 + g5 * _4) * z4, t4[7] = (y4 * v4 - d3 * M3 - g5 * b4) * z4, t4[8] = (d3 * w5 - m4 * v4 + g5 * x5) * z4, t4) : null;
        }, z3.projection = function(t4, e4, r4) {
          return t4[0] = 2 / e4, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = -2 / r4, t4[5] = 0, t4[6] = -1, t4[7] = 1, t4[8] = 1, t4;
        }, z3.str = function(t4) {
          return "mat3(" + t4[0] + ", " + t4[1] + ", " + t4[2] + ", " + t4[3] + ", " + t4[4] + ", " + t4[5] + ", " + t4[6] + ", " + t4[7] + ", " + t4[8] + ")";
        }, z3.frob = function(t4) {
          return Math.hypot(t4[0], t4[1], t4[2], t4[3], t4[4], t4[5], t4[6], t4[7], t4[8]);
        }, z3.add = function(t4, e4, r4) {
          return t4[0] = e4[0] + r4[0], t4[1] = e4[1] + r4[1], t4[2] = e4[2] + r4[2], t4[3] = e4[3] + r4[3], t4[4] = e4[4] + r4[4], t4[5] = e4[5] + r4[5], t4[6] = e4[6] + r4[6], t4[7] = e4[7] + r4[7], t4[8] = e4[8] + r4[8], t4;
        }, z3.subtract = V3, z3.multiplyScalar = function(t4, e4, r4) {
          return t4[0] = e4[0] * r4, t4[1] = e4[1] * r4, t4[2] = e4[2] * r4, t4[3] = e4[3] * r4, t4[4] = e4[4] * r4, t4[5] = e4[5] * r4, t4[6] = e4[6] * r4, t4[7] = e4[7] * r4, t4[8] = e4[8] * r4, t4;
        }, z3.multiplyScalarAndAdd = function(t4, e4, r4, n3) {
          return t4[0] = e4[0] + r4[0] * n3, t4[1] = e4[1] + r4[1] * n3, t4[2] = e4[2] + r4[2] * n3, t4[3] = e4[3] + r4[3] * n3, t4[4] = e4[4] + r4[4] * n3, t4[5] = e4[5] + r4[5] * n3, t4[6] = e4[6] + r4[6] * n3, t4[7] = e4[7] + r4[7] * n3, t4[8] = e4[8] + r4[8] * n3, t4;
        }, z3.exactEquals = function(t4, e4) {
          return t4[0] === e4[0] && t4[1] === e4[1] && t4[2] === e4[2] && t4[3] === e4[3] && t4[4] === e4[4] && t4[5] === e4[5] && t4[6] === e4[6] && t4[7] === e4[7] && t4[8] === e4[8];
        }, z3.equals = function(t4, e4) {
          var r4 = t4[0], n3 = t4[1], i4 = t4[2], s4 = t4[3], a4 = t4[4], o3 = t4[5], l4 = t4[6], u5 = t4[7], c4 = t4[8], h4 = e4[0], p4 = e4[1], f4 = e4[2], d3 = e4[3], m4 = e4[4], y4 = e4[5], g5 = e4[6], x5 = e4[7], b4 = e4[8];
          return Math.abs(r4 - h4) <= B3.EPSILON * Math.max(1, Math.abs(r4), Math.abs(h4)) && Math.abs(n3 - p4) <= B3.EPSILON * Math.max(1, Math.abs(n3), Math.abs(p4)) && Math.abs(i4 - f4) <= B3.EPSILON * Math.max(1, Math.abs(i4), Math.abs(f4)) && Math.abs(s4 - d3) <= B3.EPSILON * Math.max(1, Math.abs(s4), Math.abs(d3)) && Math.abs(a4 - m4) <= B3.EPSILON * Math.max(1, Math.abs(a4), Math.abs(m4)) && Math.abs(o3 - y4) <= B3.EPSILON * Math.max(1, Math.abs(o3), Math.abs(y4)) && Math.abs(l4 - g5) <= B3.EPSILON * Math.max(1, Math.abs(l4), Math.abs(g5)) && Math.abs(u5 - x5) <= B3.EPSILON * Math.max(1, Math.abs(u5), Math.abs(x5)) && Math.abs(c4 - b4) <= B3.EPSILON * Math.max(1, Math.abs(c4), Math.abs(b4));
        }, z3.sub = z3.mul = void 0;
        var B3 = function(t4, e4) {
          if (t4 && t4.__esModule) return t4;
          if (null === t4 || "object" !== T4(t4) && "function" != typeof t4) return { default: t4 };
          var r4 = C3(void 0);
          if (r4 && r4.has(t4)) return r4.get(t4);
          var n3 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t4) if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t4, s4)) {
            var a4 = i4 ? Object.getOwnPropertyDescriptor(t4, s4) : null;
            a4 && (a4.get || a4.set) ? Object.defineProperty(n3, s4, a4) : n3[s4] = t4[s4];
          }
          return n3.default = t4, r4 && r4.set(t4, n3), n3;
        }(f3);
        function C3(t4) {
          if ("function" != typeof WeakMap) return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (C3 = function(t5) {
            return t5 ? r4 : e4;
          })(t4);
        }
        function R(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = e4[6], c4 = e4[7], h4 = e4[8], p4 = r4[0], f4 = r4[1], d3 = r4[2], m4 = r4[3], y4 = r4[4], g5 = r4[5], x5 = r4[6], b4 = r4[7], v4 = r4[8];
          return t4[0] = p4 * n3 + f4 * a4 + d3 * u5, t4[1] = p4 * i4 + f4 * o3 + d3 * c4, t4[2] = p4 * s4 + f4 * l4 + d3 * h4, t4[3] = m4 * n3 + y4 * a4 + g5 * u5, t4[4] = m4 * i4 + y4 * o3 + g5 * c4, t4[5] = m4 * s4 + y4 * l4 + g5 * h4, t4[6] = x5 * n3 + b4 * a4 + v4 * u5, t4[7] = x5 * i4 + b4 * o3 + v4 * c4, t4[8] = x5 * s4 + b4 * l4 + v4 * h4, t4;
        }
        function V3(t4, e4, r4) {
          return t4[0] = e4[0] - r4[0], t4[1] = e4[1] - r4[1], t4[2] = e4[2] - r4[2], t4[3] = e4[3] - r4[3], t4[4] = e4[4] - r4[4], t4[5] = e4[5] - r4[5], t4[6] = e4[6] - r4[6], t4[7] = e4[7] - r4[7], t4[8] = e4[8] - r4[8], t4;
        }
        z3.mul = R, z3.sub = V3;
        var D3 = {};
        function L3(t4) {
          return L3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
            return typeof t5;
          } : function(t5) {
            return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
          }, L3(t4);
        }
        Object.defineProperty(D3, "__esModule", { value: true }), D3.create = function() {
          var t4 = new F4.ARRAY_TYPE(16);
          return F4.ARRAY_TYPE != Float32Array && (t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0), t4[0] = 1, t4[5] = 1, t4[10] = 1, t4[15] = 1, t4;
        }, D3.clone = function(t4) {
          var e4 = new F4.ARRAY_TYPE(16);
          return e4[0] = t4[0], e4[1] = t4[1], e4[2] = t4[2], e4[3] = t4[3], e4[4] = t4[4], e4[5] = t4[5], e4[6] = t4[6], e4[7] = t4[7], e4[8] = t4[8], e4[9] = t4[9], e4[10] = t4[10], e4[11] = t4[11], e4[12] = t4[12], e4[13] = t4[13], e4[14] = t4[14], e4[15] = t4[15], e4;
        }, D3.copy = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[3], t4[4] = e4[4], t4[5] = e4[5], t4[6] = e4[6], t4[7] = e4[7], t4[8] = e4[8], t4[9] = e4[9], t4[10] = e4[10], t4[11] = e4[11], t4[12] = e4[12], t4[13] = e4[13], t4[14] = e4[14], t4[15] = e4[15], t4;
        }, D3.fromValues = function(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4) {
          var y4 = new F4.ARRAY_TYPE(16);
          return y4[0] = t4, y4[1] = e4, y4[2] = r4, y4[3] = n3, y4[4] = i4, y4[5] = s4, y4[6] = a4, y4[7] = o3, y4[8] = l4, y4[9] = u5, y4[10] = c4, y4[11] = h4, y4[12] = p4, y4[13] = f4, y4[14] = d3, y4[15] = m4, y4;
        }, D3.set = function(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4, y4) {
          return t4[0] = e4, t4[1] = r4, t4[2] = n3, t4[3] = i4, t4[4] = s4, t4[5] = a4, t4[6] = o3, t4[7] = l4, t4[8] = u5, t4[9] = c4, t4[10] = h4, t4[11] = p4, t4[12] = f4, t4[13] = d3, t4[14] = m4, t4[15] = y4, t4;
        }, D3.identity = U2, D3.transpose = function(t4, e4) {
          if (t4 === e4) {
            var r4 = e4[1], n3 = e4[2], i4 = e4[3], s4 = e4[6], a4 = e4[7], o3 = e4[11];
            t4[1] = e4[4], t4[2] = e4[8], t4[3] = e4[12], t4[4] = r4, t4[6] = e4[9], t4[7] = e4[13], t4[8] = n3, t4[9] = s4, t4[11] = e4[14], t4[12] = i4, t4[13] = a4, t4[14] = o3;
          } else t4[0] = e4[0], t4[1] = e4[4], t4[2] = e4[8], t4[3] = e4[12], t4[4] = e4[1], t4[5] = e4[5], t4[6] = e4[9], t4[7] = e4[13], t4[8] = e4[2], t4[9] = e4[6], t4[10] = e4[10], t4[11] = e4[14], t4[12] = e4[3], t4[13] = e4[7], t4[14] = e4[11], t4[15] = e4[15];
          return t4;
        }, D3.invert = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = e4[4], o3 = e4[5], l4 = e4[6], u5 = e4[7], c4 = e4[8], h4 = e4[9], p4 = e4[10], f4 = e4[11], d3 = e4[12], m4 = e4[13], y4 = e4[14], g5 = e4[15], x5 = r4 * o3 - n3 * a4, b4 = r4 * l4 - i4 * a4, v4 = r4 * u5 - s4 * a4, _4 = n3 * l4 - i4 * o3, w5 = n3 * u5 - s4 * o3, M3 = i4 * u5 - s4 * l4, A4 = c4 * m4 - h4 * d3, S3 = c4 * y4 - p4 * d3, I4 = c4 * g5 - f4 * d3, k4 = h4 * y4 - p4 * m4, P4 = h4 * g5 - f4 * m4, E3 = p4 * g5 - f4 * y4, z4 = x5 * E3 - b4 * P4 + v4 * k4 + _4 * I4 - w5 * S3 + M3 * A4;
          return z4 ? (t4[0] = (o3 * E3 - l4 * P4 + u5 * k4) * (z4 = 1 / z4), t4[1] = (i4 * P4 - n3 * E3 - s4 * k4) * z4, t4[2] = (m4 * M3 - y4 * w5 + g5 * _4) * z4, t4[3] = (p4 * w5 - h4 * M3 - f4 * _4) * z4, t4[4] = (l4 * I4 - a4 * E3 - u5 * S3) * z4, t4[5] = (r4 * E3 - i4 * I4 + s4 * S3) * z4, t4[6] = (y4 * v4 - d3 * M3 - g5 * b4) * z4, t4[7] = (c4 * M3 - p4 * v4 + f4 * b4) * z4, t4[8] = (a4 * P4 - o3 * I4 + u5 * A4) * z4, t4[9] = (n3 * I4 - r4 * P4 - s4 * A4) * z4, t4[10] = (d3 * w5 - m4 * v4 + g5 * x5) * z4, t4[11] = (h4 * v4 - c4 * w5 - f4 * x5) * z4, t4[12] = (o3 * S3 - a4 * k4 - l4 * A4) * z4, t4[13] = (r4 * k4 - n3 * S3 + i4 * A4) * z4, t4[14] = (m4 * b4 - d3 * _4 - y4 * x5) * z4, t4[15] = (c4 * _4 - h4 * b4 + p4 * x5) * z4, t4) : null;
        }, D3.adjoint = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = e4[4], o3 = e4[5], l4 = e4[6], u5 = e4[7], c4 = e4[8], h4 = e4[9], p4 = e4[10], f4 = e4[11], d3 = e4[12], m4 = e4[13], y4 = e4[14], g5 = e4[15];
          return t4[0] = o3 * (p4 * g5 - f4 * y4) - h4 * (l4 * g5 - u5 * y4) + m4 * (l4 * f4 - u5 * p4), t4[1] = -(n3 * (p4 * g5 - f4 * y4) - h4 * (i4 * g5 - s4 * y4) + m4 * (i4 * f4 - s4 * p4)), t4[2] = n3 * (l4 * g5 - u5 * y4) - o3 * (i4 * g5 - s4 * y4) + m4 * (i4 * u5 - s4 * l4), t4[3] = -(n3 * (l4 * f4 - u5 * p4) - o3 * (i4 * f4 - s4 * p4) + h4 * (i4 * u5 - s4 * l4)), t4[4] = -(a4 * (p4 * g5 - f4 * y4) - c4 * (l4 * g5 - u5 * y4) + d3 * (l4 * f4 - u5 * p4)), t4[5] = r4 * (p4 * g5 - f4 * y4) - c4 * (i4 * g5 - s4 * y4) + d3 * (i4 * f4 - s4 * p4), t4[6] = -(r4 * (l4 * g5 - u5 * y4) - a4 * (i4 * g5 - s4 * y4) + d3 * (i4 * u5 - s4 * l4)), t4[7] = r4 * (l4 * f4 - u5 * p4) - a4 * (i4 * f4 - s4 * p4) + c4 * (i4 * u5 - s4 * l4), t4[8] = a4 * (h4 * g5 - f4 * m4) - c4 * (o3 * g5 - u5 * m4) + d3 * (o3 * f4 - u5 * h4), t4[9] = -(r4 * (h4 * g5 - f4 * m4) - c4 * (n3 * g5 - s4 * m4) + d3 * (n3 * f4 - s4 * h4)), t4[10] = r4 * (o3 * g5 - u5 * m4) - a4 * (n3 * g5 - s4 * m4) + d3 * (n3 * u5 - s4 * o3), t4[11] = -(r4 * (o3 * f4 - u5 * h4) - a4 * (n3 * f4 - s4 * h4) + c4 * (n3 * u5 - s4 * o3)), t4[12] = -(a4 * (h4 * y4 - p4 * m4) - c4 * (o3 * y4 - l4 * m4) + d3 * (o3 * p4 - l4 * h4)), t4[13] = r4 * (h4 * y4 - p4 * m4) - c4 * (n3 * y4 - i4 * m4) + d3 * (n3 * p4 - i4 * h4), t4[14] = -(r4 * (o3 * y4 - l4 * m4) - a4 * (n3 * y4 - i4 * m4) + d3 * (n3 * l4 - i4 * o3)), t4[15] = r4 * (o3 * p4 - l4 * h4) - a4 * (n3 * p4 - i4 * h4) + c4 * (n3 * l4 - i4 * o3), t4;
        }, D3.determinant = function(t4) {
          var e4 = t4[0], r4 = t4[1], n3 = t4[2], i4 = t4[3], s4 = t4[4], a4 = t4[5], o3 = t4[6], l4 = t4[7], u5 = t4[8], c4 = t4[9], h4 = t4[10], p4 = t4[11], f4 = t4[12], d3 = t4[13], m4 = t4[14], y4 = t4[15];
          return (e4 * a4 - r4 * s4) * (h4 * y4 - p4 * m4) - (e4 * o3 - n3 * s4) * (c4 * y4 - p4 * d3) + (e4 * l4 - i4 * s4) * (c4 * m4 - h4 * d3) + (r4 * o3 - n3 * a4) * (u5 * y4 - p4 * f4) - (r4 * l4 - i4 * a4) * (u5 * m4 - h4 * f4) + (n3 * l4 - i4 * o3) * (u5 * d3 - c4 * f4);
        }, D3.multiply = N3, D3.translate = function(t4, e4, r4) {
          var n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4 = r4[0], y4 = r4[1], g5 = r4[2];
          return e4 === t4 ? (t4[12] = e4[0] * m4 + e4[4] * y4 + e4[8] * g5 + e4[12], t4[13] = e4[1] * m4 + e4[5] * y4 + e4[9] * g5 + e4[13], t4[14] = e4[2] * m4 + e4[6] * y4 + e4[10] * g5 + e4[14], t4[15] = e4[3] * m4 + e4[7] * y4 + e4[11] * g5 + e4[15]) : (i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = e4[6], c4 = e4[7], h4 = e4[8], p4 = e4[9], f4 = e4[10], d3 = e4[11], t4[0] = n3 = e4[0], t4[1] = i4, t4[2] = s4, t4[3] = a4, t4[4] = o3, t4[5] = l4, t4[6] = u5, t4[7] = c4, t4[8] = h4, t4[9] = p4, t4[10] = f4, t4[11] = d3, t4[12] = n3 * m4 + o3 * y4 + h4 * g5 + e4[12], t4[13] = i4 * m4 + l4 * y4 + p4 * g5 + e4[13], t4[14] = s4 * m4 + u5 * y4 + f4 * g5 + e4[14], t4[15] = a4 * m4 + c4 * y4 + d3 * g5 + e4[15]), t4;
        }, D3.scale = function(t4, e4, r4) {
          var n3 = r4[0], i4 = r4[1], s4 = r4[2];
          return t4[0] = e4[0] * n3, t4[1] = e4[1] * n3, t4[2] = e4[2] * n3, t4[3] = e4[3] * n3, t4[4] = e4[4] * i4, t4[5] = e4[5] * i4, t4[6] = e4[6] * i4, t4[7] = e4[7] * i4, t4[8] = e4[8] * s4, t4[9] = e4[9] * s4, t4[10] = e4[10] * s4, t4[11] = e4[11] * s4, t4[12] = e4[12], t4[13] = e4[13], t4[14] = e4[14], t4[15] = e4[15], t4;
        }, D3.rotate = function(t4, e4, r4, n3) {
          var i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4, y4, g5, x5, b4, v4, _4, w5, M3, A4, S3, I4, k4, P4 = n3[0], E3 = n3[1], z4 = n3[2], T5 = Math.hypot(P4, E3, z4);
          return T5 < F4.EPSILON ? null : (P4 *= T5 = 1 / T5, E3 *= T5, z4 *= T5, i4 = Math.sin(r4), s4 = Math.cos(r4), l4 = e4[1], u5 = e4[2], c4 = e4[3], p4 = e4[5], f4 = e4[6], d3 = e4[7], y4 = e4[9], g5 = e4[10], x5 = e4[11], b4 = P4 * P4 * (a4 = 1 - s4) + s4, w5 = P4 * E3 * a4 - z4 * i4, M3 = E3 * E3 * a4 + s4, A4 = z4 * E3 * a4 + P4 * i4, S3 = P4 * z4 * a4 + E3 * i4, I4 = E3 * z4 * a4 - P4 * i4, k4 = z4 * z4 * a4 + s4, t4[0] = (o3 = e4[0]) * b4 + (h4 = e4[4]) * (v4 = E3 * P4 * a4 + z4 * i4) + (m4 = e4[8]) * (_4 = z4 * P4 * a4 - E3 * i4), t4[1] = l4 * b4 + p4 * v4 + y4 * _4, t4[2] = u5 * b4 + f4 * v4 + g5 * _4, t4[3] = c4 * b4 + d3 * v4 + x5 * _4, t4[4] = o3 * w5 + h4 * M3 + m4 * A4, t4[5] = l4 * w5 + p4 * M3 + y4 * A4, t4[6] = u5 * w5 + f4 * M3 + g5 * A4, t4[7] = c4 * w5 + d3 * M3 + x5 * A4, t4[8] = o3 * S3 + h4 * I4 + m4 * k4, t4[9] = l4 * S3 + p4 * I4 + y4 * k4, t4[10] = u5 * S3 + f4 * I4 + g5 * k4, t4[11] = c4 * S3 + d3 * I4 + x5 * k4, e4 !== t4 && (t4[12] = e4[12], t4[13] = e4[13], t4[14] = e4[14], t4[15] = e4[15]), t4);
        }, D3.rotateX = function(t4, e4, r4) {
          var n3 = Math.sin(r4), i4 = Math.cos(r4), s4 = e4[4], a4 = e4[5], o3 = e4[6], l4 = e4[7], u5 = e4[8], c4 = e4[9], h4 = e4[10], p4 = e4[11];
          return e4 !== t4 && (t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[3], t4[12] = e4[12], t4[13] = e4[13], t4[14] = e4[14], t4[15] = e4[15]), t4[4] = s4 * i4 + u5 * n3, t4[5] = a4 * i4 + c4 * n3, t4[6] = o3 * i4 + h4 * n3, t4[7] = l4 * i4 + p4 * n3, t4[8] = u5 * i4 - s4 * n3, t4[9] = c4 * i4 - a4 * n3, t4[10] = h4 * i4 - o3 * n3, t4[11] = p4 * i4 - l4 * n3, t4;
        }, D3.rotateY = function(t4, e4, r4) {
          var n3 = Math.sin(r4), i4 = Math.cos(r4), s4 = e4[0], a4 = e4[1], o3 = e4[2], l4 = e4[3], u5 = e4[8], c4 = e4[9], h4 = e4[10], p4 = e4[11];
          return e4 !== t4 && (t4[4] = e4[4], t4[5] = e4[5], t4[6] = e4[6], t4[7] = e4[7], t4[12] = e4[12], t4[13] = e4[13], t4[14] = e4[14], t4[15] = e4[15]), t4[0] = s4 * i4 - u5 * n3, t4[1] = a4 * i4 - c4 * n3, t4[2] = o3 * i4 - h4 * n3, t4[3] = l4 * i4 - p4 * n3, t4[8] = s4 * n3 + u5 * i4, t4[9] = a4 * n3 + c4 * i4, t4[10] = o3 * n3 + h4 * i4, t4[11] = l4 * n3 + p4 * i4, t4;
        }, D3.rotateZ = function(t4, e4, r4) {
          var n3 = Math.sin(r4), i4 = Math.cos(r4), s4 = e4[0], a4 = e4[1], o3 = e4[2], l4 = e4[3], u5 = e4[4], c4 = e4[5], h4 = e4[6], p4 = e4[7];
          return e4 !== t4 && (t4[8] = e4[8], t4[9] = e4[9], t4[10] = e4[10], t4[11] = e4[11], t4[12] = e4[12], t4[13] = e4[13], t4[14] = e4[14], t4[15] = e4[15]), t4[0] = s4 * i4 + u5 * n3, t4[1] = a4 * i4 + c4 * n3, t4[2] = o3 * i4 + h4 * n3, t4[3] = l4 * i4 + p4 * n3, t4[4] = u5 * i4 - s4 * n3, t4[5] = c4 * i4 - a4 * n3, t4[6] = h4 * i4 - o3 * n3, t4[7] = p4 * i4 - l4 * n3, t4;
        }, D3.fromTranslation = function(t4, e4) {
          return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = 1, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 1, t4[11] = 0, t4[12] = e4[0], t4[13] = e4[1], t4[14] = e4[2], t4[15] = 1, t4;
        }, D3.fromScaling = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = e4[1], t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = e4[2], t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
        }, D3.fromRotation = function(t4, e4, r4) {
          var n3, i4, s4, a4 = r4[0], o3 = r4[1], l4 = r4[2], u5 = Math.hypot(a4, o3, l4);
          return u5 < F4.EPSILON ? null : (a4 *= u5 = 1 / u5, o3 *= u5, l4 *= u5, n3 = Math.sin(e4), i4 = Math.cos(e4), t4[0] = a4 * a4 * (s4 = 1 - i4) + i4, t4[1] = o3 * a4 * s4 + l4 * n3, t4[2] = l4 * a4 * s4 - o3 * n3, t4[3] = 0, t4[4] = a4 * o3 * s4 - l4 * n3, t4[5] = o3 * o3 * s4 + i4, t4[6] = l4 * o3 * s4 + a4 * n3, t4[7] = 0, t4[8] = a4 * l4 * s4 + o3 * n3, t4[9] = o3 * l4 * s4 - a4 * n3, t4[10] = l4 * l4 * s4 + i4, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4);
        }, D3.fromXRotation = function(t4, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = n3, t4[6] = r4, t4[7] = 0, t4[8] = 0, t4[9] = -r4, t4[10] = n3, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
        }, D3.fromYRotation = function(t4, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t4[0] = n3, t4[1] = 0, t4[2] = -r4, t4[3] = 0, t4[4] = 0, t4[5] = 1, t4[6] = 0, t4[7] = 0, t4[8] = r4, t4[9] = 0, t4[10] = n3, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
        }, D3.fromZRotation = function(t4, e4) {
          var r4 = Math.sin(e4), n3 = Math.cos(e4);
          return t4[0] = n3, t4[1] = r4, t4[2] = 0, t4[3] = 0, t4[4] = -r4, t4[5] = n3, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 1, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
        }, D3.fromRotationTranslation = j4, D3.fromQuat2 = function(t4, e4) {
          var r4 = new F4.ARRAY_TYPE(3), n3 = -e4[0], i4 = -e4[1], s4 = -e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = e4[6], c4 = e4[7], h4 = n3 * n3 + i4 * i4 + s4 * s4 + a4 * a4;
          return h4 > 0 ? (r4[0] = 2 * (o3 * a4 + c4 * n3 + l4 * s4 - u5 * i4) / h4, r4[1] = 2 * (l4 * a4 + c4 * i4 + u5 * n3 - o3 * s4) / h4, r4[2] = 2 * (u5 * a4 + c4 * s4 + o3 * i4 - l4 * n3) / h4) : (r4[0] = 2 * (o3 * a4 + c4 * n3 + l4 * s4 - u5 * i4), r4[1] = 2 * (l4 * a4 + c4 * i4 + u5 * n3 - o3 * s4), r4[2] = 2 * (u5 * a4 + c4 * s4 + o3 * i4 - l4 * n3)), j4(t4, e4, r4), t4;
        }, D3.getTranslation = function(t4, e4) {
          return t4[0] = e4[12], t4[1] = e4[13], t4[2] = e4[14], t4;
        }, D3.getScaling = q3, D3.getRotation = function(t4, e4) {
          var r4 = new F4.ARRAY_TYPE(3);
          q3(r4, e4);
          var n3 = 1 / r4[0], i4 = 1 / r4[1], s4 = 1 / r4[2], a4 = e4[0] * n3, o3 = e4[1] * i4, l4 = e4[2] * s4, u5 = e4[4] * n3, c4 = e4[5] * i4, h4 = e4[6] * s4, p4 = e4[8] * n3, f4 = e4[9] * i4, d3 = e4[10] * s4, m4 = a4 + c4 + d3, y4 = 0;
          return m4 > 0 ? (y4 = 2 * Math.sqrt(m4 + 1), t4[3] = 0.25 * y4, t4[0] = (h4 - f4) / y4, t4[1] = (p4 - l4) / y4, t4[2] = (o3 - u5) / y4) : a4 > c4 && a4 > d3 ? (y4 = 2 * Math.sqrt(1 + a4 - c4 - d3), t4[3] = (h4 - f4) / y4, t4[0] = 0.25 * y4, t4[1] = (o3 + u5) / y4, t4[2] = (p4 + l4) / y4) : c4 > d3 ? (y4 = 2 * Math.sqrt(1 + c4 - a4 - d3), t4[3] = (p4 - l4) / y4, t4[0] = (o3 + u5) / y4, t4[1] = 0.25 * y4, t4[2] = (h4 + f4) / y4) : (y4 = 2 * Math.sqrt(1 + d3 - a4 - c4), t4[3] = (o3 - u5) / y4, t4[0] = (p4 + l4) / y4, t4[1] = (h4 + f4) / y4, t4[2] = 0.25 * y4), t4;
        }, D3.fromRotationTranslationScale = function(t4, e4, r4, n3) {
          var i4 = e4[0], s4 = e4[1], a4 = e4[2], o3 = e4[3], l4 = i4 + i4, u5 = s4 + s4, c4 = a4 + a4, h4 = i4 * l4, p4 = i4 * u5, f4 = i4 * c4, d3 = s4 * u5, m4 = s4 * c4, y4 = a4 * c4, g5 = o3 * l4, x5 = o3 * u5, b4 = o3 * c4, v4 = n3[0], _4 = n3[1], w5 = n3[2];
          return t4[0] = (1 - (d3 + y4)) * v4, t4[1] = (p4 + b4) * v4, t4[2] = (f4 - x5) * v4, t4[3] = 0, t4[4] = (p4 - b4) * _4, t4[5] = (1 - (h4 + y4)) * _4, t4[6] = (m4 + g5) * _4, t4[7] = 0, t4[8] = (f4 + x5) * w5, t4[9] = (m4 - g5) * w5, t4[10] = (1 - (h4 + d3)) * w5, t4[11] = 0, t4[12] = r4[0], t4[13] = r4[1], t4[14] = r4[2], t4[15] = 1, t4;
        }, D3.fromRotationTranslationScaleOrigin = function(t4, e4, r4, n3, i4) {
          var s4 = e4[0], a4 = e4[1], o3 = e4[2], l4 = e4[3], u5 = s4 + s4, c4 = a4 + a4, h4 = o3 + o3, p4 = s4 * u5, f4 = s4 * c4, d3 = s4 * h4, m4 = a4 * c4, y4 = a4 * h4, g5 = o3 * h4, x5 = l4 * u5, b4 = l4 * c4, v4 = l4 * h4, _4 = n3[0], w5 = n3[1], M3 = n3[2], A4 = i4[0], S3 = i4[1], I4 = i4[2], k4 = (1 - (m4 + g5)) * _4, P4 = (f4 + v4) * _4, E3 = (d3 - b4) * _4, z4 = (f4 - v4) * w5, T5 = (1 - (p4 + g5)) * w5, B4 = (y4 + x5) * w5, C4 = (d3 + b4) * M3, R2 = (y4 - x5) * M3, V4 = (1 - (p4 + m4)) * M3;
          return t4[0] = k4, t4[1] = P4, t4[2] = E3, t4[3] = 0, t4[4] = z4, t4[5] = T5, t4[6] = B4, t4[7] = 0, t4[8] = C4, t4[9] = R2, t4[10] = V4, t4[11] = 0, t4[12] = r4[0] + A4 - (k4 * A4 + z4 * S3 + C4 * I4), t4[13] = r4[1] + S3 - (P4 * A4 + T5 * S3 + R2 * I4), t4[14] = r4[2] + I4 - (E3 * A4 + B4 * S3 + V4 * I4), t4[15] = 1, t4;
        }, D3.fromQuat = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = r4 + r4, o3 = n3 + n3, l4 = i4 + i4, u5 = r4 * a4, c4 = n3 * a4, h4 = n3 * o3, p4 = i4 * a4, f4 = i4 * o3, d3 = i4 * l4, m4 = s4 * a4, y4 = s4 * o3, g5 = s4 * l4;
          return t4[0] = 1 - h4 - d3, t4[1] = c4 + g5, t4[2] = p4 - y4, t4[3] = 0, t4[4] = c4 - g5, t4[5] = 1 - u5 - d3, t4[6] = f4 + m4, t4[7] = 0, t4[8] = p4 + y4, t4[9] = f4 - m4, t4[10] = 1 - u5 - h4, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
        }, D3.frustum = function(t4, e4, r4, n3, i4, s4, a4) {
          var o3 = 1 / (r4 - e4), l4 = 1 / (i4 - n3), u5 = 1 / (s4 - a4);
          return t4[0] = 2 * s4 * o3, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = 2 * s4 * l4, t4[6] = 0, t4[7] = 0, t4[8] = (r4 + e4) * o3, t4[9] = (i4 + n3) * l4, t4[10] = (a4 + s4) * u5, t4[11] = -1, t4[12] = 0, t4[13] = 0, t4[14] = a4 * s4 * 2 * u5, t4[15] = 0, t4;
        }, D3.perspectiveNO = $3, D3.perspectiveZO = function(t4, e4, r4, n3, i4) {
          var s4, a4 = 1 / Math.tan(e4 / 2);
          return t4[0] = a4 / r4, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = a4, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = -1, t4[12] = 0, t4[13] = 0, t4[15] = 0, null != i4 && i4 !== 1 / 0 ? (t4[10] = i4 * (s4 = 1 / (n3 - i4)), t4[14] = i4 * n3 * s4) : (t4[10] = -1, t4[14] = -n3), t4;
        }, D3.perspectiveFromFieldOfView = function(t4, e4, r4, n3) {
          var i4 = Math.tan(e4.upDegrees * Math.PI / 180), s4 = Math.tan(e4.downDegrees * Math.PI / 180), a4 = Math.tan(e4.leftDegrees * Math.PI / 180), o3 = Math.tan(e4.rightDegrees * Math.PI / 180), l4 = 2 / (a4 + o3), u5 = 2 / (i4 + s4);
          return t4[0] = l4, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = u5, t4[6] = 0, t4[7] = 0, t4[8] = -(a4 - o3) * l4 * 0.5, t4[9] = (i4 - s4) * u5 * 0.5, t4[10] = n3 / (r4 - n3), t4[11] = -1, t4[12] = 0, t4[13] = 0, t4[14] = n3 * r4 / (r4 - n3), t4[15] = 0, t4;
        }, D3.orthoNO = G3, D3.orthoZO = function(t4, e4, r4, n3, i4, s4, a4) {
          var o3 = 1 / (e4 - r4), l4 = 1 / (n3 - i4), u5 = 1 / (s4 - a4);
          return t4[0] = -2 * o3, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = -2 * l4, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = u5, t4[11] = 0, t4[12] = (e4 + r4) * o3, t4[13] = (i4 + n3) * l4, t4[14] = s4 * u5, t4[15] = 1, t4;
        }, D3.lookAt = function(t4, e4, r4, n3) {
          var i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3 = e4[0], m4 = e4[1], y4 = e4[2], g5 = n3[0], x5 = n3[1], b4 = n3[2], v4 = r4[0], _4 = r4[1], w5 = r4[2];
          return Math.abs(d3 - v4) < F4.EPSILON && Math.abs(m4 - _4) < F4.EPSILON && Math.abs(y4 - w5) < F4.EPSILON ? U2(t4) : (c4 = d3 - v4, h4 = m4 - _4, p4 = y4 - w5, i4 = x5 * (p4 *= f4 = 1 / Math.hypot(c4, h4, p4)) - b4 * (h4 *= f4), s4 = b4 * (c4 *= f4) - g5 * p4, a4 = g5 * h4 - x5 * c4, (f4 = Math.hypot(i4, s4, a4)) ? (i4 *= f4 = 1 / f4, s4 *= f4, a4 *= f4) : (i4 = 0, s4 = 0, a4 = 0), o3 = h4 * a4 - p4 * s4, l4 = p4 * i4 - c4 * a4, u5 = c4 * s4 - h4 * i4, (f4 = Math.hypot(o3, l4, u5)) ? (o3 *= f4 = 1 / f4, l4 *= f4, u5 *= f4) : (o3 = 0, l4 = 0, u5 = 0), t4[0] = i4, t4[1] = o3, t4[2] = c4, t4[3] = 0, t4[4] = s4, t4[5] = l4, t4[6] = h4, t4[7] = 0, t4[8] = a4, t4[9] = u5, t4[10] = p4, t4[11] = 0, t4[12] = -(i4 * d3 + s4 * m4 + a4 * y4), t4[13] = -(o3 * d3 + l4 * m4 + u5 * y4), t4[14] = -(c4 * d3 + h4 * m4 + p4 * y4), t4[15] = 1, t4);
        }, D3.targetTo = function(t4, e4, r4, n3) {
          var i4 = e4[0], s4 = e4[1], a4 = e4[2], o3 = n3[0], l4 = n3[1], u5 = n3[2], c4 = i4 - r4[0], h4 = s4 - r4[1], p4 = a4 - r4[2], f4 = c4 * c4 + h4 * h4 + p4 * p4;
          f4 > 0 && (c4 *= f4 = 1 / Math.sqrt(f4), h4 *= f4, p4 *= f4);
          var d3 = l4 * p4 - u5 * h4, m4 = u5 * c4 - o3 * p4, y4 = o3 * h4 - l4 * c4;
          return (f4 = d3 * d3 + m4 * m4 + y4 * y4) > 0 && (d3 *= f4 = 1 / Math.sqrt(f4), m4 *= f4, y4 *= f4), t4[0] = d3, t4[1] = m4, t4[2] = y4, t4[3] = 0, t4[4] = h4 * y4 - p4 * m4, t4[5] = p4 * d3 - c4 * y4, t4[6] = c4 * m4 - h4 * d3, t4[7] = 0, t4[8] = c4, t4[9] = h4, t4[10] = p4, t4[11] = 0, t4[12] = i4, t4[13] = s4, t4[14] = a4, t4[15] = 1, t4;
        }, D3.str = function(t4) {
          return "mat4(" + t4[0] + ", " + t4[1] + ", " + t4[2] + ", " + t4[3] + ", " + t4[4] + ", " + t4[5] + ", " + t4[6] + ", " + t4[7] + ", " + t4[8] + ", " + t4[9] + ", " + t4[10] + ", " + t4[11] + ", " + t4[12] + ", " + t4[13] + ", " + t4[14] + ", " + t4[15] + ")";
        }, D3.frob = function(t4) {
          return Math.hypot(t4[0], t4[1], t4[2], t4[3], t4[4], t4[5], t4[6], t4[7], t4[8], t4[9], t4[10], t4[11], t4[12], t4[13], t4[14], t4[15]);
        }, D3.add = function(t4, e4, r4) {
          return t4[0] = e4[0] + r4[0], t4[1] = e4[1] + r4[1], t4[2] = e4[2] + r4[2], t4[3] = e4[3] + r4[3], t4[4] = e4[4] + r4[4], t4[5] = e4[5] + r4[5], t4[6] = e4[6] + r4[6], t4[7] = e4[7] + r4[7], t4[8] = e4[8] + r4[8], t4[9] = e4[9] + r4[9], t4[10] = e4[10] + r4[10], t4[11] = e4[11] + r4[11], t4[12] = e4[12] + r4[12], t4[13] = e4[13] + r4[13], t4[14] = e4[14] + r4[14], t4[15] = e4[15] + r4[15], t4;
        }, D3.subtract = Q2, D3.multiplyScalar = function(t4, e4, r4) {
          return t4[0] = e4[0] * r4, t4[1] = e4[1] * r4, t4[2] = e4[2] * r4, t4[3] = e4[3] * r4, t4[4] = e4[4] * r4, t4[5] = e4[5] * r4, t4[6] = e4[6] * r4, t4[7] = e4[7] * r4, t4[8] = e4[8] * r4, t4[9] = e4[9] * r4, t4[10] = e4[10] * r4, t4[11] = e4[11] * r4, t4[12] = e4[12] * r4, t4[13] = e4[13] * r4, t4[14] = e4[14] * r4, t4[15] = e4[15] * r4, t4;
        }, D3.multiplyScalarAndAdd = function(t4, e4, r4, n3) {
          return t4[0] = e4[0] + r4[0] * n3, t4[1] = e4[1] + r4[1] * n3, t4[2] = e4[2] + r4[2] * n3, t4[3] = e4[3] + r4[3] * n3, t4[4] = e4[4] + r4[4] * n3, t4[5] = e4[5] + r4[5] * n3, t4[6] = e4[6] + r4[6] * n3, t4[7] = e4[7] + r4[7] * n3, t4[8] = e4[8] + r4[8] * n3, t4[9] = e4[9] + r4[9] * n3, t4[10] = e4[10] + r4[10] * n3, t4[11] = e4[11] + r4[11] * n3, t4[12] = e4[12] + r4[12] * n3, t4[13] = e4[13] + r4[13] * n3, t4[14] = e4[14] + r4[14] * n3, t4[15] = e4[15] + r4[15] * n3, t4;
        }, D3.exactEquals = function(t4, e4) {
          return t4[0] === e4[0] && t4[1] === e4[1] && t4[2] === e4[2] && t4[3] === e4[3] && t4[4] === e4[4] && t4[5] === e4[5] && t4[6] === e4[6] && t4[7] === e4[7] && t4[8] === e4[8] && t4[9] === e4[9] && t4[10] === e4[10] && t4[11] === e4[11] && t4[12] === e4[12] && t4[13] === e4[13] && t4[14] === e4[14] && t4[15] === e4[15];
        }, D3.equals = function(t4, e4) {
          var r4 = t4[0], n3 = t4[1], i4 = t4[2], s4 = t4[3], a4 = t4[4], o3 = t4[5], l4 = t4[6], u5 = t4[7], c4 = t4[8], h4 = t4[9], p4 = t4[10], f4 = t4[11], d3 = t4[12], m4 = t4[13], y4 = t4[14], g5 = t4[15], x5 = e4[0], b4 = e4[1], v4 = e4[2], _4 = e4[3], w5 = e4[4], M3 = e4[5], A4 = e4[6], S3 = e4[7], I4 = e4[8], k4 = e4[9], P4 = e4[10], E3 = e4[11], z4 = e4[12], T5 = e4[13], B4 = e4[14], C4 = e4[15];
          return Math.abs(r4 - x5) <= F4.EPSILON * Math.max(1, Math.abs(r4), Math.abs(x5)) && Math.abs(n3 - b4) <= F4.EPSILON * Math.max(1, Math.abs(n3), Math.abs(b4)) && Math.abs(i4 - v4) <= F4.EPSILON * Math.max(1, Math.abs(i4), Math.abs(v4)) && Math.abs(s4 - _4) <= F4.EPSILON * Math.max(1, Math.abs(s4), Math.abs(_4)) && Math.abs(a4 - w5) <= F4.EPSILON * Math.max(1, Math.abs(a4), Math.abs(w5)) && Math.abs(o3 - M3) <= F4.EPSILON * Math.max(1, Math.abs(o3), Math.abs(M3)) && Math.abs(l4 - A4) <= F4.EPSILON * Math.max(1, Math.abs(l4), Math.abs(A4)) && Math.abs(u5 - S3) <= F4.EPSILON * Math.max(1, Math.abs(u5), Math.abs(S3)) && Math.abs(c4 - I4) <= F4.EPSILON * Math.max(1, Math.abs(c4), Math.abs(I4)) && Math.abs(h4 - k4) <= F4.EPSILON * Math.max(1, Math.abs(h4), Math.abs(k4)) && Math.abs(p4 - P4) <= F4.EPSILON * Math.max(1, Math.abs(p4), Math.abs(P4)) && Math.abs(f4 - E3) <= F4.EPSILON * Math.max(1, Math.abs(f4), Math.abs(E3)) && Math.abs(d3 - z4) <= F4.EPSILON * Math.max(1, Math.abs(d3), Math.abs(z4)) && Math.abs(m4 - T5) <= F4.EPSILON * Math.max(1, Math.abs(m4), Math.abs(T5)) && Math.abs(y4 - B4) <= F4.EPSILON * Math.max(1, Math.abs(y4), Math.abs(B4)) && Math.abs(g5 - C4) <= F4.EPSILON * Math.max(1, Math.abs(g5), Math.abs(C4));
        }, D3.sub = D3.mul = D3.ortho = D3.perspective = void 0;
        var F4 = function(t4, e4) {
          if (t4 && t4.__esModule) return t4;
          if (null === t4 || "object" !== L3(t4) && "function" != typeof t4) return { default: t4 };
          var r4 = O2(void 0);
          if (r4 && r4.has(t4)) return r4.get(t4);
          var n3 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t4) if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t4, s4)) {
            var a4 = i4 ? Object.getOwnPropertyDescriptor(t4, s4) : null;
            a4 && (a4.get || a4.set) ? Object.defineProperty(n3, s4, a4) : n3[s4] = t4[s4];
          }
          return n3.default = t4, r4 && r4.set(t4, n3), n3;
        }(f3);
        function O2(t4) {
          if ("function" != typeof WeakMap) return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (O2 = function(t5) {
            return t5 ? r4 : e4;
          })(t4);
        }
        function U2(t4) {
          return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = 1, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 1, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
        }
        function N3(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = e4[6], c4 = e4[7], h4 = e4[8], p4 = e4[9], f4 = e4[10], d3 = e4[11], m4 = e4[12], y4 = e4[13], g5 = e4[14], x5 = e4[15], b4 = r4[0], v4 = r4[1], _4 = r4[2], w5 = r4[3];
          return t4[0] = b4 * n3 + v4 * o3 + _4 * h4 + w5 * m4, t4[1] = b4 * i4 + v4 * l4 + _4 * p4 + w5 * y4, t4[2] = b4 * s4 + v4 * u5 + _4 * f4 + w5 * g5, t4[3] = b4 * a4 + v4 * c4 + _4 * d3 + w5 * x5, t4[4] = (b4 = r4[4]) * n3 + (v4 = r4[5]) * o3 + (_4 = r4[6]) * h4 + (w5 = r4[7]) * m4, t4[5] = b4 * i4 + v4 * l4 + _4 * p4 + w5 * y4, t4[6] = b4 * s4 + v4 * u5 + _4 * f4 + w5 * g5, t4[7] = b4 * a4 + v4 * c4 + _4 * d3 + w5 * x5, t4[8] = (b4 = r4[8]) * n3 + (v4 = r4[9]) * o3 + (_4 = r4[10]) * h4 + (w5 = r4[11]) * m4, t4[9] = b4 * i4 + v4 * l4 + _4 * p4 + w5 * y4, t4[10] = b4 * s4 + v4 * u5 + _4 * f4 + w5 * g5, t4[11] = b4 * a4 + v4 * c4 + _4 * d3 + w5 * x5, t4[12] = (b4 = r4[12]) * n3 + (v4 = r4[13]) * o3 + (_4 = r4[14]) * h4 + (w5 = r4[15]) * m4, t4[13] = b4 * i4 + v4 * l4 + _4 * p4 + w5 * y4, t4[14] = b4 * s4 + v4 * u5 + _4 * f4 + w5 * g5, t4[15] = b4 * a4 + v4 * c4 + _4 * d3 + w5 * x5, t4;
        }
        function j4(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = n3 + n3, l4 = i4 + i4, u5 = s4 + s4, c4 = n3 * o3, h4 = n3 * l4, p4 = n3 * u5, f4 = i4 * l4, d3 = i4 * u5, m4 = s4 * u5, y4 = a4 * o3, g5 = a4 * l4, x5 = a4 * u5;
          return t4[0] = 1 - (f4 + m4), t4[1] = h4 + x5, t4[2] = p4 - g5, t4[3] = 0, t4[4] = h4 - x5, t4[5] = 1 - (c4 + m4), t4[6] = d3 + y4, t4[7] = 0, t4[8] = p4 + g5, t4[9] = d3 - y4, t4[10] = 1 - (c4 + f4), t4[11] = 0, t4[12] = r4[0], t4[13] = r4[1], t4[14] = r4[2], t4[15] = 1, t4;
        }
        function q3(t4, e4) {
          var r4 = e4[4], n3 = e4[5], i4 = e4[6], s4 = e4[8], a4 = e4[9], o3 = e4[10];
          return t4[0] = Math.hypot(e4[0], e4[1], e4[2]), t4[1] = Math.hypot(r4, n3, i4), t4[2] = Math.hypot(s4, a4, o3), t4;
        }
        function $3(t4, e4, r4, n3, i4) {
          var s4, a4 = 1 / Math.tan(e4 / 2);
          return t4[0] = a4 / r4, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = a4, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = -1, t4[12] = 0, t4[13] = 0, t4[15] = 0, null != i4 && i4 !== 1 / 0 ? (t4[10] = (i4 + n3) * (s4 = 1 / (n3 - i4)), t4[14] = 2 * i4 * n3 * s4) : (t4[10] = -1, t4[14] = -2 * n3), t4;
        }
        function G3(t4, e4, r4, n3, i4, s4, a4) {
          var o3 = 1 / (e4 - r4), l4 = 1 / (n3 - i4), u5 = 1 / (s4 - a4);
          return t4[0] = -2 * o3, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = -2 * l4, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 2 * u5, t4[11] = 0, t4[12] = (e4 + r4) * o3, t4[13] = (i4 + n3) * l4, t4[14] = (a4 + s4) * u5, t4[15] = 1, t4;
        }
        function Q2(t4, e4, r4) {
          return t4[0] = e4[0] - r4[0], t4[1] = e4[1] - r4[1], t4[2] = e4[2] - r4[2], t4[3] = e4[3] - r4[3], t4[4] = e4[4] - r4[4], t4[5] = e4[5] - r4[5], t4[6] = e4[6] - r4[6], t4[7] = e4[7] - r4[7], t4[8] = e4[8] - r4[8], t4[9] = e4[9] - r4[9], t4[10] = e4[10] - r4[10], t4[11] = e4[11] - r4[11], t4[12] = e4[12] - r4[12], t4[13] = e4[13] - r4[13], t4[14] = e4[14] - r4[14], t4[15] = e4[15] - r4[15], t4;
        }
        D3.perspective = $3, D3.ortho = G3, D3.mul = N3, D3.sub = Q2;
        var Y = {}, X2 = {};
        function Z2(t4) {
          return Z2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
            return typeof t5;
          } : function(t5) {
            return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
          }, Z2(t4);
        }
        Object.defineProperty(X2, "__esModule", { value: true }), X2.create = H3, X2.clone = function(t4) {
          var e4 = new K2.ARRAY_TYPE(3);
          return e4[0] = t4[0], e4[1] = t4[1], e4[2] = t4[2], e4;
        }, X2.length = J2, X2.fromValues = function(t4, e4, r4) {
          var n3 = new K2.ARRAY_TYPE(3);
          return n3[0] = t4, n3[1] = e4, n3[2] = r4, n3;
        }, X2.copy = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4;
        }, X2.set = function(t4, e4, r4, n3) {
          return t4[0] = e4, t4[1] = r4, t4[2] = n3, t4;
        }, X2.add = function(t4, e4, r4) {
          return t4[0] = e4[0] + r4[0], t4[1] = e4[1] + r4[1], t4[2] = e4[2] + r4[2], t4;
        }, X2.subtract = tt, X2.multiply = et, X2.divide = rt, X2.ceil = function(t4, e4) {
          return t4[0] = Math.ceil(e4[0]), t4[1] = Math.ceil(e4[1]), t4[2] = Math.ceil(e4[2]), t4;
        }, X2.floor = function(t4, e4) {
          return t4[0] = Math.floor(e4[0]), t4[1] = Math.floor(e4[1]), t4[2] = Math.floor(e4[2]), t4;
        }, X2.min = function(t4, e4, r4) {
          return t4[0] = Math.min(e4[0], r4[0]), t4[1] = Math.min(e4[1], r4[1]), t4[2] = Math.min(e4[2], r4[2]), t4;
        }, X2.max = function(t4, e4, r4) {
          return t4[0] = Math.max(e4[0], r4[0]), t4[1] = Math.max(e4[1], r4[1]), t4[2] = Math.max(e4[2], r4[2]), t4;
        }, X2.round = function(t4, e4) {
          return t4[0] = Math.round(e4[0]), t4[1] = Math.round(e4[1]), t4[2] = Math.round(e4[2]), t4;
        }, X2.scale = function(t4, e4, r4) {
          return t4[0] = e4[0] * r4, t4[1] = e4[1] * r4, t4[2] = e4[2] * r4, t4;
        }, X2.scaleAndAdd = function(t4, e4, r4, n3) {
          return t4[0] = e4[0] + r4[0] * n3, t4[1] = e4[1] + r4[1] * n3, t4[2] = e4[2] + r4[2] * n3, t4;
        }, X2.distance = nt, X2.squaredDistance = it, X2.squaredLength = st, X2.negate = function(t4, e4) {
          return t4[0] = -e4[0], t4[1] = -e4[1], t4[2] = -e4[2], t4;
        }, X2.inverse = function(t4, e4) {
          return t4[0] = 1 / e4[0], t4[1] = 1 / e4[1], t4[2] = 1 / e4[2], t4;
        }, X2.normalize = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = r4 * r4 + n3 * n3 + i4 * i4;
          return s4 > 0 && (s4 = 1 / Math.sqrt(s4)), t4[0] = e4[0] * s4, t4[1] = e4[1] * s4, t4[2] = e4[2] * s4, t4;
        }, X2.dot = at, X2.cross = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = r4[0], o3 = r4[1], l4 = r4[2];
          return t4[0] = i4 * l4 - s4 * o3, t4[1] = s4 * a4 - n3 * l4, t4[2] = n3 * o3 - i4 * a4, t4;
        }, X2.lerp = function(t4, e4, r4, n3) {
          var i4 = e4[0], s4 = e4[1], a4 = e4[2];
          return t4[0] = i4 + n3 * (r4[0] - i4), t4[1] = s4 + n3 * (r4[1] - s4), t4[2] = a4 + n3 * (r4[2] - a4), t4;
        }, X2.hermite = function(t4, e4, r4, n3, i4, s4) {
          var a4 = s4 * s4, o3 = a4 * (2 * s4 - 3) + 1, l4 = a4 * (s4 - 2) + s4, u5 = a4 * (s4 - 1), c4 = a4 * (3 - 2 * s4);
          return t4[0] = e4[0] * o3 + r4[0] * l4 + n3[0] * u5 + i4[0] * c4, t4[1] = e4[1] * o3 + r4[1] * l4 + n3[1] * u5 + i4[1] * c4, t4[2] = e4[2] * o3 + r4[2] * l4 + n3[2] * u5 + i4[2] * c4, t4;
        }, X2.bezier = function(t4, e4, r4, n3, i4, s4) {
          var a4 = 1 - s4, o3 = a4 * a4, l4 = s4 * s4, u5 = o3 * a4, c4 = 3 * s4 * o3, h4 = 3 * l4 * a4, p4 = l4 * s4;
          return t4[0] = e4[0] * u5 + r4[0] * c4 + n3[0] * h4 + i4[0] * p4, t4[1] = e4[1] * u5 + r4[1] * c4 + n3[1] * h4 + i4[1] * p4, t4[2] = e4[2] * u5 + r4[2] * c4 + n3[2] * h4 + i4[2] * p4, t4;
        }, X2.random = function(t4, e4) {
          e4 = e4 || 1;
          var r4 = 2 * K2.RANDOM() * Math.PI, n3 = 2 * K2.RANDOM() - 1, i4 = Math.sqrt(1 - n3 * n3) * e4;
          return t4[0] = Math.cos(r4) * i4, t4[1] = Math.sin(r4) * i4, t4[2] = n3 * e4, t4;
        }, X2.transformMat4 = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = r4[3] * n3 + r4[7] * i4 + r4[11] * s4 + r4[15];
          return t4[0] = (r4[0] * n3 + r4[4] * i4 + r4[8] * s4 + r4[12]) / (a4 = a4 || 1), t4[1] = (r4[1] * n3 + r4[5] * i4 + r4[9] * s4 + r4[13]) / a4, t4[2] = (r4[2] * n3 + r4[6] * i4 + r4[10] * s4 + r4[14]) / a4, t4;
        }, X2.transformMat3 = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2];
          return t4[0] = n3 * r4[0] + i4 * r4[3] + s4 * r4[6], t4[1] = n3 * r4[1] + i4 * r4[4] + s4 * r4[7], t4[2] = n3 * r4[2] + i4 * r4[5] + s4 * r4[8], t4;
        }, X2.transformQuat = function(t4, e4, r4) {
          var n3 = r4[0], i4 = r4[1], s4 = r4[2], a4 = e4[0], o3 = e4[1], l4 = e4[2], u5 = i4 * l4 - s4 * o3, c4 = s4 * a4 - n3 * l4, h4 = n3 * o3 - i4 * a4, p4 = i4 * h4 - s4 * c4, f4 = s4 * u5 - n3 * h4, d3 = n3 * c4 - i4 * u5, m4 = 2 * r4[3];
          return c4 *= m4, h4 *= m4, f4 *= 2, d3 *= 2, t4[0] = a4 + (u5 *= m4) + (p4 *= 2), t4[1] = o3 + c4 + f4, t4[2] = l4 + h4 + d3, t4;
        }, X2.rotateX = function(t4, e4, r4, n3) {
          var i4 = [], s4 = [];
          return i4[0] = e4[0] - r4[0], i4[1] = e4[1] - r4[1], i4[2] = e4[2] - r4[2], s4[0] = i4[0], s4[1] = i4[1] * Math.cos(n3) - i4[2] * Math.sin(n3), s4[2] = i4[1] * Math.sin(n3) + i4[2] * Math.cos(n3), t4[0] = s4[0] + r4[0], t4[1] = s4[1] + r4[1], t4[2] = s4[2] + r4[2], t4;
        }, X2.rotateY = function(t4, e4, r4, n3) {
          var i4 = [], s4 = [];
          return i4[0] = e4[0] - r4[0], i4[1] = e4[1] - r4[1], i4[2] = e4[2] - r4[2], s4[0] = i4[2] * Math.sin(n3) + i4[0] * Math.cos(n3), s4[1] = i4[1], s4[2] = i4[2] * Math.cos(n3) - i4[0] * Math.sin(n3), t4[0] = s4[0] + r4[0], t4[1] = s4[1] + r4[1], t4[2] = s4[2] + r4[2], t4;
        }, X2.rotateZ = function(t4, e4, r4, n3) {
          var i4 = [], s4 = [];
          return i4[0] = e4[0] - r4[0], i4[1] = e4[1] - r4[1], i4[2] = e4[2] - r4[2], s4[0] = i4[0] * Math.cos(n3) - i4[1] * Math.sin(n3), s4[1] = i4[0] * Math.sin(n3) + i4[1] * Math.cos(n3), s4[2] = i4[2], t4[0] = s4[0] + r4[0], t4[1] = s4[1] + r4[1], t4[2] = s4[2] + r4[2], t4;
        }, X2.angle = function(t4, e4) {
          var r4 = t4[0], n3 = t4[1], i4 = t4[2], s4 = e4[0], a4 = e4[1], o3 = e4[2], l4 = Math.sqrt(r4 * r4 + n3 * n3 + i4 * i4) * Math.sqrt(s4 * s4 + a4 * a4 + o3 * o3), u5 = l4 && at(t4, e4) / l4;
          return Math.acos(Math.min(Math.max(u5, -1), 1));
        }, X2.zero = function(t4) {
          return t4[0] = 0, t4[1] = 0, t4[2] = 0, t4;
        }, X2.str = function(t4) {
          return "vec3(" + t4[0] + ", " + t4[1] + ", " + t4[2] + ")";
        }, X2.exactEquals = function(t4, e4) {
          return t4[0] === e4[0] && t4[1] === e4[1] && t4[2] === e4[2];
        }, X2.equals = function(t4, e4) {
          var r4 = t4[0], n3 = t4[1], i4 = t4[2], s4 = e4[0], a4 = e4[1], o3 = e4[2];
          return Math.abs(r4 - s4) <= K2.EPSILON * Math.max(1, Math.abs(r4), Math.abs(s4)) && Math.abs(n3 - a4) <= K2.EPSILON * Math.max(1, Math.abs(n3), Math.abs(a4)) && Math.abs(i4 - o3) <= K2.EPSILON * Math.max(1, Math.abs(i4), Math.abs(o3));
        }, X2.forEach = X2.sqrLen = X2.len = X2.sqrDist = X2.dist = X2.div = X2.mul = X2.sub = void 0;
        var K2 = function(t4, e4) {
          if (t4 && t4.__esModule) return t4;
          if (null === t4 || "object" !== Z2(t4) && "function" != typeof t4) return { default: t4 };
          var r4 = W2(void 0);
          if (r4 && r4.has(t4)) return r4.get(t4);
          var n3 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t4) if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t4, s4)) {
            var a4 = i4 ? Object.getOwnPropertyDescriptor(t4, s4) : null;
            a4 && (a4.get || a4.set) ? Object.defineProperty(n3, s4, a4) : n3[s4] = t4[s4];
          }
          return n3.default = t4, r4 && r4.set(t4, n3), n3;
        }(f3);
        function W2(t4) {
          if ("function" != typeof WeakMap) return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (W2 = function(t5) {
            return t5 ? r4 : e4;
          })(t4);
        }
        function H3() {
          var t4 = new K2.ARRAY_TYPE(3);
          return K2.ARRAY_TYPE != Float32Array && (t4[0] = 0, t4[1] = 0, t4[2] = 0), t4;
        }
        function J2(t4) {
          return Math.hypot(t4[0], t4[1], t4[2]);
        }
        function tt(t4, e4, r4) {
          return t4[0] = e4[0] - r4[0], t4[1] = e4[1] - r4[1], t4[2] = e4[2] - r4[2], t4;
        }
        function et(t4, e4, r4) {
          return t4[0] = e4[0] * r4[0], t4[1] = e4[1] * r4[1], t4[2] = e4[2] * r4[2], t4;
        }
        function rt(t4, e4, r4) {
          return t4[0] = e4[0] / r4[0], t4[1] = e4[1] / r4[1], t4[2] = e4[2] / r4[2], t4;
        }
        function nt(t4, e4) {
          return Math.hypot(e4[0] - t4[0], e4[1] - t4[1], e4[2] - t4[2]);
        }
        function it(t4, e4) {
          var r4 = e4[0] - t4[0], n3 = e4[1] - t4[1], i4 = e4[2] - t4[2];
          return r4 * r4 + n3 * n3 + i4 * i4;
        }
        function st(t4) {
          var e4 = t4[0], r4 = t4[1], n3 = t4[2];
          return e4 * e4 + r4 * r4 + n3 * n3;
        }
        function at(t4, e4) {
          return t4[0] * e4[0] + t4[1] * e4[1] + t4[2] * e4[2];
        }
        X2.sub = tt, X2.mul = et, X2.div = rt, X2.dist = nt, X2.sqrDist = it, X2.len = J2, X2.sqrLen = st;
        var ot, lt = (ot = H3(), function(t4, e4, r4, n3, i4, s4) {
          var a4, o3;
          for (e4 || (e4 = 3), r4 || (r4 = 0), o3 = n3 ? Math.min(n3 * e4 + r4, t4.length) : t4.length, a4 = r4; a4 < o3; a4 += e4) ot[0] = t4[a4], ot[1] = t4[a4 + 1], ot[2] = t4[a4 + 2], i4(ot, ot, s4), t4[a4] = ot[0], t4[a4 + 1] = ot[1], t4[a4 + 2] = ot[2];
          return t4;
        });
        X2.forEach = lt;
        var ut = {};
        function ct(t4) {
          return ct = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
            return typeof t5;
          } : function(t5) {
            return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
          }, ct(t4);
        }
        Object.defineProperty(ut, "__esModule", { value: true }), ut.create = ft, ut.clone = function(t4) {
          var e4 = new ht.ARRAY_TYPE(4);
          return e4[0] = t4[0], e4[1] = t4[1], e4[2] = t4[2], e4[3] = t4[3], e4;
        }, ut.fromValues = function(t4, e4, r4, n3) {
          var i4 = new ht.ARRAY_TYPE(4);
          return i4[0] = t4, i4[1] = e4, i4[2] = r4, i4[3] = n3, i4;
        }, ut.copy = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[3], t4;
        }, ut.set = function(t4, e4, r4, n3, i4) {
          return t4[0] = e4, t4[1] = r4, t4[2] = n3, t4[3] = i4, t4;
        }, ut.add = function(t4, e4, r4) {
          return t4[0] = e4[0] + r4[0], t4[1] = e4[1] + r4[1], t4[2] = e4[2] + r4[2], t4[3] = e4[3] + r4[3], t4;
        }, ut.subtract = dt, ut.multiply = mt, ut.divide = yt, ut.ceil = function(t4, e4) {
          return t4[0] = Math.ceil(e4[0]), t4[1] = Math.ceil(e4[1]), t4[2] = Math.ceil(e4[2]), t4[3] = Math.ceil(e4[3]), t4;
        }, ut.floor = function(t4, e4) {
          return t4[0] = Math.floor(e4[0]), t4[1] = Math.floor(e4[1]), t4[2] = Math.floor(e4[2]), t4[3] = Math.floor(e4[3]), t4;
        }, ut.min = function(t4, e4, r4) {
          return t4[0] = Math.min(e4[0], r4[0]), t4[1] = Math.min(e4[1], r4[1]), t4[2] = Math.min(e4[2], r4[2]), t4[3] = Math.min(e4[3], r4[3]), t4;
        }, ut.max = function(t4, e4, r4) {
          return t4[0] = Math.max(e4[0], r4[0]), t4[1] = Math.max(e4[1], r4[1]), t4[2] = Math.max(e4[2], r4[2]), t4[3] = Math.max(e4[3], r4[3]), t4;
        }, ut.round = function(t4, e4) {
          return t4[0] = Math.round(e4[0]), t4[1] = Math.round(e4[1]), t4[2] = Math.round(e4[2]), t4[3] = Math.round(e4[3]), t4;
        }, ut.scale = function(t4, e4, r4) {
          return t4[0] = e4[0] * r4, t4[1] = e4[1] * r4, t4[2] = e4[2] * r4, t4[3] = e4[3] * r4, t4;
        }, ut.scaleAndAdd = function(t4, e4, r4, n3) {
          return t4[0] = e4[0] + r4[0] * n3, t4[1] = e4[1] + r4[1] * n3, t4[2] = e4[2] + r4[2] * n3, t4[3] = e4[3] + r4[3] * n3, t4;
        }, ut.distance = gt, ut.squaredDistance = xt, ut.length = bt, ut.squaredLength = vt, ut.negate = function(t4, e4) {
          return t4[0] = -e4[0], t4[1] = -e4[1], t4[2] = -e4[2], t4[3] = -e4[3], t4;
        }, ut.inverse = function(t4, e4) {
          return t4[0] = 1 / e4[0], t4[1] = 1 / e4[1], t4[2] = 1 / e4[2], t4[3] = 1 / e4[3], t4;
        }, ut.normalize = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = r4 * r4 + n3 * n3 + i4 * i4 + s4 * s4;
          return a4 > 0 && (a4 = 1 / Math.sqrt(a4)), t4[0] = r4 * a4, t4[1] = n3 * a4, t4[2] = i4 * a4, t4[3] = s4 * a4, t4;
        }, ut.dot = function(t4, e4) {
          return t4[0] * e4[0] + t4[1] * e4[1] + t4[2] * e4[2] + t4[3] * e4[3];
        }, ut.cross = function(t4, e4, r4, n3) {
          var i4 = r4[0] * n3[1] - r4[1] * n3[0], s4 = r4[0] * n3[2] - r4[2] * n3[0], a4 = r4[0] * n3[3] - r4[3] * n3[0], o3 = r4[1] * n3[2] - r4[2] * n3[1], l4 = r4[1] * n3[3] - r4[3] * n3[1], u5 = r4[2] * n3[3] - r4[3] * n3[2], c4 = e4[0], h4 = e4[1], p4 = e4[2], f4 = e4[3];
          return t4[0] = h4 * u5 - p4 * l4 + f4 * o3, t4[1] = -c4 * u5 + p4 * a4 - f4 * s4, t4[2] = c4 * l4 - h4 * a4 + f4 * i4, t4[3] = -c4 * o3 + h4 * s4 - p4 * i4, t4;
        }, ut.lerp = function(t4, e4, r4, n3) {
          var i4 = e4[0], s4 = e4[1], a4 = e4[2], o3 = e4[3];
          return t4[0] = i4 + n3 * (r4[0] - i4), t4[1] = s4 + n3 * (r4[1] - s4), t4[2] = a4 + n3 * (r4[2] - a4), t4[3] = o3 + n3 * (r4[3] - o3), t4;
        }, ut.random = function(t4, e4) {
          var r4, n3, i4, s4, a4, o3;
          e4 = e4 || 1;
          do {
            a4 = (r4 = 2 * ht.RANDOM() - 1) * r4 + (n3 = 2 * ht.RANDOM() - 1) * n3;
          } while (a4 >= 1);
          do {
            o3 = (i4 = 2 * ht.RANDOM() - 1) * i4 + (s4 = 2 * ht.RANDOM() - 1) * s4;
          } while (o3 >= 1);
          var l4 = Math.sqrt((1 - a4) / o3);
          return t4[0] = e4 * r4, t4[1] = e4 * n3, t4[2] = e4 * i4 * l4, t4[3] = e4 * s4 * l4, t4;
        }, ut.transformMat4 = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3];
          return t4[0] = r4[0] * n3 + r4[4] * i4 + r4[8] * s4 + r4[12] * a4, t4[1] = r4[1] * n3 + r4[5] * i4 + r4[9] * s4 + r4[13] * a4, t4[2] = r4[2] * n3 + r4[6] * i4 + r4[10] * s4 + r4[14] * a4, t4[3] = r4[3] * n3 + r4[7] * i4 + r4[11] * s4 + r4[15] * a4, t4;
        }, ut.transformQuat = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = r4[0], o3 = r4[1], l4 = r4[2], u5 = r4[3], c4 = u5 * n3 + o3 * s4 - l4 * i4, h4 = u5 * i4 + l4 * n3 - a4 * s4, p4 = u5 * s4 + a4 * i4 - o3 * n3, f4 = -a4 * n3 - o3 * i4 - l4 * s4;
          return t4[0] = c4 * u5 + f4 * -a4 + h4 * -l4 - p4 * -o3, t4[1] = h4 * u5 + f4 * -o3 + p4 * -a4 - c4 * -l4, t4[2] = p4 * u5 + f4 * -l4 + c4 * -o3 - h4 * -a4, t4[3] = e4[3], t4;
        }, ut.zero = function(t4) {
          return t4[0] = 0, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4;
        }, ut.str = function(t4) {
          return "vec4(" + t4[0] + ", " + t4[1] + ", " + t4[2] + ", " + t4[3] + ")";
        }, ut.exactEquals = function(t4, e4) {
          return t4[0] === e4[0] && t4[1] === e4[1] && t4[2] === e4[2] && t4[3] === e4[3];
        }, ut.equals = function(t4, e4) {
          var r4 = t4[0], n3 = t4[1], i4 = t4[2], s4 = t4[3], a4 = e4[0], o3 = e4[1], l4 = e4[2], u5 = e4[3];
          return Math.abs(r4 - a4) <= ht.EPSILON * Math.max(1, Math.abs(r4), Math.abs(a4)) && Math.abs(n3 - o3) <= ht.EPSILON * Math.max(1, Math.abs(n3), Math.abs(o3)) && Math.abs(i4 - l4) <= ht.EPSILON * Math.max(1, Math.abs(i4), Math.abs(l4)) && Math.abs(s4 - u5) <= ht.EPSILON * Math.max(1, Math.abs(s4), Math.abs(u5));
        }, ut.forEach = ut.sqrLen = ut.len = ut.sqrDist = ut.dist = ut.div = ut.mul = ut.sub = void 0;
        var ht = function(t4, e4) {
          if (t4 && t4.__esModule) return t4;
          if (null === t4 || "object" !== ct(t4) && "function" != typeof t4) return { default: t4 };
          var r4 = pt(void 0);
          if (r4 && r4.has(t4)) return r4.get(t4);
          var n3 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t4) if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t4, s4)) {
            var a4 = i4 ? Object.getOwnPropertyDescriptor(t4, s4) : null;
            a4 && (a4.get || a4.set) ? Object.defineProperty(n3, s4, a4) : n3[s4] = t4[s4];
          }
          return n3.default = t4, r4 && r4.set(t4, n3), n3;
        }(f3);
        function pt(t4) {
          if ("function" != typeof WeakMap) return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (pt = function(t5) {
            return t5 ? r4 : e4;
          })(t4);
        }
        function ft() {
          var t4 = new ht.ARRAY_TYPE(4);
          return ht.ARRAY_TYPE != Float32Array && (t4[0] = 0, t4[1] = 0, t4[2] = 0, t4[3] = 0), t4;
        }
        function dt(t4, e4, r4) {
          return t4[0] = e4[0] - r4[0], t4[1] = e4[1] - r4[1], t4[2] = e4[2] - r4[2], t4[3] = e4[3] - r4[3], t4;
        }
        function mt(t4, e4, r4) {
          return t4[0] = e4[0] * r4[0], t4[1] = e4[1] * r4[1], t4[2] = e4[2] * r4[2], t4[3] = e4[3] * r4[3], t4;
        }
        function yt(t4, e4, r4) {
          return t4[0] = e4[0] / r4[0], t4[1] = e4[1] / r4[1], t4[2] = e4[2] / r4[2], t4[3] = e4[3] / r4[3], t4;
        }
        function gt(t4, e4) {
          return Math.hypot(e4[0] - t4[0], e4[1] - t4[1], e4[2] - t4[2], e4[3] - t4[3]);
        }
        function xt(t4, e4) {
          var r4 = e4[0] - t4[0], n3 = e4[1] - t4[1], i4 = e4[2] - t4[2], s4 = e4[3] - t4[3];
          return r4 * r4 + n3 * n3 + i4 * i4 + s4 * s4;
        }
        function bt(t4) {
          return Math.hypot(t4[0], t4[1], t4[2], t4[3]);
        }
        function vt(t4) {
          var e4 = t4[0], r4 = t4[1], n3 = t4[2], i4 = t4[3];
          return e4 * e4 + r4 * r4 + n3 * n3 + i4 * i4;
        }
        ut.sub = dt, ut.mul = mt, ut.div = yt, ut.dist = gt, ut.sqrDist = xt, ut.len = bt, ut.sqrLen = vt;
        var _t = function() {
          var t4 = ft();
          return function(e4, r4, n3, i4, s4, a4) {
            var o3, l4;
            for (r4 || (r4 = 4), n3 || (n3 = 0), l4 = i4 ? Math.min(i4 * r4 + n3, e4.length) : e4.length, o3 = n3; o3 < l4; o3 += r4) t4[0] = e4[o3], t4[1] = e4[o3 + 1], t4[2] = e4[o3 + 2], t4[3] = e4[o3 + 3], s4(t4, t4, a4), e4[o3] = t4[0], e4[o3 + 1] = t4[1], e4[o3 + 2] = t4[2], e4[o3 + 3] = t4[3];
            return e4;
          };
        }();
        function wt(t4) {
          return wt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
            return typeof t5;
          } : function(t5) {
            return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
          }, wt(t4);
        }
        ut.forEach = _t, Object.defineProperty(Y, "__esModule", { value: true }), Y.create = Et, Y.identity = function(t4) {
          return t4[0] = 0, t4[1] = 0, t4[2] = 0, t4[3] = 1, t4;
        }, Y.setAxisAngle = zt, Y.getAxisAngle = function(t4, e4) {
          var r4 = 2 * Math.acos(e4[3]), n3 = Math.sin(r4 / 2);
          return n3 > Mt.EPSILON ? (t4[0] = e4[0] / n3, t4[1] = e4[1] / n3, t4[2] = e4[2] / n3) : (t4[0] = 1, t4[1] = 0, t4[2] = 0), r4;
        }, Y.getAngle = function(t4, e4) {
          var r4 = Lt(t4, e4);
          return Math.acos(2 * r4 * r4 - 1);
        }, Y.multiply = Tt, Y.rotateX = function(t4, e4, r4) {
          r4 *= 0.5;
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = Math.sin(r4), l4 = Math.cos(r4);
          return t4[0] = n3 * l4 + a4 * o3, t4[1] = i4 * l4 + s4 * o3, t4[2] = s4 * l4 - i4 * o3, t4[3] = a4 * l4 - n3 * o3, t4;
        }, Y.rotateY = function(t4, e4, r4) {
          r4 *= 0.5;
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = Math.sin(r4), l4 = Math.cos(r4);
          return t4[0] = n3 * l4 - s4 * o3, t4[1] = i4 * l4 + a4 * o3, t4[2] = s4 * l4 + n3 * o3, t4[3] = a4 * l4 - i4 * o3, t4;
        }, Y.rotateZ = function(t4, e4, r4) {
          r4 *= 0.5;
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = Math.sin(r4), l4 = Math.cos(r4);
          return t4[0] = n3 * l4 + i4 * o3, t4[1] = i4 * l4 - n3 * o3, t4[2] = s4 * l4 + a4 * o3, t4[3] = a4 * l4 - s4 * o3, t4;
        }, Y.calculateW = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2];
          return t4[0] = r4, t4[1] = n3, t4[2] = i4, t4[3] = Math.sqrt(Math.abs(1 - r4 * r4 - n3 * n3 - i4 * i4)), t4;
        }, Y.exp = Bt, Y.ln = Ct, Y.pow = function(t4, e4, r4) {
          return Ct(t4, e4), Dt(t4, t4, r4), Bt(t4, t4), t4;
        }, Y.slerp = Rt, Y.random = function(t4) {
          var e4 = Mt.RANDOM(), r4 = Mt.RANDOM(), n3 = Mt.RANDOM(), i4 = Math.sqrt(1 - e4), s4 = Math.sqrt(e4);
          return t4[0] = i4 * Math.sin(2 * Math.PI * r4), t4[1] = i4 * Math.cos(2 * Math.PI * r4), t4[2] = s4 * Math.sin(2 * Math.PI * n3), t4[3] = s4 * Math.cos(2 * Math.PI * n3), t4;
        }, Y.invert = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = r4 * r4 + n3 * n3 + i4 * i4 + s4 * s4, o3 = a4 ? 1 / a4 : 0;
          return t4[0] = -r4 * o3, t4[1] = -n3 * o3, t4[2] = -i4 * o3, t4[3] = s4 * o3, t4;
        }, Y.conjugate = function(t4, e4) {
          return t4[0] = -e4[0], t4[1] = -e4[1], t4[2] = -e4[2], t4[3] = e4[3], t4;
        }, Y.fromMat3 = Vt, Y.fromEuler = function(t4, e4, r4, n3) {
          var i4 = 0.5 * Math.PI / 180;
          e4 *= i4, r4 *= i4, n3 *= i4;
          var s4 = Math.sin(e4), a4 = Math.cos(e4), o3 = Math.sin(r4), l4 = Math.cos(r4), u5 = Math.sin(n3), c4 = Math.cos(n3);
          return t4[0] = s4 * l4 * c4 - a4 * o3 * u5, t4[1] = a4 * o3 * c4 + s4 * l4 * u5, t4[2] = a4 * l4 * u5 - s4 * o3 * c4, t4[3] = a4 * l4 * c4 + s4 * o3 * u5, t4;
        }, Y.str = function(t4) {
          return "quat(" + t4[0] + ", " + t4[1] + ", " + t4[2] + ", " + t4[3] + ")";
        }, Y.setAxes = Y.sqlerp = Y.rotationTo = Y.equals = Y.exactEquals = Y.normalize = Y.sqrLen = Y.squaredLength = Y.len = Y.length = Y.lerp = Y.dot = Y.scale = Y.mul = Y.add = Y.set = Y.copy = Y.fromValues = Y.clone = void 0;
        var Mt = Pt(f3), At = Pt(z3), St = Pt(X2), It = Pt(ut);
        function kt(t4) {
          if ("function" != typeof WeakMap) return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (kt = function(t5) {
            return t5 ? r4 : e4;
          })(t4);
        }
        function Pt(t4, e4) {
          if (t4 && t4.__esModule) return t4;
          if (null === t4 || "object" !== wt(t4) && "function" != typeof t4) return { default: t4 };
          var r4 = kt(e4);
          if (r4 && r4.has(t4)) return r4.get(t4);
          var n3 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t4) if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t4, s4)) {
            var a4 = i4 ? Object.getOwnPropertyDescriptor(t4, s4) : null;
            a4 && (a4.get || a4.set) ? Object.defineProperty(n3, s4, a4) : n3[s4] = t4[s4];
          }
          return n3.default = t4, r4 && r4.set(t4, n3), n3;
        }
        function Et() {
          var t4 = new Mt.ARRAY_TYPE(4);
          return Mt.ARRAY_TYPE != Float32Array && (t4[0] = 0, t4[1] = 0, t4[2] = 0), t4[3] = 1, t4;
        }
        function zt(t4, e4, r4) {
          r4 *= 0.5;
          var n3 = Math.sin(r4);
          return t4[0] = n3 * e4[0], t4[1] = n3 * e4[1], t4[2] = n3 * e4[2], t4[3] = Math.cos(r4), t4;
        }
        function Tt(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = r4[0], l4 = r4[1], u5 = r4[2], c4 = r4[3];
          return t4[0] = n3 * c4 + a4 * o3 + i4 * u5 - s4 * l4, t4[1] = i4 * c4 + a4 * l4 + s4 * o3 - n3 * u5, t4[2] = s4 * c4 + a4 * u5 + n3 * l4 - i4 * o3, t4[3] = a4 * c4 - n3 * o3 - i4 * l4 - s4 * u5, t4;
        }
        function Bt(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = Math.sqrt(r4 * r4 + n3 * n3 + i4 * i4), o3 = Math.exp(s4), l4 = a4 > 0 ? o3 * Math.sin(a4) / a4 : 0;
          return t4[0] = r4 * l4, t4[1] = n3 * l4, t4[2] = i4 * l4, t4[3] = o3 * Math.cos(a4), t4;
        }
        function Ct(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = e4[2], s4 = e4[3], a4 = Math.sqrt(r4 * r4 + n3 * n3 + i4 * i4), o3 = a4 > 0 ? Math.atan2(a4, s4) / a4 : 0;
          return t4[0] = r4 * o3, t4[1] = n3 * o3, t4[2] = i4 * o3, t4[3] = 0.5 * Math.log(r4 * r4 + n3 * n3 + i4 * i4 + s4 * s4), t4;
        }
        function Rt(t4, e4, r4, n3) {
          var i4, s4, a4, o3, l4, u5 = e4[0], c4 = e4[1], h4 = e4[2], p4 = e4[3], f4 = r4[0], d3 = r4[1], m4 = r4[2], y4 = r4[3];
          return (s4 = u5 * f4 + c4 * d3 + h4 * m4 + p4 * y4) < 0 && (s4 = -s4, f4 = -f4, d3 = -d3, m4 = -m4, y4 = -y4), 1 - s4 > Mt.EPSILON ? (i4 = Math.acos(s4), a4 = Math.sin(i4), o3 = Math.sin((1 - n3) * i4) / a4, l4 = Math.sin(n3 * i4) / a4) : (o3 = 1 - n3, l4 = n3), t4[0] = o3 * u5 + l4 * f4, t4[1] = o3 * c4 + l4 * d3, t4[2] = o3 * h4 + l4 * m4, t4[3] = o3 * p4 + l4 * y4, t4;
        }
        function Vt(t4, e4) {
          var r4, n3 = e4[0] + e4[4] + e4[8];
          if (n3 > 0) r4 = Math.sqrt(n3 + 1), t4[3] = 0.5 * r4, t4[0] = (e4[5] - e4[7]) * (r4 = 0.5 / r4), t4[1] = (e4[6] - e4[2]) * r4, t4[2] = (e4[1] - e4[3]) * r4;
          else {
            var i4 = 0;
            e4[4] > e4[0] && (i4 = 1), e4[8] > e4[3 * i4 + i4] && (i4 = 2);
            var s4 = (i4 + 1) % 3, a4 = (i4 + 2) % 3;
            r4 = Math.sqrt(e4[3 * i4 + i4] - e4[3 * s4 + s4] - e4[3 * a4 + a4] + 1), t4[i4] = 0.5 * r4, t4[3] = (e4[3 * s4 + a4] - e4[3 * a4 + s4]) * (r4 = 0.5 / r4), t4[s4] = (e4[3 * s4 + i4] + e4[3 * i4 + s4]) * r4, t4[a4] = (e4[3 * a4 + i4] + e4[3 * i4 + a4]) * r4;
          }
          return t4;
        }
        Y.clone = It.clone, Y.fromValues = It.fromValues, Y.copy = It.copy, Y.set = It.set, Y.add = It.add, Y.mul = Tt;
        var Dt = It.scale;
        Y.scale = Dt;
        var Lt = It.dot;
        Y.dot = Lt, Y.lerp = It.lerp;
        var Ft = It.length;
        Y.length = Ft, Y.len = Ft;
        var Ot = It.squaredLength;
        Y.squaredLength = Ot, Y.sqrLen = Ot;
        var Ut = It.normalize;
        Y.normalize = Ut, Y.exactEquals = It.exactEquals, Y.equals = It.equals;
        var Nt, jt, qt, $t = (Nt = St.create(), jt = St.fromValues(1, 0, 0), qt = St.fromValues(0, 1, 0), function(t4, e4, r4) {
          var n3 = St.dot(e4, r4);
          return n3 < -0.999999 ? (St.cross(Nt, jt, e4), St.len(Nt) < 1e-6 && St.cross(Nt, qt, e4), St.normalize(Nt, Nt), zt(t4, Nt, Math.PI), t4) : n3 > 0.999999 ? (t4[0] = 0, t4[1] = 0, t4[2] = 0, t4[3] = 1, t4) : (St.cross(Nt, e4, r4), t4[0] = Nt[0], t4[1] = Nt[1], t4[2] = Nt[2], t4[3] = 1 + n3, Ut(t4, t4));
        });
        Y.rotationTo = $t;
        var Gt, Qt, Yt = (Gt = Et(), Qt = Et(), function(t4, e4, r4, n3, i4, s4) {
          return Rt(Gt, e4, i4, s4), Rt(Qt, r4, n3, s4), Rt(t4, Gt, Qt, 2 * s4 * (1 - s4)), t4;
        });
        Y.sqlerp = Yt;
        var Xt, Zt = (Xt = At.create(), function(t4, e4, r4, n3) {
          return Xt[0] = r4[0], Xt[3] = r4[1], Xt[6] = r4[2], Xt[1] = n3[0], Xt[4] = n3[1], Xt[7] = n3[2], Xt[2] = -e4[0], Xt[5] = -e4[1], Xt[8] = -e4[2], Ut(t4, Vt(t4, Xt));
        });
        Y.setAxes = Zt;
        var Kt = {};
        function Wt(t4) {
          return Wt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
            return typeof t5;
          } : function(t5) {
            return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
          }, Wt(t4);
        }
        Object.defineProperty(Kt, "__esModule", { value: true }), Kt.create = function() {
          var t4 = new Ht.ARRAY_TYPE(8);
          return Ht.ARRAY_TYPE != Float32Array && (t4[0] = 0, t4[1] = 0, t4[2] = 0, t4[4] = 0, t4[5] = 0, t4[6] = 0, t4[7] = 0), t4[3] = 1, t4;
        }, Kt.clone = function(t4) {
          var e4 = new Ht.ARRAY_TYPE(8);
          return e4[0] = t4[0], e4[1] = t4[1], e4[2] = t4[2], e4[3] = t4[3], e4[4] = t4[4], e4[5] = t4[5], e4[6] = t4[6], e4[7] = t4[7], e4;
        }, Kt.fromValues = function(t4, e4, r4, n3, i4, s4, a4, o3) {
          var l4 = new Ht.ARRAY_TYPE(8);
          return l4[0] = t4, l4[1] = e4, l4[2] = r4, l4[3] = n3, l4[4] = i4, l4[5] = s4, l4[6] = a4, l4[7] = o3, l4;
        }, Kt.fromRotationTranslationValues = function(t4, e4, r4, n3, i4, s4, a4) {
          var o3 = new Ht.ARRAY_TYPE(8);
          o3[0] = t4, o3[1] = e4, o3[2] = r4, o3[3] = n3;
          var l4 = 0.5 * i4, u5 = 0.5 * s4, c4 = 0.5 * a4;
          return o3[4] = l4 * n3 + u5 * r4 - c4 * e4, o3[5] = u5 * n3 + c4 * t4 - l4 * r4, o3[6] = c4 * n3 + l4 * e4 - u5 * t4, o3[7] = -l4 * t4 - u5 * e4 - c4 * r4, o3;
        }, Kt.fromRotationTranslation = ne, Kt.fromTranslation = function(t4, e4) {
          return t4[0] = 0, t4[1] = 0, t4[2] = 0, t4[3] = 1, t4[4] = 0.5 * e4[0], t4[5] = 0.5 * e4[1], t4[6] = 0.5 * e4[2], t4[7] = 0, t4;
        }, Kt.fromRotation = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[3], t4[4] = 0, t4[5] = 0, t4[6] = 0, t4[7] = 0, t4;
        }, Kt.fromMat4 = function(t4, e4) {
          var r4 = Jt.create();
          te.getRotation(r4, e4);
          var n3 = new Ht.ARRAY_TYPE(3);
          return te.getTranslation(n3, e4), ne(t4, r4, n3), t4;
        }, Kt.copy = ie, Kt.identity = function(t4) {
          return t4[0] = 0, t4[1] = 0, t4[2] = 0, t4[3] = 1, t4[4] = 0, t4[5] = 0, t4[6] = 0, t4[7] = 0, t4;
        }, Kt.set = function(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
          return t4[0] = e4, t4[1] = r4, t4[2] = n3, t4[3] = i4, t4[4] = s4, t4[5] = a4, t4[6] = o3, t4[7] = l4, t4;
        }, Kt.getDual = function(t4, e4) {
          return t4[0] = e4[4], t4[1] = e4[5], t4[2] = e4[6], t4[3] = e4[7], t4;
        }, Kt.setDual = function(t4, e4) {
          return t4[4] = e4[0], t4[5] = e4[1], t4[6] = e4[2], t4[7] = e4[3], t4;
        }, Kt.getTranslation = function(t4, e4) {
          var r4 = e4[4], n3 = e4[5], i4 = e4[6], s4 = e4[7], a4 = -e4[0], o3 = -e4[1], l4 = -e4[2], u5 = e4[3];
          return t4[0] = 2 * (r4 * u5 + s4 * a4 + n3 * l4 - i4 * o3), t4[1] = 2 * (n3 * u5 + s4 * o3 + i4 * a4 - r4 * l4), t4[2] = 2 * (i4 * u5 + s4 * l4 + r4 * o3 - n3 * a4), t4;
        }, Kt.translate = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = 0.5 * r4[0], l4 = 0.5 * r4[1], u5 = 0.5 * r4[2], c4 = e4[4], h4 = e4[5], p4 = e4[6], f4 = e4[7];
          return t4[0] = n3, t4[1] = i4, t4[2] = s4, t4[3] = a4, t4[4] = a4 * o3 + i4 * u5 - s4 * l4 + c4, t4[5] = a4 * l4 + s4 * o3 - n3 * u5 + h4, t4[6] = a4 * u5 + n3 * l4 - i4 * o3 + p4, t4[7] = -n3 * o3 - i4 * l4 - s4 * u5 + f4, t4;
        }, Kt.rotateX = function(t4, e4, r4) {
          var n3 = -e4[0], i4 = -e4[1], s4 = -e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = e4[6], c4 = e4[7], h4 = o3 * a4 + c4 * n3 + l4 * s4 - u5 * i4, p4 = l4 * a4 + c4 * i4 + u5 * n3 - o3 * s4, f4 = u5 * a4 + c4 * s4 + o3 * i4 - l4 * n3, d3 = c4 * a4 - o3 * n3 - l4 * i4 - u5 * s4;
          return Jt.rotateX(t4, e4, r4), t4[4] = h4 * (a4 = t4[3]) + d3 * (n3 = t4[0]) + p4 * (s4 = t4[2]) - f4 * (i4 = t4[1]), t4[5] = p4 * a4 + d3 * i4 + f4 * n3 - h4 * s4, t4[6] = f4 * a4 + d3 * s4 + h4 * i4 - p4 * n3, t4[7] = d3 * a4 - h4 * n3 - p4 * i4 - f4 * s4, t4;
        }, Kt.rotateY = function(t4, e4, r4) {
          var n3 = -e4[0], i4 = -e4[1], s4 = -e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = e4[6], c4 = e4[7], h4 = o3 * a4 + c4 * n3 + l4 * s4 - u5 * i4, p4 = l4 * a4 + c4 * i4 + u5 * n3 - o3 * s4, f4 = u5 * a4 + c4 * s4 + o3 * i4 - l4 * n3, d3 = c4 * a4 - o3 * n3 - l4 * i4 - u5 * s4;
          return Jt.rotateY(t4, e4, r4), t4[4] = h4 * (a4 = t4[3]) + d3 * (n3 = t4[0]) + p4 * (s4 = t4[2]) - f4 * (i4 = t4[1]), t4[5] = p4 * a4 + d3 * i4 + f4 * n3 - h4 * s4, t4[6] = f4 * a4 + d3 * s4 + h4 * i4 - p4 * n3, t4[7] = d3 * a4 - h4 * n3 - p4 * i4 - f4 * s4, t4;
        }, Kt.rotateZ = function(t4, e4, r4) {
          var n3 = -e4[0], i4 = -e4[1], s4 = -e4[2], a4 = e4[3], o3 = e4[4], l4 = e4[5], u5 = e4[6], c4 = e4[7], h4 = o3 * a4 + c4 * n3 + l4 * s4 - u5 * i4, p4 = l4 * a4 + c4 * i4 + u5 * n3 - o3 * s4, f4 = u5 * a4 + c4 * s4 + o3 * i4 - l4 * n3, d3 = c4 * a4 - o3 * n3 - l4 * i4 - u5 * s4;
          return Jt.rotateZ(t4, e4, r4), t4[4] = h4 * (a4 = t4[3]) + d3 * (n3 = t4[0]) + p4 * (s4 = t4[2]) - f4 * (i4 = t4[1]), t4[5] = p4 * a4 + d3 * i4 + f4 * n3 - h4 * s4, t4[6] = f4 * a4 + d3 * s4 + h4 * i4 - p4 * n3, t4[7] = d3 * a4 - h4 * n3 - p4 * i4 - f4 * s4, t4;
        }, Kt.rotateByQuatAppend = function(t4, e4, r4) {
          var n3 = r4[0], i4 = r4[1], s4 = r4[2], a4 = r4[3], o3 = e4[0], l4 = e4[1], u5 = e4[2], c4 = e4[3];
          return t4[0] = o3 * a4 + c4 * n3 + l4 * s4 - u5 * i4, t4[1] = l4 * a4 + c4 * i4 + u5 * n3 - o3 * s4, t4[2] = u5 * a4 + c4 * s4 + o3 * i4 - l4 * n3, t4[3] = c4 * a4 - o3 * n3 - l4 * i4 - u5 * s4, t4[4] = (o3 = e4[4]) * a4 + (c4 = e4[7]) * n3 + (l4 = e4[5]) * s4 - (u5 = e4[6]) * i4, t4[5] = l4 * a4 + c4 * i4 + u5 * n3 - o3 * s4, t4[6] = u5 * a4 + c4 * s4 + o3 * i4 - l4 * n3, t4[7] = c4 * a4 - o3 * n3 - l4 * i4 - u5 * s4, t4;
        }, Kt.rotateByQuatPrepend = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = r4[0], l4 = r4[1], u5 = r4[2], c4 = r4[3];
          return t4[0] = n3 * c4 + a4 * o3 + i4 * u5 - s4 * l4, t4[1] = i4 * c4 + a4 * l4 + s4 * o3 - n3 * u5, t4[2] = s4 * c4 + a4 * u5 + n3 * l4 - i4 * o3, t4[3] = a4 * c4 - n3 * o3 - i4 * l4 - s4 * u5, t4[4] = n3 * (c4 = r4[7]) + a4 * (o3 = r4[4]) + i4 * (u5 = r4[6]) - s4 * (l4 = r4[5]), t4[5] = i4 * c4 + a4 * l4 + s4 * o3 - n3 * u5, t4[6] = s4 * c4 + a4 * u5 + n3 * l4 - i4 * o3, t4[7] = a4 * c4 - n3 * o3 - i4 * l4 - s4 * u5, t4;
        }, Kt.rotateAroundAxis = function(t4, e4, r4, n3) {
          if (Math.abs(n3) < Ht.EPSILON) return ie(t4, e4);
          var i4 = Math.hypot(r4[0], r4[1], r4[2]);
          n3 *= 0.5;
          var s4 = Math.sin(n3), a4 = s4 * r4[0] / i4, o3 = s4 * r4[1] / i4, l4 = s4 * r4[2] / i4, u5 = Math.cos(n3), c4 = e4[0], h4 = e4[1], p4 = e4[2], f4 = e4[3];
          t4[0] = c4 * u5 + f4 * a4 + h4 * l4 - p4 * o3, t4[1] = h4 * u5 + f4 * o3 + p4 * a4 - c4 * l4, t4[2] = p4 * u5 + f4 * l4 + c4 * o3 - h4 * a4, t4[3] = f4 * u5 - c4 * a4 - h4 * o3 - p4 * l4;
          var d3 = e4[4], m4 = e4[5], y4 = e4[6], g5 = e4[7];
          return t4[4] = d3 * u5 + g5 * a4 + m4 * l4 - y4 * o3, t4[5] = m4 * u5 + g5 * o3 + y4 * a4 - d3 * l4, t4[6] = y4 * u5 + g5 * l4 + d3 * o3 - m4 * a4, t4[7] = g5 * u5 - d3 * a4 - m4 * o3 - y4 * l4, t4;
        }, Kt.add = function(t4, e4, r4) {
          return t4[0] = e4[0] + r4[0], t4[1] = e4[1] + r4[1], t4[2] = e4[2] + r4[2], t4[3] = e4[3] + r4[3], t4[4] = e4[4] + r4[4], t4[5] = e4[5] + r4[5], t4[6] = e4[6] + r4[6], t4[7] = e4[7] + r4[7], t4;
        }, Kt.multiply = se, Kt.scale = function(t4, e4, r4) {
          return t4[0] = e4[0] * r4, t4[1] = e4[1] * r4, t4[2] = e4[2] * r4, t4[3] = e4[3] * r4, t4[4] = e4[4] * r4, t4[5] = e4[5] * r4, t4[6] = e4[6] * r4, t4[7] = e4[7] * r4, t4;
        }, Kt.lerp = function(t4, e4, r4, n3) {
          var i4 = 1 - n3;
          return ae(e4, r4) < 0 && (n3 = -n3), t4[0] = e4[0] * i4 + r4[0] * n3, t4[1] = e4[1] * i4 + r4[1] * n3, t4[2] = e4[2] * i4 + r4[2] * n3, t4[3] = e4[3] * i4 + r4[3] * n3, t4[4] = e4[4] * i4 + r4[4] * n3, t4[5] = e4[5] * i4 + r4[5] * n3, t4[6] = e4[6] * i4 + r4[6] * n3, t4[7] = e4[7] * i4 + r4[7] * n3, t4;
        }, Kt.invert = function(t4, e4) {
          var r4 = le(e4);
          return t4[0] = -e4[0] / r4, t4[1] = -e4[1] / r4, t4[2] = -e4[2] / r4, t4[3] = e4[3] / r4, t4[4] = -e4[4] / r4, t4[5] = -e4[5] / r4, t4[6] = -e4[6] / r4, t4[7] = e4[7] / r4, t4;
        }, Kt.conjugate = function(t4, e4) {
          return t4[0] = -e4[0], t4[1] = -e4[1], t4[2] = -e4[2], t4[3] = e4[3], t4[4] = -e4[4], t4[5] = -e4[5], t4[6] = -e4[6], t4[7] = e4[7], t4;
        }, Kt.normalize = function(t4, e4) {
          var r4 = le(e4);
          if (r4 > 0) {
            r4 = Math.sqrt(r4);
            var n3 = e4[0] / r4, i4 = e4[1] / r4, s4 = e4[2] / r4, a4 = e4[3] / r4, o3 = e4[4], l4 = e4[5], u5 = e4[6], c4 = e4[7], h4 = n3 * o3 + i4 * l4 + s4 * u5 + a4 * c4;
            t4[0] = n3, t4[1] = i4, t4[2] = s4, t4[3] = a4, t4[4] = (o3 - n3 * h4) / r4, t4[5] = (l4 - i4 * h4) / r4, t4[6] = (u5 - s4 * h4) / r4, t4[7] = (c4 - a4 * h4) / r4;
          }
          return t4;
        }, Kt.str = function(t4) {
          return "quat2(" + t4[0] + ", " + t4[1] + ", " + t4[2] + ", " + t4[3] + ", " + t4[4] + ", " + t4[5] + ", " + t4[6] + ", " + t4[7] + ")";
        }, Kt.exactEquals = function(t4, e4) {
          return t4[0] === e4[0] && t4[1] === e4[1] && t4[2] === e4[2] && t4[3] === e4[3] && t4[4] === e4[4] && t4[5] === e4[5] && t4[6] === e4[6] && t4[7] === e4[7];
        }, Kt.equals = function(t4, e4) {
          var r4 = t4[0], n3 = t4[1], i4 = t4[2], s4 = t4[3], a4 = t4[4], o3 = t4[5], l4 = t4[6], u5 = t4[7], c4 = e4[0], h4 = e4[1], p4 = e4[2], f4 = e4[3], d3 = e4[4], m4 = e4[5], y4 = e4[6], g5 = e4[7];
          return Math.abs(r4 - c4) <= Ht.EPSILON * Math.max(1, Math.abs(r4), Math.abs(c4)) && Math.abs(n3 - h4) <= Ht.EPSILON * Math.max(1, Math.abs(n3), Math.abs(h4)) && Math.abs(i4 - p4) <= Ht.EPSILON * Math.max(1, Math.abs(i4), Math.abs(p4)) && Math.abs(s4 - f4) <= Ht.EPSILON * Math.max(1, Math.abs(s4), Math.abs(f4)) && Math.abs(a4 - d3) <= Ht.EPSILON * Math.max(1, Math.abs(a4), Math.abs(d3)) && Math.abs(o3 - m4) <= Ht.EPSILON * Math.max(1, Math.abs(o3), Math.abs(m4)) && Math.abs(l4 - y4) <= Ht.EPSILON * Math.max(1, Math.abs(l4), Math.abs(y4)) && Math.abs(u5 - g5) <= Ht.EPSILON * Math.max(1, Math.abs(u5), Math.abs(g5));
        }, Kt.sqrLen = Kt.squaredLength = Kt.len = Kt.length = Kt.dot = Kt.mul = Kt.setReal = Kt.getReal = void 0;
        var Ht = re(f3), Jt = re(Y), te = re(D3);
        function ee(t4) {
          if ("function" != typeof WeakMap) return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (ee = function(t5) {
            return t5 ? r4 : e4;
          })(t4);
        }
        function re(t4, e4) {
          if (t4 && t4.__esModule) return t4;
          if (null === t4 || "object" !== Wt(t4) && "function" != typeof t4) return { default: t4 };
          var r4 = ee(e4);
          if (r4 && r4.has(t4)) return r4.get(t4);
          var n3 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t4) if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t4, s4)) {
            var a4 = i4 ? Object.getOwnPropertyDescriptor(t4, s4) : null;
            a4 && (a4.get || a4.set) ? Object.defineProperty(n3, s4, a4) : n3[s4] = t4[s4];
          }
          return n3.default = t4, r4 && r4.set(t4, n3), n3;
        }
        function ne(t4, e4, r4) {
          var n3 = 0.5 * r4[0], i4 = 0.5 * r4[1], s4 = 0.5 * r4[2], a4 = e4[0], o3 = e4[1], l4 = e4[2], u5 = e4[3];
          return t4[0] = a4, t4[1] = o3, t4[2] = l4, t4[3] = u5, t4[4] = n3 * u5 + i4 * l4 - s4 * o3, t4[5] = i4 * u5 + s4 * a4 - n3 * l4, t4[6] = s4 * u5 + n3 * o3 - i4 * a4, t4[7] = -n3 * a4 - i4 * o3 - s4 * l4, t4;
        }
        function ie(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[3], t4[4] = e4[4], t4[5] = e4[5], t4[6] = e4[6], t4[7] = e4[7], t4;
        }
        function se(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1], s4 = e4[2], a4 = e4[3], o3 = r4[4], l4 = r4[5], u5 = r4[6], c4 = r4[7], h4 = e4[4], p4 = e4[5], f4 = e4[6], d3 = e4[7], m4 = r4[0], y4 = r4[1], g5 = r4[2], x5 = r4[3];
          return t4[0] = n3 * x5 + a4 * m4 + i4 * g5 - s4 * y4, t4[1] = i4 * x5 + a4 * y4 + s4 * m4 - n3 * g5, t4[2] = s4 * x5 + a4 * g5 + n3 * y4 - i4 * m4, t4[3] = a4 * x5 - n3 * m4 - i4 * y4 - s4 * g5, t4[4] = n3 * c4 + a4 * o3 + i4 * u5 - s4 * l4 + h4 * x5 + d3 * m4 + p4 * g5 - f4 * y4, t4[5] = i4 * c4 + a4 * l4 + s4 * o3 - n3 * u5 + p4 * x5 + d3 * y4 + f4 * m4 - h4 * g5, t4[6] = s4 * c4 + a4 * u5 + n3 * l4 - i4 * o3 + f4 * x5 + d3 * g5 + h4 * y4 - p4 * m4, t4[7] = a4 * c4 - n3 * o3 - i4 * l4 - s4 * u5 + d3 * x5 - h4 * m4 - p4 * y4 - f4 * g5, t4;
        }
        Kt.getReal = Jt.copy, Kt.setReal = Jt.copy, Kt.mul = se;
        var ae = Jt.dot;
        Kt.dot = ae;
        var oe = Jt.length;
        Kt.length = oe, Kt.len = oe;
        var le = Jt.squaredLength;
        Kt.squaredLength = le, Kt.sqrLen = le;
        var ue = {};
        function ce(t4) {
          return ce = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
            return typeof t5;
          } : function(t5) {
            return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
          }, ce(t4);
        }
        Object.defineProperty(ue, "__esModule", { value: true }), ue.create = fe, ue.clone = function(t4) {
          var e4 = new he.ARRAY_TYPE(2);
          return e4[0] = t4[0], e4[1] = t4[1], e4;
        }, ue.fromValues = function(t4, e4) {
          var r4 = new he.ARRAY_TYPE(2);
          return r4[0] = t4, r4[1] = e4, r4;
        }, ue.copy = function(t4, e4) {
          return t4[0] = e4[0], t4[1] = e4[1], t4;
        }, ue.set = function(t4, e4, r4) {
          return t4[0] = e4, t4[1] = r4, t4;
        }, ue.add = function(t4, e4, r4) {
          return t4[0] = e4[0] + r4[0], t4[1] = e4[1] + r4[1], t4;
        }, ue.subtract = de, ue.multiply = me, ue.divide = ye, ue.ceil = function(t4, e4) {
          return t4[0] = Math.ceil(e4[0]), t4[1] = Math.ceil(e4[1]), t4;
        }, ue.floor = function(t4, e4) {
          return t4[0] = Math.floor(e4[0]), t4[1] = Math.floor(e4[1]), t4;
        }, ue.min = function(t4, e4, r4) {
          return t4[0] = Math.min(e4[0], r4[0]), t4[1] = Math.min(e4[1], r4[1]), t4;
        }, ue.max = function(t4, e4, r4) {
          return t4[0] = Math.max(e4[0], r4[0]), t4[1] = Math.max(e4[1], r4[1]), t4;
        }, ue.round = function(t4, e4) {
          return t4[0] = Math.round(e4[0]), t4[1] = Math.round(e4[1]), t4;
        }, ue.scale = function(t4, e4, r4) {
          return t4[0] = e4[0] * r4, t4[1] = e4[1] * r4, t4;
        }, ue.scaleAndAdd = function(t4, e4, r4, n3) {
          return t4[0] = e4[0] + r4[0] * n3, t4[1] = e4[1] + r4[1] * n3, t4;
        }, ue.distance = ge, ue.squaredDistance = xe, ue.length = be, ue.squaredLength = ve, ue.negate = function(t4, e4) {
          return t4[0] = -e4[0], t4[1] = -e4[1], t4;
        }, ue.inverse = function(t4, e4) {
          return t4[0] = 1 / e4[0], t4[1] = 1 / e4[1], t4;
        }, ue.normalize = function(t4, e4) {
          var r4 = e4[0], n3 = e4[1], i4 = r4 * r4 + n3 * n3;
          return i4 > 0 && (i4 = 1 / Math.sqrt(i4)), t4[0] = e4[0] * i4, t4[1] = e4[1] * i4, t4;
        }, ue.dot = function(t4, e4) {
          return t4[0] * e4[0] + t4[1] * e4[1];
        }, ue.cross = function(t4, e4, r4) {
          var n3 = e4[0] * r4[1] - e4[1] * r4[0];
          return t4[0] = t4[1] = 0, t4[2] = n3, t4;
        }, ue.lerp = function(t4, e4, r4, n3) {
          var i4 = e4[0], s4 = e4[1];
          return t4[0] = i4 + n3 * (r4[0] - i4), t4[1] = s4 + n3 * (r4[1] - s4), t4;
        }, ue.random = function(t4, e4) {
          e4 = e4 || 1;
          var r4 = 2 * he.RANDOM() * Math.PI;
          return t4[0] = Math.cos(r4) * e4, t4[1] = Math.sin(r4) * e4, t4;
        }, ue.transformMat2 = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1];
          return t4[0] = r4[0] * n3 + r4[2] * i4, t4[1] = r4[1] * n3 + r4[3] * i4, t4;
        }, ue.transformMat2d = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1];
          return t4[0] = r4[0] * n3 + r4[2] * i4 + r4[4], t4[1] = r4[1] * n3 + r4[3] * i4 + r4[5], t4;
        }, ue.transformMat3 = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1];
          return t4[0] = r4[0] * n3 + r4[3] * i4 + r4[6], t4[1] = r4[1] * n3 + r4[4] * i4 + r4[7], t4;
        }, ue.transformMat4 = function(t4, e4, r4) {
          var n3 = e4[0], i4 = e4[1];
          return t4[0] = r4[0] * n3 + r4[4] * i4 + r4[12], t4[1] = r4[1] * n3 + r4[5] * i4 + r4[13], t4;
        }, ue.rotate = function(t4, e4, r4, n3) {
          var i4 = e4[0] - r4[0], s4 = e4[1] - r4[1], a4 = Math.sin(n3), o3 = Math.cos(n3);
          return t4[0] = i4 * o3 - s4 * a4 + r4[0], t4[1] = i4 * a4 + s4 * o3 + r4[1], t4;
        }, ue.angle = function(t4, e4) {
          var r4 = t4[0], n3 = t4[1], i4 = e4[0], s4 = e4[1], a4 = Math.sqrt(r4 * r4 + n3 * n3) * Math.sqrt(i4 * i4 + s4 * s4);
          return Math.acos(Math.min(Math.max(a4 && (r4 * i4 + n3 * s4) / a4, -1), 1));
        }, ue.zero = function(t4) {
          return t4[0] = 0, t4[1] = 0, t4;
        }, ue.str = function(t4) {
          return "vec2(" + t4[0] + ", " + t4[1] + ")";
        }, ue.exactEquals = function(t4, e4) {
          return t4[0] === e4[0] && t4[1] === e4[1];
        }, ue.equals = function(t4, e4) {
          var r4 = t4[0], n3 = t4[1], i4 = e4[0], s4 = e4[1];
          return Math.abs(r4 - i4) <= he.EPSILON * Math.max(1, Math.abs(r4), Math.abs(i4)) && Math.abs(n3 - s4) <= he.EPSILON * Math.max(1, Math.abs(n3), Math.abs(s4));
        }, ue.forEach = ue.sqrLen = ue.sqrDist = ue.dist = ue.div = ue.mul = ue.sub = ue.len = void 0;
        var he = function(t4, e4) {
          if (t4 && t4.__esModule) return t4;
          if (null === t4 || "object" !== ce(t4) && "function" != typeof t4) return { default: t4 };
          var r4 = pe(void 0);
          if (r4 && r4.has(t4)) return r4.get(t4);
          var n3 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t4) if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t4, s4)) {
            var a4 = i4 ? Object.getOwnPropertyDescriptor(t4, s4) : null;
            a4 && (a4.get || a4.set) ? Object.defineProperty(n3, s4, a4) : n3[s4] = t4[s4];
          }
          return n3.default = t4, r4 && r4.set(t4, n3), n3;
        }(f3);
        function pe(t4) {
          if ("function" != typeof WeakMap) return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (pe = function(t5) {
            return t5 ? r4 : e4;
          })(t4);
        }
        function fe() {
          var t4 = new he.ARRAY_TYPE(2);
          return he.ARRAY_TYPE != Float32Array && (t4[0] = 0, t4[1] = 0), t4;
        }
        function de(t4, e4, r4) {
          return t4[0] = e4[0] - r4[0], t4[1] = e4[1] - r4[1], t4;
        }
        function me(t4, e4, r4) {
          return t4[0] = e4[0] * r4[0], t4[1] = e4[1] * r4[1], t4;
        }
        function ye(t4, e4, r4) {
          return t4[0] = e4[0] / r4[0], t4[1] = e4[1] / r4[1], t4;
        }
        function ge(t4, e4) {
          return Math.hypot(e4[0] - t4[0], e4[1] - t4[1]);
        }
        function xe(t4, e4) {
          var r4 = e4[0] - t4[0], n3 = e4[1] - t4[1];
          return r4 * r4 + n3 * n3;
        }
        function be(t4) {
          return Math.hypot(t4[0], t4[1]);
        }
        function ve(t4) {
          var e4 = t4[0], r4 = t4[1];
          return e4 * e4 + r4 * r4;
        }
        ue.len = be, ue.sub = de, ue.mul = me, ue.div = ye, ue.dist = ge, ue.sqrDist = xe, ue.sqrLen = ve;
        var _e = function() {
          var t4 = fe();
          return function(e4, r4, n3, i4, s4, a4) {
            var o3, l4;
            for (r4 || (r4 = 2), n3 || (n3 = 0), l4 = i4 ? Math.min(i4 * r4 + n3, e4.length) : e4.length, o3 = n3; o3 < l4; o3 += r4) t4[0] = e4[o3], t4[1] = e4[o3 + 1], s4(t4, t4, a4), e4[o3] = t4[0], e4[o3 + 1] = t4[1];
            return e4;
          };
        }();
        function we(t4) {
          return we = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
            return typeof t5;
          } : function(t5) {
            return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
          }, we(t4);
        }
        ue.forEach = _e, Object.defineProperty(p3, "__esModule", { value: true }), t3.aa = p3.vec4 = t3.Q = p3.vec3 = p3.vec2 = p3.quat2 = t3.bl = p3.quat = t3.a9 = p3.mat4 = t3.ct = p3.mat3 = p3.mat2d = t3.b7 = p3.mat2 = p3.glMatrix = void 0;
        var Me = Re(f3);
        p3.glMatrix = Me;
        var Ae = Re(x4);
        t3.b7 = p3.mat2 = Ae;
        var Se = Re(A3);
        p3.mat2d = Se;
        var Ie = Re(z3);
        t3.ct = p3.mat3 = Ie;
        var ke = Re(D3);
        t3.a9 = p3.mat4 = ke;
        var Pe = Re(Y);
        t3.bl = p3.quat = Pe;
        var Ee = Re(Kt);
        p3.quat2 = Ee;
        var ze = Re(ue);
        p3.vec2 = ze;
        var Te = Re(X2);
        t3.Q = p3.vec3 = Te;
        var Be = Re(ut);
        function Ce(t4) {
          if ("function" != typeof WeakMap) return null;
          var e4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
          return (Ce = function(t5) {
            return t5 ? r4 : e4;
          })(t4);
        }
        function Re(t4, e4) {
          if (t4 && t4.__esModule) return t4;
          if (null === t4 || "object" !== we(t4) && "function" != typeof t4) return { default: t4 };
          var r4 = Ce(e4);
          if (r4 && r4.has(t4)) return r4.get(t4);
          var n3 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var s4 in t4) if ("default" !== s4 && Object.prototype.hasOwnProperty.call(t4, s4)) {
            var a4 = i4 ? Object.getOwnPropertyDescriptor(t4, s4) : null;
            a4 && (a4.get || a4.set) ? Object.defineProperty(n3, s4, a4) : n3[s4] = t4[s4];
          }
          return n3.default = t4, r4 && r4.set(t4, n3), n3;
        }
        t3.aa = p3.vec4 = Be;
        var Ve = De;
        function De(t4, e4, r4, n3) {
          this.cx = 3 * t4, this.bx = 3 * (r4 - t4) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e4, this.by = 3 * (n3 - e4) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t4, this.p1y = e4, this.p2x = r4, this.p2y = n3;
        }
        De.prototype = { sampleCurveX: function(t4) {
          return ((this.ax * t4 + this.bx) * t4 + this.cx) * t4;
        }, sampleCurveY: function(t4) {
          return ((this.ay * t4 + this.by) * t4 + this.cy) * t4;
        }, sampleCurveDerivativeX: function(t4) {
          return (3 * this.ax * t4 + 2 * this.bx) * t4 + this.cx;
        }, solveCurveX: function(t4, e4) {
          if (void 0 === e4 && (e4 = 1e-6), t4 < 0) return 0;
          if (t4 > 1) return 1;
          for (var r4 = t4, n3 = 0; n3 < 8; n3++) {
            var i4 = this.sampleCurveX(r4) - t4;
            if (Math.abs(i4) < e4) return r4;
            var s4 = this.sampleCurveDerivativeX(r4);
            if (Math.abs(s4) < 1e-6) break;
            r4 -= i4 / s4;
          }
          var a4 = 0, o3 = 1;
          for (r4 = t4, n3 = 0; n3 < 20 && (i4 = this.sampleCurveX(r4), !(Math.abs(i4 - t4) < e4)); n3++) t4 > i4 ? a4 = r4 : o3 = r4, r4 = 0.5 * (o3 - a4) + a4;
          return r4;
        }, solve: function(t4, e4) {
          return this.sampleCurveY(this.solveCurveX(t4, e4));
        } };
        var Le = h3(Ve), Fe = Oe;
        function Oe(t4, e4) {
          this.x = t4, this.y = e4;
        }
        Oe.prototype = { clone: function() {
          return new Oe(this.x, this.y);
        }, add: function(t4) {
          return this.clone()._add(t4);
        }, sub: function(t4) {
          return this.clone()._sub(t4);
        }, multByPoint: function(t4) {
          return this.clone()._multByPoint(t4);
        }, divByPoint: function(t4) {
          return this.clone()._divByPoint(t4);
        }, mult: function(t4) {
          return this.clone()._mult(t4);
        }, div: function(t4) {
          return this.clone()._div(t4);
        }, rotate: function(t4) {
          return this.clone()._rotate(t4);
        }, rotateAround: function(t4, e4) {
          return this.clone()._rotateAround(t4, e4);
        }, matMult: function(t4) {
          return this.clone()._matMult(t4);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t4) {
          return this.x === t4.x && this.y === t4.y;
        }, dist: function(t4) {
          return Math.sqrt(this.distSqr(t4));
        }, distSqr: function(t4) {
          var e4 = t4.x - this.x, r4 = t4.y - this.y;
          return e4 * e4 + r4 * r4;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t4) {
          return Math.atan2(this.y - t4.y, this.x - t4.x);
        }, angleWith: function(t4) {
          return this.angleWithSep(t4.x, t4.y);
        }, angleWithSep: function(t4, e4) {
          return Math.atan2(this.x * e4 - this.y * t4, this.x * t4 + this.y * e4);
        }, _matMult: function(t4) {
          var e4 = t4[2] * this.x + t4[3] * this.y;
          return this.x = t4[0] * this.x + t4[1] * this.y, this.y = e4, this;
        }, _add: function(t4) {
          return this.x += t4.x, this.y += t4.y, this;
        }, _sub: function(t4) {
          return this.x -= t4.x, this.y -= t4.y, this;
        }, _mult: function(t4) {
          return this.x *= t4, this.y *= t4, this;
        }, _div: function(t4) {
          return this.x /= t4, this.y /= t4, this;
        }, _multByPoint: function(t4) {
          return this.x *= t4.x, this.y *= t4.y, this;
        }, _divByPoint: function(t4) {
          return this.x /= t4.x, this.y /= t4.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t4 = this.y;
          return this.y = this.x, this.x = -t4, this;
        }, _rotate: function(t4) {
          var e4 = Math.cos(t4), r4 = Math.sin(t4), n3 = r4 * this.x + e4 * this.y;
          return this.x = e4 * this.x - r4 * this.y, this.y = n3, this;
        }, _rotateAround: function(t4, e4) {
          var r4 = Math.cos(t4), n3 = Math.sin(t4), i4 = e4.y + n3 * (this.x - e4.x) + r4 * (this.y - e4.y);
          return this.x = e4.x + r4 * (this.x - e4.x) - n3 * (this.y - e4.y), this.y = i4, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, Oe.convert = function(t4) {
          return t4 instanceof Oe ? t4 : Array.isArray(t4) ? new Oe(t4[0], t4[1]) : t4;
        };
        var Ue = h3(Fe);
        const Ne = Math.PI / 180, je = 180 / Math.PI;
        function qe(t4) {
          return t4 * Ne;
        }
        function $e(t4) {
          return t4 * je;
        }
        const Ge = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function Qe(t4) {
          if (t4 <= 0) return 0;
          if (t4 >= 1) return 1;
          const e4 = t4 * t4, r4 = e4 * t4;
          return 4 * (t4 < 0.5 ? r4 : 3 * (t4 - e4) + r4 - 0.75);
        }
        function Ye(t4, e4, r4, n3) {
          const i4 = new Le(t4, e4, r4, n3);
          return function(t5) {
            return i4.solve(t5);
          };
        }
        const Xe = Ye(0.25, 0.1, 0.25, 1);
        function Ze(t4, e4, r4) {
          return Math.min(r4, Math.max(e4, t4));
        }
        function Ke(t4, e4, r4) {
          return (r4 = Ze((r4 - t4) / (e4 - t4), 0, 1)) * r4 * (3 - 2 * r4);
        }
        function We(t4, e4, r4) {
          const n3 = r4 - e4, i4 = ((t4 - e4) % n3 + n3) % n3 + e4;
          return i4 === e4 ? r4 : i4;
        }
        function He(t4, e4, r4) {
          if (!t4.length) return r4(null, []);
          let n3 = t4.length;
          const i4 = new Array(t4.length);
          let s4 = null;
          t4.forEach((t5, a4) => {
            e4(t5, (t6, e5) => {
              t6 && (s4 = t6), i4[a4] = e5, 0 == --n3 && r4(s4, i4);
            });
          });
        }
        function Je(t4, ...e4) {
          for (const r4 of e4) for (const e5 in r4) t4[e5] = r4[e5];
          return t4;
        }
        let tr = 1;
        function er() {
          return tr++;
        }
        function rr() {
          return function t4(e4) {
            return e4 ? (e4 ^ Math.random() * (16 >> e4 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t4);
          }();
        }
        function nr(t4) {
          return t4 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t4) / Math.LN2));
        }
        function ir(t4) {
          return !!t4 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t4);
        }
        function sr(t4, e4) {
          t4.forEach((t5) => {
            e4[t5] && (e4[t5] = e4[t5].bind(e4));
          });
        }
        function ar(t4, e4) {
          return -1 !== t4.indexOf(e4, t4.length - e4.length);
        }
        function or(t4, e4, r4) {
          const n3 = {};
          for (const r5 in t4) n3[r5] = e4.call(this, t4[r5], r5, t4);
          return n3;
        }
        function lr(t4, e4, r4) {
          const n3 = {};
          for (const r5 in t4) e4.call(this, t4[r5], r5, t4) && (n3[r5] = t4[r5]);
          return n3;
        }
        function ur(t4) {
          return Array.isArray(t4) ? t4.map(ur) : "object" == typeof t4 && t4 ? or(t4, ur) : t4;
        }
        const cr = {};
        function hr(t4) {
          cr[t4] || ("undefined" != typeof console && console.warn(t4), cr[t4] = true);
        }
        function pr(t4, e4, r4) {
          return (r4.y - t4.y) * (e4.x - t4.x) > (e4.y - t4.y) * (r4.x - t4.x);
        }
        function fr(t4) {
          let e4 = 0;
          for (let r4, n3, i4 = 0, s4 = t4.length, a4 = s4 - 1; i4 < s4; a4 = i4++) r4 = t4[i4], n3 = t4[a4], e4 += (n3.x - r4.x) * (r4.y + n3.y);
          return e4;
        }
        function dr([t4, e4, r4]) {
          const n3 = qe(e4 + 90), i4 = qe(r4);
          return { x: t4 * Math.cos(n3) * Math.sin(i4), y: t4 * Math.sin(n3) * Math.sin(i4), z: t4 * Math.cos(i4), azimuthal: e4, polar: r4 };
        }
        function mr() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function yr(t4) {
          const e4 = {};
          if (t4.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t5, r4, n3, i4) => {
            const s4 = n3 || i4;
            return e4[r4] = !s4 || s4.toLowerCase(), "";
          }), e4["max-age"]) {
            const t5 = parseInt(e4["max-age"], 10);
            isNaN(t5) ? delete e4["max-age"] : e4["max-age"] = t5;
          }
          return e4;
        }
        let gr, xr, br, vr, _r, wr, Mr = null;
        function Ar(t4) {
          try {
            const e4 = self[t4];
            return e4.setItem("_mapbox_test_", 1), e4.removeItem("_mapbox_test_"), true;
          } catch (t5) {
            return false;
          }
        }
        function Sr(t4, e4) {
          return [t4[4 * e4], t4[4 * e4 + 1], t4[4 * e4 + 2], t4[4 * e4 + 3]];
        }
        function Ir(t4, e4, r4, n3) {
          for (; e4 < r4; ) {
            const i4 = e4 + r4 >> 1;
            t4[i4] < n3 ? e4 = i4 + 1 : r4 = i4;
          }
          return e4;
        }
        function kr(t4, e4, r4, n3) {
          for (; e4 < r4; ) {
            const i4 = e4 + r4 >> 1;
            t4[i4] <= n3 ? e4 = i4 + 1 : r4 = i4;
          }
          return e4;
        }
        function Pr(t4) {
          return t4 > 0 ? 1 / (1.001 - t4) : 1 + t4;
        }
        function Er(t4) {
          return t4 > 0 ? 1 - 1 / (1.001 - t4) : -t4;
        }
        function zr() {
          return null == gr && (gr = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), gr;
        }
        const Tr = { now: () => void 0 !== vr ? vr : performance.now(), setNow(t4) {
          vr = t4;
        }, restoreNow() {
          vr = void 0;
        }, frame(t4) {
          const e4 = requestAnimationFrame(t4);
          return { cancel: () => cancelAnimationFrame(e4) };
        }, getImageData(t4, e4 = 0) {
          const { width: r4, height: n3 } = t4;
          _r || (_r = document.createElement("canvas"));
          const i4 = _r.getContext("2d", { willReadFrequently: true });
          if (!i4) throw new Error("failed to create canvas 2d context");
          return (r4 > _r.width || n3 > _r.height) && (_r.width = r4, _r.height = n3), i4.clearRect(-e4, -e4, r4 + 2 * e4, n3 + 2 * e4), i4.drawImage(t4, 0, 0, r4, n3), i4.getImageData(-e4, -e4, r4 + 2 * e4, n3 + 2 * e4);
        }, resolveURL: (t4) => (xr || (xr = document.createElement("a")), xr.href = t4, xr.href), get devicePixelRatio() {
          return window.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!window.matchMedia && (null == br && (br = window.matchMedia("(prefers-reduced-motion: reduce)")), br.matches);
        }, hasCanvasFingerprintNoise() {
          if (void 0 !== wr) return wr;
          if (!zr()) return wr = false, false;
          const t4 = new OffscreenCanvas(85, 1), e4 = t4.getContext("2d", { willReadFrequently: true });
          let r4 = 0;
          for (let n4 = 0; n4 < t4.width; ++n4) e4.fillStyle = `rgba(${r4++},${r4++},${r4++}, 255)`, e4.fillRect(n4, 0, 1, 1);
          const n3 = e4.getImageData(0, 0, t4.width, t4.height);
          r4 = 0;
          for (let t5 = 0; t5 < n3.data.length; ++t5) if (t5 % 4 != 3 && r4++ !== n3.data[t5]) return wr = true, true;
          return wr = false, false;
        } };
        function Br(t4, e4) {
          const r4 = t4.indexOf("?");
          if (r4 < 0) return `${t4}?${new URLSearchParams(e4).toString()}`;
          const n3 = new URLSearchParams(t4.slice(r4));
          for (const t5 in e4) n3.set(t5, e4[t5]);
          return `${t4.slice(0, r4)}?${n3.toString()}`;
        }
        function Cr(t4, e4 = { persistentParams: [] }) {
          const r4 = t4.indexOf("?");
          if (r4 < 0) return t4;
          const n3 = new URLSearchParams(), i4 = new URLSearchParams(t4.slice(r4));
          for (const t5 of e4.persistentParams) {
            const e5 = i4.get(t5);
            e5 && n3.set(t5, e5);
          }
          const s4 = n3.toString();
          return `${t4.slice(0, r4)}${s4.length > 0 ? `?${s4}` : ""}`;
        }
        const Rr = "mapbox-tiles";
        let Vr = 500, Dr = 50;
        let Lr, Fr;
        function Or() {
          try {
            return caches;
          } catch (t4) {
          }
        }
        function Ur() {
          const t4 = Or();
          t4 && !Lr && (Lr = t4.open(Rr));
        }
        let Nr = 1 / 0;
        const jr = { supported: false, testSupport: function(t4) {
          !Gr && $r && (Qr ? Xr(t4) : qr = t4);
        } };
        let qr, $r, Gr = false, Qr = false;
        const Yr = "undefined" != typeof self ? self : {};
        function Xr(t4) {
          const e4 = t4.createTexture();
          t4.bindTexture(t4.TEXTURE_2D, e4);
          try {
            if (t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, t4.RGBA, t4.UNSIGNED_BYTE, $r), t4.isContextLost()) return;
            jr.supported = true;
          } catch (t5) {
          }
          t4.deleteTexture(e4), Gr = true;
        }
        Yr.document && ($r = Yr.document.createElement("img"), $r.onload = function() {
          qr && Xr(qr), qr = null, Qr = true;
        }, $r.onerror = function() {
          Gr = true, qr = null;
        }, $r.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const Zr = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image", Model: "Model" };
        "function" == typeof Object.freeze && Object.freeze(Zr);
        class Kr extends Error {
          constructor(t4, e4, r4) {
            401 === e4 && i3(r4) && (t4 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t4), this.status = e4, this.url = r4;
          }
          toString() {
            return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
          }
        }
        const Wr = mr() ? () => self.worker && self.worker.referrer : () => ("blob:" === location.protocol ? parent : self).location.href;
        const Hr = function(t4, e4) {
          if (!(/^file:/.test(r4 = t4.url) || /^file:/.test(Wr()) && !/^\w+:/.test(r4))) {
            if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(t5, e5) {
              const r5 = new AbortController(), n3 = new Request(t5.url, { method: t5.method || "GET", body: t5.body, credentials: t5.credentials, headers: t5.headers, referrer: Wr(), referrerPolicy: t5.referrerPolicy, signal: r5.signal });
              let s4 = false, a4 = false;
              const o3 = (l4 = n3.url).indexOf("sku=") > 0 && i3(l4);
              var l4;
              "json" === t5.type && n3.headers.set("Accept", "application/json");
              const u5 = (r6, i4, s5) => {
                if (a4) return;
                if (r6 && "SecurityError" !== r6.message && hr(r6.toString()), i4 && s5) return c4(i4);
                const l5 = Date.now();
                fetch(n3).then((r7) => {
                  if (r7.ok) {
                    const t6 = o3 ? r7.clone() : null;
                    return c4(r7, t6, l5);
                  }
                  return e5(new Kr(r7.statusText, r7.status, t5.url));
                }).catch((r7) => {
                  "AbortError" !== r7.name && e5(new Error(`${r7.message} ${t5.url}`));
                });
              }, c4 = (r6, i4, o4) => {
                ("arrayBuffer" === t5.type ? r6.arrayBuffer() : "json" === t5.type ? r6.json() : r6.text()).then((t6) => {
                  a4 || (i4 && o4 && function(t7, e6, r7) {
                    if (Ur(), !Lr) return;
                    const n4 = yr(e6.headers.get("Cache-Control") || "");
                    if (n4["no-store"]) return;
                    const i5 = { status: e6.status, statusText: e6.statusText, headers: new Headers() };
                    e6.headers.forEach((t8, e7) => i5.headers.set(e7, t8)), n4["max-age"] && i5.headers.set("Expires", new Date(r7 + 1e3 * n4["max-age"]).toUTCString());
                    const s5 = i5.headers.get("Expires");
                    if (!s5) return;
                    if (new Date(s5).getTime() - r7 < 42e4) return;
                    let a5 = Cr(t7.url, { persistentParams: ["language", "worldview"] });
                    if (206 === e6.status) {
                      const e7 = t7.headers.get("Range");
                      if (!e7) return;
                      i5.status = 200, a5 = Br(a5, { range: e7 });
                    }
                    !function(t8, e7) {
                      if (void 0 === Fr) try {
                        new Response(new ReadableStream()), Fr = true;
                      } catch (t9) {
                        Fr = false;
                      }
                      Fr ? e7(t8.body) : t8.blob().then(e7);
                    }(e6, (t8) => {
                      const e7 = new Response(t8, i5);
                      Ur(), Lr && Lr.then((t9) => t9.put(a5, e7)).catch((t9) => hr(t9.message));
                    });
                  }(n3, i4, o4), s4 = true, e5(null, t6, r6.headers.get("Cache-Control"), r6.headers.get("Expires")));
                }).catch((t6) => {
                  a4 || e5(new Error(t6.message));
                });
              };
              return o3 ? function(t6, e6) {
                if (Ur(), !Lr) return e6(null);
                Lr.then((r6) => {
                  let n4 = Cr(t6.url, { persistentParams: ["language", "worldview"] });
                  const i4 = t6.headers.get("Range");
                  i4 && (n4 = Br(n4, { range: i4 })), r6.match(n4).then((t7) => {
                    const i5 = function(t8) {
                      if (!t8) return false;
                      const e7 = new Date(t8.headers.get("Expires") || 0), r7 = yr(t8.headers.get("Cache-Control") || "");
                      return e7 > Date.now() && !r7["no-cache"];
                    }(t7);
                    r6.delete(n4), i5 && r6.put(n4, t7.clone()), e6(null, t7, i5);
                  }).catch(e6);
                }).catch(e6);
              }(n3, u5) : u5(null, null), { cancel: () => {
                a4 = true, s4 || r5.abort();
              } };
            }(t4, e4);
            if (mr() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t4, e4, void 0, true);
          }
          var r4;
          return function(t5, e5) {
            const r5 = new XMLHttpRequest();
            r5.open(t5.method || "GET", t5.url, true), "arrayBuffer" === t5.type && (r5.responseType = "arraybuffer");
            for (const e6 in t5.headers) r5.setRequestHeader(e6, t5.headers[e6]);
            return "json" === t5.type && (r5.responseType = "text", r5.setRequestHeader("Accept", "application/json")), r5.withCredentials = "include" === t5.credentials, r5.onerror = () => {
              e5(new Error(r5.statusText));
            }, r5.onload = () => {
              if ((r5.status >= 200 && r5.status < 300 || 0 === r5.status) && null !== r5.response) {
                let n3 = r5.response;
                if ("json" === t5.type) try {
                  n3 = JSON.parse(r5.response);
                } catch (t6) {
                  return e5(t6);
                }
                e5(null, n3, r5.getResponseHeader("Cache-Control"), r5.getResponseHeader("Expires"));
              } else e5(new Kr(r5.statusText, r5.status, t5.url));
            }, r5.send(t5.body), { cancel: () => r5.abort() };
          }(t4, e4);
        }, Jr = function(t4, e4) {
          return Hr(Je(t4, { type: "arrayBuffer" }), e4);
        };
        function tn2(t4) {
          const e4 = document.createElement("a");
          return e4.href = t4, e4.protocol === location.protocol && e4.host === location.host;
        }
        const en2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let rn, nn2;
        rn = [], nn2 = 0;
        const sn = function(t4, e4) {
          if (jr.supported && (t4.headers || (t4.headers = {}), t4.headers.accept = "image/webp,*/*"), nn2 >= n2.MAX_PARALLEL_IMAGE_REQUESTS) {
            const r5 = { requestParameters: t4, callback: e4, cancelled: false, cancel() {
              this.cancelled = true;
            } };
            return rn.push(r5), r5;
          }
          nn2++;
          let r4 = false;
          const i4 = () => {
            if (!r4) for (r4 = true, nn2--; rn.length && nn2 < n2.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const t5 = rn.shift(), { requestParameters: e5, callback: r5, cancelled: n3 } = t5;
              n3 || (t5.cancel = sn(e5, r5).cancel);
            }
          }, s4 = Jr(t4, (t5, r5, n3, s5) => {
            i4(), t5 ? e4(t5) : r5 && (self.createImageBitmap ? function(t6, e5) {
              const r6 = new Blob([new Uint8Array(t6)], { type: "image/png" });
              createImageBitmap(r6).then((t7) => {
                e5(null, t7);
              }).catch((t7) => {
                e5(new Error(`Could not load image because of ${t7.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(r5, (t6, r6) => e4(t6, r6, n3, s5)) : function(t6, e5) {
              const r6 = new Image();
              r6.onload = () => {
                e5(null, r6), URL.revokeObjectURL(r6.src), r6.onload = null, requestAnimationFrame(() => {
                  r6.src = en2;
                });
              }, r6.onerror = () => e5(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const n4 = new Blob([new Uint8Array(t6)], { type: "image/png" });
              r6.src = t6.byteLength ? URL.createObjectURL(n4) : en2;
            }(r5, (t6, r6) => e4(t6, r6, n3, s5)));
          });
          return { cancel: () => {
            s4.cancel(), i4();
          } };
        }, an = "01", on = "NO_ACCESS_TOKEN", ln = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function un(t4) {
          const e4 = t4.match(ln);
          if (!e4) throw new Error("Unable to parse URL object");
          return { protocol: e4[1], authority: e4[2], path: e4[3] || "/", params: e4[4] ? e4[4].split("&") : [] };
        }
        function cn(t4) {
          const e4 = t4.params.length ? `?${t4.params.join("&")}` : "";
          return `${t4.protocol}://${t4.authority}${t4.path}${e4}`;
        }
        const hn = "mapbox.eventData";
        function pn(t4) {
          if (!t4) return null;
          const e4 = t4.split(".");
          if (!e4 || 3 !== e4.length) return null;
          try {
            return JSON.parse(decodeURIComponent(atob(e4[1]).split("").map((t5) => "%" + ("00" + t5.charCodeAt(0).toString(16)).slice(-2)).join("")));
          } catch (t5) {
            return null;
          }
        }
        class fn {
          constructor(t4) {
            this.type = t4, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
          }
          getStorageKey(t4) {
            const e4 = pn(n2.ACCESS_TOKEN);
            let r4 = "";
            return r4 = e4 && e4.u ? btoa(encodeURIComponent(e4.u).replace(/%([0-9A-F]{2})/g, (t5, e5) => String.fromCharCode(Number("0x" + e5)))) : n2.ACCESS_TOKEN || "", t4 ? `${hn}.${t4}:${r4}` : `${hn}:${r4}`;
          }
          fetchEventData() {
            const t4 = Ar("localStorage"), e4 = this.getStorageKey(), r4 = this.getStorageKey("uuid");
            if (t4) try {
              const t5 = localStorage.getItem(e4);
              t5 && (this.eventData = JSON.parse(t5));
              const n3 = localStorage.getItem(r4);
              n3 && (this.anonId = n3);
            } catch (t5) {
              hr("Unable to read from LocalStorage");
            }
          }
          saveEventData() {
            const t4 = Ar("localStorage"), e4 = this.getStorageKey(), r4 = this.getStorageKey("uuid"), n3 = this.anonId;
            if (t4 && n3) try {
              localStorage.setItem(r4, n3), Object.keys(this.eventData).length >= 1 && localStorage.setItem(e4, JSON.stringify(this.eventData));
            } catch (t5) {
              hr("Unable to write to LocalStorage");
            }
          }
          processRequests(t4) {
          }
          postEvent(t4, e4, r4, i4) {
            if (!n2.EVENTS_URL) return;
            const s4 = un(n2.EVENTS_URL);
            s4.params.push(`access_token=${i4 || n2.ACCESS_TOKEN || ""}`);
            const a4 = { event: this.type, created: new Date(t4).toISOString() }, o3 = e4 ? Je(a4, e4) : a4, l4 = { url: cn(s4), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o3]) };
            this.pendingRequest = function(t5, e5) {
              return Hr(Je(t5, { method: "POST" }), e5);
            }(l4, (t5) => {
              this.pendingRequest = null, r4(t5), this.saveEventData(), this.processRequests(i4);
            });
          }
          queueRequest(t4, e4) {
            this.queue.push(t4), this.processRequests(e4);
          }
        }
        const dn = new class extends fn {
          constructor(t4) {
            super("appUserTurnstile"), this._customAccessToken = t4;
          }
          postTurnstileEvent(t4, e4) {
            n2.EVENTS_URL && n2.ACCESS_TOKEN && Array.isArray(t4) && t4.some((t5) => s3(t5) || i3(t5)) && this.queueRequest(Date.now(), e4);
          }
          processRequests(t4) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            const r4 = pn(n2.ACCESS_TOKEN), i4 = r4 ? r4.u : n2.ACCESS_TOKEN;
            let s4 = i4 !== this.eventData.tokenU;
            ir(this.anonId) || (this.anonId = rr(), s4 = true);
            const a4 = this.queue.shift();
            if (this.eventData.lastSuccess) {
              const t5 = new Date(this.eventData.lastSuccess), e4 = new Date(a4), r5 = (a4 - this.eventData.lastSuccess) / 864e5;
              s4 = s4 || r5 >= 1 || r5 < -1 || t5.getDate() !== e4.getDate();
            } else s4 = true;
            s4 ? this.postEvent(a4, { sdkIdentifier: "mapbox-gl-js", sdkVersion: e3, skuId: an, "enabled.telemetry": false, userId: this.anonId }, (t5) => {
              t5 || (this.eventData.lastSuccess = a4, this.eventData.tokenU = i4);
            }, t4) : this.processRequests();
          }
        }(), mn = dn.postTurnstileEvent.bind(dn), yn = new class extends fn {
          constructor() {
            super("map.load"), this.success = {}, this.skuToken = "";
          }
          postMapLoadEvent(t4, e4, r4, i4) {
            this.skuToken = e4, this.errorCb = i4, n2.EVENTS_URL && (r4 || n2.ACCESS_TOKEN ? this.queueRequest({ id: t4, timestamp: Date.now() }, r4) : this.errorCb(new Error(on)));
          }
          processRequests(t4) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { id: r4, timestamp: n3 } = this.queue.shift();
            r4 && this.success[r4] || (this.anonId || this.fetchEventData(), ir(this.anonId) || (this.anonId = rr()), this.postEvent(n3, { sdkIdentifier: "mapbox-gl-js", sdkVersion: e3, skuId: an, skuToken: this.skuToken, userId: this.anonId }, (t5) => {
              t5 ? this.errorCb(t5) : r4 && (this.success[r4] = true);
            }, t4));
          }
          remove() {
            this.errorCb = null;
          }
        }(), gn = yn.postMapLoadEvent.bind(yn), xn = new class extends fn {
          constructor() {
            super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
          }
          getMapInstanceId(t4) {
            let e4 = this.mapInstanceIdMap.get(t4);
            return e4 || (e4 = rr(), this.mapInstanceIdMap.set(t4, e4)), e4;
          }
          getEventId(t4) {
            const e4 = this.eventIdPerMapInstanceMap.get(t4) || 0;
            return this.eventIdPerMapInstanceMap.set(t4, e4 + 1), e4;
          }
          postStyleLoadEvent(t4, e4) {
            const { map: r4, style: i4, importedStyles: s4 } = e4;
            if (!n2.EVENTS_URL || !t4 && !n2.ACCESS_TOKEN) return;
            const a4 = this.getMapInstanceId(r4), o3 = { mapInstanceId: a4, eventId: this.getEventId(a4), style: i4 };
            s4.length && (o3.importedStyles = s4), this.queueRequest({ timestamp: Date.now(), payload: o3 }, t4);
          }
          processRequests(t4) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { timestamp: e4, payload: r4 } = this.queue.shift();
            this.postEvent(e4, r4, () => {
            }, t4);
          }
        }(), bn = xn.postStyleLoadEvent.bind(xn), vn = new class extends fn {
          constructor() {
            super("gljs.performance");
          }
          postPerformanceEvent(t4, e4) {
            n2.EVENTS_URL && (t4 || n2.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: e4 }, t4);
          }
          processRequests(t4) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { timestamp: r4, performanceData: n3 } = this.queue.shift(), i4 = function(t5) {
              const r5 = performance.getEntriesByType("resource"), n4 = performance.getEntriesByType("mark"), i5 = function(t6) {
                const e4 = {};
                if (t6) {
                  for (const r6 in t6) if ("other" !== r6) for (const n5 of t6[r6]) {
                    const t7 = `${r6}ResolveRangeMin`, i6 = `${r6}ResolveRangeMax`, s5 = `${r6}RequestCount`, a5 = `${r6}RequestCachedCount`;
                    e4[t7] = Math.min(e4[t7] || 1 / 0, n5.startTime), e4[i6] = Math.max(e4[i6] || -1 / 0, n5.responseEnd);
                    const o4 = (t8) => {
                      void 0 === e4[t8] && (e4[t8] = 0), ++e4[t8];
                    };
                    void 0 !== n5.transferSize && 0 === n5.transferSize && o4(a5), o4(s5);
                  }
                }
                return e4;
              }(function(t6, e4) {
                const r6 = {};
                if (t6) for (const n5 of t6) {
                  const t7 = e4(n5);
                  void 0 === r6[t7] && (r6[t7] = []), r6[t7].push(n5);
                }
                return r6;
              }(r5, c3)), s4 = window.devicePixelRatio, a4 = navigator.connection || navigator.mozConnection || navigator.webkitConnection, o3 = a4 ? a4.effectiveType : void 0, h4 = { counters: [], metadata: [], attributes: [] }, p4 = (t6, e4, r6) => {
                null != r6 && t6.push({ name: e4, value: r6.toString() });
              };
              for (const t6 in i5) p4(h4.counters, t6, i5[t6]);
              if (t5.interactionRange[0] !== 1 / 0 && t5.interactionRange[1] !== -1 / 0 && (p4(h4.counters, "interactionRangeMin", t5.interactionRange[0]), p4(h4.counters, "interactionRangeMax", t5.interactionRange[1])), n4) for (const t6 of Object.keys(u4)) {
                const e4 = u4[t6], r6 = n4.find((t7) => t7.name === e4);
                r6 && p4(h4.counters, e4, r6.startTime);
              }
              return p4(h4.counters, "visibilityHidden", t5.visibilityHidden), p4(h4.attributes, "style", function(t6) {
                if (t6) for (const e4 of t6) {
                  const t7 = e4.name.split("?")[0];
                  if (l3(t7)) {
                    const e5 = t7.split("/").slice(-2);
                    if (2 === e5.length) return `mapbox://styles/${e5[0]}/${e5[1]}`;
                  }
                }
              }(r5)), p4(h4.attributes, "terrainEnabled", t5.terrainEnabled ? "true" : "false"), p4(h4.attributes, "fogEnabled", t5.fogEnabled ? "true" : "false"), p4(h4.attributes, "projection", t5.projection), p4(h4.attributes, "zoom", t5.zoom), p4(h4.metadata, "devicePixelRatio", s4), p4(h4.metadata, "connectionEffectiveType", o3), p4(h4.metadata, "navigatorUserAgent", navigator.userAgent), p4(h4.metadata, "screenWidth", window.screen.width), p4(h4.metadata, "screenHeight", window.screen.height), p4(h4.metadata, "windowWidth", window.innerWidth), p4(h4.metadata, "windowHeight", window.innerHeight), p4(h4.metadata, "mapWidth", t5.width / s4), p4(h4.metadata, "mapHeight", t5.height / s4), p4(h4.metadata, "webglRenderer", t5.renderer), p4(h4.metadata, "webglVendor", t5.vendor), p4(h4.metadata, "sdkVersion", e3), p4(h4.metadata, "sdkIdentifier", "mapbox-gl-js"), h4;
            }(n3);
            for (const t5 of i4.metadata) ;
            for (const t5 of i4.counters) ;
            for (const t5 of i4.attributes) ;
            this.postEvent(r4, i4, () => {
            }, t4);
          }
        }(), _n = vn.postPerformanceEvent.bind(vn), wn = new class extends fn {
          constructor() {
            super("map.auth"), this.success = {}, this.skuToken = "";
          }
          getSession(t4, e4, r4, i4) {
            if (!n2.API_URL || !n2.SESSION_PATH) return;
            const s4 = un(n2.API_URL + n2.SESSION_PATH);
            s4.params.push(`sku=${e4 || ""}`), s4.params.push(`access_token=${i4 || n2.ACCESS_TOKEN || ""}`);
            const a4 = { url: cn(s4), headers: { "Content-Type": "text/plain" } };
            this.pendingRequest = function(t5, e5) {
              return Hr(Je(t5, { method: "GET" }), e5);
            }(a4, (t5) => {
              this.pendingRequest = null, r4(t5), this.saveEventData(), this.processRequests(i4);
            });
          }
          getSessionAPI(t4, e4, r4, i4) {
            this.skuToken = e4, this.errorCb = i4, n2.SESSION_PATH && n2.API_URL && (r4 || n2.ACCESS_TOKEN ? this.queueRequest({ id: t4, timestamp: Date.now() }, r4) : this.errorCb(new Error(on)));
          }
          processRequests(t4) {
            if (this.pendingRequest || 0 === this.queue.length) return;
            const { id: e4, timestamp: r4 } = this.queue.shift();
            e4 && this.success[e4] || this.getSession(r4, this.skuToken, (t5) => {
              t5 ? this.errorCb(t5) : e4 && (this.success[e4] = true);
            }, t4);
          }
          remove() {
            this.errorCb = null;
          }
        }(), Mn = wn.getSessionAPI.bind(wn), An = /* @__PURE__ */ new Set();
        var Sn = { exports: {} }, In = { exports: {} };
        In.exports = function(t4, e4) {
          var r4, n3, i4, s4, a4, o3, l4, u5;
          for (n3 = t4.length - (r4 = 3 & t4.length), i4 = e4, a4 = 3432918353, o3 = 461845907, u5 = 0; u5 < n3; ) l4 = 255 & t4.charCodeAt(u5) | (255 & t4.charCodeAt(++u5)) << 8 | (255 & t4.charCodeAt(++u5)) << 16 | (255 & t4.charCodeAt(++u5)) << 24, ++u5, i4 = 27492 + (65535 & (s4 = 5 * (65535 & (i4 = (i4 ^= l4 = (65535 & (l4 = (l4 = (65535 & l4) * a4 + (((l4 >>> 16) * a4 & 65535) << 16) & 4294967295) << 15 | l4 >>> 17)) * o3 + (((l4 >>> 16) * o3 & 65535) << 16) & 4294967295) << 13 | i4 >>> 19)) + ((5 * (i4 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s4 >>> 16) & 65535) << 16);
          switch (l4 = 0, r4) {
            case 3:
              l4 ^= (255 & t4.charCodeAt(u5 + 2)) << 16;
            case 2:
              l4 ^= (255 & t4.charCodeAt(u5 + 1)) << 8;
            case 1:
              i4 ^= l4 = (65535 & (l4 = (l4 = (65535 & (l4 ^= 255 & t4.charCodeAt(u5))) * a4 + (((l4 >>> 16) * a4 & 65535) << 16) & 4294967295) << 15 | l4 >>> 17)) * o3 + (((l4 >>> 16) * o3 & 65535) << 16) & 4294967295;
          }
          return i4 ^= t4.length, i4 = 2246822507 * (65535 & (i4 ^= i4 >>> 16)) + ((2246822507 * (i4 >>> 16) & 65535) << 16) & 4294967295, i4 = 3266489909 * (65535 & (i4 ^= i4 >>> 13)) + ((3266489909 * (i4 >>> 16) & 65535) << 16) & 4294967295, (i4 ^= i4 >>> 16) >>> 0;
        };
        var kn = In.exports, Pn = { exports: {} };
        Pn.exports = function(t4, e4) {
          for (var r4, n3 = t4.length, i4 = e4 ^ n3, s4 = 0; n3 >= 4; ) r4 = 1540483477 * (65535 & (r4 = 255 & t4.charCodeAt(s4) | (255 & t4.charCodeAt(++s4)) << 8 | (255 & t4.charCodeAt(++s4)) << 16 | (255 & t4.charCodeAt(++s4)) << 24)) + ((1540483477 * (r4 >>> 16) & 65535) << 16), i4 = 1540483477 * (65535 & i4) + ((1540483477 * (i4 >>> 16) & 65535) << 16) ^ (r4 = 1540483477 * (65535 & (r4 ^= r4 >>> 24)) + ((1540483477 * (r4 >>> 16) & 65535) << 16)), n3 -= 4, ++s4;
          switch (n3) {
            case 3:
              i4 ^= (255 & t4.charCodeAt(s4 + 2)) << 16;
            case 2:
              i4 ^= (255 & t4.charCodeAt(s4 + 1)) << 8;
            case 1:
              i4 = 1540483477 * (65535 & (i4 ^= 255 & t4.charCodeAt(s4))) + ((1540483477 * (i4 >>> 16) & 65535) << 16);
          }
          return i4 = 1540483477 * (65535 & (i4 ^= i4 >>> 13)) + ((1540483477 * (i4 >>> 16) & 65535) << 16), (i4 ^= i4 >>> 15) >>> 0;
        };
        var En = kn, zn = Pn.exports;
        Sn.exports = En, Sn.exports.murmur3 = En, Sn.exports.murmur2 = zn;
        var Tn = h3(Sn.exports);
        function Bn(t4, e4, r4) {
          r4[t4] && -1 !== r4[t4].indexOf(e4) || (r4[t4] = r4[t4] || [], r4[t4].push(e4));
        }
        function Cn(t4, e4, r4) {
          if (r4 && r4[t4]) {
            const n3 = r4[t4].indexOf(e4);
            -1 !== n3 && r4[t4].splice(n3, 1);
          }
        }
        class Rn {
          constructor(t4, e4 = {}) {
            Je(this, e4), this.type = t4;
          }
        }
        class Vn extends Rn {
          constructor(t4, e4 = {}) {
            super("error", Je({ error: t4 }, e4));
          }
        }
        class Dn {
          on(t4, e4) {
            return this._listeners = this._listeners || {}, Bn(t4, e4, this._listeners), this;
          }
          off(t4, e4) {
            return Cn(t4, e4, this._listeners), Cn(t4, e4, this._oneTimeListeners), this;
          }
          once(t4, e4) {
            return e4 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Bn(t4, e4, this._oneTimeListeners), this) : new Promise((e5) => this.once(t4, e5));
          }
          fire(t4, e4) {
            "string" == typeof t4 && (t4 = new Rn(t4, e4 || {}));
            const r4 = t4.type;
            if (this.listens(r4)) {
              t4.target = this;
              const e5 = this._listeners && this._listeners[r4] ? this._listeners[r4].slice() : [];
              for (const r5 of e5) r5.call(this, t4);
              const n3 = this._oneTimeListeners && this._oneTimeListeners[r4] ? this._oneTimeListeners[r4].slice() : [];
              for (const e6 of n3) Cn(r4, e6, this._oneTimeListeners), e6.call(this, t4);
              const i4 = this._eventedParent;
              i4 && (Je(t4, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i4.fire(t4));
            } else t4 instanceof Vn && console.error(t4.error);
            return this;
          }
          listens(t4) {
            return !!(this._listeners && this._listeners[t4] && this._listeners[t4].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t4] && this._oneTimeListeners[t4].length > 0 || this._eventedParent && this._eventedParent.listens(t4));
          }
          setEventedParent(t4, e4) {
            return this._eventedParent = t4, this._eventedParentData = e4, this;
          }
        }
        t3.z = void 0;
        var Ln = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function Fn(t4) {
          return (t4 = Math.round(t4)) < 0 ? 0 : t4 > 255 ? 255 : t4;
        }
        function On(t4) {
          return Fn("%" === t4[t4.length - 1] ? parseFloat(t4) / 100 * 255 : parseInt(t4));
        }
        function Un(t4) {
          return (e4 = "%" === t4[t4.length - 1] ? parseFloat(t4) / 100 : parseFloat(t4)) < 0 ? 0 : e4 > 1 ? 1 : e4;
          var e4;
        }
        function Nn(t4, e4, r4) {
          return r4 < 0 ? r4 += 1 : r4 > 1 && (r4 -= 1), 6 * r4 < 1 ? t4 + (e4 - t4) * r4 * 6 : 2 * r4 < 1 ? e4 : 3 * r4 < 2 ? t4 + (e4 - t4) * (2 / 3 - r4) * 6 : t4;
        }
        try {
          t3.z = {}.parseCSSColor = function(t4) {
            var e4, r4 = t4.replace(/ /g, "").toLowerCase();
            if (r4 in Ln) return Ln[r4].slice();
            if ("#" === r4[0]) return 4 === r4.length ? (e4 = parseInt(r4.substr(1), 16)) >= 0 && e4 <= 4095 ? [(3840 & e4) >> 4 | (3840 & e4) >> 8, 240 & e4 | (240 & e4) >> 4, 15 & e4 | (15 & e4) << 4, 1] : null : 7 === r4.length && (e4 = parseInt(r4.substr(1), 16)) >= 0 && e4 <= 16777215 ? [(16711680 & e4) >> 16, (65280 & e4) >> 8, 255 & e4, 1] : null;
            var n3 = r4.indexOf("("), i4 = r4.indexOf(")");
            if (-1 !== n3 && i4 + 1 === r4.length) {
              var s4 = r4.substr(0, n3), a4 = r4.substr(n3 + 1, i4 - (n3 + 1)).split(","), o3 = 1;
              switch (s4) {
                case "rgba":
                  if (4 !== a4.length) return null;
                  o3 = Un(a4.pop());
                case "rgb":
                  return 3 !== a4.length ? null : [On(a4[0]), On(a4[1]), On(a4[2]), o3];
                case "hsla":
                  if (4 !== a4.length) return null;
                  o3 = Un(a4.pop());
                case "hsl":
                  if (3 !== a4.length) return null;
                  var l4 = (parseFloat(a4[0]) % 360 + 360) % 360 / 360, u5 = Un(a4[1]), c4 = Un(a4[2]), h4 = c4 <= 0.5 ? c4 * (u5 + 1) : c4 + u5 - c4 * u5, p4 = 2 * c4 - h4;
                  return [Fn(255 * Nn(p4, h4, l4 + 1 / 3)), Fn(255 * Nn(p4, h4, l4)), Fn(255 * Nn(p4, h4, l4 - 1 / 3)), o3];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t4) {
        }
        class jn {
          constructor(t4, e4, r4, n3 = 1) {
            this.r = t4, this.g = e4, this.b = r4, this.a = n3;
          }
          static parse(e4) {
            if (!e4) return;
            if (e4 instanceof jn) return e4;
            if ("string" != typeof e4) return;
            const r4 = t3.z(e4);
            return r4 ? new jn(r4[0] / 255 * r4[3], r4[1] / 255 * r4[3], r4[2] / 255 * r4[3], r4[3]) : void 0;
          }
          toString() {
            const [t4, e4, r4, n3] = this.toArray();
            return `rgba(${Math.round(t4)},${Math.round(e4)},${Math.round(r4)},${n3})`;
          }
          toArray() {
            const { r: t4, g: e4, b: r4, a: n3 } = this;
            return 0 === n3 ? [0, 0, 0, 0] : [255 * t4 / n3, 255 * e4 / n3, 255 * r4 / n3, n3];
          }
          toArray01() {
            const { r: t4, g: e4, b: r4, a: n3 } = this;
            return 0 === n3 ? [0, 0, 0, 0] : [t4 / n3, e4 / n3, r4 / n3, n3];
          }
          toArray01Scaled(t4) {
            const { r: e4, g: r4, b: n3, a: i4 } = this;
            return 0 === i4 ? [0, 0, 0] : [e4 / i4 * t4, r4 / i4 * t4, n3 / i4 * t4];
          }
          toArray01PremultipliedAlpha() {
            const { r: t4, g: e4, b: r4, a: n3 } = this;
            return [t4, e4, r4, n3];
          }
          toArray01Linear() {
            const { r: t4, g: e4, b: r4, a: n3 } = this;
            return 0 === n3 ? [0, 0, 0, 0] : [Math.pow(t4 / n3, 2.2), Math.pow(e4 / n3, 2.2), Math.pow(r4 / n3, 2.2), n3];
          }
        }
        function qn(t4, e4, r4) {
          return t4 * (1 - r4) + e4 * r4;
        }
        function $n(t4, e4, r4) {
          return t4.map((t5, n3) => qn(t5, e4[n3], r4));
        }
        jn.black = new jn(0, 0, 0, 1), jn.white = new jn(1, 1, 1, 1), jn.transparent = new jn(0, 0, 0, 0), jn.red = new jn(1, 0, 0, 1), jn.blue = new jn(0, 0, 1, 1);
        var Gn = Object.freeze({ __proto__: null, array: $n, color: function(t4, e4, r4) {
          return new jn(qn(t4.r, e4.r, r4), qn(t4.g, e4.g, r4), qn(t4.b, e4.b, r4), qn(t4.a, e4.a, r4));
        }, number: qn });
        function Qn(t4, ...e4) {
          for (const r4 of e4) for (const e5 in r4) t4[e5] = r4[e5];
          return t4;
        }
        class Yn extends Error {
          constructor(t4, e4) {
            super(e4), this.message = e4, this.key = t4;
          }
        }
        class Xn {
          constructor(t4, e4 = []) {
            this.parent = t4, this.bindings = {};
            for (const [t5, r4] of e4) this.bindings[t5] = r4;
          }
          concat(t4) {
            return new Xn(this, t4);
          }
          get(t4) {
            if (this.bindings[t4]) return this.bindings[t4];
            if (this.parent) return this.parent.get(t4);
            throw new Error(`${t4} not found in scope.`);
          }
          has(t4) {
            return !!this.bindings[t4] || !!this.parent && this.parent.has(t4);
          }
        }
        const Zn = { kind: "null" }, Kn = { kind: "number" }, Wn = { kind: "string" }, Hn = { kind: "boolean" }, Jn = { kind: "color" }, ti = { kind: "object" }, ei = { kind: "value" }, ri = { kind: "collator" }, ni = { kind: "formatted" }, ii = { kind: "resolvedImage" };
        function si(t4, e4) {
          return { kind: "array", itemType: t4, N: e4 };
        }
        function ai(t4) {
          if ("array" === t4.kind) {
            const e4 = ai(t4.itemType);
            return "number" == typeof t4.N ? `array<${e4}, ${t4.N}>` : "value" === t4.itemType.kind ? "array" : `array<${e4}>`;
          }
          return t4.kind;
        }
        const oi = [Zn, Kn, Wn, Hn, Jn, ni, ti, si(ei), ii];
        function li(t4, e4) {
          if ("error" === e4.kind) return null;
          if ("array" === t4.kind) {
            if ("array" === e4.kind && (0 === e4.N && "value" === e4.itemType.kind || !li(t4.itemType, e4.itemType)) && ("number" != typeof t4.N || t4.N === e4.N)) return null;
          } else {
            if (t4.kind === e4.kind) return null;
            if ("value" === t4.kind) {
              for (const t5 of oi) if (!li(t5, e4)) return null;
            }
          }
          return `Expected ${ai(t4)} but found ${ai(e4)} instead.`;
        }
        function ui(t4, e4) {
          return e4.some((e5) => e5.kind === t4.kind);
        }
        function ci(t4, e4) {
          return e4.some((e5) => "null" === e5 ? null === t4 : "array" === e5 ? Array.isArray(t4) : "object" === e5 ? t4 && !Array.isArray(t4) && "object" == typeof t4 : e5 === typeof t4);
        }
        class hi {
          constructor(t4, e4, r4) {
            this.sensitivity = t4 ? e4 ? "variant" : "case" : e4 ? "accent" : "base", this.locale = r4, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t4, e4) {
            return this.collator.compare(t4, e4);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class pi {
          constructor(t4, e4, r4, n3, i4) {
            this.text = t4.normalize ? t4.normalize() : t4, this.image = e4, this.scale = r4, this.fontStack = n3, this.textColor = i4;
          }
        }
        class fi {
          constructor(t4) {
            this.sections = t4;
          }
          static fromString(t4) {
            return new fi([new pi(t4, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t4) => 0 !== t4.text.length || t4.image && 0 !== t4.image.namePrimary.length);
          }
          static factory(t4) {
            return t4 instanceof fi ? t4 : fi.fromString(t4);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t4) => t4.text).join("");
          }
          serialize() {
            const t4 = ["format"];
            for (const e4 of this.sections) {
              if (e4.image) {
                t4.push(["image", e4.image.namePrimary]);
                continue;
              }
              t4.push(e4.text);
              const r4 = {};
              e4.fontStack && (r4["text-font"] = ["literal", e4.fontStack.split(",")]), e4.scale && (r4["font-scale"] = e4.scale), e4.textColor && (r4["text-color"] = ["rgba"].concat(e4.textColor.toArray())), t4.push(r4);
            }
            return t4;
          }
        }
        class di {
          constructor(t4) {
            this.namePrimary = t4.namePrimary, t4.nameSecondary && (this.nameSecondary = t4.nameSecondary), this.available = t4.available;
          }
          toString() {
            return this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
          }
          static fromString(t4, e4) {
            return t4 ? new di({ namePrimary: t4, nameSecondary: e4, available: false }) : null;
          }
          serialize() {
            return this.nameSecondary ? ["image", this.namePrimary, this.nameSecondary] : ["image", this.namePrimary];
          }
        }
        function mi(t4, e4, r4, n3) {
          return "number" == typeof t4 && t4 >= 0 && t4 <= 255 && "number" == typeof e4 && e4 >= 0 && e4 <= 255 && "number" == typeof r4 && r4 >= 0 && r4 <= 255 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid rgba value [${[t4, e4, r4, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n3 ? [t4, e4, r4, n3] : [t4, e4, r4]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function yi(t4) {
          if (null === t4) return true;
          if ("string" == typeof t4) return true;
          if ("boolean" == typeof t4) return true;
          if ("number" == typeof t4) return true;
          if (t4 instanceof jn) return true;
          if (t4 instanceof hi) return true;
          if (t4 instanceof fi) return true;
          if (t4 instanceof di) return true;
          if (Array.isArray(t4)) {
            for (const e4 of t4) if (!yi(e4)) return false;
            return true;
          }
          if ("object" == typeof t4) {
            for (const e4 in t4) if (!yi(t4[e4])) return false;
            return true;
          }
          return false;
        }
        function gi(t4) {
          if (null === t4) return Zn;
          if ("string" == typeof t4) return Wn;
          if ("boolean" == typeof t4) return Hn;
          if ("number" == typeof t4) return Kn;
          if (t4 instanceof jn) return Jn;
          if (t4 instanceof hi) return ri;
          if (t4 instanceof fi) return ni;
          if (t4 instanceof di) return ii;
          if (Array.isArray(t4)) {
            const e4 = t4.length;
            let r4;
            for (const e5 of t4) {
              const t5 = gi(e5);
              if (r4) {
                if (r4 === t5) continue;
                r4 = ei;
                break;
              }
              r4 = t5;
            }
            return si(r4 || ei, e4);
          }
          return ti;
        }
        function xi(t4) {
          const e4 = typeof t4;
          return null === t4 ? "" : "string" === e4 || "number" === e4 || "boolean" === e4 ? String(t4) : t4 instanceof jn || t4 instanceof fi || t4 instanceof di ? t4.toString() : JSON.stringify(t4);
        }
        class bi {
          constructor(t4, e4) {
            this.type = t4, this.value = e4;
          }
          static parse(t4, e4) {
            if (2 !== t4.length) return e4.error(`'literal' expression requires exactly one argument, but found ${t4.length - 1} instead.`);
            if (!yi(t4[1])) return e4.error("invalid value");
            const r4 = t4[1];
            let n3 = gi(r4);
            const i4 = e4.expectedType;
            return "array" !== n3.kind || 0 !== n3.N || !i4 || "array" !== i4.kind || "number" == typeof i4.N && 0 !== i4.N || (n3 = i4), new bi(n3, r4);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof jn ? ["rgba"].concat(this.value.toArray()) : this.value instanceof fi ? this.value.serialize() : this.value;
          }
        }
        class vi {
          constructor(t4) {
            this.name = "ExpressionEvaluationError", this.message = t4;
          }
          toJSON() {
            return this.message;
          }
        }
        const _i = { string: Wn, number: Kn, boolean: Hn, object: ti };
        class wi {
          constructor(t4, e4) {
            this.type = t4, this.args = e4;
          }
          static parse(t4, e4) {
            if (t4.length < 2) return e4.error("Expected at least one argument.");
            let r4, n3 = 1;
            const i4 = t4[0];
            if ("array" === i4) {
              let i5, s5;
              if (t4.length > 2) {
                const r5 = t4[1];
                if ("string" != typeof r5 || !(r5 in _i) || "object" === r5) return e4.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i5 = _i[r5], n3++;
              } else i5 = ei;
              if (t4.length > 3) {
                if (null !== t4[2] && ("number" != typeof t4[2] || t4[2] < 0 || t4[2] !== Math.floor(t4[2]))) return e4.error('The length argument to "array" must be a positive integer literal', 2);
                s5 = t4[2], n3++;
              }
              r4 = si(i5, s5);
            } else r4 = _i[i4];
            const s4 = [];
            for (; n3 < t4.length; n3++) {
              const r5 = e4.parse(t4[n3], n3, ei);
              if (!r5) return null;
              s4.push(r5);
            }
            return new wi(r4, s4);
          }
          evaluate(t4) {
            for (let e4 = 0; e4 < this.args.length; e4++) {
              const r4 = this.args[e4].evaluate(t4);
              if (!li(this.type, gi(r4))) return r4;
              if (e4 === this.args.length - 1) throw new vi(`Expected value to be of type ${ai(this.type)}, but found ${ai(gi(r4))} instead.`);
            }
            return null;
          }
          eachChild(t4) {
            this.args.forEach(t4);
          }
          outputDefined() {
            return this.args.every((t4) => t4.outputDefined());
          }
          serialize() {
            const t4 = this.type, e4 = [t4.kind];
            if ("array" === t4.kind) {
              const r4 = t4.itemType;
              if ("string" === r4.kind || "number" === r4.kind || "boolean" === r4.kind) {
                e4.push(r4.kind);
                const n3 = t4.N;
                ("number" == typeof n3 || this.args.length > 1) && e4.push(n3);
              }
            }
            return e4.concat(this.args.map((t5) => t5.serialize()));
          }
        }
        class Mi {
          constructor(t4) {
            this.type = ni, this.sections = t4;
          }
          static parse(t4, e4) {
            if (t4.length < 2) return e4.error("Expected at least one argument.");
            const r4 = t4[1];
            if (!Array.isArray(r4) && "object" == typeof r4) return e4.error("First argument must be an image or text section.");
            const n3 = [];
            let i4 = false;
            for (let r5 = 1; r5 <= t4.length - 1; ++r5) {
              const s4 = t4[r5];
              if (i4 && "object" == typeof s4 && !Array.isArray(s4)) {
                i4 = false;
                let t5 = null;
                if (s4["font-scale"] && (t5 = e4.parse(s4["font-scale"], 1, Kn), !t5)) return null;
                let r6 = null;
                if (s4["text-font"] && (r6 = e4.parse(s4["text-font"], 1, si(Wn)), !r6)) return null;
                let a4 = null;
                if (s4["text-color"] && (a4 = e4.parse(s4["text-color"], 1, Jn), !a4)) return null;
                const o3 = n3[n3.length - 1];
                o3.scale = t5, o3.font = r6, o3.textColor = a4;
              } else {
                const s5 = e4.parse(t4[r5], 1, ei);
                if (!s5) return null;
                const a4 = s5.type.kind;
                if ("string" !== a4 && "value" !== a4 && "null" !== a4 && "resolvedImage" !== a4) return e4.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i4 = true, n3.push({ content: s5, scale: null, font: null, textColor: null });
              }
            }
            return new Mi(n3);
          }
          evaluate(t4) {
            return new fi(this.sections.map((e4) => {
              const r4 = e4.content.evaluate(t4);
              return gi(r4) === ii ? new pi("", r4, null, null, null) : new pi(xi(r4), null, e4.scale ? e4.scale.evaluate(t4) : null, e4.font ? e4.font.evaluate(t4).join(",") : null, e4.textColor ? e4.textColor.evaluate(t4) : null);
            }));
          }
          eachChild(t4) {
            for (const e4 of this.sections) t4(e4.content), e4.scale && t4(e4.scale), e4.font && t4(e4.font), e4.textColor && t4(e4.textColor);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t4 = ["format"];
            for (const e4 of this.sections) {
              t4.push(e4.content.serialize());
              const r4 = {};
              e4.scale && (r4["font-scale"] = e4.scale.serialize()), e4.font && (r4["text-font"] = e4.font.serialize()), e4.textColor && (r4["text-color"] = e4.textColor.serialize()), t4.push(r4);
            }
            return t4;
          }
        }
        class Ai {
          constructor(t4, e4) {
            this.type = ii, this.inputPrimary = t4, this.inputSecondary = e4;
          }
          static parse(t4, e4) {
            if (t4.length < 2) return e4.error("Expected two or more arguments.");
            const r4 = e4.parse(t4[1], 1, Wn);
            if (!r4) return e4.error("No image name provided.");
            if (2 === t4.length) return new Ai(r4);
            const n3 = e4.parse(t4[2], 1, Wn);
            return n3 ? new Ai(r4, n3) : e4.error("Secondary image variant is not a string.");
          }
          evaluate(t4) {
            const e4 = di.fromString(this.inputPrimary.evaluate(t4), this.inputSecondary ? this.inputSecondary.evaluate(t4) : void 0);
            return e4 && t4.availableImages && (e4.available = t4.availableImages.indexOf(e4.namePrimary) > -1, e4.nameSecondary && e4.available && t4.availableImages && (e4.available = t4.availableImages.indexOf(e4.nameSecondary) > -1)), e4;
          }
          eachChild(t4) {
            t4(this.inputPrimary), this.inputSecondary && t4(this.inputSecondary);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return this.inputSecondary ? ["image", this.inputPrimary.serialize(), this.inputSecondary.serialize()] : ["image", this.inputPrimary.serialize()];
          }
        }
        function Si(t4) {
          return t4 instanceof Number ? "number" : t4 instanceof String ? "string" : t4 instanceof Boolean ? "boolean" : Array.isArray(t4) ? "array" : null === t4 ? "null" : typeof t4;
        }
        const Ii = { "to-boolean": Hn, "to-color": Jn, "to-number": Kn, "to-string": Wn };
        class ki {
          constructor(t4, e4) {
            this.type = t4, this.args = e4;
          }
          static parse(t4, e4) {
            if (t4.length < 2) return e4.error("Expected at least one argument.");
            const r4 = t4[0], n3 = [];
            let i4 = Zn;
            if ("to-array" === r4) {
              if (!Array.isArray(t4[1])) return null;
              const r5 = t4[1].length;
              if (e4.expectedType) {
                if ("array" !== e4.expectedType.kind) return e4.error(`Expected ${e4.expectedType.kind} but found array.`);
                i4 = si(e4.expectedType.itemType, r5);
              } else {
                if (!(r5 > 0 && yi(t4[1][0]))) return null;
                i4 = si(gi(t4[1][0]), r5);
              }
              for (let s4 = 0; s4 < r5; s4++) {
                const r6 = t4[1][s4];
                let a4;
                if ("array" === Si(r6)) a4 = e4.parse(r6, void 0, i4.itemType);
                else {
                  const t5 = Si(r6);
                  if (t5 !== i4.itemType.kind) return e4.error(`Expected ${i4.itemType.kind} but found ${t5}.`);
                  a4 = e4.registry.literal.parse(["literal", void 0 === r6 ? null : r6], e4);
                }
                if (!a4) return null;
                n3.push(a4);
              }
            } else {
              if (("to-boolean" === r4 || "to-string" === r4) && 2 !== t4.length) return e4.error("Expected one argument.");
              i4 = Ii[r4];
              for (let r5 = 1; r5 < t4.length; r5++) {
                const i5 = e4.parse(t4[r5], r5, ei);
                if (!i5) return null;
                n3.push(i5);
              }
            }
            return new ki(i4, n3);
          }
          evaluate(t4) {
            if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t4));
            if ("color" === this.type.kind) {
              let e4, r4;
              for (const n3 of this.args) {
                if (e4 = n3.evaluate(t4), r4 = null, e4 instanceof jn) return e4;
                if ("string" == typeof e4) {
                  const r5 = t4.parseColor(e4);
                  if (r5) return r5;
                } else if (Array.isArray(e4) && (r4 = e4.length < 3 || e4.length > 4 ? `Invalid rbga value ${JSON.stringify(e4)}: expected an array containing either three or four numeric values.` : mi(e4[0], e4[1], e4[2], e4[3]), !r4)) return new jn(e4[0] / 255, e4[1] / 255, e4[2] / 255, e4[3]);
              }
              throw new vi(r4 || `Could not parse color from value '${"string" == typeof e4 ? e4 : String(JSON.stringify(e4))}'`);
            }
            if ("number" === this.type.kind) {
              let e4 = null;
              for (const r4 of this.args) {
                if (e4 = r4.evaluate(t4), null === e4) return 0;
                const n3 = Number(e4);
                if (!isNaN(n3)) return n3;
              }
              throw new vi(`Could not convert ${JSON.stringify(e4)} to number.`);
            }
            return "formatted" === this.type.kind ? fi.fromString(xi(this.args[0].evaluate(t4))) : "resolvedImage" === this.type.kind ? di.fromString(xi(this.args[0].evaluate(t4))) : "array" === this.type.kind ? this.args.map((e4) => e4.evaluate(t4)) : xi(this.args[0].evaluate(t4));
          }
          eachChild(t4) {
            this.args.forEach(t4);
          }
          outputDefined() {
            return this.args.every((t4) => t4.outputDefined());
          }
          serialize() {
            if ("formatted" === this.type.kind) return new Mi([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if ("resolvedImage" === this.type.kind) return new Ai(this.args[0]).serialize();
            const t4 = "array" === this.type.kind ? [] : [`to-${this.type.kind}`];
            return this.eachChild((e4) => {
              t4.push(e4.serialize());
            }), t4;
          }
        }
        const Pi = ["Unknown", "Point", "LineString", "Polygon"];
        class Ei {
          constructor(t4, e4) {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t4, this.options = e4;
          }
          id() {
            return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? Pi[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          measureLight(t4) {
            return this.globals.brightness || 0;
          }
          distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
              const t4 = this.featureDistanceData.center, e4 = this.featureDistanceData.scale, { x: r4, y: n3 } = this.featureTileCoord;
              return this.featureDistanceData.bearing[0] * (r4 * e4 - t4[0]) + this.featureDistanceData.bearing[1] * (n3 * e4 - t4[1]);
            }
            return 0;
          }
          parseColor(t4) {
            let e4 = this._parseColorCache[t4];
            return e4 || (e4 = this._parseColorCache[t4] = jn.parse(t4)), e4;
          }
          getConfig(t4) {
            return this.options ? this.options.get(t4) : null;
          }
        }
        class zi {
          constructor(t4, e4, r4, n3, i4) {
            this.name = t4, this.type = e4, this._evaluate = r4, this.args = n3, this._overloadIndex = i4;
          }
          evaluate(t4) {
            if (!this._evaluate) {
              const t5 = zi.definitions[this.name];
              this._evaluate = Array.isArray(t5) ? t5[2] : t5.overloads[this._overloadIndex][1];
            }
            return this._evaluate(t4, this.args);
          }
          eachChild(t4) {
            this.args.forEach(t4);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return [this.name].concat(this.args.map((t4) => t4.serialize()));
          }
          static parse(t4, e4) {
            const r4 = t4[0], n3 = zi.definitions[r4];
            if (!n3) return e4.error(`Unknown expression "${r4}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i4 = Array.isArray(n3) ? n3[0] : n3.type, s4 = Array.isArray(n3) ? [[n3[1], n3[2]]] : n3.overloads, a4 = [];
            let o3 = null, l4 = -1;
            for (const [n4, u5] of s4) {
              if (Array.isArray(n4) && n4.length !== t4.length - 1) continue;
              a4.push(n4), l4++, o3 = new qs(e4.registry, e4.path, null, e4.scope, void 0, e4._scope, e4.options);
              const s5 = [];
              let c4 = false;
              for (let e5 = 1; e5 < t4.length; e5++) {
                const r5 = t4[e5], i5 = Array.isArray(n4) ? n4[e5 - 1] : n4.type, a5 = o3.parse(r5, 1 + s5.length, i5);
                if (!a5) {
                  c4 = true;
                  break;
                }
                s5.push(a5);
              }
              if (!c4) if (Array.isArray(n4) && n4.length !== s5.length) o3.error(`Expected ${n4.length} arguments, but found ${s5.length} instead.`);
              else {
                for (let t5 = 0; t5 < s5.length; t5++) {
                  const e5 = Array.isArray(n4) ? n4[t5] : n4.type, r5 = s5[t5];
                  o3.concat(t5 + 1).checkSubtype(e5, r5.type);
                }
                if (0 === o3.errors.length) return new zi(r4, i4, u5, s5, l4);
              }
            }
            if (1 === a4.length) e4.errors.push(...o3.errors);
            else {
              const r5 = (a4.length ? a4 : s4.map(([t5]) => t5)).map(Ti).join(" | "), n4 = [];
              for (let r6 = 1; r6 < t4.length; r6++) {
                const i5 = e4.parse(t4[r6], 1 + n4.length);
                if (!i5) return null;
                n4.push(ai(i5.type));
              }
              e4.error(`Expected arguments of type ${r5}, but found (${n4.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t4, e4) {
            zi.definitions = e4;
            for (const r4 in e4) t4[r4] = zi;
          }
        }
        function Ti(t4) {
          return Array.isArray(t4) ? `(${t4.map(ai).join(", ")})` : `(${ai(t4.type)}...)`;
        }
        class Bi {
          constructor(t4, e4, r4) {
            this.type = ri, this.locale = r4, this.caseSensitive = t4, this.diacriticSensitive = e4;
          }
          static parse(t4, e4) {
            if (2 !== t4.length) return e4.error("Expected one argument.");
            const r4 = t4[1];
            if ("object" != typeof r4 || Array.isArray(r4)) return e4.error("Collator options argument must be an object.");
            const n3 = e4.parse(void 0 !== r4["case-sensitive"] && r4["case-sensitive"], 1, Hn);
            if (!n3) return null;
            const i4 = e4.parse(void 0 !== r4["diacritic-sensitive"] && r4["diacritic-sensitive"], 1, Hn);
            if (!i4) return null;
            let s4 = null;
            return r4.locale && (s4 = e4.parse(r4.locale, 1, Wn), !s4) ? null : new Bi(n3, i4, s4);
          }
          evaluate(t4) {
            return new hi(this.caseSensitive.evaluate(t4), this.diacriticSensitive.evaluate(t4), this.locale ? this.locale.evaluate(t4) : null);
          }
          eachChild(t4) {
            t4(this.caseSensitive), t4(this.diacriticSensitive), this.locale && t4(this.locale);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t4 = {};
            return t4["case-sensitive"] = this.caseSensitive.serialize(), t4["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t4.locale = this.locale.serialize()), ["collator", t4];
          }
        }
        var Ci = { exports: {} };
        Ci.exports = /* @__PURE__ */ function() {
          function t4(r5, n3, i4, s4, a4) {
            for (; s4 > i4; ) {
              if (s4 - i4 > 600) {
                var o3 = s4 - i4 + 1, l4 = n3 - i4 + 1, u5 = Math.log(o3), c4 = 0.5 * Math.exp(2 * u5 / 3), h4 = 0.5 * Math.sqrt(u5 * c4 * (o3 - c4) / o3) * (l4 - o3 / 2 < 0 ? -1 : 1);
                t4(r5, n3, Math.max(i4, Math.floor(n3 - l4 * c4 / o3 + h4)), Math.min(s4, Math.floor(n3 + (o3 - l4) * c4 / o3 + h4)), a4);
              }
              var p4 = r5[n3], f4 = i4, d3 = s4;
              for (e4(r5, i4, n3), a4(r5[s4], p4) > 0 && e4(r5, i4, s4); f4 < d3; ) {
                for (e4(r5, f4, d3), f4++, d3--; a4(r5[f4], p4) < 0; ) f4++;
                for (; a4(r5[d3], p4) > 0; ) d3--;
              }
              0 === a4(r5[i4], p4) ? e4(r5, i4, d3) : e4(r5, ++d3, s4), d3 <= n3 && (i4 = d3 + 1), n3 <= d3 && (s4 = d3 - 1);
            }
          }
          function e4(t5, e5, r5) {
            var n3 = t5[e5];
            t5[e5] = t5[r5], t5[r5] = n3;
          }
          function r4(t5, e5) {
            return t5 < e5 ? -1 : t5 > e5 ? 1 : 0;
          }
          return function(e5, n3, i4, s4, a4) {
            t4(e5, n3, i4 || 0, s4 || e5.length - 1, a4 || r4);
          };
        }();
        var Ri = h3(Ci.exports);
        function Vi(t4) {
          let e4 = 0;
          for (let r4, n3, i4 = 0, s4 = t4.length, a4 = s4 - 1; i4 < s4; a4 = i4++) r4 = t4[i4], n3 = t4[a4], e4 += (n3.x - r4.x) * (r4.y + n3.y);
          return e4;
        }
        function Di(t4, e4) {
          t4[0] = Math.min(t4[0], e4[0]), t4[1] = Math.min(t4[1], e4[1]), t4[2] = Math.max(t4[2], e4[0]), t4[3] = Math.max(t4[3], e4[1]);
        }
        function Li(t4, e4) {
          return !(t4[0] <= e4[0] || t4[2] >= e4[2] || t4[1] <= e4[1] || t4[3] >= e4[3]);
        }
        function Fi(t4, e4, r4) {
          const n3 = t4[0] - e4[0], i4 = t4[1] - e4[1], s4 = t4[0] - r4[0], a4 = t4[1] - r4[1];
          return n3 * a4 - s4 * i4 == 0 && n3 * s4 <= 0 && i4 * a4 <= 0;
        }
        function Oi(t4, e4, r4 = false) {
          let n3 = false;
          for (let o3 = 0, l4 = e4.length; o3 < l4; o3++) {
            const l5 = e4[o3];
            for (let e5 = 0, o4 = l5.length, u5 = o4 - 1; e5 < o4; u5 = e5++) {
              const o5 = l5[u5], c4 = l5[e5];
              if (Fi(t4, o5, c4)) return r4;
              (s4 = o5)[1] > (i4 = t4)[1] != (a4 = c4)[1] > i4[1] && i4[0] < (a4[0] - s4[0]) * (i4[1] - s4[1]) / (a4[1] - s4[1]) + s4[0] && (n3 = !n3);
            }
          }
          var i4, s4, a4;
          return n3;
        }
        function Ui(t4, e4, r4, n3) {
          const i4 = n3[0] - r4[0], s4 = n3[1] - r4[1], a4 = (t4[0] - r4[0]) * s4 - i4 * (t4[1] - r4[1]), o3 = (e4[0] - r4[0]) * s4 - i4 * (e4[1] - r4[1]);
          return a4 > 0 && o3 < 0 || a4 < 0 && o3 > 0;
        }
        function Ni(t4, e4, r4, n3) {
          return 0 != (i4 = [n3[0] - r4[0], n3[1] - r4[1]])[0] * (s4 = [e4[0] - t4[0], e4[1] - t4[1]])[1] - i4[1] * s4[0] && !(!Ui(t4, e4, r4, n3) || !Ui(r4, n3, t4, e4));
          var i4, s4;
        }
        const ji = 8192;
        function qi(t4, e4) {
          const r4 = (180 + t4[0]) / 360, n3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t4[1] * Math.PI / 360))) / 360, i4 = Math.pow(2, e4.z);
          return [Math.round(r4 * i4 * ji), Math.round(n3 * i4 * ji)];
        }
        function $i(t4, e4) {
          for (let r4 = 0; r4 < e4.length; r4++) if (Oi(t4, e4[r4])) return true;
          return false;
        }
        function Gi(t4, e4, r4) {
          for (const n3 of r4) for (let r5 = 0, i4 = n3.length, s4 = i4 - 1; r5 < i4; s4 = r5++) if (Ni(t4, e4, n3[s4], n3[r5])) return true;
          return false;
        }
        function Qi(t4, e4) {
          for (let r4 = 0; r4 < t4.length; ++r4) if (!Oi(t4[r4], e4)) return false;
          for (let r4 = 0; r4 < t4.length - 1; ++r4) if (Gi(t4[r4], t4[r4 + 1], e4)) return false;
          return true;
        }
        function Yi(t4, e4) {
          for (let r4 = 0; r4 < e4.length; r4++) if (Qi(t4, e4[r4])) return true;
          return false;
        }
        function Xi(t4, e4, r4) {
          const n3 = [];
          for (let i4 = 0; i4 < t4.length; i4++) {
            const s4 = [];
            for (let n4 = 0; n4 < t4[i4].length; n4++) {
              const a4 = qi(t4[i4][n4], r4);
              Di(e4, a4), s4.push(a4);
            }
            n3.push(s4);
          }
          return n3;
        }
        function Zi(t4, e4, r4) {
          const n3 = [];
          for (let i4 = 0; i4 < t4.length; i4++) {
            const s4 = Xi(t4[i4], e4, r4);
            n3.push(s4);
          }
          return n3;
        }
        function Ki(t4, e4, r4, n3) {
          if (t4[0] < r4[0] || t4[0] > r4[2]) {
            const e5 = 0.5 * n3;
            let i4 = t4[0] - r4[0] > e5 ? -n3 : r4[0] - t4[0] > e5 ? n3 : 0;
            0 === i4 && (i4 = t4[0] - r4[2] > e5 ? -n3 : r4[2] - t4[0] > e5 ? n3 : 0), t4[0] += i4;
          }
          Di(e4, t4);
        }
        function Wi(t4, e4, r4, n3) {
          const i4 = Math.pow(2, n3.z) * ji, s4 = [n3.x * ji, n3.y * ji], a4 = [];
          if (!t4) return a4;
          for (const n4 of t4) for (const t5 of n4) {
            const n5 = [t5.x + s4[0], t5.y + s4[1]];
            Ki(n5, e4, r4, i4), a4.push(n5);
          }
          return a4;
        }
        function Hi(t4, e4, r4, n3) {
          const i4 = Math.pow(2, n3.z) * ji, s4 = [n3.x * ji, n3.y * ji], a4 = [];
          if (!t4) return a4;
          for (const r5 of t4) {
            const t5 = [];
            for (const n4 of r5) {
              const r6 = [n4.x + s4[0], n4.y + s4[1]];
              Di(e4, r6), t5.push(r6);
            }
            a4.push(t5);
          }
          if (e4[2] - e4[0] <= i4 / 2) {
            (o3 = e4)[0] = o3[1] = 1 / 0, o3[2] = o3[3] = -1 / 0;
            for (const t5 of a4) for (const n4 of t5) Ki(n4, e4, r4, i4);
          }
          var o3;
          return a4;
        }
        class Ji {
          constructor(t4, e4) {
            this.type = Hn, this.geojson = t4, this.geometries = e4;
          }
          static parse(t4, e4) {
            if (2 !== t4.length) return e4.error(`'within' expression requires exactly one argument, but found ${t4.length - 1} instead.`);
            if (yi(t4[1])) {
              const e5 = t4[1];
              if ("FeatureCollection" === e5.type) for (let t5 = 0; t5 < e5.features.length; ++t5) {
                const r4 = e5.features[t5].geometry.type;
                if ("Polygon" === r4 || "MultiPolygon" === r4) return new Ji(e5, e5.features[t5].geometry);
              }
              else if ("Feature" === e5.type) {
                const t5 = e5.geometry.type;
                if ("Polygon" === t5 || "MultiPolygon" === t5) return new Ji(e5, e5.geometry);
              } else if ("Polygon" === e5.type || "MultiPolygon" === e5.type) return new Ji(e5, e5);
            }
            return e4.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t4) {
            if (null != t4.geometry() && null != t4.canonicalID()) {
              if ("Point" === t4.geometryType()) return function(t5, e4) {
                const r4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i4 = t5.canonicalID();
                if (!i4) return false;
                if ("Polygon" === e4.type) {
                  const s4 = Xi(e4.coordinates, n3, i4), a4 = Wi(t5.geometry(), r4, n3, i4);
                  if (!Li(r4, n3)) return false;
                  for (const t6 of a4) if (!Oi(t6, s4)) return false;
                }
                if ("MultiPolygon" === e4.type) {
                  const s4 = Zi(e4.coordinates, n3, i4), a4 = Wi(t5.geometry(), r4, n3, i4);
                  if (!Li(r4, n3)) return false;
                  for (const t6 of a4) if (!$i(t6, s4)) return false;
                }
                return true;
              }(t4, this.geometries);
              if ("LineString" === t4.geometryType()) return function(t5, e4) {
                const r4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i4 = t5.canonicalID();
                if (!i4) return false;
                if ("Polygon" === e4.type) {
                  const s4 = Xi(e4.coordinates, n3, i4), a4 = Hi(t5.geometry(), r4, n3, i4);
                  if (!Li(r4, n3)) return false;
                  for (const t6 of a4) if (!Qi(t6, s4)) return false;
                }
                if ("MultiPolygon" === e4.type) {
                  const s4 = Zi(e4.coordinates, n3, i4), a4 = Hi(t5.geometry(), r4, n3, i4);
                  if (!Li(r4, n3)) return false;
                  for (const t6 of a4) if (!Yi(t6, s4)) return false;
                }
                return true;
              }(t4, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["within", this.geojson];
          }
        }
        var ts = { exports: {} };
        !function(t4, e4) {
          t4.exports = function() {
            var t5 = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, e5 = 1 / 298.257223563, r4 = e5 * (2 - e5), n3 = Math.PI / 180, i4 = function(e6, i5) {
              if (void 0 === e6) throw new Error("No latitude given.");
              if (i5 && !t5[i5]) throw new Error("Unknown unit " + i5 + ". Use one of: " + Object.keys(t5).join(", "));
              var s5 = 6378.137 * n3 * (i5 ? t5[i5] : 1), a5 = Math.cos(e6 * n3), o4 = 1 / (1 - r4 * (1 - a5 * a5)), l5 = Math.sqrt(o4);
              this.kx = s5 * l5 * a5, this.ky = s5 * l5 * o4 * (1 - r4);
            }, s4 = { units: { configurable: true } };
            function a4(t6, e6) {
              return t6[0] === e6[0] && t6[1] === e6[1];
            }
            function o3(t6, e6, r5) {
              var n4 = l4(e6[0] - t6[0]);
              return [t6[0] + n4 * r5, t6[1] + (e6[1] - t6[1]) * r5];
            }
            function l4(t6) {
              for (; t6 < -180; ) t6 += 360;
              for (; t6 > 180; ) t6 -= 360;
              return t6;
            }
            return i4.fromTile = function(t6, e6, r5) {
              var s5 = Math.PI * (1 - 2 * (t6 + 0.5) / Math.pow(2, e6)), a5 = Math.atan(0.5 * (Math.exp(s5) - Math.exp(-s5))) / n3;
              return new i4(a5, r5);
            }, s4.units.get = function() {
              return t5;
            }, i4.prototype.distance = function(t6, e6) {
              var r5 = l4(t6[0] - e6[0]) * this.kx, n4 = (t6[1] - e6[1]) * this.ky;
              return Math.sqrt(r5 * r5 + n4 * n4);
            }, i4.prototype.bearing = function(t6, e6) {
              var r5 = l4(e6[0] - t6[0]) * this.kx;
              return Math.atan2(r5, (e6[1] - t6[1]) * this.ky) / n3;
            }, i4.prototype.destination = function(t6, e6, r5) {
              var i5 = r5 * n3;
              return this.offset(t6, Math.sin(i5) * e6, Math.cos(i5) * e6);
            }, i4.prototype.offset = function(t6, e6, r5) {
              return [t6[0] + e6 / this.kx, t6[1] + r5 / this.ky];
            }, i4.prototype.lineDistance = function(t6) {
              for (var e6 = 0, r5 = 0; r5 < t6.length - 1; r5++) e6 += this.distance(t6[r5], t6[r5 + 1]);
              return e6;
            }, i4.prototype.area = function(t6) {
              for (var e6 = 0, r5 = 0; r5 < t6.length; r5++) for (var n4 = t6[r5], i5 = 0, s5 = n4.length, a5 = s5 - 1; i5 < s5; a5 = i5++) e6 += l4(n4[i5][0] - n4[a5][0]) * (n4[i5][1] + n4[a5][1]) * (r5 ? -1 : 1);
              return Math.abs(e6) / 2 * this.kx * this.ky;
            }, i4.prototype.along = function(t6, e6) {
              var r5 = 0;
              if (e6 <= 0) return t6[0];
              for (var n4 = 0; n4 < t6.length - 1; n4++) {
                var i5 = t6[n4], s5 = t6[n4 + 1], a5 = this.distance(i5, s5);
                if ((r5 += a5) > e6) return o3(i5, s5, (e6 - (r5 - a5)) / a5);
              }
              return t6[t6.length - 1];
            }, i4.prototype.pointToSegmentDistance = function(t6, e6, r5) {
              var n4 = e6[0], i5 = e6[1], s5 = l4(r5[0] - n4) * this.kx, a5 = (r5[1] - i5) * this.ky, o4 = 0;
              return 0 === s5 && 0 === a5 || ((o4 = (l4(t6[0] - n4) * this.kx * s5 + (t6[1] - i5) * this.ky * a5) / (s5 * s5 + a5 * a5)) > 1 ? (n4 = r5[0], i5 = r5[1]) : o4 > 0 && (n4 += s5 / this.kx * o4, i5 += a5 / this.ky * o4)), s5 = l4(t6[0] - n4) * this.kx, a5 = (t6[1] - i5) * this.ky, Math.sqrt(s5 * s5 + a5 * a5);
            }, i4.prototype.pointOnLine = function(t6, e6) {
              for (var r5, n4, i5, s5, a5 = 1 / 0, o4 = 0; o4 < t6.length - 1; o4++) {
                var u5 = t6[o4][0], c4 = t6[o4][1], h4 = l4(t6[o4 + 1][0] - u5) * this.kx, p4 = (t6[o4 + 1][1] - c4) * this.ky, f4 = 0;
                0 === h4 && 0 === p4 || ((f4 = (l4(e6[0] - u5) * this.kx * h4 + (e6[1] - c4) * this.ky * p4) / (h4 * h4 + p4 * p4)) > 1 ? (u5 = t6[o4 + 1][0], c4 = t6[o4 + 1][1]) : f4 > 0 && (u5 += h4 / this.kx * f4, c4 += p4 / this.ky * f4));
                var d3 = (h4 = l4(e6[0] - u5) * this.kx) * h4 + (p4 = (e6[1] - c4) * this.ky) * p4;
                d3 < a5 && (a5 = d3, r5 = u5, n4 = c4, i5 = o4, s5 = f4);
              }
              return { point: [r5, n4], index: i5, t: Math.max(0, Math.min(1, s5)) };
            }, i4.prototype.lineSlice = function(t6, e6, r5) {
              var n4 = this.pointOnLine(r5, t6), i5 = this.pointOnLine(r5, e6);
              if (n4.index > i5.index || n4.index === i5.index && n4.t > i5.t) {
                var s5 = n4;
                n4 = i5, i5 = s5;
              }
              var o4 = [n4.point], l5 = n4.index + 1, u5 = i5.index;
              !a4(r5[l5], o4[0]) && l5 <= u5 && o4.push(r5[l5]);
              for (var c4 = l5 + 1; c4 <= u5; c4++) o4.push(r5[c4]);
              return a4(r5[u5], i5.point) || o4.push(i5.point), o4;
            }, i4.prototype.lineSliceAlong = function(t6, e6, r5) {
              for (var n4 = 0, i5 = [], s5 = 0; s5 < r5.length - 1; s5++) {
                var a5 = r5[s5], l5 = r5[s5 + 1], u5 = this.distance(a5, l5);
                if ((n4 += u5) > t6 && 0 === i5.length && i5.push(o3(a5, l5, (t6 - (n4 - u5)) / u5)), n4 >= e6) return i5.push(o3(a5, l5, (e6 - (n4 - u5)) / u5)), i5;
                n4 > t6 && i5.push(l5);
              }
              return i5;
            }, i4.prototype.bufferPoint = function(t6, e6) {
              var r5 = e6 / this.ky, n4 = e6 / this.kx;
              return [t6[0] - n4, t6[1] - r5, t6[0] + n4, t6[1] + r5];
            }, i4.prototype.bufferBBox = function(t6, e6) {
              var r5 = e6 / this.ky, n4 = e6 / this.kx;
              return [t6[0] - n4, t6[1] - r5, t6[2] + n4, t6[3] + r5];
            }, i4.prototype.insideBBox = function(t6, e6) {
              return l4(t6[0] - e6[0]) >= 0 && l4(t6[0] - e6[2]) <= 0 && t6[1] >= e6[1] && t6[1] <= e6[3];
            }, Object.defineProperties(i4, s4), i4;
          }();
        }(ts);
        var es = h3(ts.exports), rs = { exports: {} };
        !function(t4, e4) {
          t4.exports = function() {
            var t5 = function(t6, r4) {
              if (void 0 === t6 && (t6 = []), void 0 === r4 && (r4 = e5), this.data = t6, this.length = this.data.length, this.compare = r4, this.length > 0) for (var n3 = (this.length >> 1) - 1; n3 >= 0; n3--) this._down(n3);
            };
            function e5(t6, e6) {
              return t6 < e6 ? -1 : t6 > e6 ? 1 : 0;
            }
            return t5.prototype.push = function(t6) {
              this.data.push(t6), this.length++, this._up(this.length - 1);
            }, t5.prototype.pop = function() {
              if (0 !== this.length) {
                var t6 = this.data[0], e6 = this.data.pop();
                return this.length--, this.length > 0 && (this.data[0] = e6, this._down(0)), t6;
              }
            }, t5.prototype.peek = function() {
              return this.data[0];
            }, t5.prototype._up = function(t6) {
              for (var e6 = this.data, r4 = this.compare, n3 = e6[t6]; t6 > 0; ) {
                var i4 = t6 - 1 >> 1, s4 = e6[i4];
                if (r4(n3, s4) >= 0) break;
                e6[t6] = s4, t6 = i4;
              }
              e6[t6] = n3;
            }, t5.prototype._down = function(t6) {
              for (var e6 = this.data, r4 = this.compare, n3 = this.length >> 1, i4 = e6[t6]; t6 < n3; ) {
                var s4 = 1 + (t6 << 1), a4 = e6[s4], o3 = s4 + 1;
                if (o3 < this.length && r4(e6[o3], a4) < 0 && (s4 = o3, a4 = e6[o3]), r4(a4, i4) >= 0) break;
                e6[t6] = a4, t6 = s4;
              }
              e6[t6] = i4;
            }, t5;
          }();
        }(rs);
        var ns = h3(rs.exports), is = 8192;
        function ss(t4, e4) {
          return e4.dist - t4.dist;
        }
        const as = 100, os = 50;
        function ls(t4) {
          const e4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (e4.length !== t4.length) return false;
          for (let r4 = 0; r4 < e4.length; r4++) if (e4[r4] !== t4[r4]) return false;
          return true;
        }
        function us(t4) {
          return t4[1] - t4[0] + 1;
        }
        function cs(t4, e4) {
          const r4 = t4[1] >= t4[0] && t4[1] < e4;
          return r4 || console.warn("Distance Expression: Index is out of range"), r4;
        }
        function hs(t4, e4) {
          if (t4[0] > t4[1]) return [null, null];
          const r4 = us(t4);
          if (e4) {
            if (2 === r4) return [t4, null];
            const e5 = Math.floor(r4 / 2);
            return [[t4[0], t4[0] + e5], [t4[0] + e5, t4[1]]];
          }
          {
            if (1 === r4) return [t4, null];
            const e5 = Math.floor(r4 / 2) - 1;
            return [[t4[0], t4[0] + e5], [t4[0] + e5 + 1, t4[1]]];
          }
        }
        function ps(t4, e4) {
          const r4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (!cs(e4, t4.length)) return r4;
          for (let n3 = e4[0]; n3 <= e4[1]; ++n3) Di(r4, t4[n3]);
          return r4;
        }
        function fs(t4) {
          const e4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let r4 = 0; r4 < t4.length; ++r4) for (let n3 = 0; n3 < t4[r4].length; ++n3) Di(e4, t4[r4][n3]);
          return e4;
        }
        function ds(t4, e4, r4) {
          if (ls(t4) || ls(e4)) return NaN;
          let n3 = 0, i4 = 0;
          return t4[2] < e4[0] && (n3 = e4[0] - t4[2]), t4[0] > e4[2] && (n3 = t4[0] - e4[2]), t4[1] > e4[3] && (i4 = t4[1] - e4[3]), t4[3] < e4[1] && (i4 = e4[1] - t4[3]), r4.distance([0, 0], [n3, i4]);
        }
        function ms(t4) {
          return 360 * t4 - 180;
        }
        function ys(t4) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t4) * Math.PI / 180)) - 90;
        }
        function gs(t4, e4) {
          const r4 = Math.pow(2, e4.z), n3 = (t4.y / is + e4.y) / r4;
          return [ms((t4.x / is + e4.x) / r4), ys(n3)];
        }
        function xs(t4, e4) {
          const r4 = [];
          for (let n3 = 0; n3 < t4.length; ++n3) r4.push(gs(t4[n3], e4));
          return r4;
        }
        function bs(t4, e4, r4) {
          const n3 = r4.pointOnLine(e4, t4).point;
          return r4.distance(t4, n3);
        }
        function vs(t4, e4, r4, n3, i4) {
          const s4 = r4.slice(n3[0], n3[1] + 1);
          let a4 = 1 / 0;
          for (let r5 = e4[0]; r5 <= e4[1]; ++r5) if (0 === (a4 = Math.min(a4, bs(t4[r5], s4, i4)))) return 0;
          return a4;
        }
        function _s(t4, e4, r4, n3, i4) {
          const s4 = Math.min(i4.pointToSegmentDistance(t4, r4, n3), i4.pointToSegmentDistance(e4, r4, n3)), a4 = Math.min(i4.pointToSegmentDistance(r4, t4, e4), i4.pointToSegmentDistance(n3, t4, e4));
          return Math.min(s4, a4);
        }
        function ws(t4, e4, r4, n3, i4) {
          if (!cs(e4, t4.length) || !cs(n3, r4.length)) return NaN;
          let s4 = 1 / 0;
          for (let a4 = e4[0]; a4 < e4[1]; ++a4) for (let e5 = n3[0]; e5 < n3[1]; ++e5) {
            if (Ni(t4[a4], t4[a4 + 1], r4[e5], r4[e5 + 1])) return 0;
            s4 = Math.min(s4, _s(t4[a4], t4[a4 + 1], r4[e5], r4[e5 + 1], i4));
          }
          return s4;
        }
        function Ms(t4, e4, r4, n3, i4) {
          if (!cs(e4, t4.length) || !cs(n3, r4.length)) return NaN;
          let s4 = 1 / 0;
          for (let a4 = e4[0]; a4 <= e4[1]; ++a4) for (let e5 = n3[0]; e5 <= n3[1]; ++e5) if (0 === (s4 = Math.min(s4, i4.distance(t4[a4], r4[e5])))) return s4;
          return s4;
        }
        function As(t4, e4, r4) {
          if (Oi(t4, e4, true)) return 0;
          let n3 = 1 / 0;
          for (const i4 of e4) {
            const e5 = i4.length;
            if (e5 < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
            if (i4[0] !== i4[e5 - 1] && 0 === (n3 = Math.min(n3, r4.pointToSegmentDistance(t4, i4[e5 - 1], i4[0])))) return n3;
            if (0 === (n3 = Math.min(n3, bs(t4, i4, r4)))) return n3;
          }
          return n3;
        }
        function Ss(t4, e4, r4, n3) {
          if (!cs(e4, t4.length)) return NaN;
          for (let n4 = e4[0]; n4 <= e4[1]; ++n4) if (Oi(t4[n4], r4, true)) return 0;
          let i4 = 1 / 0;
          for (let s4 = e4[0]; s4 < e4[1]; ++s4) for (const e5 of r4) for (let r5 = 0, a4 = e5.length, o3 = a4 - 1; r5 < a4; o3 = r5++) {
            if (Ni(t4[s4], t4[s4 + 1], e5[o3], e5[r5])) return 0;
            i4 = Math.min(i4, _s(t4[s4], t4[s4 + 1], e5[o3], e5[r5], n3));
          }
          return i4;
        }
        function Is(t4, e4) {
          for (const r4 of t4) for (let t5 = 0; t5 <= r4.length - 1; ++t5) if (Oi(r4[t5], e4, true)) return true;
          return false;
        }
        function ks(t4, e4, r4, n3 = 1 / 0) {
          const i4 = fs(t4), s4 = fs(e4);
          if (n3 !== 1 / 0 && ds(i4, s4, r4) >= n3) return n3;
          if (Li(i4, s4)) {
            if (Is(t4, e4)) return 0;
          } else if (Is(e4, t4)) return 0;
          let a4 = n3;
          for (const n4 of t4) for (let t5 = 0, i5 = n4.length, s5 = i5 - 1; t5 < i5; s5 = t5++) for (const i6 of e4) for (let e5 = 0, o3 = i6.length, l4 = o3 - 1; e5 < o3; l4 = e5++) {
            if (Ni(n4[s5], n4[t5], i6[l4], i6[e5])) return 0;
            a4 = Math.min(a4, _s(n4[s5], n4[t5], i6[l4], i6[e5], r4));
          }
          return a4;
        }
        function Ps(t4, e4, r4, n3, i4, s4, a4) {
          if (null === s4 || null === a4) return;
          const o3 = ds(ps(n3, s4), ps(i4, a4), r4);
          o3 < e4 && t4.push({ dist: o3, range1: s4, range2: a4 });
        }
        function Es(t4, e4, r4, n3, i4 = 1 / 0) {
          let s4 = Math.min(n3.distance(t4[0], r4[0][0]), i4);
          if (0 === s4) return s4;
          const a4 = new ns([{ dist: 0, range1: [0, t4.length - 1], range2: [0, 0] }], ss), o3 = e4 ? os : as, l4 = fs(r4);
          for (; a4.length; ) {
            const i5 = a4.pop();
            if (i5.dist >= s4) continue;
            const u5 = i5.range1;
            if (us(u5) <= o3) {
              if (!cs(u5, t4.length)) return NaN;
              if (e4) {
                const e5 = Ss(t4, u5, r4, n3);
                if (0 === (s4 = Math.min(s4, e5))) return s4;
              } else for (let e5 = u5[0]; e5 <= u5[1]; ++e5) {
                const i6 = As(t4[e5], r4, n3);
                if (0 === (s4 = Math.min(s4, i6))) return s4;
              }
            } else {
              const r5 = hs(u5, e4);
              if (null !== r5[0]) {
                const e5 = ds(ps(t4, r5[0]), l4, n3);
                e5 < s4 && a4.push({ dist: e5, range1: r5[0], range2: [0, 0] });
              }
              if (null !== r5[1]) {
                const e5 = ds(ps(t4, r5[1]), l4, n3);
                e5 < s4 && a4.push({ dist: e5, range1: r5[1], range2: [0, 0] });
              }
            }
          }
          return s4;
        }
        function zs(t4, e4, r4, n3, i4, s4 = 1 / 0) {
          let a4 = Math.min(s4, i4.distance(t4[0], r4[0]));
          if (0 === a4) return a4;
          const o3 = new ns([{ dist: 0, range1: [0, t4.length - 1], range2: [0, r4.length - 1] }], ss), l4 = e4 ? os : as, u5 = n3 ? os : as;
          for (; o3.length; ) {
            const s5 = o3.pop();
            if (s5.dist >= a4) continue;
            const c4 = s5.range1, h4 = s5.range2;
            if (us(c4) <= l4 && us(h4) <= u5) {
              if (!cs(c4, t4.length) || !cs(h4, r4.length)) return NaN;
              if (e4 && n3 ? a4 = Math.min(a4, ws(t4, c4, r4, h4, i4)) : e4 || n3 ? e4 && !n3 ? a4 = Math.min(a4, vs(r4, h4, t4, c4, i4)) : !e4 && n3 && (a4 = Math.min(a4, vs(t4, c4, r4, h4, i4))) : a4 = Math.min(a4, Ms(t4, c4, r4, h4, i4)), 0 === a4) return a4;
            } else {
              const s6 = hs(c4, e4), l5 = hs(h4, n3);
              Ps(o3, a4, i4, t4, r4, s6[0], l5[0]), Ps(o3, a4, i4, t4, r4, s6[0], l5[1]), Ps(o3, a4, i4, t4, r4, s6[1], l5[0]), Ps(o3, a4, i4, t4, r4, s6[1], l5[1]);
            }
          }
          return a4;
        }
        function Ts(t4, e4, r4, n3, i4 = 1 / 0) {
          let s4 = i4;
          const a4 = ps(t4, [0, t4.length - 1]);
          for (const i5 of r4) if (!(s4 !== 1 / 0 && ds(a4, ps(i5, [0, i5.length - 1]), n3) >= s4) && (s4 = Math.min(s4, zs(t4, e4, i5, true, n3, s4)), 0 === s4)) return s4;
          return s4;
        }
        function Bs(t4, e4, r4, n3, i4 = 1 / 0) {
          let s4 = i4;
          const a4 = ps(t4, [0, t4.length - 1]);
          for (const i5 of r4) {
            if (s4 !== 1 / 0 && ds(a4, fs(i5), n3) >= s4) continue;
            const r5 = Es(t4, e4, i5, n3, s4);
            if (isNaN(r5)) return r5;
            if (0 === (s4 = Math.min(s4, r5))) return s4;
          }
          return s4;
        }
        function Cs(t4) {
          return "Point" === t4 || "MultiPoint" === t4 || "LineString" === t4 || "MultiLineString" === t4 || "Polygon" === t4 || "MultiPolygon" === t4;
        }
        class Rs {
          constructor(t4, e4) {
            this.type = Kn, this.geojson = t4, this.geometries = e4;
          }
          static parse(t4, e4) {
            if (2 !== t4.length) return e4.error(`'distance' expression requires either one argument, but found ' ${t4.length - 1} instead.`);
            if (yi(t4[1])) {
              const e5 = t4[1];
              if ("FeatureCollection" === e5.type) {
                for (let t5 = 0; t5 < e5.features.length; ++t5) if (Cs(e5.features[t5].geometry.type)) return new Rs(e5, e5.features[t5].geometry);
              } else if ("Feature" === e5.type) {
                if (Cs(e5.geometry.type)) return new Rs(e5, e5.geometry);
              } else if (Cs(e5.type)) return new Rs(e5, e5);
            }
            return e4.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
          }
          evaluate(t4) {
            const e4 = t4.geometry(), r4 = t4.canonicalID();
            if (null != e4 && null != r4) {
              if ("Point" === t4.geometryType()) return function(t5, e5, r5) {
                const n3 = [];
                for (const r6 of t5) for (const t6 of r6) n3.push(gs(t6, e5));
                const i4 = new es(n3[0][1], "meters");
                return "Point" === r5.type || "MultiPoint" === r5.type || "LineString" === r5.type ? zs(n3, false, "Point" === r5.type ? [r5.coordinates] : r5.coordinates, "LineString" === r5.type, i4) : "MultiLineString" === r5.type ? Ts(n3, false, r5.coordinates, i4) : "Polygon" === r5.type || "MultiPolygon" === r5.type ? Bs(n3, false, "Polygon" === r5.type ? [r5.coordinates] : r5.coordinates, i4) : null;
              }(e4, r4, this.geometries);
              if ("LineString" === t4.geometryType()) return function(t5, e5, r5) {
                const n3 = [];
                for (const r6 of t5) {
                  const t6 = [];
                  for (const n4 of r6) t6.push(gs(n4, e5));
                  n3.push(t6);
                }
                const i4 = new es(n3[0][0][1], "meters");
                if ("Point" === r5.type || "MultiPoint" === r5.type || "LineString" === r5.type) return Ts("Point" === r5.type ? [r5.coordinates] : r5.coordinates, "LineString" === r5.type, n3, i4);
                if ("MultiLineString" === r5.type) {
                  let t6 = 1 / 0;
                  for (let e6 = 0; e6 < r5.coordinates.length; e6++) {
                    const s4 = Ts(r5.coordinates[e6], true, n3, i4, t6);
                    if (isNaN(s4)) return s4;
                    if (0 === (t6 = Math.min(t6, s4))) return t6;
                  }
                  return t6;
                }
                if ("Polygon" === r5.type || "MultiPolygon" === r5.type) {
                  let t6 = 1 / 0;
                  for (let e6 = 0; e6 < n3.length; e6++) {
                    const s4 = Bs(n3[e6], true, "Polygon" === r5.type ? [r5.coordinates] : r5.coordinates, i4, t6);
                    if (isNaN(s4)) return s4;
                    if (0 === (t6 = Math.min(t6, s4))) return t6;
                  }
                  return t6;
                }
                return null;
              }(e4, r4, this.geometries);
              if ("Polygon" === t4.geometryType()) return function(t5, e5, r5) {
                const n3 = [];
                for (const r6 of function(t6, e6) {
                  const r7 = t6.length;
                  if (r7 <= 1) return [t6];
                  const n4 = [];
                  let i5, s4;
                  for (let e7 = 0; e7 < r7; e7++) {
                    const r8 = Vi(t6[e7]);
                    0 !== r8 && (t6[e7].area = Math.abs(r8), void 0 === s4 && (s4 = r8 < 0), s4 === r8 < 0 ? (i5 && n4.push(i5), i5 = [t6[e7]]) : i5.push(t6[e7]));
                  }
                  return i5 && n4.push(i5), n4;
                }(t5)) {
                  const t6 = [];
                  for (let n4 = 0; n4 < r6.length; ++n4) t6.push(xs(r6[n4], e5));
                  n3.push(t6);
                }
                const i4 = new es(n3[0][0][0][1], "meters");
                if ("Point" === r5.type || "MultiPoint" === r5.type || "LineString" === r5.type) return Bs("Point" === r5.type ? [r5.coordinates] : r5.coordinates, "LineString" === r5.type, n3, i4);
                if ("MultiLineString" === r5.type) {
                  let t6 = 1 / 0;
                  for (let e6 = 0; e6 < r5.coordinates.length; e6++) {
                    const s4 = Bs(r5.coordinates[e6], true, n3, i4, t6);
                    if (isNaN(s4)) return s4;
                    if (0 === (t6 = Math.min(t6, s4))) return t6;
                  }
                  return t6;
                }
                return "Polygon" === r5.type || "MultiPolygon" === r5.type ? function(t6, e6, r6) {
                  let n4 = 1 / 0;
                  for (const i5 of t6) for (const t7 of e6) {
                    const e7 = ks(i5, t7, r6, n4);
                    if (isNaN(e7)) return e7;
                    if (0 === (n4 = Math.min(n4, e7))) return n4;
                  }
                  return n4;
                }("Polygon" === r5.type ? [r5.coordinates] : r5.coordinates, n3, i4) : null;
              }(e4, r4, this.geometries);
              console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
            } else console.warn("Distance Expression: requirs valid feature and canonical information.");
            return null;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["distance", this.geojson];
          }
        }
        function Vs(t4, e4) {
          switch (t4) {
            case "string":
              return xi(e4);
            case "number":
              return +e4;
            case "boolean":
              return !!e4;
            case "color":
              return jn.parse(e4);
            case "formatted":
              return fi.fromString(xi(e4));
            case "resolvedImage":
              return di.fromString(xi(e4));
          }
          return e4;
        }
        function Ds(t4, e4, r4, n3) {
          return void 0 !== n3 && (t4 = n3 * Math.round(t4 / n3)), void 0 !== e4 && t4 < e4 && (t4 = e4), void 0 !== r4 && t4 > r4 && (t4 = r4), t4;
        }
        class Ls {
          constructor(t4, e4, r4) {
            this.type = t4, this.key = e4, this.scope = r4;
          }
          static parse(t4, e4) {
            let r4 = e4.expectedType;
            if (null == r4 && (r4 = ei), t4.length < 2 || t4.length > 3) return e4.error("Invalid number of arguments for 'config' expression.");
            const n3 = e4.parse(t4[1], 1);
            if (!(n3 instanceof bi)) return e4.error("Key name of 'config' expression must be a string literal.");
            if (t4.length >= 3) {
              const i4 = e4.parse(t4[2], 2);
              return i4 instanceof bi ? new Ls(r4, xi(n3.value), xi(i4.value)) : e4.error("Scope of 'config' expression must be a string literal.");
            }
            return new Ls(r4, xi(n3.value));
          }
          evaluate(t4) {
            const e4 = [this.key, this.scope, t4.scope].filter(Boolean).join(""), r4 = t4.getConfig(e4);
            if (!r4) return null;
            const { type: n3, value: i4, values: s4, minValue: a4, maxValue: o3, stepValue: l4 } = r4, u5 = r4.default.evaluate(t4);
            let c4 = u5;
            if (i4) {
              const e5 = t4.scope;
              t4.scope = (e5 || "").split("").slice(1).join(""), c4 = i4.evaluate(t4), t4.scope = e5;
            }
            return n3 && (c4 = Vs(n3, c4)), void 0 === c4 || void 0 === a4 && void 0 === o3 && void 0 === l4 || ("number" == typeof c4 ? c4 = Ds(c4, a4, o3, l4) : Array.isArray(c4) && (c4 = c4.map((t5) => "number" == typeof t5 ? Ds(t5, a4, o3, l4) : t5))), void 0 !== i4 && void 0 !== c4 && s4 && !s4.includes(c4) && (c4 = u5, n3 && (c4 = Vs(n3, c4))), (n3 && n3 !== this.type || void 0 !== c4 && gi(c4) !== this.type) && (c4 = Vs(this.type.kind, c4)), c4;
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t4 = ["config", this.key];
            return this.scope && t4.concat(this.key), t4;
          }
        }
        function Fs(t4) {
          if (t4 instanceof zi) {
            if ("get" === t4.name && 1 === t4.args.length) return false;
            if ("feature-state" === t4.name) return false;
            if ("has" === t4.name && 1 === t4.args.length) return false;
            if ("properties" === t4.name || "geometry-type" === t4.name || "id" === t4.name) return false;
            if (/^filter-/.test(t4.name)) return false;
          }
          if (t4 instanceof Ji) return false;
          if (t4 instanceof Rs) return false;
          let e4 = true;
          return t4.eachChild((t5) => {
            e4 && !Fs(t5) && (e4 = false);
          }), e4;
        }
        function Os(t4) {
          if (t4 instanceof zi && "feature-state" === t4.name) return false;
          let e4 = true;
          return t4.eachChild((t5) => {
            e4 && !Os(t5) && (e4 = false);
          }), e4;
        }
        function Us(t4) {
          if (t4 instanceof Ls) return false;
          let e4 = true;
          return t4.eachChild((t5) => {
            e4 && !Us(t5) && (e4 = false);
          }), e4;
        }
        function Ns(t4, e4) {
          if (t4 instanceof zi && e4.indexOf(t4.name) >= 0) return false;
          let r4 = true;
          return t4.eachChild((t5) => {
            r4 && !Ns(t5, e4) && (r4 = false);
          }), r4;
        }
        class js {
          constructor(t4, e4) {
            this.type = e4.type, this.name = t4, this.boundExpression = e4;
          }
          static parse(t4, e4) {
            if (2 !== t4.length || "string" != typeof t4[1]) return e4.error("'var' expression requires exactly one string literal argument.");
            const r4 = t4[1];
            return e4.scope.has(r4) ? new js(r4, e4.scope.get(r4)) : e4.error(`Unknown variable "${r4}". Make sure "${r4}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t4) {
            return this.boundExpression.evaluate(t4);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["var", this.name];
          }
        }
        class qs {
          constructor(t4, e4 = [], r4, n3 = new Xn(), i4 = [], s4, a4) {
            this.registry = t4, this.path = e4, this.key = e4.map((t5) => `[${t5}]`).join(""), this.scope = n3, this.errors = i4, this.expectedType = r4, this._scope = s4, this.options = a4;
          }
          parse(t4, e4, r4, n3, i4 = {}) {
            return e4 || r4 ? this.concat(e4, r4, n3)._parse(t4, i4) : this._parse(t4, i4);
          }
          _parse(t4, e4) {
            function r4(t5, e5, r5) {
              return "assert" === r5 ? new wi(e5, [t5]) : "coerce" === r5 ? new ki(e5, [t5]) : t5;
            }
            if (null !== t4 && "string" != typeof t4 && "boolean" != typeof t4 && "number" != typeof t4 || (t4 = ["literal", t4]), Array.isArray(t4)) {
              if (0 === t4.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n3 = "string" == typeof t4[0] ? this.registry[t4[0]] : void 0;
              if (n3) {
                let i4 = n3.parse(t4, this);
                if (!i4) return null;
                if (this.expectedType) {
                  const t5 = this.expectedType, n4 = i4.type;
                  if ("string" !== t5.kind && "number" !== t5.kind && "boolean" !== t5.kind && "object" !== t5.kind && "array" !== t5.kind || "value" !== n4.kind) if ("color" !== t5.kind && "formatted" !== t5.kind && "resolvedImage" !== t5.kind || "value" !== n4.kind && "string" !== n4.kind) {
                    if (this.checkSubtype(t5, n4)) return null;
                  } else i4 = r4(i4, t5, e4.typeAnnotation || "coerce");
                  else i4 = r4(i4, t5, e4.typeAnnotation || "assert");
                }
                if (!(i4 instanceof bi) && "resolvedImage" !== i4.type.kind && $s(i4)) {
                  const t5 = new Ei(this._scope, this.options);
                  try {
                    i4 = new bi(i4.type, i4.evaluate(t5));
                  } catch (t6) {
                    return this.error(t6.message), null;
                  }
                }
                return i4;
              }
              return ki.parse(["to-array", t4], this);
            }
            return this.error(void 0 === t4 ? "'undefined' value invalid. Use null instead." : "object" == typeof t4 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t4} instead.`);
          }
          concat(t4, e4, r4) {
            const n3 = "number" == typeof t4 ? this.path.concat(t4) : this.path, i4 = r4 ? this.scope.concat(r4) : this.scope;
            return new qs(this.registry, n3, e4 || null, i4, this.errors, this._scope, this.options);
          }
          error(t4, ...e4) {
            const r4 = `${this.key}${e4.map((t5) => `[${t5}]`).join("")}`;
            this.errors.push(new Yn(r4, t4));
          }
          checkSubtype(t4, e4) {
            const r4 = li(t4, e4);
            return r4 && this.error(r4), r4;
          }
        }
        function $s(t4) {
          if (t4 instanceof js) return $s(t4.boundExpression);
          if (t4 instanceof zi && "error" === t4.name) return false;
          if (t4 instanceof Bi) return false;
          if (t4 instanceof Ji) return false;
          if (t4 instanceof Rs) return false;
          if (t4 instanceof Ls) return false;
          const e4 = t4 instanceof ki || t4 instanceof wi;
          let r4 = true;
          return t4.eachChild((t5) => {
            r4 = e4 ? r4 && $s(t5) : r4 && t5 instanceof bi;
          }), !!r4 && Fs(t4) && Ns(t4, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
        }
        function Gs(t4, e4) {
          const r4 = t4.length - 1;
          let n3, i4, s4 = 0, a4 = r4, o3 = 0;
          for (; s4 <= a4; ) if (o3 = Math.floor((s4 + a4) / 2), n3 = t4[o3], i4 = t4[o3 + 1], n3 <= e4) {
            if (o3 === r4 || e4 < i4) return o3;
            s4 = o3 + 1;
          } else {
            if (!(n3 > e4)) throw new vi("Input is not a number.");
            a4 = o3 - 1;
          }
          return 0;
        }
        class Qs {
          constructor(t4, e4, r4) {
            this.type = t4, this.input = e4, this.labels = [], this.outputs = [];
            for (const [t5, e5] of r4) this.labels.push(t5), this.outputs.push(e5);
          }
          static parse(t4, e4) {
            if (t4.length - 1 < 4) return e4.error(`Expected at least 4 arguments, but found only ${t4.length - 1}.`);
            if ((t4.length - 1) % 2 != 0) return e4.error("Expected an even number of arguments.");
            const r4 = e4.parse(t4[1], 1, Kn);
            if (!r4) return null;
            const n3 = [];
            let i4 = null;
            e4.expectedType && "value" !== e4.expectedType.kind && (i4 = e4.expectedType);
            for (let r5 = 1; r5 < t4.length; r5 += 2) {
              const s4 = 1 === r5 ? -1 / 0 : t4[r5], a4 = t4[r5 + 1], o3 = r5, l4 = r5 + 1;
              if ("number" != typeof s4) return e4.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o3);
              if (n3.length && n3[n3.length - 1][0] >= s4) return e4.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o3);
              const u5 = e4.parse(a4, l4, i4);
              if (!u5) return null;
              i4 = i4 || u5.type, n3.push([s4, u5]);
            }
            return new Qs(i4, r4, n3);
          }
          evaluate(t4) {
            const e4 = this.labels, r4 = this.outputs;
            if (1 === e4.length) return r4[0].evaluate(t4);
            const n3 = this.input.evaluate(t4);
            if (n3 <= e4[0]) return r4[0].evaluate(t4);
            const i4 = e4.length;
            return n3 >= e4[i4 - 1] ? r4[i4 - 1].evaluate(t4) : r4[Gs(e4, n3)].evaluate(t4);
          }
          eachChild(t4) {
            t4(this.input);
            for (const e4 of this.outputs) t4(e4);
          }
          outputDefined() {
            return this.outputs.every((t4) => t4.outputDefined());
          }
          serialize() {
            const t4 = ["step", this.input.serialize()];
            for (let e4 = 0; e4 < this.labels.length; e4++) e4 > 0 && t4.push(this.labels[e4]), t4.push(this.outputs[e4].serialize());
            return t4;
          }
        }
        const Ys = 0.95047, Xs = 1.08883, Zs = 4 / 29, Ks = 6 / 29, Ws = 3 * Ks * Ks, Hs = Ks * Ks * Ks, Js = Math.PI / 180, ta = 180 / Math.PI;
        function ea(t4) {
          return t4 > Hs ? Math.pow(t4, 1 / 3) : t4 / Ws + Zs;
        }
        function ra(t4) {
          return t4 > Ks ? t4 * t4 * t4 : Ws * (t4 - Zs);
        }
        function na(t4) {
          return 255 * (t4 <= 31308e-7 ? 12.92 * t4 : 1.055 * Math.pow(t4, 1 / 2.4) - 0.055);
        }
        function ia(t4) {
          return (t4 /= 255) <= 0.04045 ? t4 / 12.92 : Math.pow((t4 + 0.055) / 1.055, 2.4);
        }
        function sa(t4) {
          const e4 = ia(t4.r), r4 = ia(t4.g), n3 = ia(t4.b), i4 = ea((0.4124564 * e4 + 0.3575761 * r4 + 0.1804375 * n3) / Ys), s4 = ea((0.2126729 * e4 + 0.7151522 * r4 + 0.072175 * n3) / 1);
          return { l: 116 * s4 - 16, a: 500 * (i4 - s4), b: 200 * (s4 - ea((0.0193339 * e4 + 0.119192 * r4 + 0.9503041 * n3) / Xs)), alpha: t4.a };
        }
        function aa(t4) {
          let e4 = (t4.l + 16) / 116, r4 = isNaN(t4.a) ? e4 : e4 + t4.a / 500, n3 = isNaN(t4.b) ? e4 : e4 - t4.b / 200;
          return e4 = 1 * ra(e4), r4 = Ys * ra(r4), n3 = Xs * ra(n3), new jn(na(3.2404542 * r4 - 1.5371385 * e4 - 0.4985314 * n3), na(-0.969266 * r4 + 1.8760108 * e4 + 0.041556 * n3), na(0.0556434 * r4 - 0.2040259 * e4 + 1.0572252 * n3), t4.alpha);
        }
        function oa(t4, e4, r4) {
          const n3 = e4 - t4;
          return t4 + r4 * (n3 > 180 || n3 < -180 ? n3 - 360 * Math.round(n3 / 360) : n3);
        }
        const la = { forward: sa, reverse: aa, interpolate: function(t4, e4, r4) {
          return { l: qn(t4.l, e4.l, r4), a: qn(t4.a, e4.a, r4), b: qn(t4.b, e4.b, r4), alpha: qn(t4.alpha, e4.alpha, r4) };
        } }, ua = { forward: function(t4) {
          const { l: e4, a: r4, b: n3 } = sa(t4), i4 = Math.atan2(n3, r4) * ta;
          return { h: i4 < 0 ? i4 + 360 : i4, c: Math.sqrt(r4 * r4 + n3 * n3), l: e4, alpha: t4.a };
        }, reverse: function(t4) {
          const e4 = t4.h * Js, r4 = t4.c;
          return aa({ l: t4.l, a: Math.cos(e4) * r4, b: Math.sin(e4) * r4, alpha: t4.alpha });
        }, interpolate: function(t4, e4, r4) {
          return { h: oa(t4.h, e4.h, r4), c: qn(t4.c, e4.c, r4), l: qn(t4.l, e4.l, r4), alpha: qn(t4.alpha, e4.alpha, r4) };
        } };
        var ca = Object.freeze({ __proto__: null, hcl: ua, lab: la });
        class ha {
          constructor(t4, e4, r4, n3, i4) {
            this.type = t4, this.operator = e4, this.interpolation = r4, this.input = n3, this.labels = [], this.outputs = [];
            for (const [t5, e5] of i4) this.labels.push(t5), this.outputs.push(e5);
          }
          static interpolationFactor(t4, e4, r4, n3) {
            let i4 = 0;
            if ("exponential" === t4.name) i4 = pa(e4, t4.base, r4, n3);
            else if ("linear" === t4.name) i4 = pa(e4, 1, r4, n3);
            else if ("cubic-bezier" === t4.name) {
              const s4 = t4.controlPoints;
              i4 = new Le(s4[0], s4[1], s4[2], s4[3]).solve(pa(e4, 1, r4, n3));
            }
            return i4;
          }
          static parse(t4, e4) {
            let [r4, n3, i4, ...s4] = t4;
            if (!Array.isArray(n3) || 0 === n3.length) return e4.error("Expected an interpolation type expression.", 1);
            if ("linear" === n3[0]) n3 = { name: "linear" };
            else if ("exponential" === n3[0]) {
              const t5 = n3[1];
              if ("number" != typeof t5) return e4.error("Exponential interpolation requires a numeric base.", 1, 1);
              n3 = { name: "exponential", base: t5 };
            } else {
              if ("cubic-bezier" !== n3[0]) return e4.error(`Unknown interpolation type ${String(n3[0])}`, 1, 0);
              {
                const t5 = n3.slice(1);
                if (4 !== t5.length || t5.some((t6) => "number" != typeof t6 || t6 < 0 || t6 > 1)) return e4.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n3 = { name: "cubic-bezier", controlPoints: t5 };
              }
            }
            if (t4.length - 1 < 4) return e4.error(`Expected at least 4 arguments, but found only ${t4.length - 1}.`);
            if ((t4.length - 1) % 2 != 0) return e4.error("Expected an even number of arguments.");
            if (i4 = e4.parse(i4, 2, Kn), !i4) return null;
            const a4 = [];
            let o3 = null;
            "interpolate-hcl" === r4 || "interpolate-lab" === r4 ? o3 = Jn : e4.expectedType && "value" !== e4.expectedType.kind && (o3 = e4.expectedType);
            for (let t5 = 0; t5 < s4.length; t5 += 2) {
              const r5 = s4[t5], n4 = s4[t5 + 1], i5 = t5 + 3, l4 = t5 + 4;
              if ("number" != typeof r5) return e4.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i5);
              if (a4.length && a4[a4.length - 1][0] >= r5) return e4.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i5);
              const u5 = e4.parse(n4, l4, o3);
              if (!u5) return null;
              o3 = o3 || u5.type, a4.push([r5, u5]);
            }
            return "number" === o3.kind || "color" === o3.kind || "array" === o3.kind && "number" === o3.itemType.kind && "number" == typeof o3.N ? new ha(o3, r4, n3, i4, a4) : e4.error(`Type ${ai(o3)} is not interpolatable.`);
          }
          evaluate(t4) {
            const e4 = this.labels, r4 = this.outputs;
            if (1 === e4.length) return r4[0].evaluate(t4);
            const n3 = this.input.evaluate(t4);
            if (n3 <= e4[0]) return r4[0].evaluate(t4);
            const i4 = e4.length;
            if (n3 >= e4[i4 - 1]) return r4[i4 - 1].evaluate(t4);
            const s4 = Gs(e4, n3), a4 = ha.interpolationFactor(this.interpolation, n3, e4[s4], e4[s4 + 1]), o3 = r4[s4].evaluate(t4), l4 = r4[s4 + 1].evaluate(t4);
            return "interpolate" === this.operator ? Gn[this.type.kind.toLowerCase()](o3, l4, a4) : "interpolate-hcl" === this.operator ? ua.reverse(ua.interpolate(ua.forward(o3), ua.forward(l4), a4)) : la.reverse(la.interpolate(la.forward(o3), la.forward(l4), a4));
          }
          eachChild(t4) {
            t4(this.input);
            for (const e4 of this.outputs) t4(e4);
          }
          outputDefined() {
            return this.outputs.every((t4) => t4.outputDefined());
          }
          serialize() {
            let t4;
            t4 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
            const e4 = [this.operator, t4, this.input.serialize()];
            for (let t5 = 0; t5 < this.labels.length; t5++) e4.push(this.labels[t5], this.outputs[t5].serialize());
            return e4;
          }
        }
        function pa(t4, e4, r4, n3) {
          const i4 = n3 - r4, s4 = t4 - r4;
          return 0 === i4 ? 0 : 1 === e4 ? s4 / i4 : (Math.pow(e4, s4) - 1) / (Math.pow(e4, i4) - 1);
        }
        class fa {
          constructor(t4, e4) {
            this.type = t4, this.args = e4;
          }
          static parse(t4, e4) {
            if (t4.length < 2) return e4.error("Expectected at least one argument.");
            let r4 = null;
            const n3 = e4.expectedType;
            n3 && "value" !== n3.kind && (r4 = n3);
            const i4 = [];
            for (const n4 of t4.slice(1)) {
              const t5 = e4.parse(n4, 1 + i4.length, r4, void 0, { typeAnnotation: "omit" });
              if (!t5) return null;
              r4 = r4 || t5.type, i4.push(t5);
            }
            const s4 = n3 && i4.some((t5) => li(n3, t5.type));
            return new fa(s4 ? ei : r4, i4);
          }
          evaluate(t4) {
            let e4, r4 = null, n3 = 0;
            for (const i4 of this.args) {
              if (n3++, r4 = i4.evaluate(t4), r4 && r4 instanceof di && !r4.available && (e4 || (e4 = r4), r4 = null, n3 === this.args.length)) return e4;
              if (null !== r4) break;
            }
            return r4;
          }
          eachChild(t4) {
            this.args.forEach(t4);
          }
          outputDefined() {
            return this.args.every((t4) => t4.outputDefined());
          }
          serialize() {
            const t4 = ["coalesce"];
            return this.eachChild((e4) => {
              t4.push(e4.serialize());
            }), t4;
          }
        }
        class da {
          constructor(t4, e4) {
            this.type = e4.type, this.bindings = [].concat(t4), this.result = e4;
          }
          evaluate(t4) {
            return this.result.evaluate(t4);
          }
          eachChild(t4) {
            for (const e4 of this.bindings) t4(e4[1]);
            t4(this.result);
          }
          static parse(t4, e4) {
            if (t4.length < 4) return e4.error(`Expected at least 3 arguments, but found ${t4.length - 1} instead.`);
            const r4 = [];
            for (let n4 = 1; n4 < t4.length - 1; n4 += 2) {
              const i4 = t4[n4];
              if ("string" != typeof i4) return e4.error(`Expected string, but found ${typeof i4} instead.`, n4);
              if (/[^a-zA-Z0-9_]/.test(i4)) return e4.error("Variable names must contain only alphanumeric characters or '_'.", n4);
              const s4 = e4.parse(t4[n4 + 1], n4 + 1);
              if (!s4) return null;
              r4.push([i4, s4]);
            }
            const n3 = e4.parse(t4[t4.length - 1], t4.length - 1, e4.expectedType, r4);
            return n3 ? new da(r4, n3) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
          serialize() {
            const t4 = ["let"];
            for (const [e4, r4] of this.bindings) t4.push(e4, r4.serialize());
            return t4.push(this.result.serialize()), t4;
          }
        }
        class ma {
          constructor(t4, e4, r4) {
            this.type = t4, this.index = e4, this.input = r4;
          }
          static parse(t4, e4) {
            if (3 !== t4.length) return e4.error(`Expected 2 arguments, but found ${t4.length - 1} instead.`);
            const r4 = e4.parse(t4[1], 1, Kn), n3 = e4.parse(t4[2], 2, si(e4.expectedType || ei));
            return r4 && n3 ? new ma(n3.type.itemType, r4, n3) : null;
          }
          evaluate(t4) {
            const e4 = this.index.evaluate(t4), r4 = this.input.evaluate(t4);
            if (e4 < 0) throw new vi(`Array index out of bounds: ${e4} < 0.`);
            if (e4 >= r4.length) throw new vi(`Array index out of bounds: ${e4} > ${r4.length - 1}.`);
            if (e4 !== Math.floor(e4)) throw new vi(`Array index must be an integer, but found ${e4} instead.`);
            return r4[e4];
          }
          eachChild(t4) {
            t4(this.index), t4(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["at", this.index.serialize(), this.input.serialize()];
          }
        }
        class ya {
          constructor(t4, e4) {
            this.type = Hn, this.needle = t4, this.haystack = e4;
          }
          static parse(t4, e4) {
            if (3 !== t4.length) return e4.error(`Expected 2 arguments, but found ${t4.length - 1} instead.`);
            const r4 = e4.parse(t4[1], 1, ei), n3 = e4.parse(t4[2], 2, ei);
            return r4 && n3 ? ui(r4.type, [Hn, Wn, Kn, Zn, ei]) ? new ya(r4, n3) : e4.error(`Expected first argument to be of type boolean, string, number or null, but found ${ai(r4.type)} instead`) : null;
          }
          evaluate(t4) {
            const e4 = this.needle.evaluate(t4), r4 = this.haystack.evaluate(t4);
            if (null == r4) return false;
            if (!ci(e4, ["boolean", "string", "number", "null"])) throw new vi(`Expected first argument to be of type boolean, string, number or null, but found ${ai(gi(e4))} instead.`);
            if (!ci(r4, ["string", "array"])) throw new vi(`Expected second argument to be of type array or string, but found ${ai(gi(r4))} instead.`);
            return r4.indexOf(e4) >= 0;
          }
          eachChild(t4) {
            t4(this.needle), t4(this.haystack);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class ga {
          constructor(t4, e4, r4) {
            this.type = Kn, this.needle = t4, this.haystack = e4, this.fromIndex = r4;
          }
          static parse(t4, e4) {
            if (t4.length <= 2 || t4.length >= 5) return e4.error(`Expected 3 or 4 arguments, but found ${t4.length - 1} instead.`);
            const r4 = e4.parse(t4[1], 1, ei), n3 = e4.parse(t4[2], 2, ei);
            if (!r4 || !n3) return null;
            if (!ui(r4.type, [Hn, Wn, Kn, Zn, ei])) return e4.error(`Expected first argument to be of type boolean, string, number or null, but found ${ai(r4.type)} instead`);
            if (4 === t4.length) {
              const i4 = e4.parse(t4[3], 3, Kn);
              return i4 ? new ga(r4, n3, i4) : null;
            }
            return new ga(r4, n3);
          }
          evaluate(t4) {
            const e4 = this.needle.evaluate(t4), r4 = this.haystack.evaluate(t4);
            if (!ci(e4, ["boolean", "string", "number", "null"])) throw new vi(`Expected first argument to be of type boolean, string, number or null, but found ${ai(gi(e4))} instead.`);
            if (!ci(r4, ["string", "array"])) throw new vi(`Expected second argument to be of type array or string, but found ${ai(gi(r4))} instead.`);
            if (this.fromIndex) {
              const n3 = this.fromIndex.evaluate(t4);
              return r4.indexOf(e4, n3);
            }
            return r4.indexOf(e4);
          }
          eachChild(t4) {
            t4(this.needle), t4(this.haystack), this.fromIndex && t4(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.fromIndex && void 0 !== this.fromIndex) {
              const t4 = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), t4];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class xa {
          constructor(t4, e4, r4, n3, i4, s4) {
            this.inputType = t4, this.type = e4, this.input = r4, this.cases = n3, this.outputs = i4, this.otherwise = s4;
          }
          static parse(t4, e4) {
            if (t4.length < 5) return e4.error(`Expected at least 4 arguments, but found only ${t4.length - 1}.`);
            if (t4.length % 2 != 1) return e4.error("Expected an even number of arguments.");
            let r4, n3;
            e4.expectedType && "value" !== e4.expectedType.kind && (n3 = e4.expectedType);
            const i4 = {}, s4 = [];
            for (let a5 = 2; a5 < t4.length - 1; a5 += 2) {
              let o4 = t4[a5];
              const l4 = t4[a5 + 1];
              Array.isArray(o4) || (o4 = [o4]);
              const u5 = e4.concat(a5);
              if (0 === o4.length) return u5.error("Expected at least one branch label.");
              for (const t5 of o4) {
                if ("number" != typeof t5 && "string" != typeof t5) return u5.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t5 && Math.abs(t5) > Number.MAX_SAFE_INTEGER) return u5.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t5 && Math.floor(t5) !== t5) return u5.error("Numeric branch labels must be integer values.");
                if (r4) {
                  if (u5.checkSubtype(r4, gi(t5))) return null;
                } else r4 = gi(t5);
                if (void 0 !== i4[String(t5)]) return u5.error("Branch labels must be unique.");
                i4[String(t5)] = s4.length;
              }
              const c4 = e4.parse(l4, a5, n3);
              if (!c4) return null;
              n3 = n3 || c4.type, s4.push(c4);
            }
            const a4 = e4.parse(t4[1], 1, ei);
            if (!a4) return null;
            const o3 = e4.parse(t4[t4.length - 1], t4.length - 1, n3);
            return o3 ? "value" !== a4.type.kind && e4.concat(1).checkSubtype(r4, a4.type) ? null : new xa(r4, n3, a4, i4, s4, o3) : null;
          }
          evaluate(t4) {
            const e4 = this.input.evaluate(t4);
            return (gi(e4) === this.inputType && this.outputs[this.cases[e4]] || this.otherwise).evaluate(t4);
          }
          eachChild(t4) {
            t4(this.input), this.outputs.forEach(t4), t4(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t4) => t4.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t4 = ["match", this.input.serialize()], e4 = Object.keys(this.cases).sort(), r4 = [], n3 = {};
            for (const t5 of e4) {
              const e5 = n3[this.cases[t5]];
              void 0 === e5 ? (n3[this.cases[t5]] = r4.length, r4.push([this.cases[t5], [t5]])) : r4[e5][1].push(t5);
            }
            const i4 = (t5) => "number" === this.inputType.kind ? Number(t5) : t5;
            for (const [e5, n4] of r4) t4.push(1 === n4.length ? i4(n4[0]) : n4.map(i4)), t4.push(this.outputs[e5].serialize());
            return t4.push(this.otherwise.serialize()), t4;
          }
        }
        class ba {
          constructor(t4, e4, r4) {
            this.type = t4, this.branches = e4, this.otherwise = r4;
          }
          static parse(t4, e4) {
            if (t4.length < 4) return e4.error(`Expected at least 3 arguments, but found only ${t4.length - 1}.`);
            if (t4.length % 2 != 0) return e4.error("Expected an odd number of arguments.");
            let r4;
            e4.expectedType && "value" !== e4.expectedType.kind && (r4 = e4.expectedType);
            const n3 = [];
            for (let i5 = 1; i5 < t4.length - 1; i5 += 2) {
              const s4 = e4.parse(t4[i5], i5, Hn);
              if (!s4) return null;
              const a4 = e4.parse(t4[i5 + 1], i5 + 1, r4);
              if (!a4) return null;
              n3.push([s4, a4]), r4 = r4 || a4.type;
            }
            const i4 = e4.parse(t4[t4.length - 1], t4.length - 1, r4);
            return i4 ? new ba(r4, n3, i4) : null;
          }
          evaluate(t4) {
            for (const [e4, r4] of this.branches) if (e4.evaluate(t4)) return r4.evaluate(t4);
            return this.otherwise.evaluate(t4);
          }
          eachChild(t4) {
            for (const [e4, r4] of this.branches) t4(e4), t4(r4);
            t4(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t4, e4]) => e4.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t4 = ["case"];
            return this.eachChild((e4) => {
              t4.push(e4.serialize());
            }), t4;
          }
        }
        class va {
          constructor(t4, e4, r4, n3) {
            this.type = t4, this.input = e4, this.beginIndex = r4, this.endIndex = n3;
          }
          static parse(t4, e4) {
            if (t4.length <= 2 || t4.length >= 5) return e4.error(`Expected 3 or 4 arguments, but found ${t4.length - 1} instead.`);
            const r4 = e4.parse(t4[1], 1, ei), n3 = e4.parse(t4[2], 2, Kn);
            if (!r4 || !n3) return null;
            if (!ui(r4.type, [si(ei), Wn, ei])) return e4.error(`Expected first argument to be of type array or string, but found ${ai(r4.type)} instead`);
            if (4 === t4.length) {
              const i4 = e4.parse(t4[3], 3, Kn);
              return i4 ? new va(r4.type, r4, n3, i4) : null;
            }
            return new va(r4.type, r4, n3);
          }
          evaluate(t4) {
            const e4 = this.input.evaluate(t4), r4 = this.beginIndex.evaluate(t4);
            if (!ci(e4, ["string", "array"])) throw new vi(`Expected first argument to be of type array or string, but found ${ai(gi(e4))} instead.`);
            if (this.endIndex) {
              const n3 = this.endIndex.evaluate(t4);
              return e4.slice(r4, n3);
            }
            return e4.slice(r4);
          }
          eachChild(t4) {
            t4(this.input), t4(this.beginIndex), this.endIndex && t4(this.endIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.endIndex && void 0 !== this.endIndex) {
              const t4 = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), t4];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          }
        }
        function _a(t4, e4) {
          return "==" === t4 || "!=" === t4 ? "boolean" === e4.kind || "string" === e4.kind || "number" === e4.kind || "null" === e4.kind || "value" === e4.kind : "string" === e4.kind || "number" === e4.kind || "value" === e4.kind;
        }
        function wa(t4, e4, r4, n3) {
          return 0 === n3.compare(e4, r4);
        }
        function Ma(t4, e4, r4) {
          const n3 = "==" !== t4 && "!=" !== t4;
          return class i4 {
            constructor(t5, e5, r5) {
              this.type = Hn, this.lhs = t5, this.rhs = e5, this.collator = r5, this.hasUntypedArgument = "value" === t5.type.kind || "value" === e5.type.kind;
            }
            static parse(t5, e5) {
              if (3 !== t5.length && 4 !== t5.length) return e5.error("Expected two or three arguments.");
              const r5 = t5[0];
              let s4 = e5.parse(t5[1], 1, ei);
              if (!s4) return null;
              if (!_a(r5, s4.type)) return e5.concat(1).error(`"${r5}" comparisons are not supported for type '${ai(s4.type)}'.`);
              let a4 = e5.parse(t5[2], 2, ei);
              if (!a4) return null;
              if (!_a(r5, a4.type)) return e5.concat(2).error(`"${r5}" comparisons are not supported for type '${ai(a4.type)}'.`);
              if (s4.type.kind !== a4.type.kind && "value" !== s4.type.kind && "value" !== a4.type.kind) return e5.error(`Cannot compare types '${ai(s4.type)}' and '${ai(a4.type)}'.`);
              n3 && ("value" === s4.type.kind && "value" !== a4.type.kind ? s4 = new wi(a4.type, [s4]) : "value" !== s4.type.kind && "value" === a4.type.kind && (a4 = new wi(s4.type, [a4])));
              let o3 = null;
              if (4 === t5.length) {
                if ("string" !== s4.type.kind && "string" !== a4.type.kind && "value" !== s4.type.kind && "value" !== a4.type.kind) return e5.error("Cannot use collator to compare non-string types.");
                if (o3 = e5.parse(t5[3], 3, ri), !o3) return null;
              }
              return new i4(s4, a4, o3);
            }
            evaluate(i5) {
              const s4 = this.lhs.evaluate(i5), a4 = this.rhs.evaluate(i5);
              if (n3 && this.hasUntypedArgument) {
                const e5 = gi(s4), r5 = gi(a4);
                if (e5.kind !== r5.kind || "string" !== e5.kind && "number" !== e5.kind) throw new vi(`Expected arguments for "${t4}" to be (string, string) or (number, number), but found (${e5.kind}, ${r5.kind}) instead.`);
              }
              if (this.collator && !n3 && this.hasUntypedArgument) {
                const t5 = gi(s4), r5 = gi(a4);
                if ("string" !== t5.kind || "string" !== r5.kind) return e4(i5, s4, a4);
              }
              return this.collator ? r4(i5, s4, a4, this.collator.evaluate(i5)) : e4(i5, s4, a4);
            }
            eachChild(t5) {
              t5(this.lhs), t5(this.rhs), this.collator && t5(this.collator);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              const e5 = [t4];
              return this.eachChild((t5) => {
                e5.push(t5.serialize());
              }), e5;
            }
          };
        }
        const Aa = Ma("==", function(t4, e4, r4) {
          return e4 === r4;
        }, wa), Sa = Ma("!=", function(t4, e4, r4) {
          return e4 !== r4;
        }, function(t4, e4, r4, n3) {
          return !wa(0, e4, r4, n3);
        }), Ia = Ma("<", function(t4, e4, r4) {
          return e4 < r4;
        }, function(t4, e4, r4, n3) {
          return n3.compare(e4, r4) < 0;
        }), ka = Ma(">", function(t4, e4, r4) {
          return e4 > r4;
        }, function(t4, e4, r4, n3) {
          return n3.compare(e4, r4) > 0;
        }), Pa = Ma("<=", function(t4, e4, r4) {
          return e4 <= r4;
        }, function(t4, e4, r4, n3) {
          return n3.compare(e4, r4) <= 0;
        }), Ea = Ma(">=", function(t4, e4, r4) {
          return e4 >= r4;
        }, function(t4, e4, r4, n3) {
          return n3.compare(e4, r4) >= 0;
        });
        class za {
          constructor(t4, e4, r4, n3, i4, s4) {
            this.type = Wn, this.number = t4, this.locale = e4, this.currency = r4, this.unit = n3, this.minFractionDigits = i4, this.maxFractionDigits = s4;
          }
          static parse(t4, e4) {
            if (3 !== t4.length) return e4.error("Expected two arguments.");
            const r4 = e4.parse(t4[1], 1, Kn);
            if (!r4) return null;
            const n3 = t4[2];
            if ("object" != typeof n3 || Array.isArray(n3)) return e4.error("NumberFormat options argument must be an object.");
            let i4 = null;
            if (n3.locale && (i4 = e4.parse(n3.locale, 1, Wn), !i4)) return null;
            let s4 = null;
            if (n3.currency && (s4 = e4.parse(n3.currency, 1, Wn), !s4)) return null;
            let a4 = null;
            if (n3.unit && (a4 = e4.parse(n3.unit, 1, Wn), !a4)) return null;
            let o3 = null;
            if (n3["min-fraction-digits"] && (o3 = e4.parse(n3["min-fraction-digits"], 1, Kn), !o3)) return null;
            let l4 = null;
            return n3["max-fraction-digits"] && (l4 = e4.parse(n3["max-fraction-digits"], 1, Kn), !l4) ? null : new za(r4, i4, s4, a4, o3, l4);
          }
          evaluate(t4) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t4) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t4) : void 0, unit: this.unit ? this.unit.evaluate(t4) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t4) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t4) : void 0 }).format(this.number.evaluate(t4));
          }
          eachChild(t4) {
            t4(this.number), this.locale && t4(this.locale), this.currency && t4(this.currency), this.unit && t4(this.unit), this.minFractionDigits && t4(this.minFractionDigits), this.maxFractionDigits && t4(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t4 = {};
            return this.locale && (t4.locale = this.locale.serialize()), this.currency && (t4.currency = this.currency.serialize()), this.unit && (t4.unit = this.unit.serialize()), this.minFractionDigits && (t4["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t4["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t4];
          }
        }
        class Ta {
          constructor(t4) {
            this.type = Kn, this.input = t4;
          }
          static parse(t4, e4) {
            if (2 !== t4.length) return e4.error(`Expected 1 argument, but found ${t4.length - 1} instead.`);
            const r4 = e4.parse(t4[1], 1);
            return r4 ? "array" !== r4.type.kind && "string" !== r4.type.kind && "value" !== r4.type.kind ? e4.error(`Expected argument of type string or array, but found ${ai(r4.type)} instead.`) : new Ta(r4) : null;
          }
          evaluate(t4) {
            const e4 = this.input.evaluate(t4);
            if ("string" == typeof e4) return e4.length;
            if (Array.isArray(e4)) return e4.length;
            throw new vi(`Expected value to be of type string or array, but found ${ai(gi(e4))} instead.`);
          }
          eachChild(t4) {
            t4(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t4 = ["length"];
            return this.eachChild((e4) => {
              t4.push(e4.serialize());
            }), t4;
          }
        }
        function Ba(t4) {
          return function() {
            t4 = 1831565813 + (t4 |= 0) | 0;
            let e4 = Math.imul(t4 ^ t4 >>> 15, 1 | t4);
            return e4 = e4 + Math.imul(e4 ^ e4 >>> 7, 61 | e4) ^ e4, ((e4 ^ e4 >>> 14) >>> 0) / 4294967296;
          };
        }
        const Ca = { "==": Aa, "!=": Sa, ">": ka, "<": Ia, ">=": Ea, "<=": Pa, array: wi, at: ma, boolean: wi, case: ba, coalesce: fa, collator: Bi, format: Mi, image: Ai, in: ya, "index-of": ga, interpolate: ha, "interpolate-hcl": ha, "interpolate-lab": ha, length: Ta, let: da, literal: bi, match: xa, number: wi, "number-format": za, object: wi, slice: va, step: Qs, string: wi, "to-boolean": ki, "to-color": ki, "to-number": ki, "to-string": ki, var: js, within: Ji, distance: Rs, config: Ls };
        function Ra(t4, [e4, r4, n3, i4]) {
          e4 = e4.evaluate(t4), r4 = r4.evaluate(t4), n3 = n3.evaluate(t4);
          const s4 = i4 ? i4.evaluate(t4) : 1, a4 = mi(e4, r4, n3, s4);
          if (a4) throw new vi(a4);
          return new jn(e4 / 255 * s4, r4 / 255 * s4, n3 / 255 * s4, s4);
        }
        function Va(t4, [e4, r4, n3, i4]) {
          e4 = e4.evaluate(t4), r4 = r4.evaluate(t4), n3 = n3.evaluate(t4);
          const s4 = i4 ? i4.evaluate(t4) : 1, a4 = function(t5, e5, r5, n4) {
            return "number" == typeof t5 && t5 >= 0 && t5 <= 360 ? "number" == typeof e5 && e5 >= 0 && e5 <= 100 && "number" == typeof r5 && r5 >= 0 && r5 <= 100 ? void 0 === n4 || "number" == typeof n4 && n4 >= 0 && n4 <= 1 ? null : `Invalid hsla value [${[t5, e5, r5, n4].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n4 ? [t5, e5, r5, n4] : [t5, e5, r5]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n4 ? [t5, e5, r5, n4] : [t5, e5, r5]).join(", ")}]: 'h' must be between 0 and 360.`;
          }(e4, r4, n3, s4);
          if (a4) throw new vi(a4);
          const o3 = `hsla(${e4}, ${r4}%, ${n3}%, ${s4})`, l4 = jn.parse(o3);
          if (!l4) throw new vi(`Failed to parse HSLA color: ${o3}`);
          return l4;
        }
        function Da(t4, e4) {
          return t4 in e4;
        }
        function La(t4, e4) {
          const r4 = e4[t4];
          return void 0 === r4 ? null : r4;
        }
        function Fa(t4) {
          return { type: t4 };
        }
        function Oa(t4) {
          return { result: "success", value: t4 };
        }
        function Ua(t4) {
          return { result: "error", value: t4 };
        }
        function Na(t4, e4) {
          return !!t4 && !!t4.parameters && t4.parameters.indexOf(e4) > -1;
        }
        function ja(t4) {
          return "data-driven" === t4["property-type"];
        }
        function qa(t4) {
          return Na(t4.expression, "measure-light");
        }
        function $a(t4) {
          return Na(t4.expression, "zoom");
        }
        function Ga(t4) {
          return !!t4.expression && t4.expression.interpolated;
        }
        function Qa(t4) {
          return "object" == typeof t4 && null !== t4 && !Array.isArray(t4);
        }
        function Ya(t4) {
          return t4;
        }
        function Xa(t4, e4) {
          const r4 = "color" === e4.type, n3 = t4.stops && "object" == typeof t4.stops[0][0], i4 = n3 || !(n3 || void 0 !== t4.property), s4 = t4.type || (Ga(e4) ? "exponential" : "interval");
          if (r4 && ((t4 = Qn({}, t4)).stops && (t4.stops = t4.stops.map((t5) => [t5[0], jn.parse(t5[1])])), t4.default = jn.parse(t4.default ? t4.default : e4.default)), t4.colorSpace && "rgb" !== t4.colorSpace && !ca[t4.colorSpace]) throw new Error(`Unknown color space: ${t4.colorSpace}`);
          let a4, o3, l4;
          if ("exponential" === s4) a4 = Ha;
          else if ("interval" === s4) a4 = Wa;
          else if ("categorical" === s4) {
            a4 = Ka, o3 = /* @__PURE__ */ Object.create(null);
            for (const e5 of t4.stops) o3[e5[0]] = e5[1];
            l4 = typeof t4.stops[0][0];
          } else {
            if ("identity" !== s4) throw new Error(`Unknown function type "${s4}"`);
            a4 = Ja;
          }
          if (n3) {
            const r5 = {}, n4 = [];
            for (let e5 = 0; e5 < t4.stops.length; e5++) {
              const i6 = t4.stops[e5], s6 = i6[0].zoom;
              void 0 === r5[s6] && (r5[s6] = { zoom: s6, type: t4.type, property: t4.property, default: t4.default, stops: [] }, n4.push(s6)), r5[s6].stops.push([i6[0].value, i6[1]]);
            }
            const i5 = [];
            for (const t5 of n4) i5.push([r5[t5].zoom, Xa(r5[t5], e4)]);
            const s5 = { name: "linear" };
            return { kind: "composite", interpolationType: s5, interpolationFactor: ha.interpolationFactor.bind(void 0, s5), zoomStops: i5.map((t5) => t5[0]), evaluate: ({ zoom: r6 }, n5) => Ha({ stops: i5, base: t4.base }, e4, r6).evaluate(r6, n5) };
          }
          if (i4) {
            const r5 = "exponential" === s4 ? { name: "exponential", base: void 0 !== t4.base ? t4.base : 1 } : null;
            return { kind: "camera", interpolationType: r5, interpolationFactor: ha.interpolationFactor.bind(void 0, r5), zoomStops: t4.stops.map((t5) => t5[0]), evaluate: ({ zoom: r6 }) => a4(t4, e4, r6, o3, l4) };
          }
          return { kind: "source", evaluate(r5, n4) {
            const i5 = n4 && n4.properties ? n4.properties[t4.property] : void 0;
            return void 0 === i5 ? Za(t4.default, e4.default) : a4(t4, e4, i5, o3, l4);
          } };
        }
        function Za(t4, e4, r4) {
          return void 0 !== t4 ? t4 : void 0 !== e4 ? e4 : void 0 !== r4 ? r4 : void 0;
        }
        function Ka(t4, e4, r4, n3, i4) {
          return Za(typeof r4 === i4 ? n3[r4] : void 0, t4.default, e4.default);
        }
        function Wa(t4, e4, r4) {
          if ("number" !== Si(r4)) return Za(t4.default, e4.default);
          const n3 = t4.stops.length;
          if (1 === n3) return t4.stops[0][1];
          if (r4 <= t4.stops[0][0]) return t4.stops[0][1];
          if (r4 >= t4.stops[n3 - 1][0]) return t4.stops[n3 - 1][1];
          const i4 = Gs(t4.stops.map((t5) => t5[0]), r4);
          return t4.stops[i4][1];
        }
        function Ha(t4, e4, r4) {
          const n3 = void 0 !== t4.base ? t4.base : 1;
          if ("number" !== Si(r4)) return Za(t4.default, e4.default);
          const i4 = t4.stops.length;
          if (1 === i4) return t4.stops[0][1];
          if (r4 <= t4.stops[0][0]) return t4.stops[0][1];
          if (r4 >= t4.stops[i4 - 1][0]) return t4.stops[i4 - 1][1];
          const s4 = Gs(t4.stops.map((t5) => t5[0]), r4), a4 = function(t5, e5, r5, n4) {
            const i5 = n4 - r5, s5 = t5 - r5;
            return 0 === i5 ? 0 : 1 === e5 ? s5 / i5 : (Math.pow(e5, s5) - 1) / (Math.pow(e5, i5) - 1);
          }(r4, n3, t4.stops[s4][0], t4.stops[s4 + 1][0]), o3 = t4.stops[s4][1], l4 = t4.stops[s4 + 1][1];
          let u5 = Gn[e4.type] || Ya;
          if (t4.colorSpace && "rgb" !== t4.colorSpace) {
            const e5 = ca[t4.colorSpace];
            u5 = (t5, r5) => e5.reverse(e5.interpolate(e5.forward(t5), e5.forward(r5), a4));
          }
          return "function" == typeof o3.evaluate ? { evaluate(...t5) {
            const e5 = o3.evaluate.apply(void 0, t5), r5 = l4.evaluate.apply(void 0, t5);
            if (void 0 !== e5 && void 0 !== r5) return u5(e5, r5, a4);
          } } : u5(o3, l4, a4);
        }
        function Ja(t4, e4, r4) {
          return "color" === e4.type ? r4 = jn.parse(r4) : "formatted" === e4.type ? r4 = fi.fromString(r4.toString()) : "resolvedImage" === e4.type ? r4 = di.fromString(r4.toString()) : Si(r4) === e4.type || "enum" === e4.type && e4.values[r4] || (r4 = void 0), Za(r4, t4.default, e4.default);
        }
        zi.register(Ca, { error: [{ kind: "error" }, [Wn], (t4, [e4]) => {
          throw new vi(e4.evaluate(t4));
        }], typeof: [Wn, [ei], (t4, [e4]) => ai(gi(e4.evaluate(t4)))], "to-rgba": [si(Kn, 4), [Jn], (t4, [e4]) => e4.evaluate(t4).toArray()], rgb: [Jn, [Kn, Kn, Kn], Ra], rgba: [Jn, [Kn, Kn, Kn, Kn], Ra], hsl: [Jn, [Kn, Kn, Kn], Va], hsla: [Jn, [Kn, Kn, Kn, Kn], Va], has: { type: Hn, overloads: [[[Wn], (t4, [e4]) => Da(e4.evaluate(t4), t4.properties())], [[Wn, ti], (t4, [e4, r4]) => Da(e4.evaluate(t4), r4.evaluate(t4))]] }, get: { type: ei, overloads: [[[Wn], (t4, [e4]) => La(e4.evaluate(t4), t4.properties())], [[Wn, ti], (t4, [e4, r4]) => La(e4.evaluate(t4), r4.evaluate(t4))]] }, "feature-state": [ei, [Wn], (t4, [e4]) => La(e4.evaluate(t4), t4.featureState || {})], properties: [ti, [], (t4) => t4.properties()], "geometry-type": [Wn, [], (t4) => t4.geometryType()], id: [ei, [], (t4) => t4.id()], zoom: [Kn, [], (t4) => t4.globals.zoom], pitch: [Kn, [], (t4) => t4.globals.pitch || 0], "distance-from-center": [Kn, [], (t4) => t4.distanceFromCenter()], "measure-light": [Kn, [Wn], (t4, [e4]) => t4.measureLight(e4.evaluate(t4))], "heatmap-density": [Kn, [], (t4) => t4.globals.heatmapDensity || 0], "line-progress": [Kn, [], (t4) => t4.globals.lineProgress || 0], "raster-value": [Kn, [], (t4) => t4.globals.rasterValue || 0], "raster-particle-speed": [Kn, [], (t4) => t4.globals.rasterParticleSpeed || 0], "sky-radial-progress": [Kn, [], (t4) => t4.globals.skyRadialProgress || 0], accumulated: [ei, [], (t4) => void 0 === t4.globals.accumulated ? null : t4.globals.accumulated], "+": [Kn, Fa(Kn), (t4, e4) => {
          let r4 = 0;
          for (const n3 of e4) r4 += n3.evaluate(t4);
          return r4;
        }], "*": [Kn, Fa(Kn), (t4, e4) => {
          let r4 = 1;
          for (const n3 of e4) r4 *= n3.evaluate(t4);
          return r4;
        }], "-": { type: Kn, overloads: [[[Kn, Kn], (t4, [e4, r4]) => e4.evaluate(t4) - r4.evaluate(t4)], [[Kn], (t4, [e4]) => -e4.evaluate(t4)]] }, "/": [Kn, [Kn, Kn], (t4, [e4, r4]) => e4.evaluate(t4) / r4.evaluate(t4)], "%": [Kn, [Kn, Kn], (t4, [e4, r4]) => e4.evaluate(t4) % r4.evaluate(t4)], ln2: [Kn, [], () => Math.LN2], pi: [Kn, [], () => Math.PI], e: [Kn, [], () => Math.E], "^": [Kn, [Kn, Kn], (t4, [e4, r4]) => Math.pow(e4.evaluate(t4), r4.evaluate(t4))], sqrt: [Kn, [Kn], (t4, [e4]) => Math.sqrt(e4.evaluate(t4))], log10: [Kn, [Kn], (t4, [e4]) => Math.log(e4.evaluate(t4)) / Math.LN10], ln: [Kn, [Kn], (t4, [e4]) => Math.log(e4.evaluate(t4))], log2: [Kn, [Kn], (t4, [e4]) => Math.log(e4.evaluate(t4)) / Math.LN2], sin: [Kn, [Kn], (t4, [e4]) => Math.sin(e4.evaluate(t4))], cos: [Kn, [Kn], (t4, [e4]) => Math.cos(e4.evaluate(t4))], tan: [Kn, [Kn], (t4, [e4]) => Math.tan(e4.evaluate(t4))], asin: [Kn, [Kn], (t4, [e4]) => Math.asin(e4.evaluate(t4))], acos: [Kn, [Kn], (t4, [e4]) => Math.acos(e4.evaluate(t4))], atan: [Kn, [Kn], (t4, [e4]) => Math.atan(e4.evaluate(t4))], min: [Kn, Fa(Kn), (t4, e4) => Math.min(...e4.map((e5) => e5.evaluate(t4)))], max: [Kn, Fa(Kn), (t4, e4) => Math.max(...e4.map((e5) => e5.evaluate(t4)))], abs: [Kn, [Kn], (t4, [e4]) => Math.abs(e4.evaluate(t4))], round: [Kn, [Kn], (t4, [e4]) => {
          const r4 = e4.evaluate(t4);
          return r4 < 0 ? -Math.round(-r4) : Math.round(r4);
        }], floor: [Kn, [Kn], (t4, [e4]) => Math.floor(e4.evaluate(t4))], ceil: [Kn, [Kn], (t4, [e4]) => Math.ceil(e4.evaluate(t4))], "filter-==": [Hn, [Wn, ei], (t4, [e4, r4]) => t4.properties()[e4.value] === r4.value], "filter-id-==": [Hn, [ei], (t4, [e4]) => t4.id() === e4.value], "filter-type-==": [Hn, [Wn], (t4, [e4]) => t4.geometryType() === e4.value], "filter-<": [Hn, [Wn, ei], (t4, [e4, r4]) => {
          const n3 = t4.properties()[e4.value], i4 = r4.value;
          return typeof n3 == typeof i4 && n3 < i4;
        }], "filter-id-<": [Hn, [ei], (t4, [e4]) => {
          const r4 = t4.id(), n3 = e4.value;
          return typeof r4 == typeof n3 && r4 < n3;
        }], "filter->": [Hn, [Wn, ei], (t4, [e4, r4]) => {
          const n3 = t4.properties()[e4.value], i4 = r4.value;
          return typeof n3 == typeof i4 && n3 > i4;
        }], "filter-id->": [Hn, [ei], (t4, [e4]) => {
          const r4 = t4.id(), n3 = e4.value;
          return typeof r4 == typeof n3 && r4 > n3;
        }], "filter-<=": [Hn, [Wn, ei], (t4, [e4, r4]) => {
          const n3 = t4.properties()[e4.value], i4 = r4.value;
          return typeof n3 == typeof i4 && n3 <= i4;
        }], "filter-id-<=": [Hn, [ei], (t4, [e4]) => {
          const r4 = t4.id(), n3 = e4.value;
          return typeof r4 == typeof n3 && r4 <= n3;
        }], "filter->=": [Hn, [Wn, ei], (t4, [e4, r4]) => {
          const n3 = t4.properties()[e4.value], i4 = r4.value;
          return typeof n3 == typeof i4 && n3 >= i4;
        }], "filter-id->=": [Hn, [ei], (t4, [e4]) => {
          const r4 = t4.id(), n3 = e4.value;
          return typeof r4 == typeof n3 && r4 >= n3;
        }], "filter-has": [Hn, [ei], (t4, [e4]) => e4.value in t4.properties()], "filter-has-id": [Hn, [], (t4) => null !== t4.id() && void 0 !== t4.id()], "filter-type-in": [Hn, [si(Wn)], (t4, [e4]) => e4.value.indexOf(t4.geometryType()) >= 0], "filter-id-in": [Hn, [si(ei)], (t4, [e4]) => e4.value.indexOf(t4.id()) >= 0], "filter-in-small": [Hn, [Wn, si(ei)], (t4, [e4, r4]) => r4.value.indexOf(t4.properties()[e4.value]) >= 0], "filter-in-large": [Hn, [Wn, si(ei)], (t4, [e4, r4]) => function(t5, e5, r5, n3) {
          for (; r5 <= n3; ) {
            const i4 = r5 + n3 >> 1;
            if (e5[i4] === t5) return true;
            e5[i4] > t5 ? n3 = i4 - 1 : r5 = i4 + 1;
          }
          return false;
        }(t4.properties()[e4.value], r4.value, 0, r4.value.length - 1)], all: { type: Hn, overloads: [[[Hn, Hn], (t4, [e4, r4]) => e4.evaluate(t4) && r4.evaluate(t4)], [Fa(Hn), (t4, e4) => {
          for (const r4 of e4) if (!r4.evaluate(t4)) return false;
          return true;
        }]] }, any: { type: Hn, overloads: [[[Hn, Hn], (t4, [e4, r4]) => e4.evaluate(t4) || r4.evaluate(t4)], [Fa(Hn), (t4, e4) => {
          for (const r4 of e4) if (r4.evaluate(t4)) return true;
          return false;
        }]] }, "!": [Hn, [Hn], (t4, [e4]) => !e4.evaluate(t4)], "is-supported-script": [Hn, [Wn], (t4, [e4]) => {
          const r4 = t4.globals && t4.globals.isSupportedScript;
          return !r4 || r4(e4.evaluate(t4));
        }], upcase: [Wn, [Wn], (t4, [e4]) => e4.evaluate(t4).toUpperCase()], downcase: [Wn, [Wn], (t4, [e4]) => e4.evaluate(t4).toLowerCase()], concat: [Wn, Fa(ei), (t4, e4) => e4.map((e5) => xi(e5.evaluate(t4))).join("")], "resolved-locale": [Wn, [ri], (t4, [e4]) => e4.evaluate(t4).resolvedLocale()], random: [Kn, [Kn, Kn, ei], (t4, e4) => {
          const [r4, n3, i4] = e4.map((e5) => e5.evaluate(t4));
          if (r4 > n3) return r4;
          if (r4 === n3) return r4;
          let s4;
          if ("string" == typeof i4) s4 = function(t5) {
            let e5 = 0;
            if (0 === t5.length) return e5;
            for (let r5 = 0; r5 < t5.length; r5++) e5 = (e5 << 5) - e5 + t5.charCodeAt(r5), e5 |= 0;
            return e5;
          }(i4);
          else {
            if ("number" != typeof i4) throw new vi(`Invalid seed input: ${i4}`);
            s4 = i4;
          }
          return r4 + Ba(s4)() * (n3 - r4);
        }] });
        class to {
          constructor(t4, e4, r4, n3) {
            this.expression = t4, this._warningHistory = {}, this._evaluator = new Ei(r4, n3), this._defaultValue = e4 ? function(t5) {
              return "color" === t5.type && (Qa(t5.default) || Array.isArray(t5.default)) ? new jn(0, 0, 0, 0) : "color" === t5.type ? jn.parse(t5.default) || null : void 0 === t5.default ? null : t5.default;
            }(e4) : null, this._enumValues = e4 && "enum" === e4.type ? e4.values : null;
          }
          evaluateWithoutErrorHandling(t4, e4, r4, n3, i4, s4, a4, o3) {
            return this._evaluator.globals = t4, this._evaluator.feature = e4, this._evaluator.featureState = r4, this._evaluator.canonical = n3 || null, this._evaluator.availableImages = i4 || null, this._evaluator.formattedSection = s4, this._evaluator.featureTileCoord = a4 || null, this._evaluator.featureDistanceData = o3 || null, this.expression.evaluate(this._evaluator);
          }
          evaluate(t4, e4, r4, n3, i4, s4, a4, o3) {
            this._evaluator.globals = t4, this._evaluator.feature = e4 || null, this._evaluator.featureState = r4 || null, this._evaluator.canonical = n3 || null, this._evaluator.availableImages = i4 || null, this._evaluator.formattedSection = s4 || null, this._evaluator.featureTileCoord = a4 || null, this._evaluator.featureDistanceData = o3 || null;
            try {
              const t5 = this.expression.evaluate(this._evaluator);
              if (null == t5 || "number" == typeof t5 && t5 != t5) return this._defaultValue;
              if (this._enumValues && !(t5 in this._enumValues)) throw new vi(`Expected value to be one of ${Object.keys(this._enumValues).map((t6) => JSON.stringify(t6)).join(", ")}, but found ${JSON.stringify(t5)} instead.`);
              return t5;
            } catch (t5) {
              return this._warningHistory[t5.message] || (this._warningHistory[t5.message] = true, "undefined" != typeof console && console.warn(t5.message)), this._defaultValue;
            }
          }
        }
        function eo(t4) {
          return Array.isArray(t4) && t4.length > 0 && "string" == typeof t4[0] && t4[0] in Ca;
        }
        function ro(t4, e4, r4, n3) {
          const i4 = new qs(Ca, [], e4 ? function(t5) {
            const e5 = { color: Jn, string: Wn, number: Kn, enum: Wn, boolean: Hn, formatted: ni, resolvedImage: ii };
            return "array" === t5.type ? si(e5[t5.value] || ei, t5.length) : e5[t5.type];
          }(e4) : void 0, void 0, void 0, r4, n3), s4 = i4.parse(t4, void 0, void 0, void 0, e4 && "string" === e4.type ? { typeAnnotation: "coerce" } : void 0);
          return s4 ? Oa(new to(s4, e4, r4, n3)) : Ua(i4.errors);
        }
        class no {
          constructor(t4, e4, r4) {
            this.kind = t4, this._styleExpression = e4, this.isLightConstant = r4, this.isStateDependent = "constant" !== t4 && !Os(e4.expression), this.isConfigDependent = !Us(e4.expression);
          }
          evaluateWithoutErrorHandling(t4, e4, r4, n3, i4, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t4, e4, r4, n3, i4, s4);
          }
          evaluate(t4, e4, r4, n3, i4, s4) {
            return this._styleExpression.evaluate(t4, e4, r4, n3, i4, s4);
          }
        }
        class io {
          constructor(t4, e4, r4, n3, i4) {
            this.kind = t4, this.zoomStops = r4, this._styleExpression = e4, this.isStateDependent = "camera" !== t4 && !Os(e4.expression), this.isLightConstant = i4, this.isConfigDependent = !Us(e4.expression), this.interpolationType = n3;
          }
          evaluateWithoutErrorHandling(t4, e4, r4, n3, i4, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t4, e4, r4, n3, i4, s4);
          }
          evaluate(t4, e4, r4, n3, i4, s4) {
            return this._styleExpression.evaluate(t4, e4, r4, n3, i4, s4);
          }
          interpolationFactor(t4, e4, r4) {
            return this.interpolationType ? ha.interpolationFactor(this.interpolationType, t4, e4, r4) : 0;
          }
        }
        function so(t4, e4, r4, n3) {
          if ("error" === (t4 = ro(t4, e4, r4, n3)).result) return t4;
          const i4 = t4.value.expression, s4 = Fs(i4);
          if (!s4 && !ja(e4)) return Ua([new Yn("", "data expressions not supported")]);
          const a4 = Ns(i4, ["zoom", "pitch", "distance-from-center"]);
          if (!a4 && !$a(e4)) return Ua([new Yn("", "zoom expressions not supported")]);
          const o3 = Ns(i4, ["measure-light"]);
          if (!o3 && !qa(e4)) return Ua([new Yn("", "measure-light expression not supported")]);
          const l4 = e4.expression && e4.expression.relaxZoomRestriction, u5 = oo(i4);
          return u5 || a4 || l4 ? u5 instanceof Yn ? Ua([u5]) : u5 instanceof ha && !Ga(e4) ? Ua([new Yn("", '"interpolate" expressions cannot be used with this property')]) : Oa(u5 ? new io(s4 ? "camera" : "composite", t4.value, u5.labels, u5 instanceof ha ? u5.interpolation : void 0, o3) : new no(s4 ? "constant" : "source", t4.value, o3)) : Ua([new Yn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
        }
        class ao {
          constructor(t4, e4) {
            this._parameters = t4, this._specification = e4, Qn(this, Xa(this._parameters, this._specification));
          }
          static deserialize(t4) {
            return new ao(t4._parameters, t4._specification);
          }
          static serialize(t4) {
            return { _parameters: t4._parameters, _specification: t4._specification };
          }
        }
        function oo(t4) {
          let e4 = null;
          if (t4 instanceof da) e4 = oo(t4.result);
          else if (t4 instanceof fa) {
            for (const r4 of t4.args) if (e4 = oo(r4), e4) break;
          } else (t4 instanceof Qs || t4 instanceof ha) && t4.input instanceof zi && "zoom" === t4.input.name && (e4 = t4);
          return e4 instanceof Yn || t4.eachChild((t5) => {
            const r4 = oo(t5);
            r4 instanceof Yn ? e4 = r4 : e4 && r4 && e4 !== r4 && (e4 = new Yn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e4;
        }
        var lo = co, uo = 3;
        function co(t4, e4, r4) {
          var n3 = this.cells = [];
          if (t4 instanceof ArrayBuffer) {
            this.arrayBuffer = t4;
            var i4 = new Int32Array(this.arrayBuffer);
            t4 = i4[0], this.d = (e4 = i4[1]) + 2 * (r4 = i4[2]);
            for (var s4 = 0; s4 < this.d * this.d; s4++) {
              var a4 = i4[uo + s4], o3 = i4[uo + s4 + 1];
              n3.push(a4 === o3 ? null : i4.subarray(a4, o3));
            }
            var l4 = i4[uo + n3.length + 1];
            this.keys = i4.subarray(i4[uo + n3.length], l4), this.bboxes = i4.subarray(l4), this.insert = this._insertReadonly;
          } else {
            this.d = e4 + 2 * r4;
            for (var u5 = 0; u5 < this.d * this.d; u5++) n3.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e4, this.extent = t4, this.padding = r4, this.scale = e4 / t4, this.uid = 0;
          var c4 = r4 / e4 * t4;
          this.min = -c4, this.max = t4 + c4;
        }
        co.prototype.insert = function(t4, e4, r4, n3, i4) {
          this._forEachCell(e4, r4, n3, i4, this._insertCell, this.uid++), this.keys.push(t4), this.bboxes.push(e4), this.bboxes.push(r4), this.bboxes.push(n3), this.bboxes.push(i4);
        }, co.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, co.prototype._insertCell = function(t4, e4, r4, n3, i4, s4) {
          this.cells[i4].push(s4);
        }, co.prototype.query = function(t4, e4, r4, n3, i4) {
          var s4 = this.min, a4 = this.max;
          if (t4 <= s4 && e4 <= s4 && a4 <= r4 && a4 <= n3 && !i4) return Array.prototype.slice.call(this.keys);
          var o3 = [];
          return this._forEachCell(t4, e4, r4, n3, this._queryCell, o3, {}, i4), o3;
        }, co.prototype._queryCell = function(t4, e4, r4, n3, i4, s4, a4, o3) {
          var l4 = this.cells[i4];
          if (null !== l4) for (var u5 = this.keys, c4 = this.bboxes, h4 = 0; h4 < l4.length; h4++) {
            var p4 = l4[h4];
            if (void 0 === a4[p4]) {
              var f4 = 4 * p4;
              (o3 ? o3(c4[f4 + 0], c4[f4 + 1], c4[f4 + 2], c4[f4 + 3]) : t4 <= c4[f4 + 2] && e4 <= c4[f4 + 3] && r4 >= c4[f4 + 0] && n3 >= c4[f4 + 1]) ? (a4[p4] = true, s4.push(u5[p4])) : a4[p4] = false;
            }
          }
        }, co.prototype._forEachCell = function(t4, e4, r4, n3, i4, s4, a4, o3) {
          for (var l4 = this._convertToCellCoord(t4), u5 = this._convertToCellCoord(e4), c4 = this._convertToCellCoord(r4), h4 = this._convertToCellCoord(n3), p4 = l4; p4 <= c4; p4++) for (var f4 = u5; f4 <= h4; f4++) {
            var d3 = this.d * f4 + p4;
            if ((!o3 || o3(this._convertFromCellCoord(p4), this._convertFromCellCoord(f4), this._convertFromCellCoord(p4 + 1), this._convertFromCellCoord(f4 + 1))) && i4.call(this, t4, e4, r4, n3, d3, s4, a4, o3)) return;
          }
        }, co.prototype._convertFromCellCoord = function(t4) {
          return (t4 - this.padding) / this.scale;
        }, co.prototype._convertToCellCoord = function(t4) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t4 * this.scale) + this.padding));
        }, co.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer) return this.arrayBuffer;
          for (var t4 = this.cells, e4 = uo + this.cells.length + 1 + 1, r4 = 0, n3 = 0; n3 < this.cells.length; n3++) r4 += this.cells[n3].length;
          var i4 = new Int32Array(e4 + r4 + this.keys.length + this.bboxes.length);
          i4[0] = this.extent, i4[1] = this.n, i4[2] = this.padding;
          for (var s4 = e4, a4 = 0; a4 < t4.length; a4++) {
            var o3 = t4[a4];
            i4[uo + a4] = s4, i4.set(o3, s4), s4 += o3.length;
          }
          return i4[uo + t4.length] = s4, i4.set(this.keys, s4), i4[uo + t4.length + 1] = s4 += this.keys.length, i4.set(this.bboxes, s4), s4 += this.bboxes.length, i4.buffer;
        };
        var ho = h3(lo);
        const po = {};
        function fo(t4, e4, r4 = {}) {
          Object.defineProperty(t4, "_classRegistryKey", { value: e4, writeable: false }), po[e4] = { klass: t4, omit: r4.omit || [] };
        }
        fo(Object, "Object"), ho.serialize = function(t4, e4) {
          const r4 = t4.toArrayBuffer();
          return e4 && e4.add(r4), { buffer: r4 };
        }, ho.deserialize = function(t4) {
          return new ho(t4.buffer);
        }, Object.defineProperty(ho, "name", { value: "Grid" }), fo(ho, "Grid"), fo(jn, "Color"), fo(Error, "Error"), fo(fi, "Formatted"), fo(pi, "FormattedSection"), fo(Kr, "AJAXError"), fo(di, "ResolvedImage"), fo(ao, "StylePropertyFunction"), fo(to, "StyleExpression", { omit: ["_evaluator"] }), fo(io, "ZoomDependentExpression"), fo(no, "ZoomConstantExpression"), fo(zi, "CompoundExpression", { omit: ["_evaluate"] });
        for (const t4 in Ca) po[Ca[t4]._classRegistryKey] || fo(Ca[t4], `Expression${t4}`);
        function mo(t4) {
          return t4 && "undefined" != typeof ArrayBuffer && (t4 instanceof ArrayBuffer || t4.constructor && "ArrayBuffer" === t4.constructor.name);
        }
        function yo(t4) {
          return self.ImageBitmap && t4 instanceof ImageBitmap;
        }
        function go(t4, e4) {
          if (null == t4 || "boolean" == typeof t4 || "number" == typeof t4 || "string" == typeof t4 || t4 instanceof Boolean || t4 instanceof Number || t4 instanceof String || t4 instanceof Date || t4 instanceof RegExp) return t4;
          if (mo(t4) || yo(t4)) return e4 && e4.add(t4), t4;
          if (ArrayBuffer.isView(t4)) {
            const r4 = t4;
            return e4 && e4.add(r4.buffer), r4;
          }
          if (t4 instanceof ImageData) return e4 && e4.add(t4.data.buffer), t4;
          if (Array.isArray(t4)) {
            const r4 = [];
            for (const n3 of t4) r4.push(go(n3, e4));
            return r4;
          }
          if (t4 instanceof Map) {
            const e5 = { $name: "Map" };
            for (const [r4, n3] of t4.entries()) e5[r4] = go(n3);
            return e5;
          }
          if ("object" == typeof t4) {
            const r4 = t4.constructor, n3 = r4._classRegistryKey;
            if (!n3) throw new Error(`can't serialize object of unregistered class ${n3}`);
            const i4 = r4.serialize ? r4.serialize(t4, e4) : {};
            if (!r4.serialize) {
              for (const r5 in t4) t4.hasOwnProperty(r5) && (po[n3].omit.indexOf(r5) >= 0 || (i4[r5] = go(t4[r5], e4)));
              t4 instanceof Error && (i4.message = t4.message);
            }
            if (i4.$name) throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n3 && (i4.$name = n3), i4;
          }
          throw new Error("can't serialize object of type " + typeof t4);
        }
        function xo(t4) {
          if (null == t4 || "boolean" == typeof t4 || "number" == typeof t4 || "string" == typeof t4 || t4 instanceof Boolean || t4 instanceof Number || t4 instanceof String || t4 instanceof Date || t4 instanceof RegExp || mo(t4) || yo(t4) || ArrayBuffer.isView(t4) || t4 instanceof ImageData) return t4;
          if (Array.isArray(t4)) return t4.map(xo);
          if ("object" == typeof t4) {
            const e4 = t4.$name || "Object";
            if ("Map" === e4) {
              const e5 = /* @__PURE__ */ new Map();
              for (const r5 of Object.keys(t4)) "$name" !== r5 && e5.set(r5, xo(t4[r5]));
              return e5;
            }
            const { klass: r4 } = po[e4];
            if (!r4) throw new Error(`can't deserialize unregistered class ${e4}`);
            if (r4.deserialize) return r4.deserialize(t4);
            const n3 = Object.create(r4.prototype);
            for (const e5 of Object.keys(t4)) "$name" !== e5 && (n3[e5] = xo(t4[e5]));
            return n3;
          }
          throw new Error("can't deserialize object of type " + typeof t4);
        }
        const bo = { "Latin-1 Supplement": (t4) => t4 >= 128 && t4 <= 255, Arabic: (t4) => t4 >= 1536 && t4 <= 1791, "Arabic Supplement": (t4) => t4 >= 1872 && t4 <= 1919, "Arabic Extended-A": (t4) => t4 >= 2208 && t4 <= 2303, "Hangul Jamo": (t4) => t4 >= 4352 && t4 <= 4607, "Unified Canadian Aboriginal Syllabics": (t4) => t4 >= 5120 && t4 <= 5759, Khmer: (t4) => t4 >= 6016 && t4 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t4) => t4 >= 6320 && t4 <= 6399, "General Punctuation": (t4) => t4 >= 8192 && t4 <= 8303, "Letterlike Symbols": (t4) => t4 >= 8448 && t4 <= 8527, "Number Forms": (t4) => t4 >= 8528 && t4 <= 8591, "Miscellaneous Technical": (t4) => t4 >= 8960 && t4 <= 9215, "Control Pictures": (t4) => t4 >= 9216 && t4 <= 9279, "Optical Character Recognition": (t4) => t4 >= 9280 && t4 <= 9311, "Enclosed Alphanumerics": (t4) => t4 >= 9312 && t4 <= 9471, "Geometric Shapes": (t4) => t4 >= 9632 && t4 <= 9727, "Miscellaneous Symbols": (t4) => t4 >= 9728 && t4 <= 9983, "Miscellaneous Symbols and Arrows": (t4) => t4 >= 11008 && t4 <= 11263, "CJK Radicals Supplement": (t4) => t4 >= 11904 && t4 <= 12031, "Kangxi Radicals": (t4) => t4 >= 12032 && t4 <= 12255, "Ideographic Description Characters": (t4) => t4 >= 12272 && t4 <= 12287, "CJK Symbols and Punctuation": (t4) => t4 >= 12288 && t4 <= 12351, Hiragana: (t4) => t4 >= 12352 && t4 <= 12447, Katakana: (t4) => t4 >= 12448 && t4 <= 12543, Bopomofo: (t4) => t4 >= 12544 && t4 <= 12591, "Hangul Compatibility Jamo": (t4) => t4 >= 12592 && t4 <= 12687, Kanbun: (t4) => t4 >= 12688 && t4 <= 12703, "Bopomofo Extended": (t4) => t4 >= 12704 && t4 <= 12735, "CJK Strokes": (t4) => t4 >= 12736 && t4 <= 12783, "Katakana Phonetic Extensions": (t4) => t4 >= 12784 && t4 <= 12799, "Enclosed CJK Letters and Months": (t4) => t4 >= 12800 && t4 <= 13055, "CJK Compatibility": (t4) => t4 >= 13056 && t4 <= 13311, "CJK Unified Ideographs Extension A": (t4) => t4 >= 13312 && t4 <= 19903, "Yijing Hexagram Symbols": (t4) => t4 >= 19904 && t4 <= 19967, "CJK Unified Ideographs": (t4) => t4 >= 19968 && t4 <= 40959, "Yi Syllables": (t4) => t4 >= 40960 && t4 <= 42127, "Yi Radicals": (t4) => t4 >= 42128 && t4 <= 42191, "Hangul Jamo Extended-A": (t4) => t4 >= 43360 && t4 <= 43391, "Hangul Syllables": (t4) => t4 >= 44032 && t4 <= 55215, "Hangul Jamo Extended-B": (t4) => t4 >= 55216 && t4 <= 55295, "Private Use Area": (t4) => t4 >= 57344 && t4 <= 63743, "CJK Compatibility Ideographs": (t4) => t4 >= 63744 && t4 <= 64255, "Arabic Presentation Forms-A": (t4) => t4 >= 64336 && t4 <= 65023, "Vertical Forms": (t4) => t4 >= 65040 && t4 <= 65055, "CJK Compatibility Forms": (t4) => t4 >= 65072 && t4 <= 65103, "Small Form Variants": (t4) => t4 >= 65104 && t4 <= 65135, "Arabic Presentation Forms-B": (t4) => t4 >= 65136 && t4 <= 65279, "Halfwidth and Fullwidth Forms": (t4) => t4 >= 65280 && t4 <= 65519, "CJK Unified Ideographs Extension B": (t4) => t4 >= 131072 && t4 <= 173791 };
        function vo(t4) {
          for (const e4 of t4) if (Mo(e4.charCodeAt(0))) return true;
          return false;
        }
        function _o(t4) {
          for (const e4 of t4) if (!wo(e4.charCodeAt(0))) return false;
          return true;
        }
        function wo(t4) {
          return !(bo.Arabic(t4) || bo["Arabic Supplement"](t4) || bo["Arabic Extended-A"](t4) || bo["Arabic Presentation Forms-A"](t4) || bo["Arabic Presentation Forms-B"](t4));
        }
        function Mo(t4) {
          return !(746 !== t4 && 747 !== t4 && (t4 < 4352 || !(bo["Bopomofo Extended"](t4) || bo.Bopomofo(t4) || bo["CJK Compatibility Forms"](t4) && !(t4 >= 65097 && t4 <= 65103) || bo["CJK Compatibility Ideographs"](t4) || bo["CJK Compatibility"](t4) || bo["CJK Radicals Supplement"](t4) || bo["CJK Strokes"](t4) || !(!bo["CJK Symbols and Punctuation"](t4) || t4 >= 12296 && t4 <= 12305 || t4 >= 12308 && t4 <= 12319 || 12336 === t4) || bo["CJK Unified Ideographs Extension A"](t4) || bo["CJK Unified Ideographs"](t4) || bo["Enclosed CJK Letters and Months"](t4) || bo["Hangul Compatibility Jamo"](t4) || bo["Hangul Jamo Extended-A"](t4) || bo["Hangul Jamo Extended-B"](t4) || bo["Hangul Jamo"](t4) || bo["Hangul Syllables"](t4) || bo.Hiragana(t4) || bo["Ideographic Description Characters"](t4) || bo.Kanbun(t4) || bo["Kangxi Radicals"](t4) || bo["Katakana Phonetic Extensions"](t4) || bo.Katakana(t4) && 12540 !== t4 || !(!bo["Halfwidth and Fullwidth Forms"](t4) || 65288 === t4 || 65289 === t4 || 65293 === t4 || t4 >= 65306 && t4 <= 65310 || 65339 === t4 || 65341 === t4 || 65343 === t4 || t4 >= 65371 && t4 <= 65503 || 65507 === t4 || t4 >= 65512 && t4 <= 65519) || !(!bo["Small Form Variants"](t4) || t4 >= 65112 && t4 <= 65118 || t4 >= 65123 && t4 <= 65126) || bo["Unified Canadian Aboriginal Syllabics"](t4) || bo["Unified Canadian Aboriginal Syllabics Extended"](t4) || bo["Vertical Forms"](t4) || bo["Yijing Hexagram Symbols"](t4) || bo["Yi Syllables"](t4) || bo["Yi Radicals"](t4))));
        }
        function Ao(t4) {
          return !(Mo(t4) || function(t5) {
            return !!(bo["Latin-1 Supplement"](t5) && (167 === t5 || 169 === t5 || 174 === t5 || 177 === t5 || 188 === t5 || 189 === t5 || 190 === t5 || 215 === t5 || 247 === t5) || bo["General Punctuation"](t5) && (8214 === t5 || 8224 === t5 || 8225 === t5 || 8240 === t5 || 8241 === t5 || 8251 === t5 || 8252 === t5 || 8258 === t5 || 8263 === t5 || 8264 === t5 || 8265 === t5 || 8273 === t5) || bo["Letterlike Symbols"](t5) || bo["Number Forms"](t5) || bo["Miscellaneous Technical"](t5) && (t5 >= 8960 && t5 <= 8967 || t5 >= 8972 && t5 <= 8991 || t5 >= 8996 && t5 <= 9e3 || 9003 === t5 || t5 >= 9085 && t5 <= 9114 || t5 >= 9150 && t5 <= 9165 || 9167 === t5 || t5 >= 9169 && t5 <= 9179 || t5 >= 9186 && t5 <= 9215) || bo["Control Pictures"](t5) && 9251 !== t5 || bo["Optical Character Recognition"](t5) || bo["Enclosed Alphanumerics"](t5) || bo["Geometric Shapes"](t5) || bo["Miscellaneous Symbols"](t5) && !(t5 >= 9754 && t5 <= 9759) || bo["Miscellaneous Symbols and Arrows"](t5) && (t5 >= 11026 && t5 <= 11055 || t5 >= 11088 && t5 <= 11097 || t5 >= 11192 && t5 <= 11243) || bo["CJK Symbols and Punctuation"](t5) || bo.Katakana(t5) || bo["Private Use Area"](t5) || bo["CJK Compatibility Forms"](t5) || bo["Small Form Variants"](t5) || bo["Halfwidth and Fullwidth Forms"](t5) || 8734 === t5 || 8756 === t5 || 8757 === t5 || t5 >= 9984 && t5 <= 10087 || t5 >= 10102 && t5 <= 10131 || 65532 === t5 || 65533 === t5);
          }(t4));
        }
        function So(t4) {
          return t4 >= 1424 && t4 <= 2303 || bo["Arabic Presentation Forms-A"](t4) || bo["Arabic Presentation Forms-B"](t4);
        }
        function Io(t4, e4) {
          return !(!e4 && So(t4) || t4 >= 2304 && t4 <= 3583 || t4 >= 3840 && t4 <= 4255 || bo.Khmer(t4));
        }
        function ko(t4) {
          for (const e4 of t4) if (So(e4.charCodeAt(0))) return true;
          return false;
        }
        const Po = "deferred", Eo = "loading", zo = "loaded";
        let To = null, Bo = "unavailable", Co = null;
        const Ro = function(t4) {
          t4 && "string" == typeof t4 && t4.indexOf("NetworkError") > -1 && (Bo = "error"), To && To(t4);
        };
        function Vo() {
          Do.fire(new Rn("pluginStateChange", { pluginStatus: Bo, pluginURL: Co }));
        }
        const Do = new Dn(), Lo = function() {
          return Bo;
        }, Fo = function() {
          if (Bo !== Po || !Co) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          Bo = Eo, Vo(), Co && Jr({ url: Co }, (t4) => {
            t4 ? Ro(t4) : (Bo = zo, Vo());
          });
        }, Oo = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Bo === zo || null != Oo.applyArabicShaping, isLoading: () => Bo === Eo, setState(t4) {
          Bo = t4.pluginStatus, Co = t4.pluginURL;
        }, isParsed: () => null != Oo.applyArabicShaping && null != Oo.processBidirectionalText && null != Oo.processStyledBidirectionalText, getPluginURL: () => Co };
        class Uo {
          constructor(t4, e4) {
            this.zoom = t4, e4 ? (this.now = e4.now, this.fadeDuration = e4.fadeDuration, this.transition = e4.transition, this.pitch = e4.pitch, this.brightness = e4.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
          }
          isSupportedScript(t4) {
            return function(t5, e4) {
              for (const r4 of t5) if (!Io(r4.charCodeAt(0), e4)) return false;
              return true;
            }(t4, Oo.isLoaded());
          }
        }
        class No {
          constructor(t4, e4, r4, n3) {
            this.property = t4, this.value = e4, this.expression = function(t5, e5, r5, n4) {
              if (Qa(t5)) return new ao(t5, e5);
              if (eo(t5) || Array.isArray(t5) && t5.length > 0) {
                const i4 = so(t5, e5, r5, n4);
                if ("error" === i4.result) throw new Error(i4.value.map((t6) => `${t6.key}: ${t6.message}`).join(", "));
                return i4.value;
              }
              {
                let r6 = t5;
                return "string" == typeof t5 && "color" === e5.type && (r6 = jn.parse(t5)), { kind: "constant", isConfigDependent: false, evaluate: () => r6 };
              }
            }(void 0 === e4 ? t4.specification.default : e4, t4.specification, r4, n3);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t4, e4, r4) {
            return this.property.possiblyEvaluate(this, t4, e4, r4);
          }
        }
        class jo {
          constructor(t4, e4, r4) {
            this.property = t4, this.value = new No(t4, void 0, e4, r4);
          }
          transitioned(t4, e4) {
            return new $o(this.property, this.value, e4, Je({}, t4.transition, this.transition), t4.now);
          }
          untransitioned() {
            return new $o(this.property, this.value, null, {}, 0);
          }
        }
        class qo {
          constructor(t4, e4, r4) {
            this._properties = t4, this._values = Object.create(t4.defaultTransitionablePropertyValues), this._scope = e4, this._options = r4, this.isConfigDependent = false;
          }
          getValue(t4) {
            return ur(this._values[t4].value.value);
          }
          setValue(t4, e4) {
            this._values.hasOwnProperty(t4) || (this._values[t4] = new jo(this._values[t4].property, this._scope, this._options)), this._values[t4].value = new No(this._values[t4].property, null === e4 ? void 0 : ur(e4), this._scope, this._options), this.isConfigDependent = this.isConfigDependent || this._values[t4].value.expression.isConfigDependent;
          }
          setTransitionOrValue(t4, e4) {
            e4 && (this._options = e4);
            const r4 = this._properties.properties;
            if (t4) for (const e5 in t4) {
              const n3 = t4[e5];
              if (ar(e5, "-transition")) {
                const t5 = e5.slice(0, -11);
                r4[t5] && this.setTransition(t5, n3);
              } else r4[e5] && this.setValue(e5, n3);
            }
          }
          getTransition(t4) {
            return ur(this._values[t4].transition);
          }
          setTransition(t4, e4) {
            this._values.hasOwnProperty(t4) || (this._values[t4] = new jo(this._values[t4].property)), this._values[t4].transition = ur(e4) || void 0;
          }
          serialize() {
            const t4 = {};
            for (const e4 of Object.keys(this._values)) {
              const r4 = this.getValue(e4);
              void 0 !== r4 && (t4[e4] = r4);
              const n3 = this.getTransition(e4);
              void 0 !== n3 && (t4[`${e4}-transition`] = n3);
            }
            return t4;
          }
          transitioned(t4, e4) {
            const r4 = new Go(this._properties);
            for (const n3 of Object.keys(this._values)) r4._values[n3] = this._values[n3].transitioned(t4, e4._values[n3]);
            return r4;
          }
          untransitioned() {
            const t4 = new Go(this._properties);
            for (const e4 of Object.keys(this._values)) t4._values[e4] = this._values[e4].untransitioned();
            return t4;
          }
        }
        class $o {
          constructor(t4, e4, r4, n3, i4) {
            const s4 = n3.delay || 0, a4 = n3.duration || 0;
            i4 = i4 || 0, this.property = t4, this.value = e4, this.begin = i4 + s4, this.end = this.begin + a4, t4.specification.transition && (n3.delay || n3.duration) && (this.prior = r4);
          }
          possiblyEvaluate(t4, e4, r4) {
            const n3 = t4.now || 0, i4 = this.value.possiblyEvaluate(t4, e4, r4), s4 = this.prior;
            if (s4) {
              if (n3 > this.end) return this.prior = null, i4;
              if (this.value.isDataDriven()) return this.prior = null, i4;
              if (n3 < this.begin) return s4.possiblyEvaluate(t4, e4, r4);
              {
                const a4 = (n3 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s4.possiblyEvaluate(t4, e4, r4), i4, Qe(a4));
              }
            }
            return i4;
          }
        }
        class Go {
          constructor(t4) {
            this._properties = t4, this._values = Object.create(t4.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t4, e4, r4) {
            const n3 = new Xo(this._properties);
            for (const i4 of Object.keys(this._values)) n3._values[i4] = this._values[i4].possiblyEvaluate(t4, e4, r4);
            return n3;
          }
          hasTransition() {
            for (const t4 of Object.keys(this._values)) if (this._values[t4].prior) return true;
            return false;
          }
        }
        class Qo {
          constructor(t4, e4, r4) {
            this._properties = t4, this._values = Object.create(t4.defaultPropertyValues), this._scope = e4, this._options = r4, this.isConfigDependent = false;
          }
          getValue(t4) {
            return ur(this._values[t4].value);
          }
          setValue(t4, e4) {
            this._values[t4] = new No(this._values[t4].property, null === e4 ? void 0 : ur(e4), this._scope, this._options), this.isConfigDependent = this.isConfigDependent || this._values[t4].expression.isConfigDependent;
          }
          serialize() {
            const t4 = {};
            for (const e4 of Object.keys(this._values)) {
              const r4 = this.getValue(e4);
              void 0 !== r4 && (t4[e4] = r4);
            }
            return t4;
          }
          possiblyEvaluate(t4, e4, r4) {
            const n3 = new Xo(this._properties);
            for (const i4 of Object.keys(this._values)) n3._values[i4] = this._values[i4].possiblyEvaluate(t4, e4, r4);
            return n3;
          }
        }
        class Yo {
          constructor(t4, e4, r4) {
            this.property = t4, this.value = e4, this.parameters = r4;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t4) {
            return "constant" === this.value.kind ? this.value.value : t4;
          }
          evaluate(t4, e4, r4, n3) {
            return this.property.evaluate(this.value, this.parameters, t4, e4, r4, n3);
          }
        }
        class Xo {
          constructor(t4) {
            this._properties = t4, this._values = Object.create(t4.defaultPossiblyEvaluatedValues);
          }
          get(t4) {
            return this._values[t4];
          }
        }
        class Zo {
          constructor(t4) {
            this.specification = t4;
          }
          possiblyEvaluate(t4, e4) {
            return t4.expression.evaluate(e4);
          }
          interpolate(t4, e4, r4) {
            const n3 = Gn[this.specification.type];
            return n3 ? n3(t4, e4, r4) : t4;
          }
        }
        class Ko {
          constructor(t4, e4) {
            this.specification = t4, this.overrides = e4;
          }
          possiblyEvaluate(t4, e4, r4, n3) {
            return new Yo(this, "constant" === t4.expression.kind || "camera" === t4.expression.kind ? { kind: "constant", value: t4.expression.evaluate(e4, null, {}, r4, n3) } : t4.expression, e4);
          }
          interpolate(t4, e4, r4) {
            if ("constant" !== t4.value.kind || "constant" !== e4.value.kind) return t4;
            if (void 0 === t4.value.value || void 0 === e4.value.value) return new Yo(this, { kind: "constant", value: void 0 }, t4.parameters);
            const n3 = Gn[this.specification.type];
            return n3 ? new Yo(this, { kind: "constant", value: n3(t4.value.value, e4.value.value, r4) }, t4.parameters) : t4;
          }
          evaluate(t4, e4, r4, n3, i4, s4) {
            return "constant" === t4.kind ? t4.value : t4.evaluate(e4, r4, n3, i4, s4);
          }
        }
        class Wo {
          constructor(t4) {
            this.specification = t4;
          }
          possiblyEvaluate(t4, e4, r4, n3) {
            return !!t4.expression.evaluate(e4, null, {}, r4, n3);
          }
          interpolate() {
            return false;
          }
        }
        class Ho {
          constructor(t4) {
            this.properties = t4, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            const e4 = new Uo(0, {});
            for (const r4 in t4) {
              const n3 = t4[r4];
              n3.specification.overridable && this.overridableProperties.push(r4);
              const i4 = this.defaultPropertyValues[r4] = new No(n3, void 0), s4 = this.defaultTransitionablePropertyValues[r4] = new jo(n3);
              this.defaultTransitioningPropertyValues[r4] = s4.untransitioned(), this.defaultPossiblyEvaluatedValues[r4] = i4.possiblyEvaluate(e4);
            }
          }
        }
        function Jo(t4) {
          return t4 instanceof Number || t4 instanceof String || t4 instanceof Boolean ? t4.valueOf() : t4;
        }
        function tl(t4) {
          if (Array.isArray(t4)) return t4.map(tl);
          if (t4 instanceof Object && !(t4 instanceof Number || t4 instanceof String || t4 instanceof Boolean)) {
            const e4 = {};
            for (const r4 in t4) e4[r4] = tl(t4[r4]);
            return e4;
          }
          return Jo(t4);
        }
        fo(Ko, "DataDrivenProperty"), fo(Zo, "DataConstantProperty"), fo(Wo, "ColorRampProperty");
        var el = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"camera":{"type":"camera"},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"expression":{},"property-type":"data-constant"},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function rl(t4) {
          if (true === t4 || false === t4) return true;
          if (!Array.isArray(t4) || 0 === t4.length) return false;
          switch (t4[0]) {
            case "has":
              return t4.length >= 2 && "$id" !== t4[1] && "$type" !== t4[1];
            case "in":
              return t4.length >= 3 && ("string" != typeof t4[1] || Array.isArray(t4[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t4.length || Array.isArray(t4[1]) || Array.isArray(t4[2]);
            case "any":
            case "all":
              for (const e4 of t4.slice(1)) if (!rl(e4) && "boolean" != typeof e4) return false;
              return true;
            default:
              return true;
          }
        }
        function nl(t4, e4 = "fill") {
          if (null == t4) return { filter: () => true, needGeometry: false, needFeature: false };
          rl(t4) || (t4 = cl(t4));
          const r4 = t4;
          let n3 = true;
          try {
            n3 = function(t5) {
              if (!al(t5)) return t5;
              let e5 = tl(t5);
              return sl(e5), e5 = il(e5), e5;
            }(r4);
          } catch (t5) {
            console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(r4, null, 2)}
        `);
          }
          const i4 = el[`filter_${e4}`], s4 = ro(n3, i4);
          let a4 = null;
          if ("error" === s4.result) throw new Error(s4.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
          a4 = (t5, e5, r5) => s4.value.evaluate(t5, e5, {}, r5);
          let o3 = null, l4 = null;
          if (n3 !== r4) {
            const t5 = ro(r4, i4);
            if ("error" === t5.result) throw new Error(t5.value.map((t6) => `${t6.key}: ${t6.message}`).join(", "));
            o3 = (e5, r5, n4, i5, s5) => t5.value.evaluate(e5, r5, {}, n4, void 0, void 0, i5, s5), l4 = !Fs(t5.value.expression);
          }
          return { filter: a4, dynamicFilter: o3 || void 0, needGeometry: ul(n3), needFeature: !!l4 };
        }
        function il(t4) {
          if (!Array.isArray(t4)) return t4;
          const e4 = function(t5) {
            if (ol.has(t5[0])) {
              for (let e5 = 1; e5 < t5.length; e5++) if (al(t5[e5])) return true;
            }
            return t5;
          }(t4);
          return true === e4 ? e4 : e4.map((t5) => il(t5));
        }
        function sl(t4) {
          let e4 = false;
          const r4 = [];
          if ("case" === t4[0]) {
            for (let n3 = 1; n3 < t4.length - 1; n3 += 2) e4 = e4 || al(t4[n3]), r4.push(t4[n3 + 1]);
            r4.push(t4[t4.length - 1]);
          } else if ("match" === t4[0]) {
            e4 = e4 || al(t4[1]);
            for (let e5 = 2; e5 < t4.length - 1; e5 += 2) r4.push(t4[e5 + 1]);
            r4.push(t4[t4.length - 1]);
          } else if ("step" === t4[0]) {
            e4 = e4 || al(t4[1]);
            for (let e5 = 1; e5 < t4.length - 1; e5 += 2) r4.push(t4[e5 + 1]);
          }
          e4 && (t4.length = 0, t4.push("any", ...r4));
          for (let e5 = 1; e5 < t4.length; e5++) sl(t4[e5]);
        }
        function al(t4) {
          if (!Array.isArray(t4)) return false;
          if ("pitch" === (e4 = t4[0]) || "distance-from-center" === e4) return true;
          var e4;
          for (let e5 = 1; e5 < t4.length; e5++) if (al(t4[e5])) return true;
          return false;
        }
        const ol = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function ll(t4, e4) {
          return t4 < e4 ? -1 : t4 > e4 ? 1 : 0;
        }
        function ul(t4) {
          if (!Array.isArray(t4)) return false;
          if ("within" === t4[0] || "distance" === t4[0]) return true;
          for (let e4 = 1; e4 < t4.length; e4++) if (ul(t4[e4])) return true;
          return false;
        }
        function cl(t4) {
          if (!t4) return true;
          const e4 = t4[0];
          return t4.length <= 1 ? "any" !== e4 : "==" === e4 ? hl(t4[1], t4[2], "==") : "!=" === e4 ? dl(hl(t4[1], t4[2], "==")) : "<" === e4 || ">" === e4 || "<=" === e4 || ">=" === e4 ? hl(t4[1], t4[2], e4) : "any" === e4 ? (r4 = t4.slice(1), ["any"].concat(r4.map(cl))) : "all" === e4 ? ["all"].concat(t4.slice(1).map(cl)) : "none" === e4 ? ["all"].concat(t4.slice(1).map(cl).map(dl)) : "in" === e4 ? pl(t4[1], t4.slice(2)) : "!in" === e4 ? dl(pl(t4[1], t4.slice(2))) : "has" === e4 ? fl(t4[1]) : "!has" !== e4 || dl(fl(t4[1]));
          var r4;
        }
        function hl(t4, e4, r4) {
          switch (t4) {
            case "$type":
              return [`filter-type-${r4}`, e4];
            case "$id":
              return [`filter-id-${r4}`, e4];
            default:
              return [`filter-${r4}`, t4, e4];
          }
        }
        function pl(t4, e4) {
          if (0 === e4.length) return false;
          switch (t4) {
            case "$type":
              return ["filter-type-in", ["literal", e4]];
            case "$id":
              return ["filter-id-in", ["literal", e4]];
            default:
              return e4.length > 200 && !e4.some((t5) => typeof t5 != typeof e4[0]) ? ["filter-in-large", t4, ["literal", e4.sort(ll)]] : ["filter-in-small", t4, ["literal", e4]];
          }
        }
        function fl(t4) {
          switch (t4) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t4];
          }
        }
        function dl(t4) {
          return ["!", t4];
        }
        const ml = "";
        function yl(t4, e4) {
          return e4 ? `${t4}${ml}${e4}` : t4;
        }
        const gl = "-transition", xl = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
        class bl extends Dn {
          constructor(t4, e4, r4, n3) {
            if (super(), this.id = t4.id, this.fqid = yl(this.id, r4), this.type = t4.type, this.scope = r4, this.options = n3, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, this.isConfigDependent = false, "custom" !== t4.type && (this.metadata = t4.metadata, this.minzoom = t4.minzoom, this.maxzoom = t4.maxzoom, "background" !== t4.type && "sky" !== t4.type && "slot" !== t4.type && (this.source = t4.source, this.sourceLayer = t4["source-layer"], this.filter = t4.filter), t4.slot && (this.slot = t4.slot), e4.layout && (this._unevaluatedLayout = new Qo(e4.layout, this.scope, n3), this.isConfigDependent = this.isConfigDependent || this._unevaluatedLayout.isConfigDependent), e4.paint)) {
              this._transitionablePaint = new qo(e4.paint, this.scope, n3);
              for (const e5 in t4.paint) this.setPaintProperty(e5, t4.paint[e5]);
              for (const e5 in t4.layout) this.setLayoutProperty(e5, t4.layout[e5]);
              this.isConfigDependent = this.isConfigDependent || this._transitionablePaint.isConfigDependent, this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Xo(e4.paint);
            }
          }
          onAdd(t4) {
          }
          onRemove(t4) {
          }
          isDraped(t4) {
            return xl.has(this.type);
          }
          getLayoutProperty(t4) {
            return "visibility" === t4 ? this.visibility : this._unevaluatedLayout.getValue(t4);
          }
          setLayoutProperty(t4, e4) {
            if ("custom" === this.type && "visibility" === t4) return void (this.visibility = e4);
            const r4 = this._unevaluatedLayout;
            r4._properties.properties[t4] && (r4.setValue(t4, e4), this.isConfigDependent = this.isConfigDependent || r4.isConfigDependent, "visibility" === t4 && this.possiblyEvaluateVisibility());
          }
          possiblyEvaluateVisibility() {
            this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 });
          }
          getPaintProperty(t4) {
            return ar(t4, gl) ? this._transitionablePaint.getTransition(t4.slice(0, -11)) : this._transitionablePaint.getValue(t4);
          }
          setPaintProperty(t4, e4) {
            const r4 = this._transitionablePaint, n3 = r4._properties.properties;
            if (ar(t4, gl)) {
              const i5 = t4.slice(0, -11);
              return n3[i5] && r4.setTransition(i5, e4 || void 0), false;
            }
            if (!n3[t4]) return false;
            const i4 = r4._values[t4], s4 = i4.value.isDataDriven(), a4 = i4.value;
            r4.setValue(t4, e4), this.isConfigDependent = this.isConfigDependent || r4.isConfigDependent, this._handleSpecialPaintPropertyUpdate(t4);
            const o3 = r4._values[t4].value, l4 = o3.isDataDriven(), u5 = ar(t4, "pattern") || "line-dasharray" === t4;
            return l4 || s4 || u5 || this._handleOverridablePaintPropertyUpdate(t4, a4, o3);
          }
          _handleSpecialPaintPropertyUpdate(t4) {
          }
          getProgramIds() {
            return null;
          }
          getDefaultProgramParams(t4, e4) {
            return null;
          }
          _handleOverridablePaintPropertyUpdate(t4, e4, r4) {
            return false;
          }
          isHidden(t4) {
            return !!(this.minzoom && t4 < this.minzoom) || !!(this.maxzoom && t4 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t4) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t4, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t4, e4) {
            this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t4, void 0, e4)), this.paint = this._transitioningPaint.possiblyEvaluate(t4, void 0, e4);
          }
          serialize() {
            return lr({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (t4, e4) => !(void 0 === t4 || "layout" === e4 && !Object.keys(t4).length || "paint" === e4 && !Object.keys(t4).length));
          }
          is3D() {
            return false;
          }
          isSky() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          hasShadowPass() {
            return false;
          }
          canCastShadows() {
            return false;
          }
          hasLightBeamPass() {
            return false;
          }
          cutoffRange() {
            return 0;
          }
          tileCoverLift() {
            return 0;
          }
          resize() {
          }
          isStateDependent() {
            for (const t4 in this.paint._values) {
              const e4 = this.paint.get(t4);
              if (e4 instanceof Yo && ja(e4.property.specification) && ("source" === e4.value.kind || "composite" === e4.value.kind) && e4.value.isStateDependent) return true;
            }
            return false;
          }
          compileFilter() {
            this._filterCompiled || (this._featureFilter = nl(this.filter), this._filterCompiled = true);
          }
          invalidateCompiledFilter() {
            this._filterCompiled = false;
          }
          dynamicFilter() {
            return this._featureFilter.dynamicFilter;
          }
          dynamicFilterNeedsFeature() {
            return this._featureFilter.needFeature;
          }
          getLayerRenderingStats() {
            return this._stats;
          }
          resetLayerRenderingStats(t4) {
            this._stats && ("shadow" === t4.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
          }
          queryRadius(t4) {
          }
          queryIntersectsFeature(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
          }
          queryIntersectsMatchingFeature(t4, e4, r4, n3) {
          }
        }
        const vl = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class _l {
          constructor(t4, e4) {
            this._structArray = t4, this._pos1 = e4 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class wl {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t4, e4) {
            return t4._trim(), e4 && (t4.isTransferred = true, e4.add(t4.arrayBuffer)), { length: t4.length, arrayBuffer: t4.arrayBuffer };
          }
          static deserialize(t4) {
            const e4 = Object.create(this.prototype);
            return e4.arrayBuffer = t4.arrayBuffer, e4.length = t4.length, e4.capacity = t4.arrayBuffer.byteLength / e4.bytesPerElement, e4._refreshViews(), e4;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t4) {
            this.reserve(t4), this.length = t4;
          }
          reserve(t4) {
            if (t4 > this.capacity) {
              this.capacity = Math.max(t4, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e4 = this.uint8;
              this._refreshViews(), e4 && this.uint8.set(e4);
            }
          }
          _refreshViews() {
            throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
          }
          emplace(...t4) {
            throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
          }
          emplaceBack(...t4) {
            throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
          }
          destroy() {
            this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
          }
        }
        function Ml(t4, e4 = 1) {
          let r4 = 0, n3 = 0;
          return { members: t4.map((t5) => {
            const i4 = vl[t5.type].BYTES_PER_ELEMENT, s4 = r4 = Al(r4, Math.max(e4, i4)), a4 = t5.components || 1;
            return n3 = Math.max(n3, i4), r4 += i4 * a4, { name: t5.name, type: t5.type, components: a4, offset: s4 };
          }), size: Al(r4, Math.max(n3, e4)), alignment: e4 };
        }
        function Al(t4, e4) {
          return Math.ceil(t4 / e4) * e4;
        }
        class Sl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4) {
            const r4 = this.length;
            return this.resize(r4 + 1), this.emplace(r4, t4, e4);
          }
          emplace(t4, e4, r4) {
            const n3 = 2 * t4;
            return this.int16[n3 + 0] = e4, this.int16[n3 + 1] = r4, t4;
          }
        }
        Sl.prototype.bytesPerElement = 4, fo(Sl, "StructArrayLayout2i4");
        class Il extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t4, e4, r4);
          }
          emplace(t4, e4, r4, n3) {
            const i4 = 3 * t4;
            return this.int16[i4 + 0] = e4, this.int16[i4 + 1] = r4, this.int16[i4 + 2] = n3, t4;
          }
        }
        Il.prototype.bytesPerElement = 6, fo(Il, "StructArrayLayout3i6");
        class kl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3) {
            const i4 = this.length;
            return this.resize(i4 + 1), this.emplace(i4, t4, e4, r4, n3);
          }
          emplace(t4, e4, r4, n3, i4) {
            const s4 = 4 * t4;
            return this.int16[s4 + 0] = e4, this.int16[s4 + 1] = r4, this.int16[s4 + 2] = n3, this.int16[s4 + 3] = i4, t4;
          }
        }
        kl.prototype.bytesPerElement = 8, fo(kl, "StructArrayLayout4i8");
        class Pl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t4, e4, r4, n3, i4);
          }
          emplace(t4, e4, r4, n3, i4, s4) {
            const a4 = 5 * t4;
            return this.int16[a4 + 0] = e4, this.int16[a4 + 1] = r4, this.int16[a4 + 2] = n3, this.int16[a4 + 3] = i4, this.int16[a4 + 4] = s4, t4;
          }
        }
        Pl.prototype.bytesPerElement = 10, fo(Pl, "StructArrayLayout5i10");
        class El extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = this.length;
            return this.resize(o3 + 1), this.emplace(o3, t4, e4, r4, n3, i4, s4, a4);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4, o3) {
            const l4 = 6 * t4, u5 = 12 * t4, c4 = 3 * t4;
            return this.int16[l4 + 0] = e4, this.int16[l4 + 1] = r4, this.uint8[u5 + 4] = n3, this.uint8[u5 + 5] = i4, this.uint8[u5 + 6] = s4, this.uint8[u5 + 7] = a4, this.float32[c4 + 2] = o3, t4;
          }
        }
        El.prototype.bytesPerElement = 12, fo(El, "StructArrayLayout2i4ub1f12");
        class zl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3) {
            const i4 = this.length;
            return this.resize(i4 + 1), this.emplace(i4, t4, e4, r4, n3);
          }
          emplace(t4, e4, r4, n3, i4) {
            const s4 = 4 * t4;
            return this.float32[s4 + 0] = e4, this.float32[s4 + 1] = r4, this.float32[s4 + 2] = n3, this.float32[s4 + 3] = i4, t4;
          }
        }
        zl.prototype.bytesPerElement = 16, fo(zl, "StructArrayLayout4f16");
        class Tl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4) {
            const r4 = this.length;
            return this.resize(r4 + 1), this.emplace(r4, t4, e4);
          }
          emplace(t4, e4, r4) {
            const n3 = 2 * t4;
            return this.float32[n3 + 0] = e4, this.float32[n3 + 1] = r4, t4;
          }
        }
        Tl.prototype.bytesPerElement = 8, fo(Tl, "StructArrayLayout2f8");
        class Bl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t4, e4, r4, n3, i4);
          }
          emplace(t4, e4, r4, n3, i4, s4) {
            const a4 = 6 * t4, o3 = 3 * t4;
            return this.uint16[a4 + 0] = e4, this.uint16[a4 + 1] = r4, this.uint16[a4 + 2] = n3, this.uint16[a4 + 3] = i4, this.float32[o3 + 2] = s4, t4;
          }
        }
        Bl.prototype.bytesPerElement = 12, fo(Bl, "StructArrayLayout4ui1f12");
        class Cl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3) {
            const i4 = this.length;
            return this.resize(i4 + 1), this.emplace(i4, t4, e4, r4, n3);
          }
          emplace(t4, e4, r4, n3, i4) {
            const s4 = 4 * t4;
            return this.uint16[s4 + 0] = e4, this.uint16[s4 + 1] = r4, this.uint16[s4 + 2] = n3, this.uint16[s4 + 3] = i4, t4;
          }
        }
        Cl.prototype.bytesPerElement = 8, fo(Cl, "StructArrayLayout4ui8");
        class Rl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4) {
            const a4 = this.length;
            return this.resize(a4 + 1), this.emplace(a4, t4, e4, r4, n3, i4, s4);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = 6 * t4;
            return this.int16[o3 + 0] = e4, this.int16[o3 + 1] = r4, this.int16[o3 + 2] = n3, this.int16[o3 + 3] = i4, this.int16[o3 + 4] = s4, this.int16[o3 + 5] = a4, t4;
          }
        }
        Rl.prototype.bytesPerElement = 12, fo(Rl, "StructArrayLayout6i12");
        class Vl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4) {
            const p4 = this.length;
            return this.resize(p4 + 1), this.emplace(p4, t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4) {
            const f4 = 12 * t4;
            return this.int16[f4 + 0] = e4, this.int16[f4 + 1] = r4, this.int16[f4 + 2] = n3, this.int16[f4 + 3] = i4, this.uint16[f4 + 4] = s4, this.uint16[f4 + 5] = a4, this.uint16[f4 + 6] = o3, this.uint16[f4 + 7] = l4, this.int16[f4 + 8] = u5, this.int16[f4 + 9] = c4, this.int16[f4 + 10] = h4, this.int16[f4 + 11] = p4, t4;
          }
        }
        Vl.prototype.bytesPerElement = 24, fo(Vl, "StructArrayLayout4i4ui4i24");
        class Dl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4) {
            const a4 = this.length;
            return this.resize(a4 + 1), this.emplace(a4, t4, e4, r4, n3, i4, s4);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = 10 * t4, l4 = 5 * t4;
            return this.int16[o3 + 0] = e4, this.int16[o3 + 1] = r4, this.int16[o3 + 2] = n3, this.float32[l4 + 2] = i4, this.float32[l4 + 3] = s4, this.float32[l4 + 4] = a4, t4;
          }
        }
        Dl.prototype.bytesPerElement = 20, fo(Dl, "StructArrayLayout3i3f20");
        class Ll extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t4) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t4);
          }
          emplace(t4, e4) {
            return this.uint32[1 * t4 + 0] = e4, t4;
          }
        }
        Ll.prototype.bytesPerElement = 4, fo(Ll, "StructArrayLayout1ul4");
        class Fl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4) {
            const r4 = this.length;
            return this.resize(r4 + 1), this.emplace(r4, t4, e4);
          }
          emplace(t4, e4, r4) {
            const n3 = 2 * t4;
            return this.uint16[n3 + 0] = e4, this.uint16[n3 + 1] = r4, t4;
          }
        }
        Fl.prototype.bytesPerElement = 4, fo(Fl, "StructArrayLayout2ui4");
        class Ol extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4) {
            const f4 = this.length;
            return this.resize(f4 + 1), this.emplace(f4, t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4) {
            const d3 = 20 * t4, m4 = 10 * t4;
            return this.int16[d3 + 0] = e4, this.int16[d3 + 1] = r4, this.int16[d3 + 2] = n3, this.int16[d3 + 3] = i4, this.int16[d3 + 4] = s4, this.float32[m4 + 3] = a4, this.float32[m4 + 4] = o3, this.float32[m4 + 5] = l4, this.float32[m4 + 6] = u5, this.int16[d3 + 14] = c4, this.uint32[m4 + 8] = h4, this.uint16[d3 + 18] = p4, this.uint16[d3 + 19] = f4, t4;
          }
        }
        Ol.prototype.bytesPerElement = 40, fo(Ol, "StructArrayLayout5i4f1i1ul2ui40");
        class Ul extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = this.length;
            return this.resize(o3 + 1), this.emplace(o3, t4, e4, r4, n3, i4, s4, a4);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4, o3) {
            const l4 = 8 * t4;
            return this.int16[l4 + 0] = e4, this.int16[l4 + 1] = r4, this.int16[l4 + 2] = n3, this.int16[l4 + 4] = i4, this.int16[l4 + 5] = s4, this.int16[l4 + 6] = a4, this.int16[l4 + 7] = o3, t4;
          }
        }
        Ul.prototype.bytesPerElement = 16, fo(Ul, "StructArrayLayout3i2i2i16");
        class Nl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t4, e4, r4, n3, i4);
          }
          emplace(t4, e4, r4, n3, i4, s4) {
            const a4 = 4 * t4, o3 = 8 * t4;
            return this.float32[a4 + 0] = e4, this.float32[a4 + 1] = r4, this.float32[a4 + 2] = n3, this.int16[o3 + 6] = i4, this.int16[o3 + 7] = s4, t4;
          }
        }
        Nl.prototype.bytesPerElement = 16, fo(Nl, "StructArrayLayout2f1f2i16");
        class jl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3) {
            const i4 = this.length;
            return this.resize(i4 + 1), this.emplace(i4, t4, e4, r4, n3);
          }
          emplace(t4, e4, r4, n3, i4) {
            const s4 = 12 * t4, a4 = 3 * t4;
            return this.uint8[s4 + 0] = e4, this.uint8[s4 + 1] = r4, this.float32[a4 + 1] = n3, this.float32[a4 + 2] = i4, t4;
          }
        }
        jl.prototype.bytesPerElement = 12, fo(jl, "StructArrayLayout2ub2f12");
        class ql extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t4, e4, r4);
          }
          emplace(t4, e4, r4, n3) {
            const i4 = 3 * t4;
            return this.uint16[i4 + 0] = e4, this.uint16[i4 + 1] = r4, this.uint16[i4 + 2] = n3, t4;
          }
        }
        ql.prototype.bytesPerElement = 6, fo(ql, "StructArrayLayout3ui6");
        class $l extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4, y4, g5, x5, b4, v4) {
            const _4 = this.length;
            return this.resize(_4 + 1), this.emplace(_4, t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4, y4, g5, x5, b4, v4);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4, y4, g5, x5, b4, v4, _4) {
            const w5 = 30 * t4, M3 = 15 * t4, A4 = 60 * t4;
            return this.int16[w5 + 0] = e4, this.int16[w5 + 1] = r4, this.int16[w5 + 2] = n3, this.float32[M3 + 2] = i4, this.float32[M3 + 3] = s4, this.uint16[w5 + 8] = a4, this.uint16[w5 + 9] = o3, this.uint32[M3 + 5] = l4, this.uint32[M3 + 6] = u5, this.uint32[M3 + 7] = c4, this.uint16[w5 + 16] = h4, this.uint16[w5 + 17] = p4, this.uint16[w5 + 18] = f4, this.float32[M3 + 10] = d3, this.float32[M3 + 11] = m4, this.uint8[A4 + 48] = y4, this.uint8[A4 + 49] = g5, this.uint8[A4 + 50] = x5, this.uint32[M3 + 13] = b4, this.int16[w5 + 28] = v4, this.uint8[A4 + 58] = _4, t4;
          }
        }
        $l.prototype.bytesPerElement = 60, fo($l, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class Gl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4, y4, g5, x5, b4, v4, _4, w5, M3, A4, S3, I4, k4, P4, E3, z4, T5) {
            const B4 = this.length;
            return this.resize(B4 + 1), this.emplace(B4, t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4, y4, g5, x5, b4, v4, _4, w5, M3, A4, S3, I4, k4, P4, E3, z4, T5);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4, y4, g5, x5, b4, v4, _4, w5, M3, A4, S3, I4, k4, P4, E3, z4, T5, B4) {
            const C4 = 20 * t4, R2 = 40 * t4, V4 = 80 * t4;
            return this.float32[C4 + 0] = e4, this.float32[C4 + 1] = r4, this.int16[R2 + 4] = n3, this.int16[R2 + 5] = i4, this.int16[R2 + 6] = s4, this.int16[R2 + 7] = a4, this.int16[R2 + 8] = o3, this.int16[R2 + 9] = l4, this.int16[R2 + 10] = u5, this.int16[R2 + 11] = c4, this.int16[R2 + 12] = h4, this.uint16[R2 + 13] = p4, this.uint16[R2 + 14] = f4, this.uint16[R2 + 15] = d3, this.uint16[R2 + 16] = m4, this.uint16[R2 + 17] = y4, this.uint16[R2 + 18] = g5, this.uint16[R2 + 19] = x5, this.uint16[R2 + 20] = b4, this.uint16[R2 + 21] = v4, this.uint16[R2 + 22] = _4, this.uint16[R2 + 23] = w5, this.uint16[R2 + 24] = M3, this.uint16[R2 + 25] = A4, this.uint16[R2 + 26] = S3, this.uint16[R2 + 27] = I4, this.uint32[C4 + 14] = k4, this.float32[C4 + 15] = P4, this.float32[C4 + 16] = E3, this.float32[C4 + 17] = z4, this.float32[C4 + 18] = T5, this.uint8[V4 + 76] = B4, t4;
          }
        }
        Gl.prototype.bytesPerElement = 80, fo(Gl, "StructArrayLayout2f9i15ui1ul4f1ub80");
        class Ql extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t4);
          }
          emplace(t4, e4) {
            return this.float32[1 * t4 + 0] = e4, t4;
          }
        }
        Ql.prototype.bytesPerElement = 4, fo(Ql, "StructArrayLayout1f4");
        class Yl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t4, e4, r4, n3, i4);
          }
          emplace(t4, e4, r4, n3, i4, s4) {
            const a4 = 5 * t4;
            return this.float32[a4 + 0] = e4, this.float32[a4 + 1] = r4, this.float32[a4 + 2] = n3, this.float32[a4 + 3] = i4, this.float32[a4 + 4] = s4, t4;
          }
        }
        Yl.prototype.bytesPerElement = 20, fo(Yl, "StructArrayLayout5f20");
        class Xl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = this.length;
            return this.resize(o3 + 1), this.emplace(o3, t4, e4, r4, n3, i4, s4, a4);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4, o3) {
            const l4 = 7 * t4;
            return this.float32[l4 + 0] = e4, this.float32[l4 + 1] = r4, this.float32[l4 + 2] = n3, this.float32[l4 + 3] = i4, this.float32[l4 + 4] = s4, this.float32[l4 + 5] = a4, this.float32[l4 + 6] = o3, t4;
          }
        }
        Xl.prototype.bytesPerElement = 28, fo(Xl, "StructArrayLayout7f28");
        class Zl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3) {
            const i4 = this.length;
            return this.resize(i4 + 1), this.emplace(i4, t4, e4, r4, n3);
          }
          emplace(t4, e4, r4, n3, i4) {
            const s4 = 6 * t4;
            return this.uint32[3 * t4 + 0] = e4, this.uint16[s4 + 2] = r4, this.uint16[s4 + 3] = n3, this.uint16[s4 + 4] = i4, t4;
          }
        }
        Zl.prototype.bytesPerElement = 12, fo(Zl, "StructArrayLayout1ul3ui12");
        class Kl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t4);
          }
          emplace(t4, e4) {
            return this.uint16[1 * t4 + 0] = e4, t4;
          }
        }
        Kl.prototype.bytesPerElement = 2, fo(Kl, "StructArrayLayout1ui2");
        class Wl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t4, e4, r4);
          }
          emplace(t4, e4, r4, n3) {
            const i4 = 3 * t4;
            return this.float32[i4 + 0] = e4, this.float32[i4 + 1] = r4, this.float32[i4 + 2] = n3, t4;
          }
        }
        Wl.prototype.bytesPerElement = 12, fo(Wl, "StructArrayLayout3f12");
        class Hl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4) {
            const y4 = this.length;
            return this.resize(y4 + 1), this.emplace(y4, t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4, y4) {
            const g5 = 16 * t4;
            return this.float32[g5 + 0] = e4, this.float32[g5 + 1] = r4, this.float32[g5 + 2] = n3, this.float32[g5 + 3] = i4, this.float32[g5 + 4] = s4, this.float32[g5 + 5] = a4, this.float32[g5 + 6] = o3, this.float32[g5 + 7] = l4, this.float32[g5 + 8] = u5, this.float32[g5 + 9] = c4, this.float32[g5 + 10] = h4, this.float32[g5 + 11] = p4, this.float32[g5 + 12] = f4, this.float32[g5 + 13] = d3, this.float32[g5 + 14] = m4, this.float32[g5 + 15] = y4, t4;
          }
        }
        Hl.prototype.bytesPerElement = 64, fo(Hl, "StructArrayLayout16f64");
        class Jl extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = this.length;
            return this.resize(o3 + 1), this.emplace(o3, t4, e4, r4, n3, i4, s4, a4);
          }
          emplace(t4, e4, r4, n3, i4, s4, a4, o3) {
            const l4 = 10 * t4, u5 = 5 * t4;
            return this.uint16[l4 + 0] = e4, this.uint16[l4 + 1] = r4, this.uint16[l4 + 2] = n3, this.uint16[l4 + 3] = i4, this.float32[u5 + 2] = s4, this.float32[u5 + 3] = a4, this.float32[u5 + 4] = o3, t4;
          }
        }
        Jl.prototype.bytesPerElement = 20, fo(Jl, "StructArrayLayout4ui3f20");
        class tu extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t4);
          }
          emplace(t4, e4) {
            return this.int16[1 * t4 + 0] = e4, t4;
          }
        }
        tu.prototype.bytesPerElement = 2, fo(tu, "StructArrayLayout1i2");
        class eu extends wl {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
          }
          emplaceBack(t4) {
            const e4 = this.length;
            return this.resize(e4 + 1), this.emplace(e4, t4);
          }
          emplace(t4, e4) {
            return this.uint8[1 * t4 + 0] = e4, t4;
          }
        }
        eu.prototype.bytesPerElement = 1, fo(eu, "StructArrayLayout1ub1");
        class ru extends _l {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get tileAnchorY() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get x1() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get y1() {
            return this._structArray.float32[this._pos4 + 4];
          }
          get x2() {
            return this._structArray.float32[this._pos4 + 5];
          }
          get y2() {
            return this._structArray.float32[this._pos4 + 6];
          }
          get padding() {
            return this._structArray.int16[this._pos2 + 14];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 8];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
        }
        ru.prototype.size = 40;
        class nu extends Ol {
          get(t4) {
            return new ru(this, t4);
          }
        }
        fo(nu, "CollisionBoxArray");
        class iu extends _l {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 5];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 6];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 7];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 10];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 11];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 48];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 49];
          }
          set placedOrientation(t4) {
            this._structArray.uint8[this._pos1 + 49] = t4;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 50];
          }
          set hidden(t4) {
            this._structArray.uint8[this._pos1 + 50] = t4;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 13];
          }
          set crossTileID(t4) {
            this._structArray.uint32[this._pos4 + 13] = t4;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 28];
          }
          get flipState() {
            return this._structArray.uint8[this._pos1 + 58];
          }
          set flipState(t4) {
            this._structArray.uint8[this._pos1 + 58] = t4;
          }
        }
        iu.prototype.size = 60;
        class su extends $l {
          get(t4) {
            return new iu(this, t4);
          }
        }
        fo(su, "PlacedSymbolArray");
        class au extends _l {
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 0];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 8];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 9];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 10];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 11];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 12];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 23];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 24];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 25];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 26];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 27];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 14];
          }
          set crossTileID(t4) {
            this._structArray.uint32[this._pos4 + 14] = t4;
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 15];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 16];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 17];
          }
          get zOffset() {
            return this._structArray.float32[this._pos4 + 18];
          }
          set zOffset(t4) {
            this._structArray.float32[this._pos4 + 18] = t4;
          }
          get hasIconTextFit() {
            return this._structArray.uint8[this._pos1 + 76];
          }
        }
        au.prototype.size = 80;
        class ou extends Gl {
          get(t4) {
            return new au(this, t4);
          }
        }
        fo(ou, "SymbolInstanceArray");
        class lu extends Ql {
          getoffsetX(t4) {
            return this.float32[1 * t4 + 0];
          }
        }
        fo(lu, "GlyphOffsetArray");
        class uu extends Sl {
          getx(t4) {
            return this.int16[2 * t4 + 0];
          }
          gety(t4) {
            return this.int16[2 * t4 + 1];
          }
        }
        fo(uu, "SymbolLineVertexArray");
        class cu extends _l {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get layoutVertexArrayOffset() {
            return this._structArray.uint16[this._pos2 + 4];
          }
        }
        cu.prototype.size = 12;
        class hu extends Zl {
          get(t4) {
            return new cu(this, t4);
          }
        }
        fo(hu, "FeatureIndexArray");
        class pu extends Fl {
          geta_centroid_pos0(t4) {
            return this.uint16[2 * t4 + 0];
          }
          geta_centroid_pos1(t4) {
            return this.uint16[2 * t4 + 1];
          }
        }
        fo(pu, "FillExtrusionCentroidArray");
        const fu = Ml([{ name: "a_pos", components: 2, type: "Int16" }], 4), du = Ml([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
        class mu {
          constructor(t4 = []) {
            this.segments = t4;
          }
          _prepareSegment(t4, e4, r4, n3) {
            let i4 = this.segments[this.segments.length - 1];
            return t4 > mu.MAX_VERTEX_ARRAY_LENGTH && hr(`Max vertices per segment is ${mu.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t4}`), (!i4 || i4.vertexLength + t4 > mu.MAX_VERTEX_ARRAY_LENGTH || i4.sortKey !== n3) && (i4 = { vertexOffset: e4, primitiveOffset: r4, vertexLength: 0, primitiveLength: 0 }, void 0 !== n3 && (i4.sortKey = n3), this.segments.push(i4)), i4;
          }
          prepareSegment(t4, e4, r4, n3) {
            return this._prepareSegment(t4, e4.length, r4.length, n3);
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t4 of this.segments) for (const e4 in t4.vaos) t4.vaos[e4].destroy();
          }
          static simpleSegment(t4, e4, r4, n3) {
            return new mu([{ vertexOffset: t4, primitiveOffset: e4, vertexLength: r4, primitiveLength: n3, vaos: {}, sortKey: 0 }]);
          }
        }
        function yu(t4, e4) {
          return 256 * (t4 = Ze(Math.floor(t4), 0, 255)) + Ze(Math.floor(e4), 0, 255);
        }
        mu.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, fo(mu, "SegmentVector");
        const gu = Ml([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), xu = Ml([{ name: "a_dash", components: 4, type: "Uint16" }]);
        class bu {
          constructor() {
            this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = false;
          }
          add(t4, e4, r4, n3) {
            this.ids.push(vu(t4)), this.positions.push(e4, r4, n3);
          }
          eachPosition(t4, e4) {
            const r4 = vu(t4);
            let n3 = 0, i4 = this.ids.length - 1;
            for (; n3 < i4; ) {
              const t5 = n3 + i4 >> 1;
              this.ids[t5] >= r4 ? i4 = t5 : n3 = t5 + 1;
            }
            for (; this.ids[n3] === r4; ) e4(this.positions[3 * n3], this.positions[3 * n3 + 1], this.positions[3 * n3 + 2]), n3++;
          }
          static serialize(t4, e4) {
            const r4 = new Float64Array(t4.ids), n3 = new Uint32Array(t4.positions);
            return _u(r4, n3, 0, r4.length - 1), e4 && (e4.add(r4.buffer), e4.add(n3.buffer)), { ids: r4, positions: n3 };
          }
          static deserialize(t4) {
            const e4 = new bu();
            let r4;
            e4.ids = t4.ids, e4.positions = t4.positions;
            for (const t5 of e4.ids) t5 !== r4 && e4.uniqueIds.push(t5), r4 = t5;
            return e4.indexed = true, e4;
          }
        }
        function vu(t4) {
          const e4 = +t4;
          return !isNaN(e4) && Number.MIN_SAFE_INTEGER <= e4 && e4 <= Number.MAX_SAFE_INTEGER ? e4 : Tn(String(t4));
        }
        function _u(t4, e4, r4, n3) {
          for (; r4 < n3; ) {
            const i4 = t4[r4 + n3 >> 1];
            let s4 = r4 - 1, a4 = n3 + 1;
            for (; ; ) {
              do {
                s4++;
              } while (t4[s4] < i4);
              do {
                a4--;
              } while (t4[a4] > i4);
              if (s4 >= a4) break;
              wu(t4, s4, a4), wu(e4, 3 * s4, 3 * a4), wu(e4, 3 * s4 + 1, 3 * a4 + 1), wu(e4, 3 * s4 + 2, 3 * a4 + 2);
            }
            a4 - r4 < n3 - a4 ? (_u(t4, e4, r4, a4), r4 = a4 + 1) : (_u(t4, e4, a4 + 1, n3), n3 = a4);
          }
        }
        function wu(t4, e4, r4) {
          const n3 = t4[e4];
          t4[e4] = t4[r4], t4[r4] = n3;
        }
        fo(bu, "FeaturePositionMap");
        class Mu {
          constructor(t4) {
            this.gl = t4.gl, this.initialized = false;
          }
          fetchUniformLocation(t4, e4) {
            return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t4, e4), this.initialized = true), !!this.location;
          }
          set(t4, e4, r4) {
            throw new Error("Uniform#set() must be implemented by each concrete Uniform");
          }
        }
        class Au extends Mu {
          constructor(t4) {
            super(t4), this.current = 0;
          }
          set(t4, e4, r4) {
            this.fetchUniformLocation(t4, e4) && this.current !== r4 && (this.current = r4, this.gl.uniform1i(this.location, r4));
          }
        }
        class Su extends Mu {
          constructor(t4) {
            super(t4), this.current = 0;
          }
          set(t4, e4, r4) {
            this.fetchUniformLocation(t4, e4) && this.current !== r4 && (this.current = r4, this.gl.uniform1f(this.location, r4));
          }
        }
        class Iu extends Mu {
          constructor(t4) {
            super(t4), this.current = [0, 0];
          }
          set(t4, e4, r4) {
            this.fetchUniformLocation(t4, e4) && (r4[0] === this.current[0] && r4[1] === this.current[1] || (this.current = r4, this.gl.uniform2f(this.location, r4[0], r4[1])));
          }
        }
        class ku extends Mu {
          constructor(t4) {
            super(t4), this.current = [0, 0, 0];
          }
          set(t4, e4, r4) {
            this.fetchUniformLocation(t4, e4) && (r4[0] === this.current[0] && r4[1] === this.current[1] && r4[2] === this.current[2] || (this.current = r4, this.gl.uniform3f(this.location, r4[0], r4[1], r4[2])));
          }
        }
        class Pu extends Mu {
          constructor(t4) {
            super(t4), this.current = [0, 0, 0, 0];
          }
          set(t4, e4, r4) {
            this.fetchUniformLocation(t4, e4) && (r4[0] === this.current[0] && r4[1] === this.current[1] && r4[2] === this.current[2] && r4[3] === this.current[3] || (this.current = r4, this.gl.uniform4f(this.location, r4[0], r4[1], r4[2], r4[3])));
          }
        }
        class Eu extends Mu {
          constructor(t4) {
            super(t4), this.current = jn.transparent;
          }
          set(t4, e4, r4) {
            this.fetchUniformLocation(t4, e4) && (r4.r === this.current.r && r4.g === this.current.g && r4.b === this.current.b && r4.a === this.current.a || (this.current = r4, this.gl.uniform4f(this.location, r4.r, r4.g, r4.b, r4.a)));
          }
        }
        const zu = new Float32Array(16);
        class Tu extends Mu {
          constructor(t4) {
            super(t4), this.current = zu;
          }
          set(t4, e4, r4) {
            if (this.fetchUniformLocation(t4, e4)) {
              if (r4[12] !== this.current[12] || r4[0] !== this.current[0]) return this.current = r4, void this.gl.uniformMatrix4fv(this.location, false, r4);
              for (let t5 = 1; t5 < 16; t5++) if (r4[t5] !== this.current[t5]) {
                this.current = r4, this.gl.uniformMatrix4fv(this.location, false, r4);
                break;
              }
            }
          }
        }
        const Bu = new Float32Array(9), Cu = new Float32Array(4);
        class Ru extends Mu {
          constructor(t4) {
            super(t4), this.current = Cu;
          }
          set(t4, e4, r4) {
            if (this.fetchUniformLocation(t4, e4)) {
              for (let t5 = 0; t5 < 4; t5++) if (r4[t5] !== this.current[t5]) {
                this.current = r4, this.gl.uniformMatrix2fv(this.location, false, r4);
                break;
              }
            }
          }
        }
        function Vu(t4) {
          return [yu(255 * t4.r, 255 * t4.g), yu(255 * t4.b, 255 * t4.a)];
        }
        class Du {
          constructor(t4, e4, r4) {
            this.value = t4, this.uniformNames = e4.map((t5) => `u_${t5}`), this.type = r4;
          }
          setUniform(t4, e4, r4, n3, i4) {
            e4.set(t4, i4, n3.constantOr(this.value));
          }
          getBinding(t4, e4) {
            return "color" === this.type ? new Eu(t4) : new Su(t4);
          }
        }
        class Lu {
          constructor(t4, e4) {
            this.uniformNames = e4.map((t5) => `u_${t5}`), this.pattern = null, this.pixelRatio = 1;
          }
          setConstantPatternPositions(t4) {
            this.pixelRatio = t4.pixelRatio || 1, this.pattern = t4.tl.concat(t4.br);
          }
          setUniform(t4, e4, r4, n3, i4) {
            const s4 = "u_pattern" === i4 || "u_dash" === i4 ? this.pattern : "u_pixel_ratio" === i4 ? this.pixelRatio : null;
            s4 && e4.set(t4, i4, s4);
          }
          getBinding(t4, e4) {
            return "u_pattern" === e4 || "u_dash" === e4 ? new Pu(t4) : new Su(t4);
          }
        }
        class Fu {
          constructor(t4, e4, r4, n3) {
            this.expression = t4, this.type = r4, this.maxValue = 0, this.paintVertexAttributes = e4.map((t5) => ({ name: `a_${t5}`, type: "Float32", components: "color" === r4 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n3();
          }
          populatePaintArray(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = this.paintVertexArray.length, l4 = this.expression.evaluate(new Uo(0, { brightness: s4 }), e4, {}, i4, n3, a4);
            this.paintVertexArray.resize(t4), this._setPaintValue(o3, t4, l4);
          }
          updatePaintArray(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = this.expression.evaluate({ zoom: 0, brightness: a4 }, r4, n3, void 0, i4);
            this._setPaintValue(t4, e4, o3);
          }
          _setPaintValue(t4, e4, r4) {
            if ("color" === this.type) {
              const n3 = Vu(r4);
              for (let r5 = t4; r5 < e4; r5++) this.paintVertexArray.emplace(r5, n3[0], n3[1]);
            } else {
              for (let n3 = t4; n3 < e4; n3++) this.paintVertexArray.emplace(n3, r4);
              this.maxValue = Math.max(this.maxValue, Math.abs(r4));
            }
          }
          upload(t4) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Ou {
          constructor(t4, e4, r4, n3, i4, s4) {
            this.expression = t4, this.uniformNames = e4.map((t5) => `u_${t5}_t`), this.type = r4, this.useIntegerZoom = n3, this.zoom = i4, this.maxValue = 0, this.paintVertexAttributes = e4.map((t5) => ({ name: `a_${t5}`, type: "Float32", components: "color" === r4 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s4();
          }
          populatePaintArray(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = this.expression.evaluate(new Uo(this.zoom, { brightness: s4 }), e4, {}, i4, n3, a4), l4 = this.expression.evaluate(new Uo(this.zoom + 1, { brightness: s4 }), e4, {}, i4, n3, a4), u5 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t4), this._setPaintValue(u5, t4, o3, l4);
          }
          updatePaintArray(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = this.expression.evaluate({ zoom: this.zoom, brightness: a4 }, r4, n3, void 0, i4), l4 = this.expression.evaluate({ zoom: this.zoom + 1, brightness: a4 }, r4, n3, void 0, i4);
            this._setPaintValue(t4, e4, o3, l4);
          }
          _setPaintValue(t4, e4, r4, n3) {
            if ("color" === this.type) {
              const i4 = Vu(r4), s4 = Vu(n3);
              for (let r5 = t4; r5 < e4; r5++) this.paintVertexArray.emplace(r5, i4[0], i4[1], s4[0], s4[1]);
            } else {
              for (let i4 = t4; i4 < e4; i4++) this.paintVertexArray.emplace(i4, r4, n3);
              this.maxValue = Math.max(this.maxValue, Math.abs(r4), Math.abs(n3));
            }
          }
          upload(t4) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t4, e4, r4, n3, i4) {
            const s4 = this.useIntegerZoom ? Math.floor(r4.zoom) : r4.zoom, a4 = Ze(this.expression.interpolationFactor(s4, this.zoom, this.zoom + 1), 0, 1);
            e4.set(t4, i4, a4);
          }
          getBinding(t4, e4) {
            return new Su(t4);
          }
        }
        class Uu {
          constructor(t4, e4, r4, n3, i4) {
            this.expression = t4, this.layerId = i4, this.paintVertexAttributes = ("array" === r4 ? xu : gu).members;
            for (let t5 = 0; t5 < e4.length; ++t5) ;
            this.paintVertexArray = new n3();
          }
          populatePaintArray(t4, e4, r4) {
            const n3 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t4), this._setPaintValues(n3, t4, e4.patterns && e4.patterns[this.layerId], r4);
          }
          updatePaintArray(t4, e4, r4, n3, i4, s4, a4) {
            this._setPaintValues(t4, e4, r4.patterns && r4.patterns[this.layerId], s4);
          }
          _setPaintValues(t4, e4, r4, n3) {
            if (!n3 || !r4) return;
            const i4 = n3[r4];
            if (!i4) return;
            const { tl: s4, br: a4, pixelRatio: o3 } = i4;
            for (let r5 = t4; r5 < e4; r5++) this.paintVertexArray.emplace(r5, s4[0], s4[1], a4[0], a4[1], o3);
          }
          upload(t4) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Nu {
          constructor(t4, e4, r4 = () => true) {
            this.binders = {}, this._buffers = [];
            const n3 = [];
            for (const i4 in t4.paint._values) {
              const s4 = t4.paint.get(i4);
              if (!r4(i4)) continue;
              if (!(s4 instanceof Yo && ja(s4.property.specification))) continue;
              const a4 = $u(i4, t4.type), o3 = s4.value, l4 = s4.property.specification.type, u5 = !!s4.property.useIntegerZoom, c4 = "line-dasharray" === i4 || i4.endsWith("pattern"), h4 = "line-dasharray" === i4 && "constant" !== t4.layout.get("line-cap").value.kind;
              if ("constant" !== o3.kind || h4) if ("source" === o3.kind || h4 || c4) {
                const e5 = Yu(i4, l4, "source");
                this.binders[i4] = c4 ? new Uu(o3, a4, l4, e5, t4.id) : new Fu(o3, a4, l4, e5), n3.push(`/a_${i4}`);
              } else {
                const t5 = Yu(i4, l4, "composite");
                this.binders[i4] = new Ou(o3, a4, l4, u5, e4, t5), n3.push(`/z_${i4}`);
              }
              else this.binders[i4] = c4 ? new Lu(o3.value, a4) : new Du(o3.value, a4, l4), n3.push(`/u_${i4}`);
            }
            this.cacheKey = n3.sort().join("");
          }
          getMaxValue(t4) {
            const e4 = this.binders[t4];
            return e4 instanceof Fu || e4 instanceof Ou ? e4.maxValue : 0;
          }
          populatePaintArrays(t4, e4, r4, n3, i4, s4, a4) {
            for (const o3 in this.binders) {
              const l4 = this.binders[o3];
              (l4 instanceof Fu || l4 instanceof Ou || l4 instanceof Uu) && l4.populatePaintArray(t4, e4, r4, n3, i4, s4, a4);
            }
          }
          setConstantPatternPositions(t4) {
            for (const e4 in this.binders) {
              const r4 = this.binders[e4];
              r4 instanceof Lu && r4.setConstantPatternPositions(t4);
            }
          }
          updatePaintArrays(t4, e4, r4, n3, i4, s4, a4, o3) {
            let l4 = false;
            const u5 = Object.keys(t4), c4 = 0 !== u5.length, h4 = c4 ? u5 : e4.uniqueIds;
            for (const u6 in this.binders) {
              const p4 = this.binders[u6];
              if ((p4 instanceof Fu || p4 instanceof Ou || p4 instanceof Uu) && (true === p4.expression.isStateDependent || false === p4.expression.isLightConstant)) {
                const f4 = i4.paint.get(u6);
                p4.expression = f4.value;
                for (const r5 of h4) {
                  const i5 = t4[r5.toString()];
                  e4.eachPosition(r5, (t5, e5, r6) => {
                    const l5 = n3.feature(t5);
                    p4.updatePaintArray(e5, r6, l5, i5, s4, a4, o3);
                  });
                }
                if (!c4) for (const e5 of r4.uniqueIds) {
                  const i5 = t4[e5.toString()];
                  r4.eachPosition(e5, (t5, e6, r5) => {
                    const l5 = n3.feature(t5);
                    p4.updatePaintArray(e6, r5, l5, i5, s4, a4, o3);
                  });
                }
                l4 = true;
              }
            }
            return l4;
          }
          defines() {
            const t4 = [];
            for (const e4 in this.binders) {
              const r4 = this.binders[e4];
              (r4 instanceof Du || r4 instanceof Lu) && t4.push(...r4.uniformNames.map((t5) => `#define HAS_UNIFORM_${t5}`));
            }
            return t4;
          }
          getBinderAttributes() {
            const t4 = [];
            for (const e4 in this.binders) {
              const r4 = this.binders[e4];
              if (r4 instanceof Fu || r4 instanceof Ou || r4 instanceof Uu) for (let e5 = 0; e5 < r4.paintVertexAttributes.length; e5++) t4.push(r4.paintVertexAttributes[e5].name);
            }
            return t4;
          }
          getBinderUniforms() {
            const t4 = [];
            for (const e4 in this.binders) {
              const r4 = this.binders[e4];
              if (r4 instanceof Du || r4 instanceof Lu || r4 instanceof Ou) for (const e5 of r4.uniformNames) t4.push(e5);
            }
            return t4;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t4) {
            const e4 = [];
            for (const r4 in this.binders) {
              const n3 = this.binders[r4];
              if (n3 instanceof Du || n3 instanceof Lu || n3 instanceof Ou) for (const i4 of n3.uniformNames) e4.push({ name: i4, property: r4, binding: n3.getBinding(t4, i4) });
            }
            return e4;
          }
          setUniforms(t4, e4, r4, n3, i4) {
            for (const { name: e5, property: s4, binding: a4 } of r4) this.binders[s4].setUniform(t4, a4, i4, n3.get(s4), e5);
          }
          updatePaintBuffers() {
            this._buffers = [];
            for (const t4 in this.binders) {
              const e4 = this.binders[t4];
              (e4 instanceof Fu || e4 instanceof Ou || e4 instanceof Uu) && e4.paintVertexBuffer && this._buffers.push(e4.paintVertexBuffer);
            }
          }
          upload(t4) {
            for (const e4 in this.binders) {
              const r4 = this.binders[e4];
              (r4 instanceof Fu || r4 instanceof Ou || r4 instanceof Uu) && r4.upload(t4);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t4 in this.binders) {
              const e4 = this.binders[t4];
              (e4 instanceof Fu || e4 instanceof Ou || e4 instanceof Uu) && e4.destroy();
            }
          }
        }
        class ju {
          constructor(t4, e4, r4 = () => true) {
            this.programConfigurations = {};
            for (const n3 of t4) this.programConfigurations[n3.id] = new Nu(n3, e4, r4);
            this.needsUpload = false, this._featureMap = new bu(), this._featureMapWithoutIds = new bu(), this._bufferOffset = 0, this._idlessCounter = 0;
          }
          populatePaintArrays(t4, e4, r4, n3, i4, s4, a4, o3) {
            for (const r5 in this.programConfigurations) this.programConfigurations[r5].populatePaintArrays(t4, e4, n3, i4, s4, a4, o3);
            void 0 !== e4.id ? this._featureMap.add(e4.id, r4, this._bufferOffset, t4) : (this._featureMapWithoutIds.add(this._idlessCounter, r4, this._bufferOffset, t4), this._idlessCounter += 1), this._bufferOffset = t4, this.needsUpload = true;
          }
          updatePaintArrays(t4, e4, r4, n3, i4, s4) {
            for (const a4 of r4) this.needsUpload = this.programConfigurations[a4.id].updatePaintArrays(t4, this._featureMap, this._featureMapWithoutIds, e4, a4, n3, i4, s4 || 0) || this.needsUpload;
          }
          get(t4) {
            return this.programConfigurations[t4];
          }
          upload(t4) {
            if (this.needsUpload) {
              for (const e4 in this.programConfigurations) this.programConfigurations[e4].upload(t4);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t4 in this.programConfigurations) this.programConfigurations[t4].destroy();
          }
        }
        const qu = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
        function $u(t4, e4) {
          return qu[t4] || [t4.replace(`${e4}-`, "").replace(/-/g, "_")];
        }
        const Gu = { "line-pattern": { source: Bl, composite: Bl }, "fill-pattern": { source: Bl, composite: Bl }, "fill-extrusion-pattern": { source: Bl, composite: Bl }, "line-dasharray": { source: Cl, composite: Cl } }, Qu = { color: { source: Tl, composite: zl }, number: { source: Ql, composite: Tl } };
        function Yu(t4, e4, r4) {
          const n3 = Gu[t4];
          return n3 && n3[r4] || Qu[e4][r4];
        }
        fo(Du, "ConstantBinder"), fo(Lu, "PatternConstantBinder"), fo(Fu, "SourceExpressionBinder"), fo(Uu, "PatternCompositeBinder"), fo(Ou, "CompositeExpressionBinder"), fo(Nu, "ProgramConfiguration", { omit: ["_buffers"] }), fo(ju, "ProgramConfigurationSet");
        const Xu = is / Math.PI / 2, Zu = 5, Ku = 6, Wu = 16383, Hu = 64, Ju = [Hu, 32, 16], tc = -Xu, ec = Xu;
        function rc(t4, e4, r4, n3 = Xu) {
          return r4 = qe(r4), [t4 * Math.sin(r4) * n3, -e4 * n3, t4 * Math.cos(r4) * n3];
        }
        function nc(t4, e4, r4) {
          return rc(Math.cos(qe(t4)), Math.sin(qe(t4)), e4, r4);
        }
        const ic = 63710088e-1, sc = 2 * Math.PI * ic;
        class ac {
          constructor(t4, e4) {
            if (isNaN(t4) || isNaN(e4)) throw new Error(`Invalid LngLat object: (${t4}, ${e4})`);
            if (this.lng = +t4, this.lat = +e4, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new ac(We(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t4) {
            const e4 = Math.PI / 180, r4 = this.lat * e4, n3 = t4.lat * e4, i4 = Math.sin(r4) * Math.sin(n3) + Math.cos(r4) * Math.cos(n3) * Math.cos((t4.lng - this.lng) * e4);
            return ic * Math.acos(Math.min(i4, 1));
          }
          toBounds(t4 = 0) {
            const e4 = 360 * t4 / 40075017, r4 = e4 / Math.cos(Math.PI / 180 * this.lat);
            return new oc({ lng: this.lng - r4, lat: this.lat - e4 }, { lng: this.lng + r4, lat: this.lat + e4 });
          }
          toEcef(t4) {
            return nc(this.lat, this.lng, Xu + t4 * Xu / ic);
          }
          static convert(t4) {
            if (t4 instanceof ac) return t4;
            if (Array.isArray(t4) && (2 === t4.length || 3 === t4.length)) return new ac(Number(t4[0]), Number(t4[1]));
            if (!Array.isArray(t4) && "object" == typeof t4 && null !== t4) return new ac(Number("lng" in t4 ? t4.lng : t4.lon), Number(t4.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        class oc {
          constructor(t4, e4) {
            if (t4) if (e4) this.setSouthWest(t4).setNorthEast(e4);
            else if (4 === t4.length) {
              const e5 = t4;
              this.setSouthWest([e5[0], e5[1]]).setNorthEast([e5[2], e5[3]]);
            } else {
              const e5 = t4;
              this.setSouthWest(e5[0]).setNorthEast(e5[1]);
            }
          }
          setNorthEast(t4) {
            return this._ne = t4 instanceof ac ? new ac(t4.lng, t4.lat) : ac.convert(t4), this;
          }
          setSouthWest(t4) {
            return this._sw = t4 instanceof ac ? new ac(t4.lng, t4.lat) : ac.convert(t4), this;
          }
          extend(t4) {
            const e4 = this._sw, r4 = this._ne;
            let n3, i4;
            if (t4 instanceof ac) n3 = t4, i4 = t4;
            else {
              if (!(t4 instanceof oc)) return Array.isArray(t4) ? 4 === t4.length || t4.every(Array.isArray) ? this.extend(oc.convert(t4)) : this.extend(ac.convert(t4)) : "object" == typeof t4 && null !== t4 && t4.hasOwnProperty("lat") && (t4.hasOwnProperty("lon") || t4.hasOwnProperty("lng")) ? this.extend(ac.convert(t4)) : this;
              if (n3 = t4._sw, i4 = t4._ne, !n3 || !i4) return this;
            }
            return e4 || r4 ? (e4.lng = Math.min(n3.lng, e4.lng), e4.lat = Math.min(n3.lat, e4.lat), r4.lng = Math.max(i4.lng, r4.lng), r4.lat = Math.max(i4.lat, r4.lat)) : (this._sw = new ac(n3.lng, n3.lat), this._ne = new ac(i4.lng, i4.lat)), this;
          }
          getCenter() {
            return new ac((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new ac(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new ac(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t4) {
            const { lng: e4, lat: r4 } = ac.convert(t4);
            let n3 = this._sw.lng <= e4 && e4 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (n3 = this._sw.lng >= e4 && e4 >= this._ne.lng), this._sw.lat <= r4 && r4 <= this._ne.lat && n3;
          }
          static convert(t4) {
            return !t4 || t4 instanceof oc ? t4 : new oc(t4);
          }
        }
        var lc = {};
        !function(t4, e4) {
          !function(t5) {
            function e5(t6, e6, n3) {
              var i4 = r4(256 * t6, 256 * (e6 = Math.pow(2, n3) - e6 - 1), n3), s4 = r4(256 * (t6 + 1), 256 * (e6 + 1), n3);
              return i4[0] + "," + i4[1] + "," + s4[0] + "," + s4[1];
            }
            function r4(t6, e6, r5) {
              var n3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r5);
              return [t6 * n3 - 2 * Math.PI * 6378137 / 2, e6 * n3 - 2 * Math.PI * 6378137 / 2];
            }
            t5.getURL = function(t6, r5, n3, i4, s4, a4) {
              return a4 = a4 || {}, t6 + "?" + ["bbox=" + e5(n3, i4, s4), "format=" + (a4.format || "image/png"), "service=" + (a4.service || "WMS"), "version=" + (a4.version || "1.1.1"), "request=" + (a4.request || "GetMap"), "srs=" + (a4.srs || "EPSG:3857"), "width=" + (a4.width || 256), "height=" + (a4.height || 256), "layers=" + r5].join("&");
            }, t5.getTileBBox = e5, t5.getMercCoords = r4, Object.defineProperty(t5, "__esModule", { value: true });
          }(e4);
        }(0, lc);
        var uc = lc;
        class cc {
          constructor(t4, e4, r4) {
            this.z = t4, this.x = e4, this.y = r4, this.key = fc(0, t4, t4, e4, r4);
          }
          equals(t4) {
            return this.z === t4.z && this.x === t4.x && this.y === t4.y;
          }
          url(t4, e4) {
            const r4 = uc.getTileBBox(this.x, this.y, this.z), n3 = function(t5, e5, r5) {
              let n4, i4 = "";
              for (let s4 = t5; s4 > 0; s4--) n4 = 1 << s4 - 1, i4 += (e5 & n4 ? 1 : 0) + (r5 & n4 ? 2 : 0);
              return i4;
            }(this.z, this.x, this.y);
            return t4[(this.x + this.y) % t4.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e4 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n3).replace("{bbox-epsg-3857}", r4);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class hc {
          constructor(t4, e4) {
            this.wrap = t4, this.canonical = e4, this.key = fc(t4, e4.z, e4.z, e4.x, e4.y);
          }
        }
        class pc {
          constructor(t4, e4, r4, n3, i4) {
            this.overscaledZ = t4, this.wrap = e4, this.canonical = new cc(r4, +n3, +i4), this.key = 0 === e4 && t4 === r4 ? this.canonical.key : fc(e4, t4, r4, n3, i4);
          }
          equals(t4) {
            return this.overscaledZ === t4.overscaledZ && this.wrap === t4.wrap && this.canonical.equals(t4.canonical);
          }
          scaledTo(t4) {
            const e4 = this.canonical.z - t4;
            return t4 > this.canonical.z ? new pc(t4, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new pc(t4, this.wrap, t4, this.canonical.x >> e4, this.canonical.y >> e4);
          }
          calculateScaledKey(t4, e4 = true) {
            if (this.overscaledZ === t4 && e4) return this.key;
            if (t4 > this.canonical.z) return fc(this.wrap * +e4, t4, this.canonical.z, this.canonical.x, this.canonical.y);
            {
              const r4 = this.canonical.z - t4;
              return fc(this.wrap * +e4, t4, t4, this.canonical.x >> r4, this.canonical.y >> r4);
            }
          }
          isChildOf(t4) {
            if (t4.wrap !== this.wrap) return false;
            const e4 = this.canonical.z - t4.canonical.z;
            return 0 === t4.overscaledZ || t4.overscaledZ < this.overscaledZ && t4.canonical.z < this.canonical.z && t4.canonical.x === this.canonical.x >> e4 && t4.canonical.y === this.canonical.y >> e4;
          }
          children(t4) {
            if (this.overscaledZ >= t4) return [new pc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e4 = this.canonical.z + 1, r4 = 2 * this.canonical.x, n3 = 2 * this.canonical.y;
            return [new pc(e4, this.wrap, e4, r4, n3), new pc(e4, this.wrap, e4, r4 + 1, n3), new pc(e4, this.wrap, e4, r4, n3 + 1), new pc(e4, this.wrap, e4, r4 + 1, n3 + 1)];
          }
          isLessThan(t4) {
            return this.wrap < t4.wrap || !(this.wrap > t4.wrap) && (this.overscaledZ < t4.overscaledZ || !(this.overscaledZ > t4.overscaledZ) && (this.canonical.x < t4.canonical.x || !(this.canonical.x > t4.canonical.x) && this.canonical.y < t4.canonical.y));
          }
          wrapped() {
            return new pc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t4) {
            return new pc(this.overscaledZ, t4, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new hc(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
        }
        function fc(t4, e4, r4, n3, i4) {
          const s4 = 1 << Math.min(r4, 22);
          let a4 = s4 * (i4 % s4) + n3 % s4;
          return t4 && r4 < 22 && (a4 += s4 * s4 * ((t4 < 0 ? -2 * t4 - 1 : 2 * t4) % (1 << 2 * (22 - r4)))), 16 * (32 * a4 + r4) + (e4 - r4);
        }
        const dc = [(t4) => {
          let e4 = t4.canonical.x - 1, r4 = t4.wrap;
          return e4 < 0 && (e4 = (1 << t4.canonical.z) - 1, r4--), new pc(t4.overscaledZ, r4, t4.canonical.z, e4, t4.canonical.y);
        }, (t4) => {
          let e4 = t4.canonical.x + 1, r4 = t4.wrap;
          return e4 === 1 << t4.canonical.z && (e4 = 0, r4++), new pc(t4.overscaledZ, r4, t4.canonical.z, e4, t4.canonical.y);
        }, (t4) => new pc(t4.overscaledZ, t4.wrap, t4.canonical.z, t4.canonical.x, (0 === t4.canonical.y ? 1 << t4.canonical.z : t4.canonical.y) - 1), (t4) => new pc(t4.overscaledZ, t4.wrap, t4.canonical.z, t4.canonical.x, t4.canonical.y === (1 << t4.canonical.z) - 1 ? 0 : t4.canonical.y + 1)];
        fo(cc, "CanonicalTileID"), fo(pc, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
        const mc = 0, yc = 25.5;
        function gc(t4) {
          return sc * Math.cos(t4 * Math.PI / 180);
        }
        function xc(t4) {
          return (180 + t4) / 360;
        }
        function bc(t4) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t4 * Math.PI / 360))) / 360;
        }
        function vc(t4, e4) {
          return t4 / gc(e4);
        }
        function _c(t4) {
          return 360 * t4 - 180;
        }
        function wc(t4) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t4) * Math.PI / 180)) - 90;
        }
        function Mc(t4, e4) {
          return t4 * gc(wc(e4));
        }
        const Ac = 85.051129;
        function Sc(t4) {
          return Math.cos(qe(Ze(t4, -Ac, Ac)));
        }
        function Ic(t4, e4) {
          const r4 = Ze(e4, mc, yc), n3 = Math.pow(2, r4);
          return Sc(t4) * sc / (512 * n3);
        }
        function kc(t4) {
          return 1 / Math.cos(t4 * Math.PI / 180);
        }
        function Pc(t4, e4 = 0) {
          const r4 = Math.exp(Math.PI * (1 - (t4.y + e4 / is) / (1 << t4.z) * 2));
          return 80150034 * r4 / (r4 * r4 + 1) / is / (1 << t4.z);
        }
        class Ec {
          constructor(t4, e4, r4 = 0) {
            this.x = +t4, this.y = +e4, this.z = +r4;
          }
          static fromLngLat(t4, e4 = 0) {
            const r4 = ac.convert(t4);
            return new Ec(xc(r4.lng), bc(r4.lat), vc(e4, r4.lat));
          }
          toLngLat() {
            return new ac(_c(this.x), wc(this.y));
          }
          toAltitude() {
            return Mc(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / sc * kc(wc(this.y));
          }
        }
        function zc(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
          const u5 = (e4 + n3) / 2, c4 = (r4 + i4) / 2, h4 = new Ue(u5, c4);
          o3(h4), function(t5, e5, r5, n4, i5, s5) {
            const a5 = r5 - i5, o4 = n4 - s5;
            return Math.abs((n4 - e5) * a5 - (r5 - t5) * o4) / Math.hypot(a5, o4);
          }(h4.x, h4.y, s4.x, s4.y, a4.x, a4.y) >= l4 ? (zc(t4, e4, r4, u5, c4, s4, h4, o3, l4), zc(t4, u5, c4, n3, i4, h4, a4, o3, l4)) : t4.push(a4);
        }
        function Tc(t4, e4, r4) {
          let n3 = t4[0], i4 = n3.x, s4 = n3.y;
          e4(n3);
          const a4 = [n3];
          for (let o3 = 1; o3 < t4.length; o3++) {
            const l4 = t4[o3], { x: u5, y: c4 } = l4;
            e4(l4), zc(a4, i4, s4, u5, c4, n3, l4, e4, r4), i4 = u5, s4 = c4, n3 = l4;
          }
          return a4;
        }
        function Bc(t4, e4, r4, n3) {
          if (n3(e4, r4)) {
            const i4 = e4.add(r4)._mult(0.5);
            Bc(t4, e4, i4, n3), Bc(t4, i4, r4, n3);
          } else t4.push(r4);
        }
        function Cc(t4, e4) {
          let r4 = t4[0];
          const n3 = [r4];
          for (let i4 = 1; i4 < t4.length; i4++) {
            const s4 = t4[i4];
            Bc(n3, r4, s4, e4), r4 = s4;
          }
          return n3;
        }
        const Rc = Math.pow(2, 14) - 1, Vc = -Rc - 1;
        function Dc(t4, e4) {
          const r4 = Math.round(t4.x * e4), n3 = Math.round(t4.y * e4);
          return t4.x = Ze(r4, Vc, Rc), t4.y = Ze(n3, Vc, Rc), (r4 < t4.x || r4 > t4.x + 1 || n3 < t4.y || n3 > t4.y + 1) && hr("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t4;
        }
        function Lc(t4, e4, r4) {
          const n3 = t4.loadGeometry(), i4 = t4.extent, s4 = is / i4;
          if (e4 && r4 && r4.projection.isReprojectedInTileSpace) {
            const s5 = 1 << e4.z, { scale: a4, x: o3, y: l4, projection: u5 } = r4, c4 = (t5) => {
              const r5 = _c((e4.x + t5.x / i4) / s5), n4 = wc((e4.y + t5.y / i4) / s5), c5 = u5.project(r5, n4);
              t5.x = (c5.x * a4 - o3) * i4, t5.y = (c5.y * a4 - l4) * i4;
            };
            for (let e5 = 0; e5 < n3.length; e5++) if (1 !== t4.type) n3[e5] = Tc(n3[e5], c4, 1);
            else {
              const t5 = [];
              for (const r5 of n3[e5]) r5.x < 0 || r5.x >= i4 || r5.y < 0 || r5.y >= i4 || (c4(r5), t5.push(r5));
              n3[e5] = t5;
            }
          }
          for (const t5 of n3) for (const e5 of t5) Dc(e5, s4);
          return n3;
        }
        function Fc(t4, e4) {
          return { type: t4.type, id: t4.id, properties: t4.properties, geometry: e4 ? Lc(t4) : [] };
        }
        function Oc(t4, e4, r4, n3, i4) {
          t4.emplaceBack(2 * e4 + (n3 + 1) / 2, 2 * r4 + (i4 + 1) / 2);
        }
        function Uc(t4, e4, r4) {
          const n3 = 16384;
          t4.emplaceBack(e4.x, e4.y, e4.z, r4[0] * n3, r4[1] * n3, r4[2] * n3);
        }
        class Nc {
          constructor(t4) {
            this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.fqid), this.index = t4.index, this.hasPattern = false, this.projection = t4.projection, this.layoutVertexArray = new Sl(), this.indexArray = new ql(), this.segments = new mu(), this.programConfigurations = new ju(t4.layers, t4.zoom), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id);
          }
          populate(t4, e4, r4, n3) {
            const i4 = this.layers[0], s4 = [];
            let a4 = null;
            "circle" === i4.type && (a4 = i4.layout.get("circle-sort-key"));
            for (const { feature: e5, id: i5, index: o4, sourceLayerIndex: l4 } of t4) {
              const t5 = this.layers[0]._featureFilter.needGeometry, u5 = Fc(e5, t5);
              if (!this.layers[0]._featureFilter.filter(new Uo(this.zoom), u5, r4)) continue;
              const c4 = a4 ? a4.evaluate(u5, {}, r4) : void 0, h4 = { id: i5, properties: e5.properties, type: e5.type, sourceLayerIndex: l4, index: o4, geometry: t5 ? u5.geometry : Lc(e5, r4, n3), patterns: {}, sortKey: c4 };
              s4.push(h4);
            }
            a4 && s4.sort((t5, e5) => t5.sortKey - e5.sortKey);
            let o3 = null;
            "globe" === n3.projection.name && (this.globeExtVertexArray = new Rl(), o3 = n3.projection);
            for (const n4 of s4) {
              const { geometry: i5, index: s5, sourceLayerIndex: a5 } = n4, l4 = t4[s5].feature;
              this.addFeature(n4, i5, s5, e4.availableImages, r4, o3, e4.brightness), e4.featureIndex.insert(l4, i5, s5, a5, this.index);
            }
          }
          update(t4, e4, r4, n3, i4) {
            const s4 = 0 !== Object.keys(t4).length;
            s4 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t4, e4, s4 ? this.stateDependentLayers : this.layers, r4, n3, i4);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t4) {
            this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, fu.members), this.indexBuffer = t4.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t4.createVertexBuffer(this.globeExtVertexArray, du.members))), this.programConfigurations.upload(t4), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
          }
          addFeature(t4, e4, r4, n3, i4, s4, a4) {
            for (const r5 of e4) for (const e5 of r5) {
              const r6 = e5.x, n4 = e5.y;
              if (r6 < 0 || r6 >= is || n4 < 0 || n4 >= is) continue;
              if (s4) {
                const t5 = s4.projectTilePoint(r6, n4, i4), e6 = s4.upVector(i4, r6, n4), a6 = this.globeExtVertexArray;
                Uc(a6, t5, e6), Uc(a6, t5, e6), Uc(a6, t5, e6), Uc(a6, t5, e6);
              }
              const a5 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t4.sortKey), o3 = a5.vertexLength;
              Oc(this.layoutVertexArray, r6, n4, -1, -1), Oc(this.layoutVertexArray, r6, n4, 1, -1), Oc(this.layoutVertexArray, r6, n4, 1, 1), Oc(this.layoutVertexArray, r6, n4, -1, 1), this.indexArray.emplaceBack(o3, o3 + 1, o3 + 2), this.indexArray.emplaceBack(o3, o3 + 2, o3 + 3), a5.vertexLength += 4, a5.primitiveLength += 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r4, {}, n3, i4, a4);
          }
        }
        function jc(t4, e4) {
          for (let r4 = 0; r4 < t4.length; r4++) if (Wc(e4, t4[r4])) return true;
          for (let r4 = 0; r4 < e4.length; r4++) if (Wc(t4, e4[r4])) return true;
          return !!Qc(t4, e4);
        }
        function qc(t4, e4, r4) {
          return !!Wc(t4, e4) || !!Xc(e4, t4, r4);
        }
        function $c(t4, e4) {
          if (1 === t4.length) return Kc(e4, t4[0]);
          for (let r4 = 0; r4 < e4.length; r4++) {
            const n3 = e4[r4];
            for (let e5 = 0; e5 < n3.length; e5++) if (Wc(t4, n3[e5])) return true;
          }
          for (let r4 = 0; r4 < t4.length; r4++) if (Kc(e4, t4[r4])) return true;
          for (let r4 = 0; r4 < e4.length; r4++) if (Qc(t4, e4[r4])) return true;
          return false;
        }
        function Gc(t4, e4, r4) {
          if (t4.length > 1) {
            if (Qc(t4, e4)) return true;
            for (let n3 = 0; n3 < e4.length; n3++) if (Xc(e4[n3], t4, r4)) return true;
          }
          for (let n3 = 0; n3 < t4.length; n3++) if (Xc(t4[n3], e4, r4)) return true;
          return false;
        }
        function Qc(t4, e4) {
          if (0 === t4.length || 0 === e4.length) return false;
          for (let r4 = 0; r4 < t4.length - 1; r4++) {
            const n3 = t4[r4], i4 = t4[r4 + 1];
            for (let t5 = 0; t5 < e4.length - 1; t5++) if (Yc(n3, i4, e4[t5], e4[t5 + 1])) return true;
          }
          return false;
        }
        function Yc(t4, e4, r4, n3) {
          return pr(t4, r4, n3) !== pr(e4, r4, n3) && pr(t4, e4, r4) !== pr(t4, e4, n3);
        }
        function Xc(t4, e4, r4) {
          const n3 = r4 * r4;
          if (1 === e4.length) return t4.distSqr(e4[0]) < n3;
          for (let r5 = 1; r5 < e4.length; r5++) if (Zc(t4, e4[r5 - 1], e4[r5]) < n3) return true;
          return false;
        }
        function Zc(t4, e4, r4) {
          const n3 = e4.distSqr(r4);
          if (0 === n3) return t4.distSqr(e4);
          const i4 = ((t4.x - e4.x) * (r4.x - e4.x) + (t4.y - e4.y) * (r4.y - e4.y)) / n3;
          return t4.distSqr(i4 < 0 ? e4 : i4 > 1 ? r4 : r4.sub(e4)._mult(i4)._add(e4));
        }
        function Kc(t4, e4) {
          let r4, n3, i4, s4 = false;
          for (let a4 = 0; a4 < t4.length; a4++) {
            r4 = t4[a4];
            for (let t5 = 0, a5 = r4.length - 1; t5 < r4.length; a5 = t5++) n3 = r4[t5], i4 = r4[a5], n3.y > e4.y != i4.y > e4.y && e4.x < (i4.x - n3.x) * (e4.y - n3.y) / (i4.y - n3.y) + n3.x && (s4 = !s4);
          }
          return s4;
        }
        function Wc(t4, e4) {
          let r4 = false;
          for (let n3 = 0, i4 = t4.length - 1; n3 < t4.length; i4 = n3++) {
            const s4 = t4[n3], a4 = t4[i4];
            s4.y > e4.y != a4.y > e4.y && e4.x < (a4.x - s4.x) * (e4.y - s4.y) / (a4.y - s4.y) + s4.x && (r4 = !r4);
          }
          return r4;
        }
        function Hc(t4, e4, r4, n3, i4) {
          for (const s5 of t4) if (e4 <= s5.x && r4 <= s5.y && n3 >= s5.x && i4 >= s5.y) return true;
          const s4 = [new Ue(e4, r4), new Ue(e4, i4), new Ue(n3, i4), new Ue(n3, r4)];
          if (t4.length > 2) {
            for (const e5 of s4) if (Wc(t4, e5)) return true;
          }
          for (let e5 = 0; e5 < t4.length - 1; e5++) if (Jc(t4[e5], t4[e5 + 1], s4)) return true;
          return false;
        }
        function Jc(t4, e4, r4) {
          const n3 = r4[0], i4 = r4[2];
          if (t4.x < n3.x && e4.x < n3.x || t4.x > i4.x && e4.x > i4.x || t4.y < n3.y && e4.y < n3.y || t4.y > i4.y && e4.y > i4.y) return false;
          const s4 = pr(t4, e4, r4[0]);
          return s4 !== pr(t4, e4, r4[1]) || s4 !== pr(t4, e4, r4[2]) || s4 !== pr(t4, e4, r4[3]);
        }
        function th(t4, e4, r4, n3, i4, s4) {
          let a4 = e4.y - t4.y, o3 = t4.x - e4.x;
          if (s4 = s4 || 0) {
            const t5 = a4 * a4 + o3 * o3;
            if (0 === t5) return true;
            const e5 = Math.sqrt(t5);
            a4 /= e5, o3 /= e5;
          }
          return !((r4.x - t4.x) * a4 + (r4.y - t4.y) * o3 - s4 < 0 || (n3.x - t4.x) * a4 + (n3.y - t4.y) * o3 - s4 < 0 || (i4.x - t4.x) * a4 + (i4.y - t4.y) * o3 - s4 < 0);
        }
        function eh(t4, e4, r4, n3, i4, s4, a4) {
          return !(th(t4, e4, n3, i4, s4, a4) || th(e4, r4, n3, i4, s4, a4) || th(r4, t4, n3, i4, s4, a4) || th(n3, i4, t4, e4, r4, a4) || th(i4, s4, t4, e4, r4, a4) || th(s4, n3, t4, e4, r4, a4));
        }
        function rh(t4, e4, r4) {
          const n3 = e4.paint.get(t4).value;
          return "constant" === n3.kind ? n3.value : r4.programConfigurations.get(e4.id).getMaxValue(t4);
        }
        function nh(t4) {
          return Math.sqrt(t4[0] * t4[0] + t4[1] * t4[1]);
        }
        function ih(t4, e4, r4, n3, i4) {
          if (!e4[0] && !e4[1]) return t4;
          const s4 = Ue.convert(e4)._mult(i4);
          "viewport" === r4 && s4._rotate(-n3);
          const a4 = [];
          for (let e5 = 0; e5 < t4.length; e5++) a4.push(t4[e5].sub(s4));
          return a4;
        }
        function sh(t4, e4, r4, n3) {
          const i4 = Ue.convert(t4)._mult(n3);
          return "viewport" === e4 && i4._rotate(-r4), i4;
        }
        fo(Nc, "CircleBucket", { omit: ["layers"] });
        const ah = new Ho({ "circle-sort-key": new Ko(el.layout_circle["circle-sort-key"]), visibility: new Zo(el.layout_circle.visibility) });
        var oh = { paint: new Ho({ "circle-radius": new Ko(el.paint_circle["circle-radius"]), "circle-color": new Ko(el.paint_circle["circle-color"]), "circle-blur": new Ko(el.paint_circle["circle-blur"]), "circle-opacity": new Ko(el.paint_circle["circle-opacity"]), "circle-translate": new Zo(el.paint_circle["circle-translate"]), "circle-translate-anchor": new Zo(el.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Zo(el.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Zo(el.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ko(el.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ko(el.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ko(el.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new Zo(el.paint_circle["circle-emissive-strength"]) }), layout: ah };
        class lh {
          constructor(t4, e4) {
            this.pos = t4, this.dir = e4;
          }
          intersectsPlane(e4, r4, n3) {
            const i4 = t3.Q.dot(r4, this.dir);
            if (Math.abs(i4) < 1e-6) return false;
            const s4 = ((e4[0] - this.pos[0]) * r4[0] + (e4[1] - this.pos[1]) * r4[1] + (e4[2] - this.pos[2]) * r4[2]) / i4;
            return n3[0] = this.pos[0] + this.dir[0] * s4, n3[1] = this.pos[1] + this.dir[1] * s4, n3[2] = this.pos[2] + this.dir[2] * s4, true;
          }
          closestPointOnSphere(e4, r4, n3) {
            if (t3.Q.equals(this.pos, e4) || 0 === r4) return n3[0] = n3[1] = n3[2] = 0, false;
            const [i4, s4, a4] = this.dir, o3 = this.pos[0] - e4[0], l4 = this.pos[1] - e4[1], u5 = this.pos[2] - e4[2], c4 = i4 * i4 + s4 * s4 + a4 * a4, h4 = 2 * (o3 * i4 + l4 * s4 + u5 * a4), p4 = h4 * h4 - 4 * c4 * (o3 * o3 + l4 * l4 + u5 * u5 - r4 * r4);
            if (p4 < 0) {
              const t4 = Math.max(-h4 / 2, 0), e5 = o3 + i4 * t4, c5 = l4 + s4 * t4, p5 = u5 + a4 * t4, f4 = Math.hypot(e5, c5, p5);
              return n3[0] = e5 * r4 / f4, n3[1] = c5 * r4 / f4, n3[2] = p5 * r4 / f4, false;
            }
            {
              const t4 = (-h4 - Math.sqrt(p4)) / (2 * c4);
              if (t4 < 0) {
                const t5 = Math.hypot(o3, l4, u5);
                return n3[0] = o3 * r4 / t5, n3[1] = l4 * r4 / t5, n3[2] = u5 * r4 / t5, false;
              }
              return n3[0] = o3 + i4 * t4, n3[1] = l4 + s4 * t4, n3[2] = u5 + a4 * t4, true;
            }
          }
        }
        class uh {
          constructor(t4, e4, r4, n3, i4) {
            this.TL = t4, this.TR = e4, this.BR = r4, this.BL = n3, this.horizon = i4;
          }
          static fromInvProjectionMatrix(e4, r4, n3) {
            const i4 = [-1, 1, 1], s4 = [1, 1, 1], a4 = [1, -1, 1], o3 = [-1, -1, 1], l4 = t3.Q.transformMat4(i4, i4, e4), u5 = t3.Q.transformMat4(s4, s4, e4), c4 = t3.Q.transformMat4(a4, a4, e4), h4 = t3.Q.transformMat4(o3, o3, e4);
            return new uh(l4, u5, c4, h4, r4 / n3);
          }
        }
        function ch(e4, r4, n3) {
          let i4 = 1 / 0, s4 = -1 / 0;
          const a4 = [];
          for (const o3 of e4) {
            t3.Q.sub(a4, o3, r4);
            const e5 = t3.Q.dot(a4, n3);
            i4 = Math.min(i4, e5), s4 = Math.max(s4, e5);
          }
          return [i4, s4];
        }
        function hh(e4, r4) {
          let n3 = true;
          for (let i4 = 0; i4 < e4.planes.length; i4++) {
            const s4 = e4.planes[i4];
            let a4 = 0;
            for (let e5 = 0; e5 < r4.length; e5++) a4 += t3.Q.dot(s4, r4[e5]) + s4[3] >= 0;
            if (0 === a4) return 0;
            a4 !== r4.length && (n3 = false);
          }
          return n3 ? 2 : 1;
        }
        function ph(t4, e4) {
          for (const r4 of t4.projections) {
            const n3 = ch(e4, t4.points[0], r4.axis);
            if (r4.projection[1] < n3[0] || r4.projection[0] > n3[1]) return 0;
          }
          return 1;
        }
        function fh(e4, r4) {
          let n3 = 0;
          const i4 = [0, 0, 0, 0];
          for (let s4 = 0; s4 < e4.length; s4++) i4[0] = e4[s4][0], i4[1] = e4[s4][1], i4[2] = e4[s4][2], i4[3] = 1, t3.aa.dot(i4, r4) >= 0 && n3++;
          return n3;
        }
        class dh {
          constructor(e4, r4) {
            this.points = e4 || new Array(8).fill([0, 0, 0]), this.planes = r4 || new Array(6).fill([0, 0, 0, 0]), this.bounds = mh.fromPoints(this.points), this.projections = [], this.frustumEdges = [t3.Q.sub([], this.points[2], this.points[3]), t3.Q.sub([], this.points[0], this.points[3]), t3.Q.sub([], this.points[4], this.points[0]), t3.Q.sub([], this.points[5], this.points[1]), t3.Q.sub([], this.points[6], this.points[2]), t3.Q.sub([], this.points[7], this.points[3])];
            for (const t4 of this.frustumEdges) {
              const e5 = [0, -t4[2], t4[1]], r5 = [t4[2], 0, -t4[0]];
              this.projections.push({ axis: e5, projection: ch(this.points, this.points[0], e5) }), this.projections.push({ axis: r5, projection: ch(this.points, this.points[0], r5) });
            }
          }
          static fromInvProjectionMatrix(e4, r4, n3, i4) {
            const s4 = Math.pow(2, n3), a4 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((n4) => {
              const a5 = t3.aa.transformMat4([], n4, e4), o4 = 1 / a5[3] / r4 * s4;
              return t3.aa.mul(a5, a5, [o4, o4, i4 ? 1 / a5[3] : o4, o4]);
            }), o3 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e5) => {
              const r5 = t3.Q.sub([], a4[e5[0]], a4[e5[1]]), n4 = t3.Q.sub([], a4[e5[2]], a4[e5[1]]), i5 = t3.Q.normalize([], t3.Q.cross([], r5, n4)), s5 = -t3.Q.dot(i5, a4[e5[1]]);
              return i5.concat(s5);
            }), l4 = [];
            for (let t4 = 0; t4 < a4.length; t4++) l4.push([a4[t4][0], a4[t4][1], a4[t4][2]]);
            return new dh(l4, o3);
          }
          intersectsPrecise(e4, r4, n3) {
            for (let t4 = 0; t4 < r4.length; t4++) if (!fh(e4, r4[t4])) return 0;
            for (let t4 = 0; t4 < this.planes.length; t4++) if (!fh(e4, this.planes[t4])) return 0;
            for (const r5 of n3) for (const n4 of this.frustumEdges) {
              const i4 = t3.Q.cross([], r5, n4), s4 = t3.Q.length(i4);
              if (0 === s4) continue;
              t3.Q.scale(i4, i4, 1 / s4);
              const a4 = ch(this.points, this.points[0], i4), o3 = ch(e4, this.points[0], i4);
              if (a4[0] > o3[1] || o3[0] > a4[1]) return 0;
            }
            return 1;
          }
        }
        class mh {
          static fromPoints(e4) {
            const r4 = [1 / 0, 1 / 0, 1 / 0], n3 = [-1 / 0, -1 / 0, -1 / 0];
            for (const i4 of e4) t3.Q.min(r4, r4, i4), t3.Q.max(n3, n3, i4);
            return new mh(r4, n3);
          }
          static fromTileIdAndHeight(t4, e4, r4) {
            const n3 = 1 << t4.canonical.z, i4 = t4.canonical.x, s4 = t4.canonical.y;
            return new mh([i4 / n3, s4 / n3, e4], [(i4 + 1) / n3, (s4 + 1) / n3, r4]);
          }
          static applyTransform(e4, r4) {
            const n3 = e4.getCorners();
            for (let e5 = 0; e5 < n3.length; ++e5) t3.Q.transformMat4(n3[e5], n3[e5], r4);
            return mh.fromPoints(n3);
          }
          static projectAabbCorners(e4, r4) {
            const n3 = e4.getCorners();
            for (let e5 = 0; e5 < n3.length; ++e5) t3.Q.transformMat4(n3[e5], n3[e5], r4);
            return n3;
          }
          constructor(e4, r4) {
            this.min = e4, this.max = r4, this.center = t3.Q.scale([], t3.Q.add([], this.min, this.max), 0.5);
          }
          quadrant(e4) {
            const r4 = [e4 % 2 == 0, e4 < 2], n3 = t3.Q.clone(this.min), i4 = t3.Q.clone(this.max);
            for (let t4 = 0; t4 < r4.length; t4++) n3[t4] = r4[t4] ? this.min[t4] : this.center[t4], i4[t4] = r4[t4] ? this.center[t4] : this.max[t4];
            return i4[2] = this.max[2], new mh(n3, i4);
          }
          distanceX(t4) {
            return Math.max(Math.min(this.max[0], t4[0]), this.min[0]) - t4[0];
          }
          distanceY(t4) {
            return Math.max(Math.min(this.max[1], t4[1]), this.min[1]) - t4[1];
          }
          distanceZ(t4) {
            return Math.max(Math.min(this.max[2], t4[2]), this.min[2]) - t4[2];
          }
          getCorners() {
            const t4 = this.min, e4 = this.max;
            return [[t4[0], t4[1], t4[2]], [e4[0], t4[1], t4[2]], [e4[0], e4[1], t4[2]], [t4[0], e4[1], t4[2]], [t4[0], t4[1], e4[2]], [e4[0], t4[1], e4[2]], [e4[0], e4[1], e4[2]], [t4[0], e4[1], e4[2]]];
          }
          intersects(t4) {
            return this.intersectsAabb(t4.bounds) ? hh(t4, this.getCorners()) : 0;
          }
          intersectsFlat(t4) {
            return this.intersectsAabb(t4.bounds) ? hh(t4, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
          }
          intersectsPrecise(t4, e4) {
            return e4 || this.intersects(t4) ? ph(t4, this.getCorners()) : 0;
          }
          intersectsPreciseFlat(t4, e4) {
            return e4 || this.intersectsFlat(t4) ? ph(t4, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
          }
          intersectsAabb(t4) {
            for (let e4 = 0; e4 < 3; ++e4) if (this.min[e4] > t4.max[e4] || t4.min[e4] > this.max[e4]) return false;
            return true;
          }
          intersectsAabbXY(t4) {
            return !(this.min[0] > t4.max[0] || t4.min[0] > this.max[0] || this.min[1] > t4.max[1] || t4.min[1] > this.max[1]);
          }
          encapsulate(t4) {
            for (let e4 = 0; e4 < 3; e4++) this.min[e4] = Math.min(this.min[e4], t4.min[e4]), this.max[e4] = Math.max(this.max[e4], t4.max[e4]);
          }
          encapsulatePoint(t4) {
            for (let e4 = 0; e4 < 3; e4++) this.min[e4] = Math.min(this.min[e4], t4[e4]), this.max[e4] = Math.max(this.max[e4], t4[e4]);
          }
          closestPoint(t4) {
            return [Math.max(Math.min(this.max[0], t4[0]), this.min[0]), Math.max(Math.min(this.max[1], t4[1]), this.min[1]), Math.max(Math.min(this.max[2], t4[2]), this.min[2])];
          }
        }
        fo(mh, "Aabb");
        const yh = Ml([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: gh } = yh, xh = Ml([{ name: "a_pos_3", components: 3, type: "Int16" }]);
        var bh = Ml([{ name: "a_pos", type: "Int16", components: 2 }]);
        function vh(t4) {
          return t4 * Xu / ic;
        }
        const _h = [new mh([tc, tc, tc], [ec, ec, ec]), new mh([tc, tc, tc], [0, 0, ec]), new mh([0, tc, tc], [ec, 0, ec]), new mh([tc, 0, tc], [0, ec, ec]), new mh([0, 0, tc], [ec, ec, ec])];
        function wh(e4, r4, n3, i4 = true) {
          const s4 = t3.Q.scale([], e4._camera.position, e4.worldSize), a4 = [r4, n3, 1, 1];
          t3.aa.transformMat4(a4, a4, e4.pixelMatrixInverse), t3.aa.scale(a4, a4, 1 / a4[3]);
          const o3 = t3.Q.sub([], a4, s4), l4 = t3.Q.normalize([], o3), u5 = e4.globeMatrix, c4 = [u5[12], u5[13], u5[14]], h4 = t3.Q.sub([], c4, s4), p4 = t3.Q.length(h4), f4 = t3.Q.normalize([], h4), d3 = e4.worldSize / (2 * Math.PI), m4 = t3.Q.dot(f4, l4), y4 = Math.asin(d3 / p4);
          if (y4 < Math.acos(m4)) {
            if (!i4) return null;
            const e5 = [], r5 = [];
            t3.Q.scale(e5, l4, p4 / m4), t3.Q.normalize(r5, t3.Q.sub(r5, e5, h4)), t3.Q.normalize(l4, t3.Q.add(l4, h4, t3.Q.scale(l4, r5, Math.tan(y4) * p4)));
          }
          const g5 = [];
          new lh(s4, l4).closestPointOnSphere(c4, d3, g5);
          const x5 = t3.Q.normalize([], Sr(u5, 0)), b4 = t3.Q.normalize([], Sr(u5, 1)), v4 = t3.Q.normalize([], Sr(u5, 2)), _4 = t3.Q.dot(x5, g5), w5 = t3.Q.dot(b4, g5), M3 = t3.Q.dot(v4, g5), A4 = $e(Math.asin(-w5 / d3));
          let S3 = $e(Math.atan2(_4, M3));
          S3 = e4.center.lng + function(t4, e5) {
            const r5 = (e5 - t4 + 180) % 360 - 180;
            return r5 < -180 ? r5 + 360 : r5;
          }(e4.center.lng, S3);
          const I4 = xc(S3), k4 = Ze(bc(A4), 0, 1);
          return new Ec(I4, k4);
        }
        class Mh {
          constructor(e4, r4, n3) {
            this.a = t3.Q.sub([], e4, n3), this.b = t3.Q.sub([], r4, n3), this.center = n3;
            const i4 = t3.Q.normalize([], this.a), s4 = t3.Q.normalize([], this.b);
            this.angle = Math.acos(t3.Q.dot(i4, s4));
          }
        }
        function Ah(t4, e4) {
          if (0 === t4.angle) return null;
          let r4;
          return r4 = 0 === t4.a[e4] ? 1 / t4.angle * 0.5 * Math.PI : 1 / t4.angle * Math.atan(t4.b[e4] / t4.a[e4] / Math.sin(t4.angle) - 1 / Math.tan(t4.angle)), r4 < 0 || r4 > 1 ? null : function(t5, e5, r5, n3) {
            const i4 = Math.sin(r5);
            return t5 * (Math.sin((1 - n3) * r5) / i4) + e5 * (Math.sin(n3 * r5) / i4);
          }(t4.a[e4], t4.b[e4], t4.angle, Ze(r4, 0, 1)) + t4.center[e4];
        }
        function Sh(t4) {
          if (t4.z <= 1) return _h[t4.z + 2 * t4.y + t4.x];
          const e4 = zh(Eh(t4));
          return mh.fromPoints(e4);
        }
        function Ih(e4, r4, n3) {
          return t3.Q.scale(e4, e4, 1 - n3), t3.Q.scaleAndAdd(e4, e4, r4, n3);
        }
        function kh(e4, r4, n3) {
          for (const i4 of e4) t3.Q.transformMat4(i4, i4, r4), t3.Q.scale(i4, i4, n3);
        }
        function Ph(e4, r4, n3, i4) {
          const s4 = r4 / e4.worldSize, a4 = e4.globeMatrix;
          if (n3.z <= 1) {
            const t4 = Sh(n3).getCorners();
            return kh(t4, a4, s4), mh.fromPoints(t4);
          }
          const o3 = Eh(n3, i4), l4 = zh(o3, Xu + vh(e4._tileCoverLift));
          kh(l4, a4, s4);
          const u5 = Number.MAX_VALUE, c4 = [-u5, -u5, -u5], h4 = [u5, u5, u5];
          if (o3.contains(e4.center)) {
            for (const e5 of l4) t3.Q.min(h4, h4, e5), t3.Q.max(c4, c4, e5);
            c4[2] = 0;
            const r5 = e4.point, n4 = [r5.x * s4, r5.y * s4, 0];
            return t3.Q.min(h4, h4, n4), t3.Q.max(c4, c4, n4), new mh(h4, c4);
          }
          if (e4._tileCoverLift > 0) {
            for (const e5 of l4) t3.Q.min(h4, h4, e5), t3.Q.max(c4, c4, e5);
            return new mh(h4, c4);
          }
          const p4 = [a4[12] * s4, a4[13] * s4, a4[14] * s4], f4 = o3.getCenter(), d3 = Ze(e4.center.lat, -Ac, Ac), m4 = Ze(f4.lat, -Ac, Ac), y4 = xc(e4.center.lng), g5 = bc(d3);
          let x5 = y4 - xc(f4.lng);
          const b4 = g5 - bc(m4);
          x5 > 0.5 ? x5 -= 1 : x5 < -0.5 && (x5 += 1);
          let v4 = 0;
          if (Math.abs(x5) > Math.abs(b4)) v4 = x5 >= 0 ? 1 : 3;
          else {
            v4 = b4 >= 0 ? 0 : 2;
            const e5 = [a4[4] * s4, a4[5] * s4, a4[6] * s4], r5 = -Math.sin(qe(b4 >= 0 ? o3.getSouth() : o3.getNorth())) * Xu;
            t3.Q.scaleAndAdd(p4, p4, e5, r5);
          }
          const _4 = l4[v4], w5 = l4[(v4 + 1) % 4], M3 = new Mh(_4, w5, p4), A4 = [Ah(M3, 0) || _4[0], Ah(M3, 1) || _4[1], Ah(M3, 2) || _4[2]], S3 = Oh(e4.zoom);
          if (S3 > 0) {
            const i5 = function({ x: t4, y: e5, z: r5 }, n4, i6, s6, a5) {
              const o4 = 1 / (1 << r5);
              let l5 = t4 * o4, u6 = l5 + o4, c5 = e5 * o4, h5 = c5 + o4, p5 = 0;
              const f5 = (l5 + u6) / 2 - s6;
              return f5 > 0.5 ? p5 = -1 : f5 < -0.5 && (p5 = 1), l5 = ((l5 + p5) * n4 - (s6 *= n4)) * i6 + s6, u6 = ((u6 + p5) * n4 - s6) * i6 + s6, c5 = (c5 * n4 - (a5 *= n4)) * i6 + a5, h5 = (h5 * n4 - a5) * i6 + a5, [[l5, h5, 0], [u6, h5, 0], [u6, c5, 0], [l5, c5, 0]];
            }(n3, r4, e4._pixelsPerMercatorPixel, y4, g5);
            for (let t4 = 0; t4 < l4.length; t4++) Ih(l4[t4], i5[t4], S3);
            const s5 = t3.Q.add([], i5[v4], i5[(v4 + 1) % 4]);
            t3.Q.scale(s5, s5, 0.5), Ih(A4, s5, S3);
          }
          for (const e5 of l4) t3.Q.min(h4, h4, e5), t3.Q.max(c4, c4, e5);
          return h4[2] = Math.min(_4[2], w5[2]), t3.Q.min(h4, h4, A4), t3.Q.max(c4, c4, A4), new mh(h4, c4);
        }
        function Eh({ x: t4, y: e4, z: r4 }, n3 = false) {
          const i4 = 1 / (1 << r4), s4 = new ac(_c(t4 * i4), e4 === (1 << r4) - 1 && n3 ? -90 : wc((e4 + 1) * i4)), a4 = new ac(_c((t4 + 1) * i4), 0 === e4 && n3 ? 90 : wc(e4 * i4));
          return new oc(s4, a4);
        }
        function zh(t4, e4 = Xu) {
          const r4 = qe(t4.getNorth()), n3 = qe(t4.getSouth()), i4 = Math.cos(r4), s4 = Math.cos(n3), a4 = Math.sin(r4), o3 = Math.sin(n3), l4 = t4.getWest(), u5 = t4.getEast();
          return [rc(s4, o3, l4, e4), rc(s4, o3, u5, e4), rc(i4, a4, u5, e4), rc(i4, a4, l4, e4)];
        }
        function Th(t4, e4, r4, n3) {
          const i4 = 1 << r4.z, s4 = (t4 / is + r4.x) / i4;
          return nc(wc((e4 / is + r4.y) / i4), _c(s4), n3);
        }
        function Bh({ min: t4, max: e4 }) {
          return Wu / Math.max(e4[0] - t4[0], e4[1] - t4[1], e4[2] - t4[2]);
        }
        const Ch = new Float64Array(16);
        function Rh(e4) {
          const r4 = Bh(e4), n3 = t3.a9.fromScaling(Ch, [r4, r4, r4]);
          return t3.a9.translate(n3, n3, t3.Q.negate([], e4.min));
        }
        function Vh(e4) {
          const r4 = t3.a9.fromTranslation(Ch, e4.min), n3 = 1 / Bh(e4);
          return t3.a9.scale(r4, r4, [n3, n3, n3]);
        }
        function Dh(t4) {
          const e4 = is / (2 * Math.PI);
          return t4 / (2 * Math.PI) / e4;
        }
        function Lh(t4, e4) {
          return is / (512 * Math.pow(2, t4)) * Bh(Sh(e4));
        }
        function Fh(e4, r4, n3, i4, s4) {
          const a4 = Dh(n3), o3 = [e4, r4, -n3 / (2 * Math.PI)], l4 = t3.a9.identity(new Float64Array(16));
          return t3.a9.translate(l4, l4, o3), t3.a9.scale(l4, l4, [a4, a4, a4]), t3.a9.rotateX(l4, l4, qe(-s4)), t3.a9.rotateY(l4, l4, qe(-i4)), l4;
        }
        function Oh(t4) {
          return Ke(Zu, Ku, t4);
        }
        function Uh(e4, r4) {
          const n3 = nc(r4.lat, r4.lng), i4 = function(e5) {
            const r5 = nc(e5._center.lat, e5._center.lng), n4 = t3.Q.fromValues(0, 1, 0);
            let i5 = t3.Q.cross([], n4, r5);
            const s5 = t3.a9.fromRotation([], -e5.angle, r5);
            i5 = t3.Q.transformMat4(i5, i5, s5), t3.a9.fromRotation(s5, -e5._pitch, i5);
            const a4 = t3.Q.normalize([], r5);
            return t3.Q.scale(a4, a4, vh(e5.cameraToCenterDistance / e5.pixelsPerMeter)), t3.Q.transformMat4(a4, a4, s5), t3.Q.add([], r5, a4);
          }(e4), s4 = t3.Q.subtract([], i4, n3);
          return t3.Q.angle(s4, n3);
        }
        function Nh(t4, e4) {
          return Uh(t4, e4) > Math.PI / 2 * 1.01;
        }
        const jh = qe(85), qh = Math.cos(jh), $h = Math.sin(jh), Gh = t3.a9.create(), Qh = (t4) => {
          const e4 = [];
          return "map" === t4.paint.get("circle-pitch-alignment") && e4.push("PITCH_WITH_MAP"), "map" === t4.paint.get("circle-pitch-scale") && e4.push("SCALE_WITH_MAP"), e4;
        };
        function Yh(e4, r4, n3, i4, s4, a4, o3, l4, u5) {
          if (a4 && e4.queryGeometry.isAboveHorizon) return false;
          a4 && (u5 *= e4.pixelToTileUnitsFactor);
          const c4 = e4.tileID.canonical, h4 = n3.projection.upVectorScale(c4, n3.center.lat, n3.worldSize).metersToTile;
          for (const p4 of r4) for (const r5 of p4) {
            const p5 = r5.add(l4), f4 = s4 && n3.elevation ? n3.elevation.exaggeration() * s4.getElevationAt(p5.x, p5.y, true) : 0, d3 = n3.projection.projectTilePoint(p5.x, p5.y, c4);
            if (f4 > 0) {
              const t4 = n3.projection.upVector(c4, p5.x, p5.y);
              d3.x += t4[0] * h4 * f4, d3.y += t4[1] * h4 * f4, d3.z += t4[2] * h4 * f4;
            }
            const m4 = a4 ? p5 : Xh(d3.x, d3.y, d3.z, i4), y4 = a4 ? e4.tilespaceRays.map((t4) => Wh(t4, f4)) : e4.queryGeometry.screenGeometry, g5 = t3.aa.transformMat4([], [d3.x, d3.y, d3.z, 1], i4);
            if (!o3 && a4 ? u5 *= g5[3] / n3.cameraToCenterDistance : o3 && !a4 && (u5 *= n3.cameraToCenterDistance / g5[3]), a4) {
              const t4 = wc((r5.y / is + c4.y) / (1 << c4.z));
              u5 /= n3.projection.pixelsPerMeter(t4, 1) / vc(1, t4);
            }
            if (qc(y4, m4, u5)) return true;
          }
          return false;
        }
        function Xh(e4, r4, n3, i4) {
          const s4 = t3.aa.transformMat4([], [e4, r4, n3, 1], i4);
          return new Ue(s4[0] / s4[3], s4[1] / s4[3]);
        }
        const Zh = t3.Q.fromValues(0, 0, 0), Kh = t3.Q.fromValues(0, 0, 1);
        function Wh(e4, r4) {
          const n3 = t3.Q.create();
          return Zh[2] = r4, e4.intersectsPlane(Zh, Kh, n3), new Ue(n3[0], n3[1]);
        }
        class Hh extends Nc {
        }
        function Jh(t4, { width: e4, height: r4 }, n3, i4) {
          if (i4) {
            if (i4 instanceof Uint8ClampedArray) i4 = new Uint8Array(i4.buffer);
            else if (i4.length !== e4 * r4 * n3) throw new RangeError("mismatched image size");
          } else i4 = new Uint8Array(e4 * r4 * n3);
          return t4.width = e4, t4.height = r4, t4.data = i4, t4;
        }
        function tp(t4, e4, r4) {
          const { width: n3, height: i4 } = e4;
          n3 === t4.width && i4 === t4.height || (ep(t4, e4, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t4.width, n3), height: Math.min(t4.height, i4) }, r4), t4.width = n3, t4.height = i4, t4.data = e4.data);
        }
        function ep(t4, e4, r4, n3, i4, s4, a4) {
          if (0 === i4.width || 0 === i4.height) return e4;
          if (i4.width > t4.width || i4.height > t4.height || r4.x > t4.width - i4.width || r4.y > t4.height - i4.height) throw new RangeError("out of range source coordinates for image copy");
          if (i4.width > e4.width || i4.height > e4.height || n3.x > e4.width - i4.width || n3.y > e4.height - i4.height) throw new RangeError("out of range destination coordinates for image copy");
          const o3 = t4.data, l4 = e4.data, u5 = 4 === s4 && a4;
          for (let a5 = 0; a5 < i4.height; a5++) {
            const c4 = ((r4.y + a5) * t4.width + r4.x) * s4, h4 = ((n3.y + a5) * e4.width + n3.x) * s4;
            if (u5) for (let t5 = 0; t5 < i4.width; t5++) {
              const e5 = c4 + t5 * s4 + 3, r5 = h4 + t5 * s4;
              l4[r5 + 0] = 255, l4[r5 + 1] = 255, l4[r5 + 2] = 255, l4[r5 + 3] = o3[e5];
            }
            else for (let t5 = 0; t5 < i4.width * s4; t5++) l4[h4 + t5] = o3[c4 + t5];
          }
          return e4;
        }
        fo(Hh, "HeatmapBucket", { omit: ["layers"] });
        class rp {
          constructor(t4, e4) {
            Jh(this, t4, 1, e4);
          }
          resize(t4) {
            tp(this, new rp(t4), 1);
          }
          clone() {
            return new rp({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t4, e4, r4, n3, i4) {
            ep(t4, e4, r4, n3, i4, 1);
          }
        }
        class np {
          constructor(t4, e4) {
            Jh(this, t4, 4, e4);
          }
          resize(t4) {
            tp(this, new np(t4), 4);
          }
          replace(t4, e4) {
            e4 ? this.data.set(t4) : this.data = t4 instanceof Uint8ClampedArray ? new Uint8Array(t4.buffer) : t4;
          }
          clone() {
            return new np({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t4, e4, r4, n3, i4, s4) {
            ep(t4, e4, r4, n3, i4, 4, s4);
          }
        }
        class ip {
          constructor(t4, e4) {
            this.width = t4.width, this.height = t4.height, this.data = e4 instanceof Uint8Array ? new Float32Array(e4.buffer) : e4;
          }
        }
        fo(rp, "AlphaImage"), fo(np, "RGBAImage");
        const sp = new Ho({ visibility: new Zo(el.layout_heatmap.visibility) });
        var ap = { paint: new Ho({ "heatmap-radius": new Ko(el.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ko(el.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Zo(el.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Wo(el.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Zo(el.paint_heatmap["heatmap-opacity"]) }), layout: sp };
        function op(t4) {
          const e4 = {}, r4 = t4.resolution || 256, n3 = t4.clips ? t4.clips.length : 1, i4 = t4.image || new np({ width: r4, height: n3 }), s4 = (r5, n4, s5) => {
            e4[t4.evaluationKey] = s5;
            const a4 = t4.expression.evaluate(e4);
            a4 && (i4.data[r5 + n4 + 0] = Math.floor(255 * a4.r / a4.a), i4.data[r5 + n4 + 1] = Math.floor(255 * a4.g / a4.a), i4.data[r5 + n4 + 2] = Math.floor(255 * a4.b / a4.a), i4.data[r5 + n4 + 3] = Math.floor(255 * a4.a));
          };
          if (t4.clips) for (let e5 = 0, i5 = 0; e5 < n3; ++e5, i5 += 4 * r4) for (let n4 = 0, a4 = 0; n4 < r4; n4++, a4 += 4) {
            const o3 = n4 / (r4 - 1), { start: l4, end: u5 } = t4.clips[e5];
            s4(i5, a4, l4 * (1 - o3) + u5 * o3);
          }
          else for (let t5 = 0, e5 = 0; t5 < r4; t5++, e5 += 4) s4(0, e5, t5 / (r4 - 1));
          return i4;
        }
        const lp = new Ho({ visibility: new Zo(el.layout_hillshade.visibility) });
        var up = { paint: new Ho({ "hillshade-illumination-direction": new Zo(el.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Zo(el.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Zo(el.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Zo(el.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Zo(el.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Zo(el.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new Zo(el.paint_hillshade["hillshade-emissive-strength"]) }), layout: lp };
        const cp = Ml([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: hp } = cp;
        var pp = { exports: {} };
        function fp(t4, e4, r4) {
          r4 = r4 || 2;
          var n3, i4, s4, a4, o3, l4, u5, c4 = e4 && e4.length, h4 = c4 ? e4[0] * r4 : t4.length, p4 = dp(t4, 0, h4, r4, true), f4 = [];
          if (!p4 || p4.next === p4.prev) return f4;
          if (c4 && (p4 = function(t5, e5, r5, n4) {
            var i5, s5, a5, o4 = [];
            for (i5 = 0, s5 = e5.length; i5 < s5; i5++) (a5 = dp(t5, e5[i5] * n4, i5 < s5 - 1 ? e5[i5 + 1] * n4 : t5.length, n4, false)) === a5.next && (a5.steiner = true), o4.push(Sp(a5));
            for (o4.sort(_p), i5 = 0; i5 < o4.length; i5++) r5 = wp(o4[i5], r5);
            return r5;
          }(t4, e4, p4, r4)), t4.length > 80 * r4) {
            n3 = s4 = t4[0], i4 = a4 = t4[1];
            for (var d3 = r4; d3 < h4; d3 += r4) (o3 = t4[d3]) < n3 && (n3 = o3), (l4 = t4[d3 + 1]) < i4 && (i4 = l4), o3 > s4 && (s4 = o3), l4 > a4 && (a4 = l4);
            u5 = 0 !== (u5 = Math.max(s4 - n3, a4 - i4)) ? 32767 / u5 : 0;
          }
          return yp(p4, f4, r4, n3, i4, u5, 0), f4;
        }
        function dp(t4, e4, r4, n3, i4) {
          var s4, a4;
          if (i4 === Fp(t4, e4, r4, n3) > 0) for (s4 = e4; s4 < r4; s4 += n3) a4 = Vp(s4, t4[s4], t4[s4 + 1], a4);
          else for (s4 = r4 - n3; s4 >= e4; s4 -= n3) a4 = Vp(s4, t4[s4], t4[s4 + 1], a4);
          return a4 && Ep(a4, a4.next) && (Dp(a4), a4 = a4.next), a4;
        }
        function mp(t4, e4) {
          if (!t4) return t4;
          e4 || (e4 = t4);
          var r4, n3 = t4;
          do {
            if (r4 = false, n3.steiner || !Ep(n3, n3.next) && 0 !== Pp(n3.prev, n3, n3.next)) n3 = n3.next;
            else {
              if (Dp(n3), (n3 = e4 = n3.prev) === n3.next) break;
              r4 = true;
            }
          } while (r4 || n3 !== e4);
          return e4;
        }
        function yp(t4, e4, r4, n3, i4, s4, a4) {
          if (t4) {
            !a4 && s4 && function(t5, e5, r5, n4) {
              var i5 = t5;
              do {
                0 === i5.z && (i5.z = Ap(i5.x, i5.y, e5, r5, n4)), i5.prevZ = i5.prev, i5.nextZ = i5.next, i5 = i5.next;
              } while (i5 !== t5);
              i5.prevZ.nextZ = null, i5.prevZ = null, function(t6) {
                var e6, r6, n5, i6, s5, a5, o4, l5, u6 = 1;
                do {
                  for (r6 = t6, t6 = null, s5 = null, a5 = 0; r6; ) {
                    for (a5++, n5 = r6, o4 = 0, e6 = 0; e6 < u6 && (o4++, n5 = n5.nextZ); e6++) ;
                    for (l5 = u6; o4 > 0 || l5 > 0 && n5; ) 0 !== o4 && (0 === l5 || !n5 || r6.z <= n5.z) ? (i6 = r6, r6 = r6.nextZ, o4--) : (i6 = n5, n5 = n5.nextZ, l5--), s5 ? s5.nextZ = i6 : t6 = i6, i6.prevZ = s5, s5 = i6;
                    r6 = n5;
                  }
                  s5.nextZ = null, u6 *= 2;
                } while (a5 > 1);
              }(i5);
            }(t4, n3, i4, s4);
            for (var o3, l4, u5 = t4; t4.prev !== t4.next; ) if (o3 = t4.prev, l4 = t4.next, s4 ? xp(t4, n3, i4, s4) : gp(t4)) e4.push(o3.i / r4 | 0), e4.push(t4.i / r4 | 0), e4.push(l4.i / r4 | 0), Dp(t4), t4 = l4.next, u5 = l4.next;
            else if ((t4 = l4) === u5) {
              a4 ? 1 === a4 ? yp(t4 = bp(mp(t4), e4, r4), e4, r4, n3, i4, s4, 2) : 2 === a4 && vp(t4, e4, r4, n3, i4, s4) : yp(mp(t4), e4, r4, n3, i4, s4, 1);
              break;
            }
          }
        }
        function gp(t4) {
          var e4 = t4.prev, r4 = t4, n3 = t4.next;
          if (Pp(e4, r4, n3) >= 0) return false;
          for (var i4 = e4.x, s4 = r4.x, a4 = n3.x, o3 = e4.y, l4 = r4.y, u5 = n3.y, c4 = i4 < s4 ? i4 < a4 ? i4 : a4 : s4 < a4 ? s4 : a4, h4 = o3 < l4 ? o3 < u5 ? o3 : u5 : l4 < u5 ? l4 : u5, p4 = i4 > s4 ? i4 > a4 ? i4 : a4 : s4 > a4 ? s4 : a4, f4 = o3 > l4 ? o3 > u5 ? o3 : u5 : l4 > u5 ? l4 : u5, d3 = n3.next; d3 !== e4; ) {
            if (d3.x >= c4 && d3.x <= p4 && d3.y >= h4 && d3.y <= f4 && Ip(i4, o3, s4, l4, a4, u5, d3.x, d3.y) && Pp(d3.prev, d3, d3.next) >= 0) return false;
            d3 = d3.next;
          }
          return true;
        }
        function xp(t4, e4, r4, n3) {
          var i4 = t4.prev, s4 = t4, a4 = t4.next;
          if (Pp(i4, s4, a4) >= 0) return false;
          for (var o3 = i4.x, l4 = s4.x, u5 = a4.x, c4 = i4.y, h4 = s4.y, p4 = a4.y, f4 = o3 < l4 ? o3 < u5 ? o3 : u5 : l4 < u5 ? l4 : u5, d3 = c4 < h4 ? c4 < p4 ? c4 : p4 : h4 < p4 ? h4 : p4, m4 = o3 > l4 ? o3 > u5 ? o3 : u5 : l4 > u5 ? l4 : u5, y4 = c4 > h4 ? c4 > p4 ? c4 : p4 : h4 > p4 ? h4 : p4, g5 = Ap(f4, d3, e4, r4, n3), x5 = Ap(m4, y4, e4, r4, n3), b4 = t4.prevZ, v4 = t4.nextZ; b4 && b4.z >= g5 && v4 && v4.z <= x5; ) {
            if (b4.x >= f4 && b4.x <= m4 && b4.y >= d3 && b4.y <= y4 && b4 !== i4 && b4 !== a4 && Ip(o3, c4, l4, h4, u5, p4, b4.x, b4.y) && Pp(b4.prev, b4, b4.next) >= 0) return false;
            if (b4 = b4.prevZ, v4.x >= f4 && v4.x <= m4 && v4.y >= d3 && v4.y <= y4 && v4 !== i4 && v4 !== a4 && Ip(o3, c4, l4, h4, u5, p4, v4.x, v4.y) && Pp(v4.prev, v4, v4.next) >= 0) return false;
            v4 = v4.nextZ;
          }
          for (; b4 && b4.z >= g5; ) {
            if (b4.x >= f4 && b4.x <= m4 && b4.y >= d3 && b4.y <= y4 && b4 !== i4 && b4 !== a4 && Ip(o3, c4, l4, h4, u5, p4, b4.x, b4.y) && Pp(b4.prev, b4, b4.next) >= 0) return false;
            b4 = b4.prevZ;
          }
          for (; v4 && v4.z <= x5; ) {
            if (v4.x >= f4 && v4.x <= m4 && v4.y >= d3 && v4.y <= y4 && v4 !== i4 && v4 !== a4 && Ip(o3, c4, l4, h4, u5, p4, v4.x, v4.y) && Pp(v4.prev, v4, v4.next) >= 0) return false;
            v4 = v4.nextZ;
          }
          return true;
        }
        function bp(t4, e4, r4) {
          var n3 = t4;
          do {
            var i4 = n3.prev, s4 = n3.next.next;
            !Ep(i4, s4) && zp(i4, n3, n3.next, s4) && Cp(i4, s4) && Cp(s4, i4) && (e4.push(i4.i / r4 | 0), e4.push(n3.i / r4 | 0), e4.push(s4.i / r4 | 0), Dp(n3), Dp(n3.next), n3 = t4 = s4), n3 = n3.next;
          } while (n3 !== t4);
          return mp(n3);
        }
        function vp(t4, e4, r4, n3, i4, s4) {
          var a4 = t4;
          do {
            for (var o3 = a4.next.next; o3 !== a4.prev; ) {
              if (a4.i !== o3.i && kp(a4, o3)) {
                var l4 = Rp(a4, o3);
                return a4 = mp(a4, a4.next), l4 = mp(l4, l4.next), yp(a4, e4, r4, n3, i4, s4, 0), void yp(l4, e4, r4, n3, i4, s4, 0);
              }
              o3 = o3.next;
            }
            a4 = a4.next;
          } while (a4 !== t4);
        }
        function _p(t4, e4) {
          return t4.x - e4.x;
        }
        function wp(t4, e4) {
          var r4 = function(t5, e5) {
            var r5, n4 = e5, i4 = t5.x, s4 = t5.y, a4 = -1 / 0;
            do {
              if (s4 <= n4.y && s4 >= n4.next.y && n4.next.y !== n4.y) {
                var o3 = n4.x + (s4 - n4.y) * (n4.next.x - n4.x) / (n4.next.y - n4.y);
                if (o3 <= i4 && o3 > a4 && (a4 = o3, r5 = n4.x < n4.next.x ? n4 : n4.next, o3 === i4)) return r5;
              }
              n4 = n4.next;
            } while (n4 !== e5);
            if (!r5) return null;
            var l4, u5 = r5, c4 = r5.x, h4 = r5.y, p4 = 1 / 0;
            n4 = r5;
            do {
              i4 >= n4.x && n4.x >= c4 && i4 !== n4.x && Ip(s4 < h4 ? i4 : a4, s4, c4, h4, s4 < h4 ? a4 : i4, s4, n4.x, n4.y) && (l4 = Math.abs(s4 - n4.y) / (i4 - n4.x), Cp(n4, t5) && (l4 < p4 || l4 === p4 && (n4.x > r5.x || n4.x === r5.x && Mp(r5, n4))) && (r5 = n4, p4 = l4)), n4 = n4.next;
            } while (n4 !== u5);
            return r5;
          }(t4, e4);
          if (!r4) return e4;
          var n3 = Rp(r4, t4);
          return mp(n3, n3.next), mp(r4, r4.next);
        }
        function Mp(t4, e4) {
          return Pp(t4.prev, t4, e4.prev) < 0 && Pp(e4.next, t4, t4.next) < 0;
        }
        function Ap(t4, e4, r4, n3, i4) {
          return (t4 = 1431655765 & ((t4 = 858993459 & ((t4 = 252645135 & ((t4 = 16711935 & ((t4 = (t4 - r4) * i4 | 0) | t4 << 8)) | t4 << 4)) | t4 << 2)) | t4 << 1)) | (e4 = 1431655765 & ((e4 = 858993459 & ((e4 = 252645135 & ((e4 = 16711935 & ((e4 = (e4 - n3) * i4 | 0) | e4 << 8)) | e4 << 4)) | e4 << 2)) | e4 << 1)) << 1;
        }
        function Sp(t4) {
          var e4 = t4, r4 = t4;
          do {
            (e4.x < r4.x || e4.x === r4.x && e4.y < r4.y) && (r4 = e4), e4 = e4.next;
          } while (e4 !== t4);
          return r4;
        }
        function Ip(t4, e4, r4, n3, i4, s4, a4, o3) {
          return (i4 - a4) * (e4 - o3) >= (t4 - a4) * (s4 - o3) && (t4 - a4) * (n3 - o3) >= (r4 - a4) * (e4 - o3) && (r4 - a4) * (s4 - o3) >= (i4 - a4) * (n3 - o3);
        }
        function kp(t4, e4) {
          return t4.next.i !== e4.i && t4.prev.i !== e4.i && !function(t5, e5) {
            var r4 = t5;
            do {
              if (r4.i !== t5.i && r4.next.i !== t5.i && r4.i !== e5.i && r4.next.i !== e5.i && zp(r4, r4.next, t5, e5)) return true;
              r4 = r4.next;
            } while (r4 !== t5);
            return false;
          }(t4, e4) && (Cp(t4, e4) && Cp(e4, t4) && function(t5, e5) {
            var r4 = t5, n3 = false, i4 = (t5.x + e5.x) / 2, s4 = (t5.y + e5.y) / 2;
            do {
              r4.y > s4 != r4.next.y > s4 && r4.next.y !== r4.y && i4 < (r4.next.x - r4.x) * (s4 - r4.y) / (r4.next.y - r4.y) + r4.x && (n3 = !n3), r4 = r4.next;
            } while (r4 !== t5);
            return n3;
          }(t4, e4) && (Pp(t4.prev, t4, e4.prev) || Pp(t4, e4.prev, e4)) || Ep(t4, e4) && Pp(t4.prev, t4, t4.next) > 0 && Pp(e4.prev, e4, e4.next) > 0);
        }
        function Pp(t4, e4, r4) {
          return (e4.y - t4.y) * (r4.x - e4.x) - (e4.x - t4.x) * (r4.y - e4.y);
        }
        function Ep(t4, e4) {
          return t4.x === e4.x && t4.y === e4.y;
        }
        function zp(t4, e4, r4, n3) {
          var i4 = Bp(Pp(t4, e4, r4)), s4 = Bp(Pp(t4, e4, n3)), a4 = Bp(Pp(r4, n3, t4)), o3 = Bp(Pp(r4, n3, e4));
          return i4 !== s4 && a4 !== o3 || !(0 !== i4 || !Tp(t4, r4, e4)) || !(0 !== s4 || !Tp(t4, n3, e4)) || !(0 !== a4 || !Tp(r4, t4, n3)) || !(0 !== o3 || !Tp(r4, e4, n3));
        }
        function Tp(t4, e4, r4) {
          return e4.x <= Math.max(t4.x, r4.x) && e4.x >= Math.min(t4.x, r4.x) && e4.y <= Math.max(t4.y, r4.y) && e4.y >= Math.min(t4.y, r4.y);
        }
        function Bp(t4) {
          return t4 > 0 ? 1 : t4 < 0 ? -1 : 0;
        }
        function Cp(t4, e4) {
          return Pp(t4.prev, t4, t4.next) < 0 ? Pp(t4, e4, t4.next) >= 0 && Pp(t4, t4.prev, e4) >= 0 : Pp(t4, e4, t4.prev) < 0 || Pp(t4, t4.next, e4) < 0;
        }
        function Rp(t4, e4) {
          var r4 = new Lp(t4.i, t4.x, t4.y), n3 = new Lp(e4.i, e4.x, e4.y), i4 = t4.next, s4 = e4.prev;
          return t4.next = e4, e4.prev = t4, r4.next = i4, i4.prev = r4, n3.next = r4, r4.prev = n3, s4.next = n3, n3.prev = s4, n3;
        }
        function Vp(t4, e4, r4, n3) {
          var i4 = new Lp(t4, e4, r4);
          return n3 ? (i4.next = n3.next, i4.prev = n3, n3.next.prev = i4, n3.next = i4) : (i4.prev = i4, i4.next = i4), i4;
        }
        function Dp(t4) {
          t4.next.prev = t4.prev, t4.prev.next = t4.next, t4.prevZ && (t4.prevZ.nextZ = t4.nextZ), t4.nextZ && (t4.nextZ.prevZ = t4.prevZ);
        }
        function Lp(t4, e4, r4) {
          this.i = t4, this.x = e4, this.y = r4, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function Fp(t4, e4, r4, n3) {
          for (var i4 = 0, s4 = e4, a4 = r4 - n3; s4 < r4; s4 += n3) i4 += (t4[a4] - t4[s4]) * (t4[s4 + 1] + t4[a4 + 1]), a4 = s4;
          return i4;
        }
        pp.exports = fp, pp.exports.default = fp, fp.deviation = function(t4, e4, r4, n3) {
          var i4 = e4 && e4.length, s4 = Math.abs(Fp(t4, 0, i4 ? e4[0] * r4 : t4.length, r4));
          if (i4) for (var a4 = 0, o3 = e4.length; a4 < o3; a4++) s4 -= Math.abs(Fp(t4, e4[a4] * r4, a4 < o3 - 1 ? e4[a4 + 1] * r4 : t4.length, r4));
          var l4 = 0;
          for (a4 = 0; a4 < n3.length; a4 += 3) {
            var u5 = n3[a4] * r4, c4 = n3[a4 + 1] * r4, h4 = n3[a4 + 2] * r4;
            l4 += Math.abs((t4[u5] - t4[h4]) * (t4[c4 + 1] - t4[u5 + 1]) - (t4[u5] - t4[c4]) * (t4[h4 + 1] - t4[u5 + 1]));
          }
          return 0 === s4 && 0 === l4 ? 0 : Math.abs((l4 - s4) / s4);
        }, fp.flatten = function(t4) {
          for (var e4 = t4[0][0].length, r4 = { vertices: [], holes: [], dimensions: e4 }, n3 = 0, i4 = 0; i4 < t4.length; i4++) {
            for (var s4 = 0; s4 < t4[i4].length; s4++) for (var a4 = 0; a4 < e4; a4++) r4.vertices.push(t4[i4][s4][a4]);
            i4 > 0 && r4.holes.push(n3 += t4[i4 - 1].length);
          }
          return r4;
        };
        var Op = h3(pp.exports);
        function Up(t4, e4) {
          const r4 = t4.length;
          if (r4 <= 1) return [t4];
          const n3 = [];
          let i4, s4;
          for (let e5 = 0; e5 < r4; e5++) {
            const r5 = fr(t4[e5]);
            0 !== r5 && (t4[e5].area = Math.abs(r5), void 0 === s4 && (s4 = r5 < 0), s4 === r5 < 0 ? (i4 && n3.push(i4), i4 = [t4[e5]]) : i4.push(t4[e5]));
          }
          if (i4 && n3.push(i4), e4 > 1) for (let t5 = 0; t5 < n3.length; t5++) n3[t5].length <= e4 || (Ri(n3[t5], e4, 1, n3[t5].length - 1, Np), n3[t5] = n3[t5].slice(0, e4));
          return n3;
        }
        function Np(t4, e4) {
          return e4.area - t4.area;
        }
        function jp(t4, e4, r4) {
          const n3 = r4.patternDependencies;
          let i4 = false;
          for (const r5 of e4) {
            const e5 = r5.paint.get(`${t4}-pattern`);
            e5.isConstant() || (i4 = true);
            const s4 = e5.constantOr(null);
            s4 && (i4 = true, n3[s4] = true);
          }
          return i4;
        }
        function qp(t4, e4, r4, n3, i4) {
          const s4 = i4.patternDependencies;
          for (const a4 of e4) {
            const e5 = a4.paint.get(`${t4}-pattern`).value;
            if ("constant" !== e5.kind) {
              let t5 = e5.evaluate({ zoom: n3 }, r4, {}, i4.availableImages);
              t5 = t5 && t5.name ? t5.name : t5, s4[t5] = true, r4.patterns[a4.id] = t5;
            }
          }
          return r4;
        }
        class $p {
          constructor(t4) {
            this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.fqid), this.index = t4.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Sl(), this.indexArray = new ql(), this.indexArray2 = new Fl(), this.programConfigurations = new ju(t4.layers, t4.zoom), this.segments = new mu(), this.segments2 = new mu(), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id), this.projection = t4.projection;
          }
          populate(t4, e4, r4, n3) {
            this.hasPattern = jp("fill", this.layers, e4);
            const i4 = this.layers[0].layout.get("fill-sort-key"), s4 = [];
            for (const { feature: a4, id: o3, index: l4, sourceLayerIndex: u5 } of t4) {
              const t5 = this.layers[0]._featureFilter.needGeometry, c4 = Fc(a4, t5);
              if (!this.layers[0]._featureFilter.filter(new Uo(this.zoom), c4, r4)) continue;
              const h4 = i4 ? i4.evaluate(c4, {}, r4, e4.availableImages) : void 0, p4 = { id: o3, properties: a4.properties, type: a4.type, sourceLayerIndex: u5, index: l4, geometry: t5 ? c4.geometry : Lc(a4, r4, n3), patterns: {}, sortKey: h4 };
              s4.push(p4);
            }
            i4 && s4.sort((t5, e5) => t5.sortKey - e5.sortKey);
            for (const n4 of s4) {
              const { geometry: i5, index: s5, sourceLayerIndex: a4 } = n4;
              if (this.hasPattern) {
                const t5 = qp("fill", this.layers, n4, this.zoom, e4);
                this.patternFeatures.push(t5);
              } else this.addFeature(n4, i5, s5, r4, {}, e4.availableImages, e4.brightness);
              e4.featureIndex.insert(t4[s5].feature, i5, s5, a4, this.index);
            }
          }
          update(t4, e4, r4, n3, i4) {
            const s4 = 0 !== Object.keys(t4).length;
            s4 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t4, e4, s4 ? this.stateDependentLayers : this.layers, r4, n3, i4);
          }
          addFeatures(t4, e4, r4, n3, i4, s4) {
            for (const t5 of this.patternFeatures) this.addFeature(t5, t5.geometry, t5.index, e4, r4, n3, s4);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t4) {
            this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, hp), this.indexBuffer = t4.createIndexBuffer(this.indexArray), this.indexBuffer2 = t4.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t4), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t4, e4, r4, n3, i4, s4 = [], a4) {
            for (const t5 of Up(e4, 500)) {
              let e5 = 0;
              for (const r6 of t5) e5 += r6.length;
              const r5 = this.segments.prepareSegment(e5, this.layoutVertexArray, this.indexArray), n4 = r5.vertexLength, i5 = [], s5 = [];
              for (const e6 of t5) {
                if (0 === e6.length) continue;
                e6 !== t5[0] && s5.push(i5.length / 2);
                const r6 = this.segments2.prepareSegment(e6.length, this.layoutVertexArray, this.indexArray2), n5 = r6.vertexLength;
                this.layoutVertexArray.emplaceBack(e6[0].x, e6[0].y), this.indexArray2.emplaceBack(n5 + e6.length - 1, n5), i5.push(e6[0].x), i5.push(e6[0].y);
                for (let t6 = 1; t6 < e6.length; t6++) this.layoutVertexArray.emplaceBack(e6[t6].x, e6[t6].y), this.indexArray2.emplaceBack(n5 + t6 - 1, n5 + t6), i5.push(e6[t6].x), i5.push(e6[t6].y);
                r6.vertexLength += e6.length, r6.primitiveLength += e6.length;
              }
              const a5 = Op(i5, s5);
              for (let t6 = 0; t6 < a5.length; t6 += 3) this.indexArray.emplaceBack(n4 + a5[t6], n4 + a5[t6 + 1], n4 + a5[t6 + 2]);
              r5.vertexLength += e5, r5.primitiveLength += a5.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r4, i4, s4, n3, a4);
          }
        }
        fo($p, "FillBucket", { omit: ["layers", "patternFeatures"] });
        const Gp = new Ho({ "fill-sort-key": new Ko(el.layout_fill["fill-sort-key"]), visibility: new Zo(el.layout_fill.visibility) });
        var Qp = { paint: new Ho({ "fill-antialias": new Zo(el.paint_fill["fill-antialias"]), "fill-opacity": new Ko(el.paint_fill["fill-opacity"]), "fill-color": new Ko(el.paint_fill["fill-color"]), "fill-outline-color": new Ko(el.paint_fill["fill-outline-color"]), "fill-translate": new Zo(el.paint_fill["fill-translate"]), "fill-translate-anchor": new Zo(el.paint_fill["fill-translate-anchor"]), "fill-pattern": new Ko(el.paint_fill["fill-pattern"]), "fill-emissive-strength": new Zo(el.paint_fill["fill-emissive-strength"]) }), layout: Gp };
        const Yp = Ml([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Xp = Ml([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Zp = Ml([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Kp = Ml([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), Wp = Ml([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Hp } = Yp;
        var Jp = {}, tf = Fe, ef = rf;
        function rf(t4, e4, r4, n3, i4) {
          this.properties = {}, this.extent = r4, this.type = 0, this._pbf = t4, this._geometry = -1, this._keys = n3, this._values = i4, t4.readFields(nf, this, e4);
        }
        function nf(t4, e4, r4) {
          1 == t4 ? e4.id = r4.readVarint() : 2 == t4 ? function(t5, e5) {
            for (var r5 = t5.readVarint() + t5.pos; t5.pos < r5; ) {
              var n3 = e5._keys[t5.readVarint()], i4 = e5._values[t5.readVarint()];
              e5.properties[n3] = i4;
            }
          }(r4, e4) : 3 == t4 ? e4.type = r4.readVarint() : 4 == t4 && (e4._geometry = r4.pos);
        }
        function sf(t4) {
          for (var e4, r4, n3 = 0, i4 = 0, s4 = t4.length, a4 = s4 - 1; i4 < s4; a4 = i4++) n3 += ((r4 = t4[a4]).x - (e4 = t4[i4]).x) * (e4.y + r4.y);
          return n3;
        }
        rf.types = ["Unknown", "Point", "LineString", "Polygon"], rf.prototype.loadGeometry = function() {
          var t4 = this._pbf;
          t4.pos = this._geometry;
          for (var e4, r4 = t4.readVarint() + t4.pos, n3 = 1, i4 = 0, s4 = 0, a4 = 0, o3 = []; t4.pos < r4; ) {
            if (i4 <= 0) {
              var l4 = t4.readVarint();
              n3 = 7 & l4, i4 = l4 >> 3;
            }
            if (i4--, 1 === n3 || 2 === n3) s4 += t4.readSVarint(), a4 += t4.readSVarint(), 1 === n3 && (e4 && o3.push(e4), e4 = []), e4.push(new tf(s4, a4));
            else {
              if (7 !== n3) throw new Error("unknown command " + n3);
              e4 && e4.push(e4[0].clone());
            }
          }
          return e4 && o3.push(e4), o3;
        }, rf.prototype.bbox = function() {
          var t4 = this._pbf;
          t4.pos = this._geometry;
          for (var e4 = t4.readVarint() + t4.pos, r4 = 1, n3 = 0, i4 = 0, s4 = 0, a4 = 1 / 0, o3 = -1 / 0, l4 = 1 / 0, u5 = -1 / 0; t4.pos < e4; ) {
            if (n3 <= 0) {
              var c4 = t4.readVarint();
              r4 = 7 & c4, n3 = c4 >> 3;
            }
            if (n3--, 1 === r4 || 2 === r4) (i4 += t4.readSVarint()) < a4 && (a4 = i4), i4 > o3 && (o3 = i4), (s4 += t4.readSVarint()) < l4 && (l4 = s4), s4 > u5 && (u5 = s4);
            else if (7 !== r4) throw new Error("unknown command " + r4);
          }
          return [a4, l4, o3, u5];
        }, rf.prototype.toGeoJSON = function(t4, e4, r4) {
          var n3, i4, s4 = this.extent * Math.pow(2, r4), a4 = this.extent * t4, o3 = this.extent * e4, l4 = this.loadGeometry(), u5 = rf.types[this.type];
          function c4(t5) {
            for (var e5 = 0; e5 < t5.length; e5++) {
              var r5 = t5[e5];
              t5[e5] = [360 * (r5.x + a4) / s4 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r5.y + o3) / s4) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h4 = [];
              for (n3 = 0; n3 < l4.length; n3++) h4[n3] = l4[n3][0];
              c4(l4 = h4);
              break;
            case 2:
              for (n3 = 0; n3 < l4.length; n3++) c4(l4[n3]);
              break;
            case 3:
              for (l4 = function(t5) {
                var e5 = t5.length;
                if (e5 <= 1) return [t5];
                for (var r5, n4, i5 = [], s5 = 0; s5 < e5; s5++) {
                  var a5 = sf(t5[s5]);
                  0 !== a5 && (void 0 === n4 && (n4 = a5 < 0), n4 === a5 < 0 ? (r5 && i5.push(r5), r5 = [t5[s5]]) : r5.push(t5[s5]));
                }
                return r5 && i5.push(r5), i5;
              }(l4), n3 = 0; n3 < l4.length; n3++) for (i4 = 0; i4 < l4[n3].length; i4++) c4(l4[n3][i4]);
          }
          1 === l4.length ? l4 = l4[0] : u5 = "Multi" + u5;
          var p4 = { type: "Feature", geometry: { type: u5, coordinates: l4 }, properties: this.properties };
          return "id" in this && (p4.id = this.id), p4;
        };
        var af = ef, of2 = lf;
        function lf(t4, e4) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t4, this._keys = [], this._values = [], this._features = [], t4.readFields(uf, this, e4), this.length = this._features.length;
        }
        function uf(t4, e4, r4) {
          15 === t4 ? e4.version = r4.readVarint() : 1 === t4 ? e4.name = r4.readString() : 5 === t4 ? e4.extent = r4.readVarint() : 2 === t4 ? e4._features.push(r4.pos) : 3 === t4 ? e4._keys.push(r4.readString()) : 4 === t4 && e4._values.push(function(t5) {
            for (var e5 = null, r5 = t5.readVarint() + t5.pos; t5.pos < r5; ) {
              var n3 = t5.readVarint() >> 3;
              e5 = 1 === n3 ? t5.readString() : 2 === n3 ? t5.readFloat() : 3 === n3 ? t5.readDouble() : 4 === n3 ? t5.readVarint64() : 5 === n3 ? t5.readVarint() : 6 === n3 ? t5.readSVarint() : 7 === n3 ? t5.readBoolean() : null;
            }
            return e5;
          }(r4));
        }
        lf.prototype.feature = function(t4) {
          if (t4 < 0 || t4 >= this._features.length) throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t4];
          var e4 = this._pbf.readVarint() + this._pbf.pos;
          return new af(this._pbf, e4, this.extent, this._keys, this._values);
        };
        var cf = of2;
        function hf(t4, e4, r4) {
          if (3 === t4) {
            var n3 = new cf(r4, r4.readVarint() + r4.pos);
            n3.length && (e4[n3.name] = n3);
          }
        }
        var pf = Jp.VectorTile = function(t4, e4) {
          this.layers = t4.readFields(hf, {}, e4);
        }, ff = Jp.VectorTileFeature = ef;
        function df(t4, e4, r4, n3) {
          const i4 = [], s4 = 0 === n3 ? (t5, e5, r5, n4, i5, s5) => {
            t5.push(new Ue(s5, r5 + (s5 - e5) / (n4 - e5) * (i5 - r5)));
          } : (t5, e5, r5, n4, i5, s5) => {
            t5.push(new Ue(e5 + (s5 - r5) / (i5 - r5) * (n4 - e5), s5));
          };
          for (const a4 of t4) {
            const t5 = [];
            for (const i5 of a4) {
              if (i5.length <= 2) continue;
              const a5 = [];
              for (let t6 = 0; t6 < i5.length - 1; t6++) {
                const o4 = i5[t6].x, l5 = i5[t6].y, u5 = i5[t6 + 1].x, c4 = i5[t6 + 1].y, h4 = 0 === n3 ? o4 : l5, p4 = 0 === n3 ? u5 : c4;
                h4 < e4 ? p4 > e4 && s4(a5, o4, l5, u5, c4, e4) : h4 > r4 ? p4 < r4 && s4(a5, o4, l5, u5, c4, r4) : a5.push(i5[t6]), p4 < e4 && h4 >= e4 && s4(a5, o4, l5, u5, c4, e4), p4 > r4 && h4 <= r4 && s4(a5, o4, l5, u5, c4, r4);
              }
              let o3 = i5[i5.length - 1];
              const l4 = 0 === n3 ? o3.x : o3.y;
              l4 >= e4 && l4 <= r4 && a5.push(o3), a5.length && (o3 = a5[a5.length - 1], a5[0].x === o3.x && a5[0].y === o3.y || a5.push(a5[0]), t5.push(a5));
            }
            t5.length && i4.push(t5);
          }
          return i4;
        }
        function mf(t4, e4) {
          return t4.x - e4.x || t4.y - e4.y;
        }
        function yf(t4, e4) {
          return 0 === mf(t4.min, e4.min) && 0 === mf(t4.max, e4.max);
        }
        function gf(t4, e4) {
          return !(t4.min.x > e4.max.x || t4.max.x < e4.min.x || t4.min.y > e4.max.y || t4.max.y < e4.min.y);
        }
        function xf(t4, e4, r4) {
          const n3 = 1 / is, i4 = 1 / (1 << r4.canonical.z), s4 = (e4.x * n3 + r4.canonical.x) * i4 + r4.wrap, a4 = (e4.y * n3 + r4.canonical.y) * i4;
          return { min: new Ue((t4.x * n3 + r4.canonical.x) * i4 + r4.wrap, (t4.y * n3 + r4.canonical.y) * i4), max: new Ue(s4, a4) };
        }
        function bf(t4, e4, r4) {
          const n3 = 1 << r4.canonical.z, i4 = ((e4.x - r4.wrap) * n3 - r4.canonical.x) * is, s4 = (e4.y * n3 - r4.canonical.y) * is;
          return { min: new Ue(((t4.x - r4.wrap) * n3 - r4.canonical.x) * is, (t4.y * n3 - r4.canonical.y) * is), max: new Ue(i4, s4) };
        }
        function vf(t4, e4, r4, n3, i4, s4, a4) {
          const o3 = t4.indices, l4 = t4.vertices, u5 = [];
          for (let c4 = n3; c4 < n3 + i4; c4 += 3) {
            const n4 = e4[r4[c4 + 0] + s4], i5 = e4[r4[c4 + 1] + s4], h4 = e4[r4[c4 + 2] + s4], p4 = Math.min(n4.x, i5.x, h4.x), f4 = Math.max(n4.x, i5.x, h4.x), d3 = Math.min(n4.y, i5.y, h4.y), m4 = Math.max(n4.y, i5.y, h4.y);
            u5.length = 0, t4.grid.query(new Ue(p4, d3), new Ue(f4, m4), u5);
            for (let t5 = 0; t5 < u5.length; t5++) {
              const e5 = u5[t5];
              if (eh(l4[o3[3 * e5 + 0]], l4[o3[3 * e5 + 1]], l4[o3[3 * e5 + 2]], n4, i5, h4, a4)) return true;
            }
          }
          return false;
        }
        function _f(t4, e4, r4, n3) {
          if (!t4 || !r4) return false;
          let i4 = t4.vertices;
          if (!e4.canonical.equals(n3.canonical) || e4.wrap !== n3.wrap) {
            if (r4.vertices.length < t4.vertices.length) return _f(r4, n3, t4, e4);
            const s4 = e4.canonical, a4 = n3.canonical, o3 = Math.pow(2, a4.z - s4.z);
            i4 = t4.vertices.map((t5) => new Ue((t5.x + s4.x * is) * o3 - a4.x * is, (t5.y + s4.y * is) * o3 - a4.y * is));
          }
          return vf(r4, i4, t4.indices, 0, t4.indices.length, 0, 0);
        }
        Jp.VectorTileLayer = of2;
        class wf {
          constructor(t4) {
            this.size = t4, this.minimums = [], this.maximums = [], this.leaves = [];
          }
          getElevation(t4, e4) {
            const r4 = this.toIdx(t4, e4);
            return { min: this.minimums[r4], max: this.maximums[r4] };
          }
          isLeaf(t4, e4) {
            return this.leaves[this.toIdx(t4, e4)];
          }
          toIdx(t4, e4) {
            return e4 * this.size + t4;
          }
        }
        function Mf(t4, e4, r4, n3) {
          let i4 = 0, s4 = Number.MAX_VALUE;
          for (let a4 = 0; a4 < 3; a4++) if (Math.abs(n3[a4]) < 1e-15) {
            if (r4[a4] < t4[a4] || r4[a4] > e4[a4]) return null;
          } else {
            const o3 = 1 / n3[a4];
            let l4 = (t4[a4] - r4[a4]) * o3, u5 = (e4[a4] - r4[a4]) * o3;
            if (l4 > u5) {
              const t5 = l4;
              l4 = u5, u5 = t5;
            }
            if (l4 > i4 && (i4 = l4), u5 < s4 && (s4 = u5), i4 > s4) return null;
          }
          return i4;
        }
        function Af(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4) {
          const h4 = n3 - t4, p4 = i4 - e4, f4 = s4 - r4, d3 = a4 - t4, m4 = o3 - e4, y4 = l4 - r4, g5 = c4[1] * y4 - c4[2] * m4, x5 = c4[2] * d3 - c4[0] * y4, b4 = c4[0] * m4 - c4[1] * d3, v4 = h4 * g5 + p4 * x5 + f4 * b4;
          if (Math.abs(v4) < 1e-15) return null;
          const _4 = 1 / v4, w5 = u5[0] - t4, M3 = u5[1] - e4, A4 = u5[2] - r4, S3 = (w5 * g5 + M3 * x5 + A4 * b4) * _4;
          if (S3 < 0 || S3 > 1) return null;
          const I4 = M3 * f4 - A4 * p4, k4 = A4 * h4 - w5 * f4, P4 = w5 * p4 - M3 * h4, E3 = (c4[0] * I4 + c4[1] * k4 + c4[2] * P4) * _4;
          return E3 < 0 || S3 + E3 > 1 ? null : (d3 * I4 + m4 * k4 + y4 * P4) * _4;
        }
        function Sf(t4, e4, r4) {
          return (t4 - e4) / (r4 - e4);
        }
        function If(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
          const u5 = 1 << r4, c4 = s4 - n3, h4 = a4 - i4, p4 = (t4 + 1) / u5 * c4 + n3, f4 = (e4 + 0) / u5 * h4 + i4, d3 = (e4 + 1) / u5 * h4 + i4;
          o3[0] = (t4 + 0) / u5 * c4 + n3, o3[1] = f4, l4[0] = p4, l4[1] = d3;
        }
        class kf {
          constructor(t4) {
            if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t4, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
            const e4 = function(t5) {
              const e5 = Math.ceil(Math.log2(t5.dim / 8)), r5 = [];
              let n4 = Math.ceil(Math.pow(2, e5));
              const i4 = 1 / n4, s4 = (t6, e6, r6, n5, i5) => {
                const s5 = n5 ? 1 : 0, a5 = (t6 + 1) * r6 - s5, o4 = e6 * r6, l4 = (e6 + 1) * r6 - s5;
                i5[0] = t6 * r6, i5[1] = o4, i5[2] = a5, i5[3] = l4;
              };
              let a4 = new wf(n4);
              const o3 = [];
              for (let e6 = 0; e6 < n4 * n4; e6++) {
                s4(e6 % n4, Math.floor(e6 / n4), i4, false, o3);
                const r6 = Ef(o3[0], o3[1], t5), l4 = Ef(o3[2], o3[1], t5), u5 = Ef(o3[2], o3[3], t5), c4 = Ef(o3[0], o3[3], t5);
                a4.minimums.push(Math.min(r6, l4, u5, c4)), a4.maximums.push(Math.max(r6, l4, u5, c4)), a4.leaves.push(1);
              }
              for (r5.push(a4), n4 /= 2; n4 >= 1; n4 /= 2) {
                const t6 = r5[r5.length - 1];
                a4 = new wf(n4);
                for (let e6 = 0; e6 < n4 * n4; e6++) {
                  s4(e6 % n4, Math.floor(e6 / n4), 2, true, o3);
                  const r6 = t6.getElevation(o3[0], o3[1]), i5 = t6.getElevation(o3[2], o3[1]), l4 = t6.getElevation(o3[2], o3[3]), u5 = t6.getElevation(o3[0], o3[3]), c4 = t6.isLeaf(o3[0], o3[1]), h4 = t6.isLeaf(o3[2], o3[1]), p4 = t6.isLeaf(o3[2], o3[3]), f4 = t6.isLeaf(o3[0], o3[3]), d3 = Math.min(r6.min, i5.min, l4.min, u5.min), m4 = Math.max(r6.max, i5.max, l4.max, u5.max), y4 = c4 && h4 && p4 && f4;
                  a4.maximums.push(m4), a4.minimums.push(d3), a4.leaves.push(m4 - d3 <= 5 && y4 ? 1 : 0);
                }
                r5.push(a4);
              }
              return r5;
            }(this.dem), r4 = e4.length - 1, n3 = e4[r4];
            this._addNode(n3.minimums[0], n3.maximums[0], n3.leaves[0]), this._construct(e4, 0, 0, r4, 0);
          }
          raycastRoot(t4, e4, r4, n3, i4, s4, a4 = 1) {
            return Mf([t4, e4, -100], [r4, n3, this.maximums[0] * a4], i4, s4);
          }
          raycast(e4, r4, n3, i4, s4, a4, o3 = 1) {
            if (!this.nodeCount) return null;
            const l4 = this.raycastRoot(e4, r4, n3, i4, s4, a4, o3);
            if (null == l4) return null;
            const u5 = [], c4 = [], h4 = [], p4 = [], f4 = [{ idx: 0, t: l4, nodex: 0, nodey: 0, depth: 0 }];
            for (; f4.length > 0; ) {
              const { idx: l5, t: d3, nodex: m4, nodey: y4, depth: g5 } = f4.pop();
              if (this.leaves[l5]) {
                If(m4, y4, g5, e4, r4, n3, i4, h4, p4);
                const l6 = 1 << g5, u6 = (m4 + 0) / l6, c5 = (m4 + 1) / l6, f5 = (y4 + 0) / l6, x6 = (y4 + 1) / l6, b4 = Ef(u6, f5, this.dem) * o3, v4 = Ef(c5, f5, this.dem) * o3, _4 = Ef(c5, x6, this.dem) * o3, w5 = Ef(u6, x6, this.dem) * o3, M3 = Af(h4[0], h4[1], b4, p4[0], h4[1], v4, p4[0], p4[1], _4, s4, a4), A4 = Af(p4[0], p4[1], _4, h4[0], p4[1], w5, h4[0], h4[1], b4, s4, a4), S3 = Math.min(null !== M3 ? M3 : Number.MAX_VALUE, null !== A4 ? A4 : Number.MAX_VALUE);
                if (S3 !== Number.MAX_VALUE) return S3;
                {
                  const e5 = t3.Q.scaleAndAdd([], s4, a4, d3);
                  if (Pf(b4, v4, w5, _4, Sf(e5[0], h4[0], p4[0]), Sf(e5[1], h4[1], p4[1])) >= e5[2]) return d3;
                }
                continue;
              }
              let x5 = 0;
              for (let t4 = 0; t4 < this._siblingOffset.length; t4++) {
                If((m4 << 1) + this._siblingOffset[t4][0], (y4 << 1) + this._siblingOffset[t4][1], g5 + 1, e4, r4, n3, i4, h4, p4), h4[2] = -100, p4[2] = this.maximums[this.childOffsets[l5] + t4] * o3;
                const f5 = Mf(h4, p4, s4, a4);
                if (null != f5) {
                  const e5 = f5;
                  u5[t4] = e5;
                  let r5 = false;
                  for (let n4 = 0; n4 < x5 && !r5; n4++) e5 >= u5[c4[n4]] && (c4.splice(n4, 0, t4), r5 = true);
                  r5 || (c4[x5] = t4), x5++;
                }
              }
              for (let t4 = 0; t4 < x5; t4++) {
                const e5 = c4[t4];
                f4.push({ idx: this.childOffsets[l5] + e5, t: u5[e5], nodex: (m4 << 1) + this._siblingOffset[e5][0], nodey: (y4 << 1) + this._siblingOffset[e5][1], depth: g5 + 1 });
              }
            }
            return null;
          }
          _addNode(t4, e4, r4) {
            return this.minimums.push(t4), this.maximums.push(e4), this.leaves.push(r4), this.childOffsets.push(0), this.nodeCount++;
          }
          _construct(t4, e4, r4, n3, i4) {
            if (1 === t4[n3].isLeaf(e4, r4)) return;
            this.childOffsets[i4] || (this.childOffsets[i4] = this.nodeCount);
            const s4 = n3 - 1, a4 = t4[s4];
            let o3 = 0, l4 = 0;
            for (let t5 = 0; t5 < this._siblingOffset.length; t5++) {
              const n4 = 2 * e4 + this._siblingOffset[t5][0], i5 = 2 * r4 + this._siblingOffset[t5][1], s5 = a4.getElevation(n4, i5), u5 = a4.isLeaf(n4, i5), c4 = this._addNode(s5.min, s5.max, u5);
              u5 && (o3 |= 1 << t5), l4 || (l4 = c4);
            }
            for (let n4 = 0; n4 < this._siblingOffset.length; n4++) o3 & 1 << n4 || this._construct(t4, 2 * e4 + this._siblingOffset[n4][0], 2 * r4 + this._siblingOffset[n4][1], s4, l4 + n4);
          }
        }
        function Pf(t4, e4, r4, n3, i4, s4) {
          return qn(qn(t4, r4, s4), qn(e4, n3, s4), i4);
        }
        function Ef(t4, e4, r4) {
          const n3 = r4.dim, i4 = Ze(t4 * n3 - 0.5, 0, n3 - 1), s4 = Ze(e4 * n3 - 0.5, 0, n3 - 1), a4 = Math.floor(i4), o3 = Math.floor(s4), l4 = Math.min(a4 + 1, n3 - 1), u5 = Math.min(o3 + 1, n3 - 1);
          return Pf(r4.get(a4, o3), r4.get(l4, o3), r4.get(a4, u5), r4.get(l4, u5), i4 - a4, s4 - o3);
        }
        const zf = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
        function Tf(t4, e4, r4) {
          return (256 * t4 * 256 + 256 * e4 + r4) / 10 - 1e4;
        }
        function Bf(t4, e4, r4) {
          return 256 * t4 + e4 + r4 / 256 - 32768;
        }
        class Cf {
          get tree() {
            return this._tree || this._buildQuadTree(), this._tree;
          }
          constructor(t4, e4, r4, n3 = false) {
            if (this.uid = t4, e4.height !== e4.width) throw new RangeError("DEM tiles must be square");
            if (r4 && "mapbox" !== r4 && "terrarium" !== r4) return hr(`"${r4}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = e4.height;
            const i4 = this.dim = e4.height - 2, s4 = new Uint32Array(e4.data.buffer);
            if (this.pixels = new Uint8Array(e4.data.buffer), this.floatView = new Float32Array(e4.data.buffer), this.borderReady = n3, this._modifiedForSources = {}, !n3) {
              for (let t5 = 0; t5 < i4; t5++) s4[this._idx(-1, t5)] = s4[this._idx(0, t5)], s4[this._idx(i4, t5)] = s4[this._idx(i4 - 1, t5)], s4[this._idx(t5, -1)] = s4[this._idx(t5, 0)], s4[this._idx(t5, i4)] = s4[this._idx(t5, i4 - 1)];
              s4[this._idx(-1, -1)] = s4[this._idx(0, 0)], s4[this._idx(i4, -1)] = s4[this._idx(i4 - 1, 0)], s4[this._idx(-1, i4)] = s4[this._idx(0, i4 - 1)], s4[this._idx(i4, i4)] = s4[this._idx(i4 - 1, i4 - 1)];
            }
            const a4 = "terrarium" === r4 ? Bf : Tf;
            for (let t5 = 0; t5 < s4.length; ++t5) {
              const e5 = 4 * t5;
              this.floatView[t5] = a4(this.pixels[e5], this.pixels[e5 + 1], this.pixels[e5 + 2]);
            }
            this._timestamp = Tr.now();
          }
          _buildQuadTree() {
            this._tree = new kf(this);
          }
          get(t4, e4, r4 = false) {
            r4 && (t4 = Ze(t4, -1, this.dim), e4 = Ze(e4, -1, this.dim));
            const n3 = this._idx(t4, e4);
            return this.floatView[n3];
          }
          set(t4, e4, r4) {
            const n3 = this._idx(t4, e4), i4 = this.floatView[n3];
            return this.floatView[n3] = r4, r4 - i4;
          }
          static getUnpackVector(t4) {
            return zf[t4];
          }
          _idx(t4, e4) {
            if (t4 < -1 || t4 >= this.dim + 1 || e4 < -1 || e4 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (e4 + 1) * this.stride + (t4 + 1);
          }
          static pack(t4, e4) {
            const r4 = [0, 0, 0, 0], n3 = Cf.getUnpackVector(e4);
            let i4 = Math.floor((t4 + n3[3]) / n3[2]);
            return r4[2] = i4 % 256, i4 = Math.floor(i4 / 256), r4[1] = i4 % 256, i4 = Math.floor(i4 / 256), r4[0] = i4, r4;
          }
          getPixels() {
            return new ip({ width: this.stride, height: this.stride }, this.pixels);
          }
          backfillBorder(t4, e4, r4) {
            if (this.dim !== t4.dim) throw new Error("dem dimension mismatch");
            let n3 = e4 * this.dim, i4 = e4 * this.dim + this.dim, s4 = r4 * this.dim, a4 = r4 * this.dim + this.dim;
            switch (e4) {
              case -1:
                n3 = i4 - 1;
                break;
              case 1:
                i4 = n3 + 1;
            }
            switch (r4) {
              case -1:
                s4 = a4 - 1;
                break;
              case 1:
                a4 = s4 + 1;
            }
            const o3 = -e4 * this.dim, l4 = -r4 * this.dim;
            for (let e5 = s4; e5 < a4; e5++) for (let r5 = n3; r5 < i4; r5++) {
              const n4 = 4 * this._idx(r5, e5), i5 = 4 * this._idx(r5 + o3, e5 + l4);
              this.pixels[n4 + 0] = t4.pixels[i5 + 0], this.pixels[n4 + 1] = t4.pixels[i5 + 1], this.pixels[n4 + 2] = t4.pixels[i5 + 2], this.pixels[n4 + 3] = t4.pixels[i5 + 3];
            }
          }
          onDeserialize() {
            this._tree && (this._tree.dem = this);
          }
        }
        fo(Cf, "DEMData"), fo(kf, "DemMinMaxQuadTree", { omit: ["dem"] });
        class Rf {
          constructor(t4, e4, r4) {
            this._demTile = t4, this._dem = this._demTile.dem, this._scale = e4, this._offset = r4;
          }
          static create(t4, e4, r4) {
            const n3 = r4 || t4.findDEMTileFor(e4);
            if (!n3 || !n3.dem) return;
            const i4 = n3.dem, s4 = n3.tileID, a4 = 1 << e4.canonical.z - s4.canonical.z;
            return new Rf(n3, i4.dim / is / a4, [(e4.canonical.x / a4 - s4.canonical.x) * i4.dim, (e4.canonical.y / a4 - s4.canonical.y) * i4.dim]);
          }
          tileCoordToPixel(t4, e4) {
            const r4 = e4 * this._scale + this._offset[1], n3 = Math.floor(t4 * this._scale + this._offset[0]), i4 = Math.floor(r4);
            return new Ue(n3, i4);
          }
          getElevationAt(t4, e4, r4, n3) {
            const i4 = t4 * this._scale + this._offset[0], s4 = e4 * this._scale + this._offset[1], a4 = Math.floor(i4), o3 = Math.floor(s4), l4 = this._dem;
            return n3 = !!n3, r4 ? qn(qn(l4.get(a4, o3, n3), l4.get(a4, o3 + 1, n3), s4 - o3), qn(l4.get(a4 + 1, o3, n3), l4.get(a4 + 1, o3 + 1, n3), s4 - o3), i4 - a4) : l4.get(a4, o3, n3);
          }
          getElevationAtPixel(t4, e4, r4) {
            return this._dem.get(t4, e4, !!r4);
          }
          getMeterToDEM(t4) {
            return (1 << this._demTile.tileID.canonical.z) * vc(1, t4) * this._dem.stride;
          }
        }
        const Vf = ff.types, Df = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius"], Lf = ["fill-extrusion-flood-light-ground-radius"], Ff = Math.pow(2, 13), Of = Math.pow(2, 15) - 1, Uf = new Ue(0, 1), Nf = 2147483648;
        function jf(t4, e4, r4, n3, i4, s4, a4, o3) {
          t4.emplaceBack((e4 << 1) + a4, (r4 << 1) + s4, (Math.floor(n3 * Ff) << 1) + i4, Math.round(o3));
        }
        function qf(t4, e4, r4, n3, i4, s4) {
          t4.emplaceBack(e4.x, e4.y, (r4.x << 1) + n3, (r4.y << 1) + i4, s4);
        }
        function $f(t4, e4, r4) {
          const n3 = 16384;
          t4.emplaceBack(e4.x, e4.y, e4.z, r4[0] * n3, r4[1] * n3, r4[2] * n3);
        }
        class Gf {
          constructor() {
            this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
          }
        }
        class Qf {
          constructor() {
            this.centroidXY = new Ue(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new Ue(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new Ue(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
          }
          span() {
            return new Ue(this.max.x - this.min.x, this.max.y - this.min.y);
          }
        }
        class Yf {
          constructor() {
            this.acc = new Ue(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
          }
          startRing(t4, e4) {
            t4.min.x === Number.MAX_VALUE && (t4.min.x = t4.max.x = e4.x, t4.min.y = t4.max.y = e4.y);
          }
          appendEdge(t4, e4, r4) {
            this.accCount++, this.acc._add(e4);
            let n3 = !!this.borders;
            e4.x < t4.min.x ? (t4.min.x = e4.x, n3 = true) : e4.x > t4.max.x && (t4.max.x = e4.x, n3 = true), e4.y < t4.min.y ? (t4.min.y = e4.y, n3 = true) : e4.y > t4.max.y && (t4.max.y = e4.y, n3 = true), ((0 === e4.x || e4.x === is) && e4.x === r4.x) != ((0 === e4.y || e4.y === is) && e4.y === r4.y) && this.processBorderOverlap(e4, r4), n3 && this.checkBorderIntersection(e4, r4);
          }
          checkBorderIntersection(t4, e4) {
            e4.x < 0 != t4.x < 0 && this.addBorderIntersection(0, qn(e4.y, t4.y, (0 - e4.x) / (t4.x - e4.x))), e4.x > is != t4.x > is && this.addBorderIntersection(1, qn(e4.y, t4.y, (is - e4.x) / (t4.x - e4.x))), e4.y < 0 != t4.y < 0 && this.addBorderIntersection(2, qn(e4.x, t4.x, (0 - e4.y) / (t4.y - e4.y))), e4.y > is != t4.y > is && this.addBorderIntersection(3, qn(e4.x, t4.x, (is - e4.y) / (t4.y - e4.y)));
          }
          addBorderIntersection(t4, e4) {
            this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
            const r4 = this.borders[t4];
            e4 < r4[0] && (r4[0] = e4), e4 > r4[1] && (r4[1] = e4);
          }
          processBorderOverlap(t4, e4) {
            if (t4.x === e4.x) {
              if (t4.y === e4.y) return;
              const r4 = 0 === t4.x ? 0 : 1;
              this.addBorderIntersection(r4, e4.y), this.addBorderIntersection(r4, t4.y);
            } else {
              const r4 = 0 === t4.y ? 2 : 3;
              this.addBorderIntersection(r4, e4.x), this.addBorderIntersection(r4, t4.x);
            }
          }
          centroid() {
            return 0 === this.accCount ? new Ue(0, 0) : new Ue(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
          }
          intersectsCount() {
            return this.borders ? this.borders.reduce((t4, e4) => t4 + +(e4[0] !== Number.MAX_VALUE), 0) : 0;
          }
        }
        function Xf(t4, e4) {
          const r4 = t4.add(e4)._unit(), n3 = Ze(t4.x * r4.x + t4.y * r4.y, -1, 1);
          var i4, s4, a4;
          return i4 = Math.acos(n3), Math.min(4, Math.max(-4, Math.tan(i4))) / 4 * Of * ((s4 = t4).x * (a4 = e4).y - s4.y * a4.x < 0 ? -1 : 1);
        }
        const Zf = [(t4) => t4.x < 0, (t4) => t4.x > is, (t4) => t4.y < 0, (t4) => t4.y > is];
        function Kf(t4, e4, r4, n3) {
          const i4 = [4];
          if (0 === n3) return i4;
          r4._mult(n3);
          const s4 = t4.sub(r4), a4 = e4.sub(r4), o3 = [t4, e4, s4, a4];
          for (let t5 = 0; t5 < 4; t5++) for (const e5 of o3) if (Zf[t5](e5)) {
            i4.push(t5);
            break;
          }
          return i4;
        }
        class Wf {
          constructor(t4) {
            this.vertexArray = new Pl(), this.indexArray = new ql(), this.programConfigurations = new ju(t4.layers, t4.zoom, (t5) => Lf.includes(t5)), this._segments = new mu(), this.hiddenByLandmarkVertexArray = new eu(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new mu();
          }
          getDefaultSegment() {
            return this.regionSegments[4];
          }
          hasData() {
            return 0 !== this.vertexArray.length;
          }
          addData(t4, e4, r4, n3 = false) {
            const i4 = t4.length;
            if (i4 > 2) {
              let s4 = Math.max(0, this._segments.get().length - 1);
              const a4 = this._segments._prepareSegment(4 * i4, this.vertexArray.length, 2 * this._segmentToGroundQuads[s4].length);
              let o3;
              s4 !== this._segments.get().length - 1 && (s4++, this._segmentToGroundQuads[s4] = [], this._segmentToRegionTriCounts[s4] = [0, 0, 0, 0, 0]);
              {
                const e5 = t4[0], r5 = t4[1];
                o3 = Xf(e5.sub(t4[i4 - 1])._perp()._unit(), r5.sub(e5)._perp()._unit());
              }
              for (let l4 = 0; l4 < i4; l4++) {
                const u5 = l4 === i4 - 1 ? 0 : l4 + 1, c4 = t4[l4], h4 = t4[u5], p4 = t4[u5 === i4 - 1 ? 0 : u5 + 1], f4 = h4.sub(c4)._perp()._unit(), d3 = Xf(f4, p4.sub(h4)._perp()._unit()), m4 = o3, y4 = d3;
                if (rd(c4, h4, e4) || n3 && nd(c4, e4) && nd(h4, e4)) {
                  o3 = d3;
                  continue;
                }
                const g5 = a4.vertexLength;
                qf(this.vertexArray, c4, h4, 1, 1, m4), qf(this.vertexArray, c4, h4, 1, 0, m4), qf(this.vertexArray, c4, h4, 0, 1, y4), qf(this.vertexArray, c4, h4, 0, 0, y4), a4.vertexLength += 4;
                const x5 = Kf(c4, h4, f4, r4);
                for (const t5 of x5) this._segmentToGroundQuads[s4].push({ id: g5, region: t5 }), this._segmentToRegionTriCounts[s4][t5] += 2, a4.primitiveLength += 2;
                o3 = d3;
              }
            }
          }
          prepareBorderSegments() {
            if (!this.hasData()) return;
            const t4 = this._segments.get(), e4 = t4.length;
            for (let t5 = 0; t5 < e4; t5++) this._segmentToGroundQuads[t5].sort((t6, e5) => t6.region - e5.region);
            for (let r4 = 0; r4 < e4; r4++) {
              const e5 = this._segmentToGroundQuads[r4], n3 = t4[r4], i4 = this._segmentToRegionTriCounts[r4];
              i4.reduce((t5, e6) => t5 + e6, 0);
              let s4 = 0;
              for (let t5 = 0; t5 <= 4; t5++) {
                const e6 = i4[t5];
                if (0 !== e6) {
                  let r5 = this.regionSegments[t5];
                  r5 || (r5 = this.regionSegments[t5] = new mu());
                  const i5 = { vertexOffset: n3.vertexOffset, primitiveOffset: n3.primitiveOffset + s4, vertexLength: n3.vertexLength, primitiveLength: e6 };
                  r5.get().push(i5);
                }
                s4 += e6;
              }
              for (let t5 = 0; t5 < e5.length; t5++) {
                const r5 = e5[t5].id;
                this.indexArray.emplaceBack(r5, r5 + 1, r5 + 3), this.indexArray.emplaceBack(r5, r5 + 3, r5 + 2);
              }
            }
            this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
          }
          addPaintPropertiesData(t4, e4, r4, n3, i4, s4) {
            this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t4, e4, r4, n3, i4, s4);
          }
          upload(t4) {
            this.hasData() && (this.vertexBuffer = t4.createVertexBuffer(this.vertexArray, Xp.members), this.indexBuffer = t4.createIndexBuffer(this.indexArray));
          }
          uploadPaintProperties(t4) {
            this.hasData() && this.programConfigurations.upload(t4);
          }
          update(t4, e4, r4, n3, i4, s4) {
            this.hasData() && this.programConfigurations.updatePaintArrays(t4, e4, r4, n3, i4, s4);
          }
          updateHiddenByLandmark(t4) {
            if (!this.hasData()) return;
            const e4 = t4.groundVertexCount + t4.groundVertexArrayOffset;
            if (0 === t4.groundVertexCount) return;
            const r4 = t4.flags & Nf ? 1 : 0;
            for (let n3 = t4.groundVertexArrayOffset; n3 < e4; ++n3) this.hiddenByLandmarkVertexArray.emplace(n3, r4);
            this._needsHiddenByLandmarkUpdate = true;
          }
          uploadHiddenByLandmark(t4) {
            this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t4.createVertexBuffer(this.hiddenByLandmarkVertexArray, Kp.members, true) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = false);
          }
          destroy() {
            if (this.vertexBuffer) {
              this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
              for (let t4 = 0; t4 <= 4; t4++) {
                const e4 = this.regionSegments[t4];
                e4 && e4.destroy();
              }
            }
          }
        }
        class Hf {
          constructor(t4) {
            this.zoom = t4.zoom, this.canonical = t4.canonical, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.fqid), this.index = t4.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t4.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new ql(), this.footprintVertices = new Sl(), this.footprintSegments = [], this.layoutVertexArray = new kl(), this.centroidVertexArray = new pu(), this.indexArray = new ql(), this.programConfigurations = new ju(t4.layers, t4.zoom, (t5) => Df.includes(t5)), this.segments = new mu(), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id), this.groundEffect = new Wf(t4), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
          }
          populate(t4, e4, r4, n3) {
            this.features = [], this.hasPattern = jp("fill-extrusion", this.layers, e4), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = Pc(r4), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
            for (const { feature: i4, id: s4, index: a4, sourceLayerIndex: o3 } of t4) {
              const t5 = this.layers[0]._featureFilter.needGeometry, l4 = Fc(i4, t5);
              if (!this.layers[0]._featureFilter.filter(new Uo(this.zoom), l4, r4)) continue;
              const u5 = { id: s4, sourceLayerIndex: o3, index: a4, geometry: t5 ? l4.geometry : Lc(i4, r4, n3), properties: i4.properties, type: i4.type, patterns: {} }, c4 = this.layoutVertexArray.length;
              this.hasPattern ? this.features.push(qp("fill-extrusion", this.layers, u5, this.zoom, e4)) : this.addFeature(u5, u5.geometry, a4, r4, {}, e4.availableImages, n3, e4.brightness), e4.featureIndex.insert(i4, u5.geometry, a4, o3, this.index, c4);
            }
            this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
          }
          addFeatures(t4, e4, r4, n3, i4, s4) {
            for (const t5 of this.features) {
              const { geometry: a4 } = t5;
              this.addFeature(t5, a4, t5.index, e4, r4, n3, i4, s4);
            }
            this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
          }
          update(t4, e4, r4, n3, i4) {
            const s4 = 0 !== Object.keys(t4).length;
            if (s4 && !this.stateDependentLayers.length) return;
            const a4 = s4 ? this.stateDependentLayers : this.layers;
            this.programConfigurations.updatePaintArrays(t4, e4, a4, r4, n3, i4), this.groundEffect.update(t4, e4, a4, r4, n3, i4);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
          }
          upload(t4) {
            this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, Hp), this.indexBuffer = t4.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t4.createVertexBuffer(this.layoutVertexExtArray, Wp.members, true)), this.groundEffect.upload(t4)), this.groundEffect.uploadPaintProperties(t4), this.programConfigurations.upload(t4), this.uploaded = true;
          }
          uploadCentroid(t4) {
            this.groundEffect.uploadHiddenByLandmark(t4), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t4.createVertexBuffer(this.centroidVertexArray, Zp.members, true) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = false);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t4, e4, r4, n3, i4, s4, a4, o3) {
            const l4 = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(t4, {}) / this.tileToMeter, u5 = [new Ue(0, 0), new Ue(is, is)], c4 = a4.projection, h4 = "globe" === c4.name, p4 = "Polygon" === Vf[t4.type], f4 = new Yf();
            f4.centroidDataIndex = this.centroidData.length;
            const d3 = new Qf(), m4 = this.layers[0].paint.get("fill-extrusion-base").evaluate(t4, {}, n3) <= 0, y4 = this.layers[0].paint.get("fill-extrusion-height").evaluate(t4, {}, n3);
            d3.height = y4, d3.vertexArrayOffset = this.layoutVertexArray.length, d3.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h4 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Rl());
            const g5 = Up(e4, 500);
            for (let t5 = g5.length - 1; t5 >= 0; t5--) {
              const e5 = g5[t5];
              (0 === e5.length || (x5 = e5[0]).every((t6) => t6.x <= 0) || x5.every((t6) => t6.x >= is) || x5.every((t6) => t6.y <= 0) || x5.every((t6) => t6.y >= is)) && g5.splice(t5, 1);
            }
            var x5;
            let b4;
            if (h4) b4 = od(g5, u5, n3);
            else {
              b4 = [];
              for (const t5 of g5) b4.push({ polygon: t5, bounds: u5 });
            }
            const v4 = p4 ? this.edgeRadius : 0, _4 = v4 > 0 && this.zoom < 17, w5 = (t5, e5) => {
              if (0 === t5.length) return false;
              const r5 = t5[t5.length - 1];
              return e5.x === r5.x && e5.y === r5.y;
            };
            for (const { polygon: t5, bounds: e5 } of b4) {
              let r5 = 0, i5 = 0;
              for (const e6 of t5) p4 && !e6[0].equals(e6[e6.length - 1]) && e6.push(e6[0]), i5 += p4 ? e6.length - 1 : e6.length;
              const s5 = this.segments.prepareSegment((p4 ? 5 : 4) * i5, this.layoutVertexArray, this.indexArray);
              d3.footprintSegIdx < 0 && (d3.footprintSegIdx = this.footprintSegments.length), d3.polygonSegIdx < 0 && (d3.polygonSegIdx = this.polygonSegments.length);
              const a5 = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, o4 = new Gf();
              if (o4.vertexOffset = this.footprintVertices.length, o4.indexOffset = 3 * this.footprintIndices.length, o4.ringIndices = [], p4) {
                const i6 = [], a6 = [];
                r5 = s5.vertexLength;
                for (let r6 = 0; r6 < t5.length; r6++) {
                  const u7 = t5[r6];
                  u7.length && 0 !== r6 && a6.push(i6.length / 2);
                  const p5 = [];
                  let f5, d4;
                  f5 = u7[1].sub(u7[0])._perp()._unit(), o4.ringIndices.push(u7.length - 1);
                  for (let t6 = 1; t6 < u7.length; t6++) {
                    const e6 = u7[t6], r7 = u7[t6 === u7.length - 1 ? 1 : t6 + 1], a7 = e6.clone();
                    if (v4) {
                      d4 = r7.sub(e6)._perp()._unit();
                      const t7 = f5.add(d4)._unit(), n4 = v4 * Math.min(4, 1 / (f5.x * t7.x + f5.y * t7.y));
                      a7.x += n4 * t7.x, a7.y += n4 * t7.y, a7.x = Math.round(a7.x), a7.y = Math.round(a7.y), f5 = d4;
                    }
                    !m4 || 0 !== v4 && !_4 || w5(p5, a7) || p5.push(a7), jf(this.layoutVertexArray, a7.x, a7.y, 0, 0, 1, 1, 0), s5.vertexLength++, this.footprintVertices.emplaceBack(e6.x, e6.y), i6.push(e6.x, e6.y), h4 && $f(this.layoutVertexExtArray, c4.projectTilePoint(a7.x, a7.y, n3), c4.upVector(n3, a7.x, a7.y));
                  }
                  m4 && (0 === v4 || _4) && (0 !== p5.length && w5(p5, p5[0]) && p5.pop(), this.groundEffect.addData(p5, e5, l4));
                }
                const u6 = Op(i6, a6);
                for (let t6 = 0; t6 < u6.length; t6 += 3) this.footprintIndices.emplaceBack(o4.vertexOffset + u6[t6 + 0], o4.vertexOffset + u6[t6 + 1], o4.vertexOffset + u6[t6 + 2]), this.indexArray.emplaceBack(r5 + u6[t6], r5 + u6[t6 + 2], r5 + u6[t6 + 1]), s5.primitiveLength++;
                o4.indexCount += u6.length, o4.vertexCount += this.footprintVertices.length - o4.vertexOffset;
              }
              for (let i6 = 0; i6 < t5.length; i6++) {
                const a6 = t5[i6];
                f4.startRing(d3, a6[0]);
                let o5 = a6.length > 4 && id(a6[a6.length - 2], a6[0], a6[1]), u6 = v4 ? td(a6[a6.length - 2], a6[0], a6[1], v4) : 0;
                const y5 = [];
                let g6, x6, b5;
                x6 = a6[1].sub(a6[0])._perp()._unit();
                let _5 = true;
                for (let t6 = 1, i7 = 0; t6 < a6.length; t6++) {
                  let l5 = a6[t6 - 1], p5 = a6[t6];
                  const M3 = a6[t6 === a6.length - 1 ? 1 : t6 + 1];
                  if (f4.appendEdge(d3, p5, l5), rd(p5, l5, e5)) {
                    v4 && (x6 = M3.sub(p5)._perp()._unit(), _5 = !_5);
                    continue;
                  }
                  const A4 = p5.sub(l5)._perp(), S3 = A4.x / (Math.abs(A4.x) + Math.abs(A4.y)), I4 = A4.y > 0 ? 1 : 0, k4 = l5.dist(p5);
                  if (i7 + k4 > 32768 && (i7 = 0), v4) {
                    b5 = M3.sub(p5)._perp()._unit();
                    let t7 = ed(l5, p5, M3, Jf(x6, b5), v4);
                    isNaN(t7) && (t7 = 0);
                    const e6 = p5.sub(l5)._unit();
                    l5 = l5.add(e6.mult(u6))._round(), p5 = p5.add(e6.mult(-t7))._round(), u6 = t7, x6 = b5, m4 && this.zoom >= 17 && (w5(y5, l5) || y5.push(l5), w5(y5, p5) || y5.push(p5));
                  }
                  const P4 = s5.vertexLength, E3 = a6.length > 4 && id(l5, p5, M3);
                  let z4 = sd(i7, o5, _5);
                  if (jf(this.layoutVertexArray, l5.x, l5.y, S3, I4, 0, 0, z4), jf(this.layoutVertexArray, l5.x, l5.y, S3, I4, 0, 1, z4), i7 += k4, z4 = sd(i7, E3, !_5), o5 = E3, jf(this.layoutVertexArray, p5.x, p5.y, S3, I4, 0, 0, z4), jf(this.layoutVertexArray, p5.x, p5.y, S3, I4, 0, 1, z4), s5.vertexLength += 4, this.indexArray.emplaceBack(P4 + 0, P4 + 1, P4 + 2), this.indexArray.emplaceBack(P4 + 1, P4 + 3, P4 + 2), s5.primitiveLength += 2, v4) {
                    const n4 = r5 + (1 === t6 ? a6.length - 2 : t6 - 2), i8 = 1 === t6 ? r5 : n4 + 1;
                    if (this.indexArray.emplaceBack(P4 + 1, n4, P4 + 3), this.indexArray.emplaceBack(n4, i8, P4 + 3), s5.primitiveLength += 2, void 0 === g6 && (g6 = P4), !rd(M3, a6[t6], e5)) {
                      const e6 = t6 === a6.length - 1 ? g6 : s5.vertexLength;
                      this.indexArray.emplaceBack(P4 + 2, P4 + 3, e6), this.indexArray.emplaceBack(P4 + 3, e6 + 1, e6), this.indexArray.emplaceBack(P4 + 3, i8, e6 + 1), s5.primitiveLength += 3;
                    }
                    _5 = !_5;
                  }
                  if (h4) {
                    const t7 = this.layoutVertexExtArray, e6 = c4.projectTilePoint(l5.x, l5.y, n3), r6 = c4.projectTilePoint(p5.x, p5.y, n3), i8 = c4.upVector(n3, l5.x, l5.y), s6 = c4.upVector(n3, p5.x, p5.y);
                    $f(t7, e6, i8), $f(t7, e6, i8), $f(t7, r6, s6), $f(t7, r6, s6);
                  }
                }
                p4 && (r5 += a6.length - 1), m4 && v4 && this.zoom >= 17 && (0 !== y5.length && w5(y5, y5[0]) && y5.pop(), this.groundEffect.addData(y5, e5, l4, v4 > 0));
              }
              this.footprintSegments.push(o4), a5.triangleCount = this.indexArray.length - a5.triangleArrayOffset, this.polygonSegments.push(a5), ++d3.footprintSegLen, ++d3.polygonSegLen;
            }
            if (d3.vertexCount = this.layoutVertexArray.length - d3.vertexArrayOffset, d3.groundVertexCount = this.groundEffect.vertexArray.length - d3.groundVertexArrayOffset, 0 !== d3.vertexCount) {
              if (d3.centroidXY = f4.borders ? Uf : this.encodeCentroid(f4, d3), this.centroidData.push(d3), f4.borders) {
                this.featuresOnBorder.push(f4);
                const t5 = this.featuresOnBorder.length - 1;
                for (let e5 = 0; e5 < f4.borders.length; e5++) f4.borders[e5][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e5].push(t5);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r4, i4, s4, n3, o3), this.groundEffect.addPaintPropertiesData(t4, r4, i4, s4, n3, o3), this.maxHeight = Math.max(this.maxHeight, y4);
            }
          }
          sortBorders() {
            for (let t4 = 0; t4 < this.borderFeatureIndices.length; t4++) this.borderFeatureIndices[t4].sort((e4, r4) => this.featuresOnBorder[e4].borders[t4][0] - this.featuresOnBorder[r4].borders[t4][0]);
          }
          splitToSubtiles() {
            const t4 = [];
            for (let e5 = 0; e5 < this.centroidData.length; e5++) {
              const r5 = this.centroidData[e5], n4 = +(r5.min.y + r5.max.y > is), i5 = 2 * n4 + (+(r5.min.x + r5.max.x > is) ^ n4);
              for (let n5 = 0; n5 < r5.polygonSegLen; n5++) {
                const s5 = r5.polygonSegIdx + n5;
                t4.push({ centroidIdx: e5, subtile: i5, polygonSegmentIdx: s5, triangleSegmentIdx: this.polygonSegments[s5].triangleSegIdx });
              }
            }
            const e4 = new ql();
            t4.sort((t5, e5) => t5.triangleSegmentIdx === e5.triangleSegmentIdx ? t5.subtile - e5.subtile : t5.triangleSegmentIdx - e5.triangleSegmentIdx);
            let r4 = 0, n3 = 0, i4 = 0;
            for (const e5 of t4) {
              if (e5.triangleSegmentIdx !== r4) break;
              i4++;
            }
            const s4 = t4.length;
            for (; n3 !== t4.length; ) {
              r4 = t4[n3].triangleSegmentIdx;
              let a4 = 0, o3 = n3, l4 = n3;
              for (let e5 = o3; e5 < i4 && t4[e5].subtile === a4; e5++) l4++;
              for (; o3 !== i4; ) {
                const n4 = t4[o3];
                a4 = n4.subtile;
                const s5 = this.centroidData[n4.centroidIdx].min.clone(), u5 = this.centroidData[n4.centroidIdx].max.clone(), c4 = { vertexOffset: this.segments.segments[r4].vertexOffset, primitiveOffset: e4.length, vertexLength: this.segments.segments[r4].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
                for (let r5 = o3; r5 < l4; r5++) {
                  const n5 = t4[r5], i5 = this.polygonSegments[n5.polygonSegmentIdx], a5 = this.centroidData[n5.centroidIdx].min, o4 = this.centroidData[n5.centroidIdx].max, l5 = this.indexArray.uint16;
                  for (let t5 = i5.triangleArrayOffset; t5 < i5.triangleArrayOffset + i5.triangleCount; t5++) e4.emplaceBack(l5[3 * t5], l5[3 * t5 + 1], l5[3 * t5 + 2]);
                  c4.primitiveLength += i5.triangleCount, s5.x = Math.min(s5.x, a5.x), s5.y = Math.min(s5.y, a5.y), u5.x = Math.max(u5.x, o4.x), u5.y = Math.max(u5.y, o4.y);
                }
                c4.primitiveLength > 0 && this.triangleSubSegments.push({ segment: c4, min: s5, max: u5 }), o3 = l4;
                for (let e5 = o3; e5 < i4 && t4[e5].subtile === t4[o3].subtile; e5++) l4++;
              }
              n3 = i4;
              for (let e5 = n3; e5 < s4 && t4[e5].triangleSegmentIdx === t4[n3].triangleSegmentIdx; e5++) i4++;
            }
            e4._trim(), this.indexArray = e4;
          }
          getVisibleSegments(t4, e4, r4) {
            let n3 = 0, i4 = 0;
            const s4 = 1 << t4.canonical.z;
            if (e4) {
              const r5 = e4.getMinMaxForTile(t4);
              r5 && (n3 = r5.min, i4 = r5.max);
            }
            i4 += this.maxHeight;
            const a4 = t4.toUnwrapped();
            let o3;
            const l4 = [a4.canonical.x / s4 + a4.wrap, a4.canonical.y / s4], u5 = [(a4.canonical.x + 1) / s4 + a4.wrap, (a4.canonical.y + 1) / s4], c4 = new mu(), h4 = (t5, e5, r5) => [t5[0] * (1 - r5[0]) + e5[0] * r5[0], t5[1] * (1 - r5[1]) + e5[1] * r5[1]], p4 = [], f4 = [];
            for (const t5 of this.triangleSubSegments) {
              p4[0] = t5.min.x / is, p4[1] = t5.min.y / is, f4[0] = t5.max.x / is, f4[1] = t5.max.y / is;
              const e5 = h4(l4, u5, p4), s5 = h4(l4, u5, f4);
              if (0 === new mh([e5[0], e5[1], n3], [s5[0], s5[1], i4]).intersectsPrecise(r4)) {
                o3 && (c4.segments.push(o3), o3 = void 0);
                continue;
              }
              const a5 = t5.segment;
              o3 && o3.vertexOffset !== a5.vertexOffset && (c4.segments.push(o3), o3 = void 0), o3 ? (o3.vertexLength += a5.vertexLength, o3.primitiveLength += a5.primitiveLength) : o3 = { vertexOffset: a5.vertexOffset, primitiveLength: a5.primitiveLength, vertexLength: a5.vertexLength, primitiveOffset: a5.primitiveOffset, sortKey: void 0, vaos: {} };
            }
            return o3 && c4.segments.push(o3), c4;
          }
          encodeCentroid(t4, e4) {
            const r4 = t4.centroid(), n3 = e4.span(), i4 = Math.min(7, Math.round(n3.x * this.tileToMeter / 10)), s4 = Math.min(7, Math.round(n3.y * this.tileToMeter / 10));
            return new Ue(Ze(r4.x, 1, is - 1) << 3 | i4, Ze(r4.y, 1, is - 1) << 3 | s4);
          }
          encodeBorderCentroid(t4) {
            if (!t4.borders) return new Ue(0, 0);
            const e4 = t4.borders, r4 = Number.MAX_VALUE;
            if (e4[0][0] !== r4 || e4[1][0] !== r4) {
              const t5 = e4[0][0] !== r4 ? 0 : 1;
              return new Ue(6 | (e4[0][0] !== r4 ? 0 : 65528), (e4[t5][0] + e4[t5][1]) / 2 << 3 | 6);
            }
            {
              const t5 = e4[2][0] !== r4 ? 2 : 3;
              return new Ue((e4[t5][0] + e4[t5][1]) / 2 << 3 | 6, 6 | (e4[2][0] !== r4 ? 0 : 65528));
            }
          }
          showCentroid(t4) {
            const e4 = this.centroidData[t4.centroidDataIndex];
            e4.flags &= Nf, e4.centroidXY.x = 0, e4.centroidXY.y = 0, this.writeCentroidToBuffer(e4);
          }
          writeCentroidToBuffer(t4) {
            this.groundEffect.updateHiddenByLandmark(t4);
            const e4 = t4.vertexArrayOffset, r4 = t4.vertexCount + t4.vertexArrayOffset, n3 = t4.flags & Nf ? Uf : t4.centroidXY, i4 = this.centroidVertexArray.geta_centroid_pos0(e4);
            if (this.centroidVertexArray.geta_centroid_pos1(e4) !== n3.y || i4 !== n3.x) {
              for (let t5 = e4; t5 < r4; ++t5) this.centroidVertexArray.emplace(t5, n3.x, n3.y);
              this.needsCentroidUpdate = true;
            }
          }
          createCentroidsBuffer() {
            this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
            for (const t4 of this.centroidData) this.writeCentroidToBuffer(t4);
          }
          updateReplacement(t4, e4) {
            if (e4.updateTime === this.replacementUpdateTime) return;
            this.replacementUpdateTime = e4.updateTime;
            const r4 = e4.getReplacementRegionsForTile(t4.toUnwrapped());
            if (function(t5, e5) {
              if (t5.length !== e5.length) return false;
              for (let r5 = 0; r5 < t5.length; r5++) if (t5[r5].sourceId !== e5[r5].sourceId || !yf(t5[r5], e5[r5])) return false;
              return true;
            }(this.activeReplacements, r4)) return;
            if (this.activeReplacements = r4, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();
            else for (const t5 of this.centroidData) t5.flags &= 2147483647;
            const n3 = [];
            for (const e5 of this.activeReplacements) {
              const r5 = Math.pow(2, e5.footprintTileId.canonical.z - t4.canonical.z);
              for (const i4 of this.centroidData) if (!(i4.flags & Nf || e5.min.x > i4.max.x || i4.min.x > e5.max.x || e5.min.y > i4.max.y || i4.min.y > e5.max.y)) for (let s4 = 0; s4 < i4.footprintSegLen; s4++) {
                const a4 = this.footprintSegments[i4.footprintSegIdx + s4];
                if (n3.length = 0, ld(this.footprintVertices, a4.vertexOffset, a4.vertexCount, e5.footprintTileId.canonical, t4.canonical, n3), vf(e5.footprint, n3, this.footprintIndices.uint16, a4.indexOffset, a4.indexCount, -a4.vertexOffset, -r5)) {
                  i4.flags |= Nf;
                  break;
                }
              }
            }
            for (const t5 of this.centroidData) this.writeCentroidToBuffer(t5);
            this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
          }
          footprintContainsPoint(t4, e4, r4) {
            let n3 = false;
            for (let i4 = 0; i4 < r4.footprintSegLen; i4++) {
              const s4 = this.footprintSegments[r4.footprintSegIdx + i4];
              let a4 = 0;
              for (const r5 of s4.ringIndices) {
                for (let i5 = a4, o3 = r5 + a4 - 1; i5 < r5 + a4; o3 = i5++) {
                  const r6 = this.footprintVertices.int16[2 * (i5 + s4.vertexOffset) + 0], a5 = this.footprintVertices.int16[2 * (i5 + s4.vertexOffset) + 1], l4 = this.footprintVertices.int16[2 * (o3 + s4.vertexOffset) + 1];
                  a5 > e4 != l4 > e4 && t4 < (this.footprintVertices.int16[2 * (o3 + s4.vertexOffset) + 0] - r6) * (e4 - a5) / (l4 - a5) + r6 && (n3 = !n3);
                }
                a4 = r5;
              }
            }
            return n3;
          }
          getHeightAtTileCoord(t4, e4) {
            let r4 = Number.NEGATIVE_INFINITY, n3 = true;
            const i4 = 4 * (t4 + is) * is + (e4 + is);
            if (this.partLookup.hasOwnProperty(i4)) {
              const t5 = this.partLookup[i4];
              return t5 ? { height: t5.height, hidden: !!(t5.flags & Nf) } : void 0;
            }
            for (const s4 of this.centroidData) t4 > s4.max.x || s4.min.x > t4 || e4 > s4.max.y || s4.min.y > e4 || this.footprintContainsPoint(t4, e4, s4) && s4 && s4.height > r4 && (r4 = s4.height, this.partLookup[i4] = s4, n3 = !!(s4.flags & Nf));
            if (r4 !== Number.NEGATIVE_INFINITY) return { height: r4, hidden: n3 };
            this.partLookup[i4] = void 0;
          }
        }
        function Jf(t4, e4) {
          const r4 = t4.add(e4)._unit();
          return t4.x * r4.x + t4.y * r4.y;
        }
        function td(t4, e4, r4, n3) {
          const i4 = e4.sub(t4)._perp()._unit(), s4 = r4.sub(e4)._perp()._unit();
          return ed(t4, e4, r4, Jf(i4, s4), n3);
        }
        function ed(t4, e4, r4, n3, i4) {
          const s4 = Math.sqrt(1 - n3 * n3);
          return Math.min(t4.dist(e4) / 3, e4.dist(r4) / 3, i4 * s4 / n3);
        }
        function rd(t4, e4, r4) {
          return t4.x < r4[0].x && e4.x < r4[0].x || t4.x > r4[1].x && e4.x > r4[1].x || t4.y < r4[0].y && e4.y < r4[0].y || t4.y > r4[1].y && e4.y > r4[1].y;
        }
        function nd(t4, e4) {
          return t4.x < e4[0].x || t4.x > e4[1].x || t4.y < e4[0].y || t4.y > e4[1].y;
        }
        function id(t4, e4, r4) {
          if (t4.x < 0 || t4.x >= is || e4.x < 0 || e4.x >= is || r4.x < 0 || r4.x >= is) return false;
          const n3 = r4.sub(e4), i4 = n3.perp(), s4 = t4.sub(e4);
          return (n3.x * s4.x + n3.y * s4.y) / Math.sqrt((n3.x * n3.x + n3.y * n3.y) * (s4.x * s4.x + s4.y * s4.y)) > -0.866 && i4.x * s4.x + i4.y * s4.y < 0;
        }
        function sd(t4, e4, r4) {
          const n3 = e4 ? 2 | t4 : -3 & t4;
          return r4 ? 1 | n3 : -2 & n3;
        }
        function ad() {
          const t4 = Math.PI / 32, e4 = Math.tan(t4), r4 = ic;
          return r4 * Math.sqrt(1 + 2 * e4 * e4) - r4;
        }
        function od(t4, e4, r4) {
          const n3 = 1 << r4.z, i4 = _c(r4.x / n3), s4 = _c((r4.x + 1) / n3), a4 = wc(r4.y / n3), o3 = wc((r4.y + 1) / n3);
          return function(t5, e5, r5, n4, i5 = 0, s5) {
            const a5 = [];
            if (!t5.length || !r5 || !n4) return a5;
            const o4 = (t6, e6) => {
              for (const r6 of t6) a5.push({ polygon: r6, bounds: e6 });
            }, l4 = Math.ceil(Math.log2(r5)), u5 = Math.ceil(Math.log2(n4)), c4 = l4 - u5, h4 = [];
            for (let t6 = 0; t6 < Math.abs(c4); t6++) h4.push(c4 > 0 ? 0 : 1);
            for (let t6 = 0; t6 < Math.min(l4, u5); t6++) h4.push(0), h4.push(1);
            let p4 = t5;
            if (p4 = df(p4, e5[0].y - i5, e5[1].y + i5, 1), p4 = df(p4, e5[0].x - i5, e5[1].x + i5, 0), !p4.length) return a5;
            const f4 = [];
            for (h4.length ? f4.push({ polygons: p4, bounds: e5, depth: 0 }) : o4(p4, e5); f4.length; ) {
              const t6 = f4.pop(), e6 = t6.depth, r6 = h4[e6], n5 = t6.bounds[0], a6 = t6.bounds[1], l5 = 0 === r6 ? n5.x : n5.y, u6 = 0 === r6 ? a6.x : a6.y, c5 = s5 ? s5(r6, l5, u6) : 0.5 * (l5 + u6), p5 = df(t6.polygons, l5 - i5, c5 + i5, r6), d3 = df(t6.polygons, c5 - i5, u6 + i5, r6);
              if (p5.length) {
                const t7 = [n5, new Ue(0 === r6 ? c5 : a6.x, 1 === r6 ? c5 : a6.y)];
                h4.length > e6 + 1 ? f4.push({ polygons: p5, bounds: t7, depth: e6 + 1 }) : o4(p5, t7);
              }
              if (d3.length) {
                const t7 = [new Ue(0 === r6 ? c5 : n5.x, 1 === r6 ? c5 : n5.y), a6];
                h4.length > e6 + 1 ? f4.push({ polygons: d3, bounds: t7, depth: e6 + 1 }) : o4(d3, t7);
              }
            }
            return a5;
          }(t4, e4, Math.ceil((s4 - i4) / 11.25), Math.ceil((a4 - o3) / 11.25), 1, (t5, e5, i5) => {
            if (0 === t5) return 0.5 * (e5 + i5);
            {
              const t6 = wc((r4.y + e5 / is) / n3);
              return (bc(0.5 * (wc((r4.y + i5 / is) / n3) + t6)) * n3 - r4.y) * is;
            }
          });
        }
        function ld(t4, e4, r4, n3, i4, s4) {
          const a4 = Math.pow(2, n3.z - i4.z);
          for (let o3 = 0; o3 < r4; o3++) {
            let r5 = t4.int16[2 * (o3 + e4) + 0], l4 = t4.int16[2 * (o3 + e4) + 1];
            r5 = (r5 + i4.x * is) * a4 - n3.x * is, l4 = (l4 + i4.y * is) * a4 - n3.y * is, s4.push(new Ue(r5, l4));
          }
        }
        fo(Hf, "FillExtrusionBucket", { omit: ["layers", "features"] }), fo(Qf, "PartData"), fo(Gf, "FootprintSegment"), fo(Yf, "BorderCentroidData"), fo(Wf, "GroundEffect");
        const ud = new Ho({ visibility: new Zo(el["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new Zo(el["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
        var cd = { paint: new Ho({ "fill-extrusion-opacity": new Zo(el["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ko(el["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Zo(el["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Zo(el["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Ko(el["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ko(el["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ko(el["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Zo(el["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Zo(el["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Zo(el["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new Zo(el["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new Zo(el["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new Zo(el["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new Zo(el["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new Zo(el["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new Ko(el["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new Ko(el["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new Zo(el["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new Zo(el["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new Zo(el["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new Zo(el["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new Zo(el["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]) }), layout: ud };
        class hd extends Ue {
          constructor(t4, e4, r4) {
            super(t4, e4), this.z = r4;
          }
        }
        function pd(t4, e4) {
          return t4.x * e4.x + t4.y * e4.y;
        }
        function fd(t4, e4) {
          if (1 === t4.length) {
            let r4 = 0;
            const n3 = e4[r4++];
            let i4;
            for (; !i4 || n3.equals(i4); ) if (i4 = e4[r4++], !i4) return 1 / 0;
            for (; r4 < e4.length; r4++) {
              const s4 = e4[r4], a4 = t4[0], o3 = i4.sub(n3), l4 = s4.sub(n3), u5 = a4.sub(n3), c4 = pd(o3, o3), h4 = pd(o3, l4), p4 = pd(l4, l4), f4 = pd(u5, o3), d3 = pd(u5, l4), m4 = c4 * p4 - h4 * h4, y4 = (p4 * f4 - h4 * d3) / m4, g5 = (c4 * d3 - h4 * f4) / m4, x5 = n3.z * (1 - y4 - g5) + i4.z * y4 + s4.z * g5;
              if (isFinite(x5)) return x5;
            }
            return 1 / 0;
          }
          {
            let t5 = 1 / 0;
            for (const r4 of e4) t5 = Math.min(t5, r4.z);
            return t5;
          }
        }
        function dd(t4, e4, r4, n3, i4, s4, a4, o3) {
          const l4 = a4 * i4.getElevationAt(t4, e4, true, true), u5 = 0 !== s4[0], c4 = u5 ? 0 === s4[1] ? a4 * (s4[0] / 7 - 450) : a4 * function(t5, e5, r5) {
            const n4 = Math.floor(e5[0] / 8), i5 = Math.floor(e5[1] / 8), s5 = 10 * (e5[0] - 8 * n4), a5 = 10 * (e5[1] - 8 * i5), o4 = t5.getElevationAt(n4, i5, true, true), l5 = t5.getMeterToDEM(r5), u6 = Math.floor(0.5 * (s5 * l5 - 1)), c5 = Math.floor(0.5 * (a5 * l5 - 1)), h4 = t5.tileCoordToPixel(n4, i5), p4 = 2 * u6 + 1, f4 = 2 * c5 + 1, d3 = function(t6, e6, r6, n5, i6) {
              return [t6.getElevationAtPixel(e6, r6, true), t6.getElevationAtPixel(e6 + i6, r6, true), t6.getElevationAtPixel(e6, r6 + i6, true), t6.getElevationAtPixel(e6 + n5, r6 + i6, true)];
            }(t5, h4.x - u6, h4.y - c5, p4, f4), m4 = Math.abs(d3[0] - d3[1]), y4 = Math.abs(d3[2] - d3[3]), g5 = Math.abs(d3[0] - d3[2]) + Math.abs(d3[1] - d3[3]), x5 = Math.min(0.25, 0.5 * l5 * (m4 + y4) / p4), b4 = Math.min(0.25, 0.5 * l5 * g5 / f4);
            return o4 + Math.max(x5 * s5, b4 * a5);
          }(i4, s4, o3) : l4;
          return { base: l4 + (0 === r4) ? -1 : r4, top: u5 ? Math.max(c4 + n3, l4 + r4 + 2) : l4 + n3 };
        }
        const md = Ml([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: yd } = md, gd = Ml([{ name: "a_packed", components: 4, type: "Float32" }]), { members: xd } = gd, bd = Ml([{ name: "a_pattern_data", components: 2, type: "Float32" }]), { members: vd } = bd;
        class _d {
          constructor(t4, e4) {
            this.width = t4, this.height = e4, this.nextRow = 0, this.image = new rp({ width: t4, height: e4 }), this.positions = {}, this.uploaded = false;
          }
          getDash(t4, e4) {
            const r4 = this.getKey(t4, e4);
            return this.positions[r4];
          }
          trim() {
            const t4 = this.width, e4 = this.height = nr(this.nextRow);
            this.image.resize({ width: t4, height: e4 });
          }
          getKey(t4, e4) {
            return t4.join(",") + e4;
          }
          getDashRanges(t4, e4, r4) {
            const n3 = [];
            let i4 = t4.length % 2 == 1 ? -t4[t4.length - 1] * r4 : 0, s4 = t4[0] * r4, a4 = true;
            n3.push({ left: i4, right: s4, isDash: a4, zeroLength: 0 === t4[0] });
            let o3 = t4[0];
            for (let e5 = 1; e5 < t4.length; e5++) {
              a4 = !a4;
              const l4 = t4[e5];
              i4 = o3 * r4, o3 += l4, s4 = o3 * r4, n3.push({ left: i4, right: s4, isDash: a4, zeroLength: 0 === l4 });
            }
            return n3;
          }
          addRoundDash(t4, e4, r4) {
            const n3 = e4 / 2;
            for (let e5 = -r4; e5 <= r4; e5++) {
              const i4 = this.width * (this.nextRow + r4 + e5);
              let s4 = 0, a4 = t4[s4];
              for (let o3 = 0; o3 < this.width; o3++) {
                o3 / a4.right > 1 && (a4 = t4[++s4]);
                const l4 = Math.abs(o3 - a4.left), u5 = Math.abs(o3 - a4.right), c4 = Math.min(l4, u5);
                let h4;
                const p4 = e5 / r4 * (n3 + 1);
                if (a4.isDash) {
                  const t5 = n3 - Math.abs(p4);
                  h4 = Math.sqrt(c4 * c4 + t5 * t5);
                } else h4 = n3 - Math.sqrt(c4 * c4 + p4 * p4);
                this.image.data[i4 + o3] = Math.max(0, Math.min(255, h4 + 128));
              }
            }
          }
          addRegularDash(t4, e4) {
            for (let e5 = t4.length - 1; e5 >= 0; --e5) {
              const r5 = t4[e5], n4 = t4[e5 + 1];
              r5.zeroLength ? t4.splice(e5, 1) : n4 && n4.isDash === r5.isDash && (n4.left = r5.left, t4.splice(e5, 1));
            }
            const r4 = t4[0], n3 = t4[t4.length - 1];
            r4.isDash === n3.isDash && (r4.left = n3.left - this.width, n3.right = r4.right + this.width);
            const i4 = this.width * this.nextRow;
            let s4 = 0, a4 = t4[s4];
            for (let r5 = 0; r5 < this.width; r5++) {
              r5 / a4.right > 1 && (a4 = t4[++s4]);
              const n4 = Math.abs(r5 - a4.left), o3 = Math.abs(r5 - a4.right), l4 = Math.min(n4, o3);
              this.image.data[i4 + r5] = Math.max(0, Math.min(255, (a4.isDash ? l4 : -l4) + e4 + 128));
            }
          }
          addDash(t4, e4) {
            const r4 = this.getKey(t4, e4);
            if (this.positions[r4]) return this.positions[r4];
            const n3 = "round" === e4, i4 = n3 ? 7 : 0, s4 = 2 * i4 + 1;
            if (this.nextRow + s4 > this.height) return hr("LineAtlas out of space"), null;
            0 === t4.length && t4.push(1);
            let a4 = 0;
            for (let e5 = 0; e5 < t4.length; e5++) t4[e5] < 0 && (hr("Negative value is found in line dasharray, replacing values with 0"), t4[e5] = 0), a4 += t4[e5];
            if (0 !== a4) {
              const r5 = this.width / a4, s5 = this.getDashRanges(t4, this.width, r5);
              n3 ? this.addRoundDash(s5, r5, i4) : this.addRegularDash(s5, "square" === e4 ? 0.5 * r5 : 0);
            }
            const o3 = this.nextRow + i4;
            this.nextRow += s4;
            const l4 = { tl: [o3, i4], br: [a4, 0] };
            return this.positions[r4] = l4, l4;
          }
        }
        fo(_d, "LineAtlas");
        const wd = ff.types, Md = Math.cos(Math.PI / 180 * 37.5), Ad = Math.cos(Math.PI / 180 * 5);
        class Sd {
          constructor(t4) {
            this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.fqid), this.index = t4.index, this.projection = t4.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t5) => {
              this.gradients[t5.id] = {};
            }), this.layoutVertexArray = new El(), this.layoutVertexArray2 = new zl(), this.patternVertexArray = new Tl(), this.indexArray = new ql(), this.programConfigurations = new ju(t4.layers, t4.zoom), this.segments = new mu(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id);
          }
          populate(t4, e4, r4, n3) {
            this.hasPattern = jp("line", this.layers, e4);
            const i4 = this.layers[0].layout.get("line-sort-key"), s4 = [];
            for (const { feature: e5, id: a5, index: o4, sourceLayerIndex: l5 } of t4) {
              const t5 = this.layers[0]._featureFilter.needGeometry, u5 = Fc(e5, t5);
              if (!this.layers[0]._featureFilter.filter(new Uo(this.zoom), u5, r4)) continue;
              const c4 = i4 ? i4.evaluate(u5, {}, r4) : void 0, h4 = { id: a5, properties: e5.properties, type: e5.type, sourceLayerIndex: l5, index: o4, geometry: t5 ? u5.geometry : Lc(e5, r4, n3), patterns: {}, sortKey: c4 };
              s4.push(h4);
            }
            i4 && s4.sort((t5, e5) => t5.sortKey - e5.sortKey);
            const { lineAtlas: a4, featureIndex: o3 } = e4, l4 = this.addConstantDashes(a4);
            for (const n4 of s4) {
              const { geometry: i5, index: s5, sourceLayerIndex: u5 } = n4;
              if (l4 && this.addFeatureDashes(n4, a4), this.hasPattern) {
                const t5 = qp("line", this.layers, n4, this.zoom, e4);
                this.patternFeatures.push(t5);
              } else this.addFeature(n4, i5, s5, r4, a4.positions, e4.availableImages, e4.brightness);
              o3.insert(t4[s5].feature, i5, s5, u5, this.index);
            }
          }
          addConstantDashes(t4) {
            let e4 = false;
            for (const r4 of this.layers) {
              const n3 = r4.paint.get("line-dasharray").value, i4 = r4.layout.get("line-cap").value;
              if ("constant" !== n3.kind || "constant" !== i4.kind) e4 = true;
              else {
                const e5 = i4.value, r5 = n3.value;
                if (!r5) continue;
                t4.addDash(r5, e5);
              }
            }
            return e4;
          }
          addFeatureDashes(t4, e4) {
            const r4 = this.zoom;
            for (const n3 of this.layers) {
              const i4 = n3.paint.get("line-dasharray").value, s4 = n3.layout.get("line-cap").value;
              if ("constant" === i4.kind && "constant" === s4.kind) continue;
              let a4, o3;
              if ("constant" === i4.kind) {
                if (a4 = i4.value, !a4) continue;
              } else a4 = i4.evaluate({ zoom: r4 }, t4);
              o3 = "constant" === s4.kind ? s4.value : s4.evaluate({ zoom: r4 }, t4), e4.addDash(a4, o3), t4.patterns[n3.id] = e4.getKey(a4, o3);
            }
          }
          update(t4, e4, r4, n3, i4) {
            const s4 = 0 !== Object.keys(t4).length;
            s4 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t4, e4, s4 ? this.stateDependentLayers : this.layers, r4, n3, i4);
          }
          addFeatures(t4, e4, r4, n3, i4, s4) {
            for (const t5 of this.patternFeatures) this.addFeature(t5, t5.geometry, t5.index, e4, r4, n3, s4);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t4) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t4.createVertexBuffer(this.layoutVertexArray2, xd)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t4.createVertexBuffer(this.patternVertexArray, vd)), this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, yd), this.indexBuffer = t4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t4), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t4) {
            if (t4.properties && t4.properties.hasOwnProperty("mapbox_clip_start") && t4.properties.hasOwnProperty("mapbox_clip_end")) return { start: +t4.properties.mapbox_clip_start, end: +t4.properties.mapbox_clip_end };
          }
          addFeature(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = this.layers[0].layout, l4 = o3.get("line-join").evaluate(t4, {}), u5 = o3.get("line-cap").evaluate(t4, {}), c4 = o3.get("line-miter-limit"), h4 = o3.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t4);
            for (const r5 of e4) this.addLine(r5, t4, l4, u5, c4, h4);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r4, i4, s4, n3, a4);
          }
          addLine(t4, e4, r4, n3, i4, s4) {
            this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0;
            const a4 = "none" === r4;
            if (this.patternJoinNone = this.hasPattern && a4, this.segmentStart = 0, this.segmentPoints = [], this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e5 = 0; e5 < t4.length - 1; e5++) this.totalDistance += t4[e5].dist(t4[e5 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const o3 = "Polygon" === wd[e4.type];
            let l4 = t4.length;
            for (; l4 >= 2 && t4[l4 - 1].equals(t4[l4 - 2]); ) l4--;
            let u5 = 0;
            for (; u5 < l4 - 1 && t4[u5].equals(t4[u5 + 1]); ) u5++;
            if (l4 < (o3 ? 3 : 2)) return;
            "bevel" === r4 && (i4 = 1.05);
            const c4 = this.overscaling <= 16 ? 15 * is / (512 * this.overscaling) : 0, h4 = this.segments.prepareSegment(10 * l4, this.layoutVertexArray, this.indexArray);
            let p4, f4, d3, m4, y4;
            this.e1 = this.e2 = -1, o3 && (p4 = t4[l4 - 2], y4 = t4[u5].sub(p4)._unit()._perp());
            for (let e5 = u5; e5 < l4; e5++) {
              if (d3 = e5 === l4 - 1 ? o3 ? t4[u5 + 1] : void 0 : t4[e5 + 1], d3 && t4[e5].equals(d3)) continue;
              y4 && (m4 = y4), p4 && (f4 = p4), p4 = t4[e5], y4 = d3 ? d3.sub(p4)._unit()._perp() : m4, m4 = m4 || y4;
              const g5 = f4 && d3;
              let x5 = g5 ? r4 : o3 || a4 ? "butt" : n3;
              const b4 = m4.x * y4.x + m4.y * y4.y;
              if (a4) {
                const t5 = function(t6) {
                  if (t6.patternJoinNone) {
                    const e6 = t6.segmentPoints.length / 2, r5 = t6.lineSoFar - t6.segmentStart;
                    for (let n4 = 0; n4 < e6; ++n4) {
                      const e7 = t6.segmentPoints[2 * n4 + 1], i5 = Math.round(t6.segmentPoints[2 * n4]) + 0.5 + 0.25 * e7;
                      t6.patternVertexArray.emplaceBack(i5, r5), t6.patternVertexArray.emplaceBack(i5, r5);
                    }
                    t6.segmentPoints = [], t6.segmentStart = t6.lineSoFar;
                  }
                  t6.e1 = t6.e2 = -1;
                };
                if (g5 && b4 < Ad) {
                  this.updateDistance(f4, p4), this.addCurrentVertex(p4, m4, 1, 1, h4), t5(this), this.addCurrentVertex(p4, y4, -1, -1, h4);
                  continue;
                }
                if (f4) {
                  if (!d3) {
                    this.updateDistance(f4, p4), this.addCurrentVertex(p4, m4, 1, 1, h4), t5(this);
                    continue;
                  }
                  x5 = "miter";
                }
              }
              let v4 = m4.add(y4);
              0 === v4.x && 0 === v4.y || v4._unit();
              const _4 = v4.x * y4.x + v4.y * y4.y, w5 = 0 !== _4 ? 1 / _4 : 1 / 0, M3 = 2 * Math.sqrt(2 - 2 * _4), A4 = _4 < Md && f4 && d3, S3 = m4.x * y4.y - m4.y * y4.x > 0;
              if (A4 && e5 > u5) {
                const t5 = p4.dist(f4);
                if (t5 > 2 * c4) {
                  const e6 = p4.sub(p4.sub(f4)._mult(c4 / t5)._round());
                  this.updateDistance(f4, e6), this.addCurrentVertex(e6, m4, 0, 0, h4), f4 = e6;
                }
              }
              if (g5 && "round" === x5 && (w5 < s4 ? x5 = "miter" : w5 <= 2 && (x5 = "fakeround")), "miter" === x5 && w5 > i4 && (x5 = "bevel"), "bevel" === x5 && (w5 > 2 && (x5 = "flipbevel"), w5 < i4 && (x5 = "miter")), f4 && this.updateDistance(f4, p4), "miter" === x5) v4._mult(w5), this.addCurrentVertex(p4, v4, 0, 0, h4);
              else if ("flipbevel" === x5) {
                if (w5 > 100) v4 = y4.mult(-1);
                else {
                  const t5 = w5 * m4.add(y4).mag() / m4.sub(y4).mag();
                  v4._perp()._mult(t5 * (S3 ? -1 : 1));
                }
                this.addCurrentVertex(p4, v4, 0, 0, h4), this.addCurrentVertex(p4, v4.mult(-1), 0, 0, h4);
              } else if ("bevel" === x5 || "fakeround" === x5) {
                const t5 = -Math.sqrt(w5 * w5 - 1), e6 = S3 ? t5 : 0, r5 = S3 ? 0 : t5;
                if (f4 && this.addCurrentVertex(p4, m4, e6, r5, h4), "fakeround" === x5) {
                  const t6 = Math.round(180 * M3 / Math.PI / 20);
                  for (let e7 = 1; e7 < t6; e7++) {
                    let r6 = e7 / t6;
                    if (0.5 !== r6) {
                      const t7 = r6 - 0.5;
                      r6 += r6 * t7 * (r6 - 1) * ((1.0904 + b4 * (b4 * (3.55645 - 1.43519 * b4) - 3.2452)) * t7 * t7 + (0.848013 + b4 * (0.215638 * b4 - 1.06021)));
                    }
                    const n4 = y4.sub(m4)._mult(r6)._add(m4)._unit()._mult(S3 ? -1 : 1);
                    this.addHalfVertex(p4, n4.x, n4.y, false, S3, 0, h4);
                  }
                }
                d3 && this.addCurrentVertex(p4, y4, -e6, -r5, h4);
              } else "butt" === x5 ? this.addCurrentVertex(p4, v4, 0, 0, h4) : "square" === x5 ? (f4 || this.addCurrentVertex(p4, v4, -1, -1, h4), this.addCurrentVertex(p4, v4, 0, 0, h4), f4 && this.addCurrentVertex(p4, v4, 1, 1, h4)) : "round" === x5 && (f4 && (this.addCurrentVertex(p4, m4, 0, 0, h4), this.addCurrentVertex(p4, m4, 1, 1, h4, true)), d3 && (this.addCurrentVertex(p4, y4, -1, -1, h4, true), this.addCurrentVertex(p4, y4, 0, 0, h4)));
              if (A4 && e5 < l4 - 1) {
                const t5 = p4.dist(d3);
                if (t5 > 2 * c4) {
                  const e6 = p4.add(d3.sub(p4)._mult(c4 / t5)._round());
                  this.updateDistance(p4, e6), this.addCurrentVertex(e6, y4, 0, 0, h4), p4 = e6;
                }
              }
            }
          }
          addCurrentVertex(t4, e4, r4, n3, i4, s4 = false) {
            const a4 = e4.y * n3 - e4.x, o3 = -e4.y - e4.x * n3;
            this.addHalfVertex(t4, e4.x + e4.y * r4, e4.y - e4.x * r4, s4, false, r4, i4), this.addHalfVertex(t4, a4, o3, s4, true, -n3, i4), this.patternJoinNone && this.segmentPoints.push(this.lineSoFar - this.segmentStart, r4);
          }
          addHalfVertex({ x: t4, y: e4 }, r4, n3, i4, s4, a4, o3) {
            this.layoutVertexArray.emplaceBack((t4 << 1) + (i4 ? 1 : 0), (e4 << 1) + (s4 ? 1 : 0), Math.round(63 * r4) + 128, Math.round(63 * n3) + 128, 1 + (0 === a4 ? 0 : a4 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
            const l4 = o3.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l4), o3.primitiveLength++), s4 ? this.e2 = l4 : this.e1 = l4;
          }
          updateScaledDistance() {
            if (this.lineClips) {
              const t4 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
              this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t4 * this.lineClips.start + this.distance;
            } else this.lineSoFar = this.distance;
          }
          updateDistance(t4, e4) {
            this.distance += t4.dist(e4), this.updateScaledDistance();
          }
        }
        fo(Sd, "LineBucket", { omit: ["layers", "patternFeatures"] });
        const Id = new Ho({ "line-cap": new Ko(el.layout_line["line-cap"]), "line-join": new Ko(el.layout_line["line-join"]), "line-miter-limit": new Zo(el.layout_line["line-miter-limit"]), "line-round-limit": new Zo(el.layout_line["line-round-limit"]), "line-sort-key": new Ko(el.layout_line["line-sort-key"]), visibility: new Zo(el.layout_line.visibility) });
        var kd = { paint: new Ho({ "line-opacity": new Ko(el.paint_line["line-opacity"]), "line-color": new Ko(el.paint_line["line-color"]), "line-translate": new Zo(el.paint_line["line-translate"]), "line-translate-anchor": new Zo(el.paint_line["line-translate-anchor"]), "line-width": new Ko(el.paint_line["line-width"]), "line-gap-width": new Ko(el.paint_line["line-gap-width"]), "line-offset": new Ko(el.paint_line["line-offset"]), "line-blur": new Ko(el.paint_line["line-blur"]), "line-dasharray": new Ko(el.paint_line["line-dasharray"]), "line-pattern": new Ko(el.paint_line["line-pattern"]), "line-gradient": new Wo(el.paint_line["line-gradient"]), "line-trim-offset": new Zo(el.paint_line["line-trim-offset"]), "line-emissive-strength": new Zo(el.paint_line["line-emissive-strength"]), "line-border-width": new Ko(el.paint_line["line-border-width"]), "line-border-color": new Ko(el.paint_line["line-border-color"]) }), layout: Id };
        function Pd(t4, e4, r4) {
          return e4 * (is / (t4.tileSize * Math.pow(2, r4 - t4.tileID.overscaledZ)));
        }
        function Ed(t4, e4) {
          return 1 / Pd(t4, 1, e4.tileZoom);
        }
        function zd(t4, e4, r4, n3) {
          return t4.translatePosMatrix(n3 || e4.tileID.projMatrix, e4, r4.paint.get("line-translate"), r4.paint.get("line-translate-anchor"));
        }
        const Td = (t4) => {
          const e4 = [];
          Bd(t4) && e4.push("RENDER_LINE_DASH"), t4.paint.get("line-gradient") && e4.push("RENDER_LINE_GRADIENT");
          const r4 = t4.paint.get("line-trim-offset");
          0 === r4[0] && 0 === r4[1] || e4.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t4.paint.get("line-border-width").constantOr(1) && e4.push("RENDER_LINE_BORDER");
          const n3 = "none" === t4.layout.get("line-join").constantOr("miter"), i4 = !!t4.paint.get("line-pattern").constantOr(1);
          return n3 && i4 && e4.push("LINE_JOIN_NONE"), e4;
        };
        function Bd(t4) {
          const e4 = t4.paint.get("line-dasharray").value;
          return e4.value || "constant" !== e4.kind;
        }
        const Cd = new class extends Ko {
          possiblyEvaluate(t4, e4) {
            return e4 = new Uo(Math.floor(e4.zoom), { now: e4.now, fadeDuration: e4.fadeDuration, transition: e4.transition }), super.possiblyEvaluate(t4, e4);
          }
          evaluate(t4, e4, r4, n3) {
            return e4 = Je({}, e4, { zoom: Math.floor(e4.zoom) }), super.evaluate(t4, e4, r4, n3);
          }
        }(kd.paint.properties["line-width"].specification);
        function Rd(t4, e4) {
          return e4 > 0 ? e4 + 2 * t4 : t4;
        }
        Cd.useIntegerZoom = true;
        const Vd = Ml([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Dd = Ml([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Ld = Ml([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
        Ml([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Fd = Ml([{ name: "a_z_offset", components: 1, type: "Float32" }], 4), Od = Ml([{ name: "a_texb", components: 2, type: "Uint16" }]), Ud = Ml([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), Nd = Ml([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_z_offset", components: 1, type: "Float32" }]);
        Ml([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const jd = Ml([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), qd = Ml([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        Ml([{ name: "triangle", components: 3, type: "Uint16" }]), Ml([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Ml([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }]), Ml([{ type: "Float32", name: "offsetX" }]), Ml([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
        var $d = 24;
        const Gd = 128;
        function Qd(t4, e4) {
          const { expression: r4 } = e4;
          if ("constant" === r4.kind) return { kind: "constant", layoutSize: r4.evaluate(new Uo(t4 + 1)) };
          if ("source" === r4.kind) return { kind: "source" };
          {
            const { zoomStops: e5, interpolationType: n3 } = r4;
            let i4 = 0;
            for (; i4 < e5.length && e5[i4] <= t4; ) i4++;
            i4 = Math.max(0, i4 - 1);
            let s4 = i4;
            for (; s4 < e5.length && e5[s4] < t4 + 1; ) s4++;
            s4 = Math.min(e5.length - 1, s4);
            const a4 = e5[i4], o3 = e5[s4];
            return "composite" === r4.kind ? { kind: "composite", minZoom: a4, maxZoom: o3, interpolationType: n3 } : { kind: "camera", minZoom: a4, maxZoom: o3, minSize: r4.evaluate(new Uo(a4)), maxSize: r4.evaluate(new Uo(o3)), interpolationType: n3 };
          }
        }
        function Yd(t4, { uSize: e4, uSizeT: r4 }, { lowerSize: n3, upperSize: i4 }) {
          return "source" === t4.kind ? n3 / Gd : "composite" === t4.kind ? qn(n3 / Gd, i4 / Gd, r4) : e4;
        }
        function Xd(t4, e4) {
          let r4 = 0, n3 = 0;
          if ("constant" === t4.kind) n3 = t4.layoutSize;
          else if ("source" !== t4.kind) {
            const { interpolationType: i4, minZoom: s4, maxZoom: a4 } = t4, o3 = i4 ? Ze(ha.interpolationFactor(i4, e4, s4, a4), 0, 1) : 0;
            "camera" === t4.kind ? n3 = qn(t4.minSize, t4.maxSize, o3) : r4 = o3;
          }
          return { uSizeT: r4, uSize: n3 };
        }
        var Zd = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: Gd, evaluateSizeForFeature: Yd, evaluateSizeForZoom: Xd, getSizeData: Qd });
        function Kd(t4, e4, r4) {
          return t4.sections.forEach((t5) => {
            t5.text = function(t6, e5, r5) {
              const n3 = e5.layout.get("text-transform").evaluate(r5, {});
              return "uppercase" === n3 ? t6 = t6.toLocaleUpperCase() : "lowercase" === n3 && (t6 = t6.toLocaleLowerCase()), Oo.applyArabicShaping && (t6 = Oo.applyArabicShaping(t6)), t6;
            }(t5.text, e4, r4);
          }), t4;
        }
        const Wd = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42", "\u2190": "\u2191", "\u2192": "\u2193" };
        function Hd(t4) {
          return "\uFE36" === t4 || "\uFE48" === t4 || "\uFE38" === t4 || "\uFE44" === t4 || "\uFE42" === t4 || "\uFE3E" === t4 || "\uFE3C" === t4 || "\uFE3A" === t4 || "\uFE18" === t4 || "\uFE40" === t4 || "\uFE10" === t4 || "\uFE13" === t4 || "\uFE14" === t4 || "\uFF40" === t4 || "\uFFE3" === t4 || "\uFE11" === t4 || "\uFE12" === t4;
        }
        function Jd(t4) {
          return "\uFE35" === t4 || "\uFE47" === t4 || "\uFE37" === t4 || "\uFE43" === t4 || "\uFE41" === t4 || "\uFE3D" === t4 || "\uFE3B" === t4 || "\uFE39" === t4 || "\uFE17" === t4 || "\uFE3F" === t4;
        }
        var tm = {
          /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
          read: function(t4, e4, r4, n3, i4) {
            var s4, a4, o3 = 8 * i4 - n3 - 1, l4 = (1 << o3) - 1, u5 = l4 >> 1, c4 = -7, h4 = r4 ? i4 - 1 : 0, p4 = r4 ? -1 : 1, f4 = t4[e4 + h4];
            for (h4 += p4, s4 = f4 & (1 << -c4) - 1, f4 >>= -c4, c4 += o3; c4 > 0; s4 = 256 * s4 + t4[e4 + h4], h4 += p4, c4 -= 8) ;
            for (a4 = s4 & (1 << -c4) - 1, s4 >>= -c4, c4 += n3; c4 > 0; a4 = 256 * a4 + t4[e4 + h4], h4 += p4, c4 -= 8) ;
            if (0 === s4) s4 = 1 - u5;
            else {
              if (s4 === l4) return a4 ? NaN : 1 / 0 * (f4 ? -1 : 1);
              a4 += Math.pow(2, n3), s4 -= u5;
            }
            return (f4 ? -1 : 1) * a4 * Math.pow(2, s4 - n3);
          },
          write: function(t4, e4, r4, n3, i4, s4) {
            var a4, o3, l4, u5 = 8 * s4 - i4 - 1, c4 = (1 << u5) - 1, h4 = c4 >> 1, p4 = 23 === i4 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f4 = n3 ? 0 : s4 - 1, d3 = n3 ? 1 : -1, m4 = e4 < 0 || 0 === e4 && 1 / e4 < 0 ? 1 : 0;
            for (e4 = Math.abs(e4), isNaN(e4) || e4 === 1 / 0 ? (o3 = isNaN(e4) ? 1 : 0, a4 = c4) : (a4 = Math.floor(Math.log(e4) / Math.LN2), e4 * (l4 = Math.pow(2, -a4)) < 1 && (a4--, l4 *= 2), (e4 += a4 + h4 >= 1 ? p4 / l4 : p4 * Math.pow(2, 1 - h4)) * l4 >= 2 && (a4++, l4 /= 2), a4 + h4 >= c4 ? (o3 = 0, a4 = c4) : a4 + h4 >= 1 ? (o3 = (e4 * l4 - 1) * Math.pow(2, i4), a4 += h4) : (o3 = e4 * Math.pow(2, h4 - 1) * Math.pow(2, i4), a4 = 0)); i4 >= 8; t4[r4 + f4] = 255 & o3, f4 += d3, o3 /= 256, i4 -= 8) ;
            for (a4 = a4 << i4 | o3, u5 += i4; u5 > 0; t4[r4 + f4] = 255 & a4, f4 += d3, a4 /= 256, u5 -= 8) ;
            t4[r4 + f4 - d3] |= 128 * m4;
          }
        }, em = nm, rm = tm;
        function nm(t4) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t4) ? t4 : new Uint8Array(t4 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        nm.Varint = 0, nm.Fixed64 = 1, nm.Bytes = 2, nm.Fixed32 = 5;
        var im = 4294967296, sm = 1 / im, am = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function om(t4) {
          return t4.type === nm.Bytes ? t4.readVarint() + t4.pos : t4.pos + 1;
        }
        function lm(t4, e4, r4) {
          return r4 ? 4294967296 * e4 + (t4 >>> 0) : 4294967296 * (e4 >>> 0) + (t4 >>> 0);
        }
        function um(t4, e4, r4) {
          var n3 = e4 <= 16383 ? 1 : e4 <= 2097151 ? 2 : e4 <= 268435455 ? 3 : Math.floor(Math.log(e4) / (7 * Math.LN2));
          r4.realloc(n3);
          for (var i4 = r4.pos - 1; i4 >= t4; i4--) r4.buf[i4 + n3] = r4.buf[i4];
        }
        function cm(t4, e4) {
          for (var r4 = 0; r4 < t4.length; r4++) e4.writeVarint(t4[r4]);
        }
        function hm(t4, e4) {
          for (var r4 = 0; r4 < t4.length; r4++) e4.writeSVarint(t4[r4]);
        }
        function pm(t4, e4) {
          for (var r4 = 0; r4 < t4.length; r4++) e4.writeFloat(t4[r4]);
        }
        function fm(t4, e4) {
          for (var r4 = 0; r4 < t4.length; r4++) e4.writeDouble(t4[r4]);
        }
        function dm(t4, e4) {
          for (var r4 = 0; r4 < t4.length; r4++) e4.writeBoolean(t4[r4]);
        }
        function mm(t4, e4) {
          for (var r4 = 0; r4 < t4.length; r4++) e4.writeFixed32(t4[r4]);
        }
        function ym(t4, e4) {
          for (var r4 = 0; r4 < t4.length; r4++) e4.writeSFixed32(t4[r4]);
        }
        function gm(t4, e4) {
          for (var r4 = 0; r4 < t4.length; r4++) e4.writeFixed64(t4[r4]);
        }
        function xm(t4, e4) {
          for (var r4 = 0; r4 < t4.length; r4++) e4.writeSFixed64(t4[r4]);
        }
        function bm(t4, e4) {
          return (t4[e4] | t4[e4 + 1] << 8 | t4[e4 + 2] << 16) + 16777216 * t4[e4 + 3];
        }
        function vm(t4, e4, r4) {
          t4[r4] = e4, t4[r4 + 1] = e4 >>> 8, t4[r4 + 2] = e4 >>> 16, t4[r4 + 3] = e4 >>> 24;
        }
        function _m(t4, e4) {
          return (t4[e4] | t4[e4 + 1] << 8 | t4[e4 + 2] << 16) + (t4[e4 + 3] << 24);
        }
        nm.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t4, e4, r4) {
          for (r4 = r4 || this.length; this.pos < r4; ) {
            var n3 = this.readVarint(), i4 = n3 >> 3, s4 = this.pos;
            this.type = 7 & n3, t4(i4, e4, this), this.pos === s4 && this.skip(n3);
          }
          return e4;
        }, readMessage: function(t4, e4) {
          return this.readFields(t4, e4, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t4 = bm(this.buf, this.pos);
          return this.pos += 4, t4;
        }, readSFixed32: function() {
          var t4 = _m(this.buf, this.pos);
          return this.pos += 4, t4;
        }, readFixed64: function() {
          var t4 = bm(this.buf, this.pos) + bm(this.buf, this.pos + 4) * im;
          return this.pos += 8, t4;
        }, readSFixed64: function() {
          var t4 = bm(this.buf, this.pos) + _m(this.buf, this.pos + 4) * im;
          return this.pos += 8, t4;
        }, readFloat: function() {
          var t4 = rm.read(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t4;
        }, readDouble: function() {
          var t4 = rm.read(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t4;
        }, readVarint: function(t4) {
          var e4, r4, n3 = this.buf;
          return e4 = 127 & (r4 = n3[this.pos++]), r4 < 128 ? e4 : (e4 |= (127 & (r4 = n3[this.pos++])) << 7, r4 < 128 ? e4 : (e4 |= (127 & (r4 = n3[this.pos++])) << 14, r4 < 128 ? e4 : (e4 |= (127 & (r4 = n3[this.pos++])) << 21, r4 < 128 ? e4 : function(t5, e5, r5) {
            var n4, i4, s4 = r5.buf;
            if (n4 = (112 & (i4 = s4[r5.pos++])) >> 4, i4 < 128) return lm(t5, n4, e5);
            if (n4 |= (127 & (i4 = s4[r5.pos++])) << 3, i4 < 128) return lm(t5, n4, e5);
            if (n4 |= (127 & (i4 = s4[r5.pos++])) << 10, i4 < 128) return lm(t5, n4, e5);
            if (n4 |= (127 & (i4 = s4[r5.pos++])) << 17, i4 < 128) return lm(t5, n4, e5);
            if (n4 |= (127 & (i4 = s4[r5.pos++])) << 24, i4 < 128) return lm(t5, n4, e5);
            if (n4 |= (1 & (i4 = s4[r5.pos++])) << 31, i4 < 128) return lm(t5, n4, e5);
            throw new Error("Expected varint not more than 10 bytes");
          }(e4 |= (15 & (r4 = n3[this.pos])) << 28, t4, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t4 = this.readVarint();
          return t4 % 2 == 1 ? (t4 + 1) / -2 : t4 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t4 = this.readVarint() + this.pos, e4 = this.pos;
          return this.pos = t4, t4 - e4 >= 12 && am ? function(t5, e5, r4) {
            return am.decode(t5.subarray(e5, r4));
          }(this.buf, e4, t4) : function(t5, e5, r4) {
            for (var n3 = "", i4 = e5; i4 < r4; ) {
              var s4, a4, o3, l4 = t5[i4], u5 = null, c4 = l4 > 239 ? 4 : l4 > 223 ? 3 : l4 > 191 ? 2 : 1;
              if (i4 + c4 > r4) break;
              1 === c4 ? l4 < 128 && (u5 = l4) : 2 === c4 ? 128 == (192 & (s4 = t5[i4 + 1])) && (u5 = (31 & l4) << 6 | 63 & s4) <= 127 && (u5 = null) : 3 === c4 ? (a4 = t5[i4 + 2], 128 == (192 & (s4 = t5[i4 + 1])) && 128 == (192 & a4) && ((u5 = (15 & l4) << 12 | (63 & s4) << 6 | 63 & a4) <= 2047 || u5 >= 55296 && u5 <= 57343) && (u5 = null)) : 4 === c4 && (a4 = t5[i4 + 2], o3 = t5[i4 + 3], 128 == (192 & (s4 = t5[i4 + 1])) && 128 == (192 & a4) && 128 == (192 & o3) && ((u5 = (15 & l4) << 18 | (63 & s4) << 12 | (63 & a4) << 6 | 63 & o3) <= 65535 || u5 >= 1114112) && (u5 = null)), null === u5 ? (u5 = 65533, c4 = 1) : u5 > 65535 && (u5 -= 65536, n3 += String.fromCharCode(u5 >>> 10 & 1023 | 55296), u5 = 56320 | 1023 & u5), n3 += String.fromCharCode(u5), i4 += c4;
            }
            return n3;
          }(this.buf, e4, t4);
        }, readBytes: function() {
          var t4 = this.readVarint() + this.pos, e4 = this.buf.subarray(this.pos, t4);
          return this.pos = t4, e4;
        }, readPackedVarint: function(t4, e4) {
          if (this.type !== nm.Bytes) return t4.push(this.readVarint(e4));
          var r4 = om(this);
          for (t4 = t4 || []; this.pos < r4; ) t4.push(this.readVarint(e4));
          return t4;
        }, readPackedSVarint: function(t4) {
          if (this.type !== nm.Bytes) return t4.push(this.readSVarint());
          var e4 = om(this);
          for (t4 = t4 || []; this.pos < e4; ) t4.push(this.readSVarint());
          return t4;
        }, readPackedBoolean: function(t4) {
          if (this.type !== nm.Bytes) return t4.push(this.readBoolean());
          var e4 = om(this);
          for (t4 = t4 || []; this.pos < e4; ) t4.push(this.readBoolean());
          return t4;
        }, readPackedFloat: function(t4) {
          if (this.type !== nm.Bytes) return t4.push(this.readFloat());
          var e4 = om(this);
          for (t4 = t4 || []; this.pos < e4; ) t4.push(this.readFloat());
          return t4;
        }, readPackedDouble: function(t4) {
          if (this.type !== nm.Bytes) return t4.push(this.readDouble());
          var e4 = om(this);
          for (t4 = t4 || []; this.pos < e4; ) t4.push(this.readDouble());
          return t4;
        }, readPackedFixed32: function(t4) {
          if (this.type !== nm.Bytes) return t4.push(this.readFixed32());
          var e4 = om(this);
          for (t4 = t4 || []; this.pos < e4; ) t4.push(this.readFixed32());
          return t4;
        }, readPackedSFixed32: function(t4) {
          if (this.type !== nm.Bytes) return t4.push(this.readSFixed32());
          var e4 = om(this);
          for (t4 = t4 || []; this.pos < e4; ) t4.push(this.readSFixed32());
          return t4;
        }, readPackedFixed64: function(t4) {
          if (this.type !== nm.Bytes) return t4.push(this.readFixed64());
          var e4 = om(this);
          for (t4 = t4 || []; this.pos < e4; ) t4.push(this.readFixed64());
          return t4;
        }, readPackedSFixed64: function(t4) {
          if (this.type !== nm.Bytes) return t4.push(this.readSFixed64());
          var e4 = om(this);
          for (t4 = t4 || []; this.pos < e4; ) t4.push(this.readSFixed64());
          return t4;
        }, skip: function(t4) {
          var e4 = 7 & t4;
          if (e4 === nm.Varint) for (; this.buf[this.pos++] > 127; ) ;
          else if (e4 === nm.Bytes) this.pos = this.readVarint() + this.pos;
          else if (e4 === nm.Fixed32) this.pos += 4;
          else {
            if (e4 !== nm.Fixed64) throw new Error("Unimplemented type: " + e4);
            this.pos += 8;
          }
        }, writeTag: function(t4, e4) {
          this.writeVarint(t4 << 3 | e4);
        }, realloc: function(t4) {
          for (var e4 = this.length || 16; e4 < this.pos + t4; ) e4 *= 2;
          if (e4 !== this.length) {
            var r4 = new Uint8Array(e4);
            r4.set(this.buf), this.buf = r4, this.length = e4;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t4) {
          this.realloc(4), vm(this.buf, t4, this.pos), this.pos += 4;
        }, writeSFixed32: function(t4) {
          this.realloc(4), vm(this.buf, t4, this.pos), this.pos += 4;
        }, writeFixed64: function(t4) {
          this.realloc(8), vm(this.buf, -1 & t4, this.pos), vm(this.buf, Math.floor(t4 * sm), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t4) {
          this.realloc(8), vm(this.buf, -1 & t4, this.pos), vm(this.buf, Math.floor(t4 * sm), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t4) {
          (t4 = +t4 || 0) > 268435455 || t4 < 0 ? function(t5, e4) {
            var r4, n3;
            if (t5 >= 0 ? (r4 = t5 % 4294967296 | 0, n3 = t5 / 4294967296 | 0) : (n3 = ~(-t5 / 4294967296), 4294967295 ^ (r4 = ~(-t5 % 4294967296)) ? r4 = r4 + 1 | 0 : (r4 = 0, n3 = n3 + 1 | 0)), t5 >= 18446744073709552e3 || t5 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
            e4.realloc(10), function(t6, e5, r5) {
              r5.buf[r5.pos++] = 127 & t6 | 128, t6 >>>= 7, r5.buf[r5.pos++] = 127 & t6 | 128, t6 >>>= 7, r5.buf[r5.pos++] = 127 & t6 | 128, t6 >>>= 7, r5.buf[r5.pos++] = 127 & t6 | 128, r5.buf[r5.pos] = 127 & (t6 >>>= 7);
            }(r4, 0, e4), function(t6, e5) {
              var r5 = (7 & t6) << 4;
              e5.buf[e5.pos++] |= r5 | ((t6 >>>= 3) ? 128 : 0), t6 && (e5.buf[e5.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e5.buf[e5.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e5.buf[e5.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e5.buf[e5.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e5.buf[e5.pos++] = 127 & t6)))));
            }(n3, e4);
          }(t4, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t4 | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = 127 & (t4 >>>= 7) | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = 127 & (t4 >>>= 7) | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = t4 >>> 7 & 127))));
        }, writeSVarint: function(t4) {
          this.writeVarint(t4 < 0 ? 2 * -t4 - 1 : 2 * t4);
        }, writeBoolean: function(t4) {
          this.writeVarint(Boolean(t4));
        }, writeString: function(t4) {
          t4 = String(t4), this.realloc(4 * t4.length), this.pos++;
          var e4 = this.pos;
          this.pos = function(t5, e5, r5) {
            for (var n3, i4, s4 = 0; s4 < e5.length; s4++) {
              if ((n3 = e5.charCodeAt(s4)) > 55295 && n3 < 57344) {
                if (!i4) {
                  n3 > 56319 || s4 + 1 === e5.length ? (t5[r5++] = 239, t5[r5++] = 191, t5[r5++] = 189) : i4 = n3;
                  continue;
                }
                if (n3 < 56320) {
                  t5[r5++] = 239, t5[r5++] = 191, t5[r5++] = 189, i4 = n3;
                  continue;
                }
                n3 = i4 - 55296 << 10 | n3 - 56320 | 65536, i4 = null;
              } else i4 && (t5[r5++] = 239, t5[r5++] = 191, t5[r5++] = 189, i4 = null);
              n3 < 128 ? t5[r5++] = n3 : (n3 < 2048 ? t5[r5++] = n3 >> 6 | 192 : (n3 < 65536 ? t5[r5++] = n3 >> 12 | 224 : (t5[r5++] = n3 >> 18 | 240, t5[r5++] = n3 >> 12 & 63 | 128), t5[r5++] = n3 >> 6 & 63 | 128), t5[r5++] = 63 & n3 | 128);
            }
            return r5;
          }(this.buf, t4, this.pos);
          var r4 = this.pos - e4;
          r4 >= 128 && um(e4, r4, this), this.pos = e4 - 1, this.writeVarint(r4), this.pos += r4;
        }, writeFloat: function(t4) {
          this.realloc(4), rm.write(this.buf, t4, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t4) {
          this.realloc(8), rm.write(this.buf, t4, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t4) {
          var e4 = t4.length;
          this.writeVarint(e4), this.realloc(e4);
          for (var r4 = 0; r4 < e4; r4++) this.buf[this.pos++] = t4[r4];
        }, writeRawMessage: function(t4, e4) {
          this.pos++;
          var r4 = this.pos;
          t4(e4, this);
          var n3 = this.pos - r4;
          n3 >= 128 && um(r4, n3, this), this.pos = r4 - 1, this.writeVarint(n3), this.pos += n3;
        }, writeMessage: function(t4, e4, r4) {
          this.writeTag(t4, nm.Bytes), this.writeRawMessage(e4, r4);
        }, writePackedVarint: function(t4, e4) {
          e4.length && this.writeMessage(t4, cm, e4);
        }, writePackedSVarint: function(t4, e4) {
          e4.length && this.writeMessage(t4, hm, e4);
        }, writePackedBoolean: function(t4, e4) {
          e4.length && this.writeMessage(t4, dm, e4);
        }, writePackedFloat: function(t4, e4) {
          e4.length && this.writeMessage(t4, pm, e4);
        }, writePackedDouble: function(t4, e4) {
          e4.length && this.writeMessage(t4, fm, e4);
        }, writePackedFixed32: function(t4, e4) {
          e4.length && this.writeMessage(t4, mm, e4);
        }, writePackedSFixed32: function(t4, e4) {
          e4.length && this.writeMessage(t4, ym, e4);
        }, writePackedFixed64: function(t4, e4) {
          e4.length && this.writeMessage(t4, gm, e4);
        }, writePackedSFixed64: function(t4, e4) {
          e4.length && this.writeMessage(t4, xm, e4);
        }, writeBytesField: function(t4, e4) {
          this.writeTag(t4, nm.Bytes), this.writeBytes(e4);
        }, writeFixed32Field: function(t4, e4) {
          this.writeTag(t4, nm.Fixed32), this.writeFixed32(e4);
        }, writeSFixed32Field: function(t4, e4) {
          this.writeTag(t4, nm.Fixed32), this.writeSFixed32(e4);
        }, writeFixed64Field: function(t4, e4) {
          this.writeTag(t4, nm.Fixed64), this.writeFixed64(e4);
        }, writeSFixed64Field: function(t4, e4) {
          this.writeTag(t4, nm.Fixed64), this.writeSFixed64(e4);
        }, writeVarintField: function(t4, e4) {
          this.writeTag(t4, nm.Varint), this.writeVarint(e4);
        }, writeSVarintField: function(t4, e4) {
          this.writeTag(t4, nm.Varint), this.writeSVarint(e4);
        }, writeStringField: function(t4, e4) {
          this.writeTag(t4, nm.Bytes), this.writeString(e4);
        }, writeFloatField: function(t4, e4) {
          this.writeTag(t4, nm.Fixed32), this.writeFloat(e4);
        }, writeDoubleField: function(t4, e4) {
          this.writeTag(t4, nm.Fixed64), this.writeDouble(e4);
        }, writeBooleanField: function(t4, e4) {
          this.writeVarintField(t4, Boolean(e4));
        } };
        var wm = h3(em);
        const Mm = 3;
        function Am(t4, e4, r4) {
          e4.glyphs = [], 1 === t4 && r4.readMessage(Sm, e4);
        }
        function Sm(t4, e4, r4) {
          if (3 === t4) {
            const { id: t5, bitmap: n3, width: i4, height: s4, left: a4, top: o3, advance: l4 } = r4.readMessage(Im, {});
            e4.glyphs.push({ id: t5, bitmap: new rp({ width: i4 + 2 * Mm, height: s4 + 2 * Mm }, n3), metrics: { width: i4, height: s4, left: a4, top: o3, advance: l4 } });
          } else 4 === t4 ? e4.ascender = r4.readSVarint() : 5 === t4 && (e4.descender = r4.readSVarint());
        }
        function Im(t4, e4, r4) {
          1 === t4 ? e4.id = r4.readVarint() : 2 === t4 ? e4.bitmap = r4.readBytes() : 3 === t4 ? e4.width = r4.readVarint() : 4 === t4 ? e4.height = r4.readVarint() : 5 === t4 ? e4.left = r4.readSVarint() : 6 === t4 ? e4.top = r4.readSVarint() : 7 === t4 && (e4.advance = r4.readVarint());
        }
        const km = Mm, Pm = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
        class Em {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t4, e4) {
            const r4 = new Em();
            return r4.scale = t4 || 1, r4.fontStack = e4, r4;
          }
          static forImage(t4) {
            const e4 = new Em();
            return e4.imageName = t4, e4;
          }
        }
        class zm {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t4, e4) {
            const r4 = new zm();
            for (let n3 = 0; n3 < t4.sections.length; n3++) {
              const i4 = t4.sections[n3];
              i4.image ? r4.addImageSection(i4) : r4.addTextSection(i4, e4);
            }
            return r4;
          }
          length() {
            return this.text.length;
          }
          getSection(t4) {
            return this.sections[this.sectionIndex[t4]];
          }
          getSections() {
            return this.sections;
          }
          getSectionIndex(t4) {
            return this.sectionIndex[t4];
          }
          getCodePoint(t4) {
            return this.text.codePointAt(t4);
          }
          verticalizePunctuation(t4) {
            this.text = function(t5, e4) {
              let r4 = "";
              for (let n3 = 0; n3 < t5.length; n3++) {
                const i4 = t5.charCodeAt(n3 + 1) || null, s4 = t5.charCodeAt(n3 - 1) || null;
                r4 += !e4 && (i4 && Ao(i4) && !Wd[t5[n3 + 1]] || s4 && Ao(s4) && !Wd[t5[n3 - 1]]) || !Wd[t5[n3]] ? t5[n3] : Wd[t5[n3]];
              }
              return r4;
            }(this.text, t4);
          }
          trim() {
            let t4 = 0;
            for (let e5 = 0; e5 < this.text.length && Bm[this.text.charCodeAt(e5)]; e5++) t4++;
            let e4 = this.text.length;
            for (let r4 = this.text.length - 1; r4 >= 0 && r4 >= t4 && Bm[this.text.charCodeAt(r4)]; r4--) e4--;
            this.text = this.text.substring(t4, e4), this.sectionIndex = this.sectionIndex.slice(t4, e4);
          }
          substring(t4, e4) {
            const r4 = new zm();
            return r4.text = this.text.substring(t4, e4), r4.sectionIndex = this.sectionIndex.slice(t4, e4), r4.sections = this.sections, r4;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t4, e4) => Math.max(t4, this.sections[e4].scale), 0);
          }
          addTextSection(t4, e4) {
            this.text += t4.text, this.sections.push(Em.forText(t4.scale, t4.fontStack || e4));
            const r4 = this.sections.length - 1;
            for (let e5 = 0; e5 < t4.text.length; ++e5) this.sectionIndex.push(r4);
          }
          addImageSection(t4) {
            const e4 = t4.image ? t4.image.namePrimary : "";
            if (0 === e4.length) return void hr("Can't add FormattedSection with an empty image.");
            const r4 = this.getNextImageSectionCharCode();
            r4 ? (this.text += String.fromCodePoint(r4), this.sections.push(Em.forImage(e4)), this.sectionIndex.push(this.sections.length - 1)) : hr("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Tm(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3) {
          const m4 = zm.fromFeature(t4, i4);
          h4 === Pm.vertical && m4.verticalizePunctuation(p4);
          let y4 = [];
          const g5 = function(t5, e5, r5, n4, i5, s5) {
            if (!t5) return [];
            const a5 = [], o4 = function(t6, e6, r6, n5, i6, s6) {
              let a6 = 0;
              for (let r7 = 0; r7 < t6.length(); r7++) {
                const o5 = t6.getSection(r7);
                a6 += Rm(t6.getCodePoint(r7), o5, n5, i6, e6, s6);
              }
              return a6 / Math.max(1, Math.ceil(a6 / r6));
            }(t5, e5, r5, n4, i5, s5), l5 = t5.text.indexOf("\u200B") >= 0;
            let u6 = 0;
            for (let r6 = 0; r6 < t5.length(); r6++) {
              const h5 = t5.getSection(r6), p5 = t5.getCodePoint(r6);
              if (Bm[p5] || (u6 += Rm(p5, h5, n4, i5, e5, s5)), r6 < t5.length() - 1) {
                const e6 = !((c5 = p5) < 11904 || !(bo["Bopomofo Extended"](c5) || bo.Bopomofo(c5) || bo["CJK Compatibility Forms"](c5) || bo["CJK Compatibility Ideographs"](c5) || bo["CJK Compatibility"](c5) || bo["CJK Radicals Supplement"](c5) || bo["CJK Strokes"](c5) || bo["CJK Symbols and Punctuation"](c5) || bo["CJK Unified Ideographs Extension A"](c5) || bo["CJK Unified Ideographs"](c5) || bo["Enclosed CJK Letters and Months"](c5) || bo["Halfwidth and Fullwidth Forms"](c5) || bo.Hiragana(c5) || bo["Ideographic Description Characters"](c5) || bo["Kangxi Radicals"](c5) || bo["Katakana Phonetic Extensions"](c5) || bo.Katakana(c5) || bo["Vertical Forms"](c5) || bo["Yi Radicals"](c5) || bo["Yi Syllables"](c5)));
                (Cm[p5] || e6 || h5.imageName) && a5.push(Lm(r6 + 1, u6, o4, a5, Dm(p5, t5.getCodePoint(r6 + 1), e6 && l5), false));
              }
            }
            var c5;
            return Fm(Lm(t5.length(), u6, o4, a5, 0, true));
          }(m4, u5, s4, e4, n3, f4), { processBidirectionalText: x5, processStyledBidirectionalText: b4 } = Oo;
          if (x5 && 1 === m4.sections.length) {
            const t5 = x5(m4.toString(), g5);
            for (const e5 of t5) {
              const t6 = new zm();
              t6.text = e5, t6.sections = m4.sections;
              for (let r5 = 0; r5 < e5.length; r5++) t6.sectionIndex.push(0);
              y4.push(t6);
            }
          } else if (b4) {
            const t5 = b4(m4.text, m4.sectionIndex, g5);
            for (const e5 of t5) {
              const t6 = new zm();
              t6.text = e5[0], t6.sectionIndex = e5[1], t6.sections = m4.sections, y4.push(t6);
            }
          } else y4 = function(t5, e5) {
            const r5 = [], n4 = t5.text;
            let i5 = 0;
            for (const n5 of e5) r5.push(t5.substring(i5, n5)), i5 = n5;
            return i5 < n4.length && r5.push(t5.substring(i5, n4.length)), r5;
          }(m4, g5);
          const v4 = [], _4 = { positionedLines: v4, text: m4.toString(), top: c4[1], bottom: c4[1], left: c4[0], right: c4[0], writingMode: h4, iconsInText: false, verticalizable: false, hasBaseline: false };
          return function(t5, e5, r5, n4, i5, s5, a5, o4, l5, u6, c5, h5) {
            let p5 = 0, f5 = 0, d4 = 0;
            const m5 = "right" === o4 ? 1 : "left" === o4 ? 0 : 0.5;
            let y5 = false;
            for (const t6 of i5) {
              const r6 = t6.getSections();
              for (const t7 of r6) {
                if (t7.imageName) continue;
                const r7 = e5[t7.fontStack];
                if (r7 && (y5 = void 0 !== r7.ascender && void 0 !== r7.descender, !y5)) break;
              }
              if (!y5) break;
            }
            let g6 = 0;
            for (const a6 of i5) {
              a6.trim();
              const i6 = a6.getMaxScale(), o5 = (i6 - 1) * $d, b6 = { positionedGlyphs: [], lineOffset: 0 };
              t5.positionedLines[g6] = b6;
              const v6 = b6.positionedGlyphs;
              let _6 = 0;
              if (!a6.length()) {
                f5 += s5, ++g6;
                continue;
              }
              let w5 = 0, M3 = 0;
              for (let s6 = 0; s6 < a6.length(); s6++) {
                const o6 = a6.getSection(s6), d5 = a6.getSectionIndex(s6), m6 = a6.getCodePoint(s6);
                let g7 = o6.scale, b7 = null, A5 = null, S3 = null, I4 = $d, k4 = 0;
                const P4 = !(l5 === Pm.horizontal || !c5 && !Mo(m6) || c5 && (Bm[m6] || (x6 = m6, bo.Arabic(x6) || bo["Arabic Supplement"](x6) || bo["Arabic Extended-A"](x6) || bo["Arabic Presentation Forms-A"](x6) || bo["Arabic Presentation Forms-B"](x6))));
                if (o6.imageName) {
                  const e6 = n4[o6.imageName];
                  if (!e6) continue;
                  S3 = o6.imageName, t5.iconsInText = t5.iconsInText || true, A5 = e6.paddedRect;
                  const r6 = e6.displaySize;
                  g7 = g7 * $d / h5, b7 = { width: r6[0], height: r6[1], left: 0, top: -km, advance: P4 ? r6[1] : r6[0], localGlyph: false }, k4 = y5 ? -b7.height * g7 : i6 * $d - 17 - r6[1] * g7, I4 = b7.advance;
                  const s7 = (P4 ? r6[0] : r6[1]) * g7 - $d * i6;
                  s7 > 0 && s7 > _6 && (_6 = s7);
                } else {
                  const t6 = r5[o6.fontStack];
                  if (!t6) continue;
                  t6[m6] && (A5 = t6[m6]);
                  const n5 = e5[o6.fontStack];
                  if (!n5) continue;
                  const s7 = n5.glyphs[m6];
                  if (!s7) continue;
                  if (b7 = s7.metrics, I4 = 8203 !== m6 ? $d : 0, y5) {
                    const t7 = void 0 !== n5.ascender ? Math.abs(n5.ascender) : 0, e6 = void 0 !== n5.descender ? Math.abs(n5.descender) : 0, r6 = (t7 + e6) * g7;
                    w5 < r6 && (w5 = r6, M3 = (t7 - e6) / 2 * g7), k4 = -t7 * g7;
                  } else k4 = (i6 - g7) * $d - 17;
                }
                P4 ? (t5.verticalizable = true, v6.push({ glyph: m6, imageName: S3, x: p5, y: f5 + k4, vertical: P4, scale: g7, localGlyph: b7.localGlyph, fontStack: o6.fontStack, sectionIndex: d5, metrics: b7, rect: A5 }), p5 += I4 * g7 + u6) : (v6.push({ glyph: m6, imageName: S3, x: p5, y: f5 + k4, vertical: P4, scale: g7, localGlyph: b7.localGlyph, fontStack: o6.fontStack, sectionIndex: d5, metrics: b7, rect: A5 }), p5 += b7.advance * g7 + u6);
              }
              0 !== v6.length && (d4 = Math.max(p5 - u6, d4), y5 ? Um(v6, m5, _6, M3, s5 * i6 / 2) : Um(v6, m5, _6, 0, s5 / 2)), p5 = 0;
              const A4 = s5 * i6 + _6;
              b6.lineOffset = Math.max(_6, o5), f5 += A4, ++g6;
            }
            var x6;
            const b5 = f5, { horizontalAlign: v5, verticalAlign: _5 } = Om(a5);
            (function(t6, e6, r6, n5, i6, s6) {
              const a6 = (e6 - r6) * i6, o5 = -s6 * n5;
              for (const e7 of t6) for (const t7 of e7.positionedGlyphs) t7.x += a6, t7.y += o5;
            })(t5.positionedLines, m5, v5, _5, d4, b5), t5.top += -_5 * b5, t5.bottom = t5.top + b5, t5.left += -v5 * d4, t5.right = t5.left + d4, t5.hasBaseline = y5;
          }(_4, e4, r4, n3, y4, a4, o3, l4, h4, u5, p4, d3), !function(t5) {
            for (const e5 of t5) if (0 !== e5.positionedGlyphs.length) return false;
            return true;
          }(v4) && _4;
        }
        const Bm = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Cm = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function Rm(t4, e4, r4, n3, i4, s4) {
          if (e4.imageName) {
            const t5 = n3[e4.imageName];
            return t5 ? t5.displaySize[0] * e4.scale * $d / s4 + i4 : 0;
          }
          {
            const n4 = r4[e4.fontStack], s5 = n4 && n4.glyphs[t4];
            return s5 ? s5.metrics.advance * e4.scale + i4 : 0;
          }
        }
        function Vm(t4, e4, r4, n3) {
          const i4 = Math.pow(t4 - e4, 2);
          return n3 ? t4 < e4 ? i4 / 2 : 2 * i4 : i4 + Math.abs(r4) * r4;
        }
        function Dm(t4, e4, r4) {
          let n3 = 0;
          return 10 === t4 && (n3 -= 1e4), r4 && (n3 += 150), 40 !== t4 && 65288 !== t4 || (n3 += 50), 41 !== e4 && 65289 !== e4 || (n3 += 50), n3;
        }
        function Lm(t4, e4, r4, n3, i4, s4) {
          let a4 = null, o3 = Vm(e4, r4, i4, s4);
          for (const t5 of n3) {
            const n4 = Vm(e4 - t5.x, r4, i4, s4) + t5.badness;
            n4 <= o3 && (a4 = t5, o3 = n4);
          }
          return { index: t4, x: e4, priorBreak: a4, badness: o3 };
        }
        function Fm(t4) {
          return t4 ? Fm(t4.priorBreak).concat(t4.index) : [];
        }
        function Om(t4) {
          let e4 = 0.5, r4 = 0.5;
          switch (t4) {
            case "right":
            case "top-right":
            case "bottom-right":
              e4 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e4 = 0;
          }
          switch (t4) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r4 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r4 = 0;
          }
          return { horizontalAlign: e4, verticalAlign: r4 };
        }
        function Um(t4, e4, r4, n3, i4) {
          if (!(e4 || r4 || n3 || i4)) return;
          const s4 = t4.length - 1, a4 = t4[s4], o3 = (a4.x + a4.metrics.advance * a4.scale) * e4;
          for (let e5 = 0; e5 <= s4; e5++) t4[e5].x -= o3, t4[e5].y += r4 + n3 + i4;
        }
        function Nm(t4, e4, r4, n3) {
          const { horizontalAlign: i4, verticalAlign: s4 } = Om(n3), a4 = r4[0] - t4.displaySize[0] * i4, o3 = r4[1] - t4.displaySize[1] * s4;
          return { imagePrimary: t4, imageSecondary: e4, top: o3, bottom: o3 + t4.displaySize[1], left: a4, right: a4 + t4.displaySize[0] };
        }
        function jm(t4, e4, r4, n3, i4, s4) {
          const a4 = t4.imagePrimary;
          let o3;
          if (a4.content) {
            const t5 = a4.content, e5 = a4.pixelRatio || 1;
            o3 = [t5[0] / e5, t5[1] / e5, a4.displaySize[0] - t5[2] / e5, a4.displaySize[1] - t5[3] / e5];
          }
          const l4 = e4.left * s4, u5 = e4.right * s4;
          let c4, h4, p4, f4;
          "width" === r4 || "both" === r4 ? (f4 = i4[0] + l4 - n3[3], h4 = i4[0] + u5 + n3[1]) : (f4 = i4[0] + (l4 + u5 - a4.displaySize[0]) / 2, h4 = f4 + a4.displaySize[0]);
          const d3 = e4.top * s4, m4 = e4.bottom * s4;
          return "height" === r4 || "both" === r4 ? (c4 = i4[1] + d3 - n3[0], p4 = i4[1] + m4 + n3[2]) : (c4 = i4[1] + (d3 + m4 - a4.displaySize[1]) / 2, p4 = c4 + a4.displaySize[1]), { imagePrimary: a4, imageSecondary: void 0, top: c4, right: h4, bottom: p4, left: f4, collisionPadding: o3 };
        }
        class qm extends Ue {
          constructor(t4, e4, r4, n3, i4) {
            super(t4, e4), this.angle = n3, this.z = r4, void 0 !== i4 && (this.segment = i4);
          }
          clone() {
            return new qm(this.x, this.y, this.z, this.angle, this.segment);
          }
        }
        function $m(t4, e4, r4, n3, i4) {
          if (void 0 === e4.segment) return true;
          let s4 = e4, a4 = e4.segment + 1, o3 = 0;
          for (; o3 > -r4 / 2; ) {
            if (a4--, a4 < 0) return false;
            o3 -= t4[a4].dist(s4), s4 = t4[a4];
          }
          o3 += t4[a4].dist(t4[a4 + 1]), a4++;
          const l4 = [];
          let u5 = 0;
          for (; o3 < r4 / 2; ) {
            const e5 = t4[a4], r5 = t4[a4 + 1];
            if (!r5) return false;
            let s5 = t4[a4 - 1].angleTo(e5) - e5.angleTo(r5);
            for (s5 = Math.abs((s5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l4.push({ distance: o3, angleDelta: s5 }), u5 += s5; o3 - l4[0].distance > n3; ) u5 -= l4.shift().angleDelta;
            if (u5 > i4) return false;
            a4++, o3 += e5.dist(r5);
          }
          return true;
        }
        function Gm(t4) {
          let e4 = 0;
          for (let r4 = 0; r4 < t4.length - 1; r4++) e4 += t4[r4].dist(t4[r4 + 1]);
          return e4;
        }
        function Qm(t4, e4, r4) {
          return t4 ? 0.6 * e4 * r4 : 0;
        }
        function Ym(t4, e4) {
          return Math.max(t4 ? t4.right - t4.left : 0, e4 ? e4.right - e4.left : 0);
        }
        function Xm(t4, e4, r4, n3, i4, s4) {
          const a4 = Qm(r4, i4, s4), o3 = Ym(r4, n3) * s4;
          let l4 = 0;
          const u5 = Gm(t4) / 2;
          for (let r5 = 0; r5 < t4.length - 1; r5++) {
            const n4 = t4[r5], i5 = t4[r5 + 1], s5 = n4.dist(i5);
            if (l4 + s5 > u5) {
              const c4 = (u5 - l4) / s5, h4 = qn(n4.x, i5.x, c4), p4 = qn(n4.y, i5.y, c4), f4 = new qm(h4, p4, 0, i5.angleTo(n4), r5);
              return !a4 || $m(t4, f4, o3, a4, e4) ? f4 : void 0;
            }
            l4 += s5;
          }
        }
        function Zm(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
          const u5 = Qm(n3, s4, a4), c4 = Ym(n3, i4), h4 = c4 * a4, p4 = 0 === t4[0].x || t4[0].x === l4 || 0 === t4[0].y || t4[0].y === l4;
          return e4 - h4 < e4 / 4 && (e4 = h4 + e4 / 4), Km(t4, p4 ? e4 / 2 * o3 % e4 : (c4 / 2 + 2 * s4) * a4 * o3 % e4, e4, u5, r4, h4, p4, false, l4);
        }
        function Km(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
          const u5 = s4 / 2, c4 = Gm(t4);
          let h4 = 0, p4 = e4 - r4, f4 = [];
          for (let e5 = 0; e5 < t4.length - 1; e5++) {
            const a5 = t4[e5], o4 = t4[e5 + 1], d3 = a5.dist(o4), m4 = o4.angleTo(a5);
            for (; p4 + r4 < h4 + d3; ) {
              p4 += r4;
              const y4 = (p4 - h4) / d3, g5 = qn(a5.x, o4.x, y4), x5 = qn(a5.y, o4.y, y4);
              if (g5 >= 0 && g5 < l4 && x5 >= 0 && x5 < l4 && p4 - u5 >= 0 && p4 + u5 <= c4) {
                const r5 = new qm(g5, x5, 0, m4, e5);
                n3 && !$m(t4, r5, s4, n3, i4) || f4.push(r5);
              }
            }
            h4 += d3;
          }
          return o3 || f4.length || a4 || (f4 = Km(t4, h4 / 2, r4, n3, i4, s4, a4, true, l4)), f4;
        }
        function Wm(t4, e4, r4, n3, i4) {
          const s4 = [];
          for (let a4 = 0; a4 < t4.length; a4++) {
            const o3 = t4[a4];
            let l4;
            for (let t5 = 0; t5 < o3.length - 1; t5++) {
              let a5 = o3[t5], u5 = o3[t5 + 1];
              a5.x < e4 && u5.x < e4 || (a5.x < e4 ? a5 = new Ue(e4, a5.y + (e4 - a5.x) / (u5.x - a5.x) * (u5.y - a5.y))._round() : u5.x < e4 && (u5 = new Ue(e4, a5.y + (e4 - a5.x) / (u5.x - a5.x) * (u5.y - a5.y))._round()), a5.y < r4 && u5.y < r4 || (a5.y < r4 ? a5 = new Ue(a5.x + (r4 - a5.y) / (u5.y - a5.y) * (u5.x - a5.x), r4)._round() : u5.y < r4 && (u5 = new Ue(a5.x + (r4 - a5.y) / (u5.y - a5.y) * (u5.x - a5.x), r4)._round()), a5.x >= n3 && u5.x >= n3 || (a5.x >= n3 ? a5 = new Ue(n3, a5.y + (n3 - a5.x) / (u5.x - a5.x) * (u5.y - a5.y))._round() : u5.x >= n3 && (u5 = new Ue(n3, a5.y + (n3 - a5.x) / (u5.x - a5.x) * (u5.y - a5.y))._round()), a5.y >= i4 && u5.y >= i4 || (a5.y >= i4 ? a5 = new Ue(a5.x + (i4 - a5.y) / (u5.y - a5.y) * (u5.x - a5.x), i4)._round() : u5.y >= i4 && (u5 = new Ue(a5.x + (i4 - a5.y) / (u5.y - a5.y) * (u5.x - a5.x), i4)._round()), l4 && a5.equals(l4[l4.length - 1]) || (l4 = [a5], s4.push(l4)), l4.push(u5)))));
            }
          }
          return s4;
        }
        function Hm(t4) {
          let e4 = 0, r4 = 0;
          for (const n4 of t4) e4 += n4.w * n4.h, r4 = Math.max(r4, n4.w);
          t4.sort((t5, e5) => e5.h - t5.h);
          const n3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e4 / 0.95)), r4), h: 1 / 0 }];
          let i4 = 0, s4 = 0;
          for (const e5 of t4) for (let t5 = n3.length - 1; t5 >= 0; t5--) {
            const r5 = n3[t5];
            if (!(e5.w > r5.w || e5.h > r5.h)) {
              if (e5.x = r5.x, e5.y = r5.y, s4 = Math.max(s4, e5.y + e5.h), i4 = Math.max(i4, e5.x + e5.w), e5.w === r5.w && e5.h === r5.h) {
                const e6 = n3.pop();
                t5 < n3.length && (n3[t5] = e6);
              } else e5.h === r5.h ? (r5.x += e5.w, r5.w -= e5.w) : e5.w === r5.w ? (r5.y += e5.h, r5.h -= e5.h) : (n3.push({ x: r5.x + e5.w, y: r5.y, w: r5.w - e5.w, h: e5.h }), r5.y += e5.h, r5.h -= e5.h);
              break;
            }
          }
          return { w: i4, h: s4, fill: e4 / (i4 * s4) || 0 };
        }
        fo(qm, "Anchor");
        const Jm = 1;
        class ty {
          constructor(t4, { pixelRatio: e4, version: r4, stretchX: n3, stretchY: i4, content: s4 }) {
            this.paddedRect = t4, this.pixelRatio = e4, this.stretchX = n3, this.stretchY = i4, this.content = s4, this.version = r4;
          }
          get tl() {
            return [this.paddedRect.x + Jm, this.paddedRect.y + Jm];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - Jm, this.paddedRect.y + this.paddedRect.h - Jm];
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * Jm) / this.pixelRatio, (this.paddedRect.h - 2 * Jm) / this.pixelRatio];
          }
        }
        class ey {
          constructor(t4, e4) {
            const r4 = {}, n3 = {};
            this.haveRenderCallbacks = [];
            const i4 = [];
            this.addImages(t4, r4, i4), this.addImages(e4, n3, i4);
            const { w: s4, h: a4 } = Hm(i4), o3 = new np({ width: s4 || 1, height: a4 || 1 });
            for (const e5 in t4) {
              const n4 = t4[e5], i5 = r4[e5].paddedRect;
              np.copy(n4.data, o3, { x: 0, y: 0 }, { x: i5.x + Jm, y: i5.y + Jm }, n4.data, n4.sdf);
            }
            for (const t5 in e4) {
              const r5 = e4[t5], i5 = n3[t5].paddedRect, s5 = i5.x + Jm, a5 = i5.y + Jm, l4 = r5.data.width, u5 = r5.data.height;
              np.copy(r5.data, o3, { x: 0, y: 0 }, { x: s5, y: a5 }, r5.data), np.copy(r5.data, o3, { x: 0, y: u5 - 1 }, { x: s5, y: a5 - 1 }, { width: l4, height: 1 }), np.copy(r5.data, o3, { x: 0, y: 0 }, { x: s5, y: a5 + u5 }, { width: l4, height: 1 }), np.copy(r5.data, o3, { x: l4 - 1, y: 0 }, { x: s5 - 1, y: a5 }, { width: 1, height: u5 }), np.copy(r5.data, o3, { x: 0, y: 0 }, { x: s5 + l4, y: a5 }, { width: 1, height: u5 });
            }
            this.image = o3, this.iconPositions = r4, this.patternPositions = n3;
          }
          addImages(t4, e4, r4) {
            for (const n3 in t4) {
              const i4 = t4[n3], s4 = { x: 0, y: 0, w: i4.data.width + 2 * Jm, h: i4.data.height + 2 * Jm };
              r4.push(s4), e4[n3] = new ty(s4, i4), i4.hasRenderCallback && this.haveRenderCallbacks.push(n3);
            }
          }
          patchUpdatedImages(t4, e4, r4) {
            this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e5) => t4.hasImage(e5, r4)), t4.dispatchRenderCallbacks(this.haveRenderCallbacks, r4);
            for (const n3 in t4.getUpdatedImages(r4)) this.patchUpdatedImage(this.iconPositions[n3], t4.getImage(n3, r4), e4), this.patchUpdatedImage(this.patternPositions[n3], t4.getImage(n3, r4), e4);
          }
          patchUpdatedImage(t4, e4, r4) {
            if (!t4 || !e4) return;
            if (t4.version === e4.version) return;
            t4.version = e4.version;
            const [n3, i4] = t4.tl, s4 = !!Object.keys(this.patternPositions).length;
            r4.update(e4.data, { useMipmap: s4 }, { x: n3, y: i4 });
          }
        }
        fo(ty, "ImagePosition"), fo(ey, "ImageAtlas");
        const ry = 1e20;
        function ny(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
          for (let u5 = e4; u5 < e4 + n3; u5++) iy(t4, r4 * s4 + u5, s4, i4, a4, o3, l4);
          for (let u5 = r4; u5 < r4 + i4; u5++) iy(t4, u5 * s4 + e4, 1, n3, a4, o3, l4);
        }
        function iy(t4, e4, r4, n3, i4, s4, a4) {
          s4[0] = 0, a4[0] = -ry, a4[1] = ry, i4[0] = t4[e4];
          for (let o3 = 1, l4 = 0, u5 = 0; o3 < n3; o3++) {
            i4[o3] = t4[e4 + o3 * r4];
            const n4 = o3 * o3;
            do {
              const t5 = s4[l4];
              u5 = (i4[o3] - i4[t5] + n4 - t5 * t5) / (o3 - t5) / 2;
            } while (u5 <= a4[l4] && --l4 > -1);
            l4++, s4[l4] = o3, a4[l4] = u5, a4[l4 + 1] = ry;
          }
          for (let o3 = 0, l4 = 0; o3 < n3; o3++) {
            for (; a4[l4 + 1] < o3; ) l4++;
            const n4 = s4[l4], u5 = o3 - n4;
            t4[e4 + o3 * r4] = i4[n4] + u5 * u5;
          }
        }
        const sy = 2, ay = { none: 0, ideographs: 1, all: 2 };
        class oy {
          constructor(t4, e4, r4) {
            this.requestManager = t4, this.localGlyphMode = e4, this.localFontFamily = r4, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
          }
          setURL(t4, e4) {
            this.urls[e4] = t4;
          }
          getGlyphs(t4, e4, r4) {
            const i4 = [], s4 = this.urls[e4] || n2.GLYPHS_URL;
            for (const e5 in t4) for (const r5 of t4[e5]) i4.push({ stack: e5, id: r5 });
            He(i4, ({ stack: t5, id: e5 }, r5) => {
              let n3 = this.entries[t5];
              n3 || (n3 = this.entries[t5] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
              let i5 = n3.glyphs[e5];
              if (void 0 !== i5) return void r5(null, { stack: t5, id: e5, glyph: i5 });
              if (i5 = this._tinySDF(n3, t5, e5), i5) return n3.glyphs[e5] = i5, void r5(null, { stack: t5, id: e5, glyph: i5 });
              const a4 = Math.floor(e5 / 256);
              if (256 * a4 > 65535) return void r5(new Error("glyphs > 65535 not supported"));
              if (n3.ranges[a4]) return void r5(null, { stack: t5, id: e5, glyph: i5 });
              let o3 = n3.requests[a4];
              o3 || (o3 = n3.requests[a4] = [], oy.loadGlyphRange(t5, a4, s4, this.requestManager, (t6, e6) => {
                if (e6) {
                  n3.ascender = e6.ascender, n3.descender = e6.descender;
                  for (const t7 in e6.glyphs) this._doesCharSupportLocalGlyph(+t7) || (n3.glyphs[+t7] = e6.glyphs[+t7]);
                  n3.ranges[a4] = true;
                }
                for (const r6 of o3) r6(t6, e6);
                delete n3.requests[a4];
              })), o3.push((n4, i6) => {
                n4 ? r5(n4) : i6 && r5(null, { stack: t5, id: e5, glyph: i6.glyphs[e5] || null });
              });
            }, (t5, e5) => {
              if (t5) r4(t5);
              else if (e5) {
                const t6 = {};
                for (const { stack: r5, id: n3, glyph: i5 } of e5) void 0 === t6[r5] && (t6[r5] = {}), void 0 === t6[r5].glyphs && (t6[r5].glyphs = {}), t6[r5].glyphs[n3] = i5 && { id: i5.id, bitmap: i5.bitmap.clone(), metrics: i5.metrics }, t6[r5].ascender = this.entries[r5].ascender, t6[r5].descender = this.entries[r5].descender;
                r4(null, t6);
              }
            });
          }
          _doesCharSupportLocalGlyph(t4) {
            return this.localGlyphMode !== ay.none && (this.localGlyphMode === ay.all ? !!this.localFontFamily : !!this.localFontFamily && (bo["CJK Unified Ideographs"](t4) || bo["Hangul Syllables"](t4) || bo.Hiragana(t4) || bo.Katakana(t4) || bo["CJK Symbols and Punctuation"](t4) || bo["CJK Unified Ideographs Extension A"](t4) || bo["CJK Unified Ideographs Extension B"](t4)));
          }
          _tinySDF(t4, e4, r4) {
            const n3 = this.localFontFamily;
            if (!n3 || !this._doesCharSupportLocalGlyph(r4)) return;
            let i4 = t4.tinySDF;
            if (!i4) {
              let r5 = "400";
              /bold/i.test(e4) ? r5 = "900" : /medium/i.test(e4) ? r5 = "500" : /light/i.test(e4) && (r5 = "200"), i4 = t4.tinySDF = new oy.TinySDF({ fontFamily: n3, fontWeight: r5, fontSize: 24 * sy, buffer: 3 * sy, radius: 8 * sy }), i4.fontWeight = r5;
            }
            if (this.localGlyphs[i4.fontWeight][r4]) return this.localGlyphs[i4.fontWeight][r4];
            const s4 = String.fromCodePoint(r4), { data: a4, width: o3, height: l4, glyphWidth: u5, glyphHeight: c4, glyphLeft: h4, glyphTop: p4, glyphAdvance: f4 } = i4.draw(s4);
            return this.localGlyphs[i4.fontWeight][r4] = { id: r4, bitmap: new rp({ width: o3, height: l4 }, a4), metrics: { width: u5 / sy, height: c4 / sy, left: h4 / sy, top: p4 / sy - 27, advance: f4 / sy, localGlyph: true } };
          }
        }
        oy.loadGlyphRange = function(t4, e4, r4, n3, i4) {
          const s4 = 256 * e4, a4 = s4 + 255, o3 = n3.transformRequest(n3.normalizeGlyphsURL(r4).replace("{fontstack}", t4).replace("{range}", `${s4}-${a4}`), Zr.Glyphs);
          Jr(o3, (t5, e5) => {
            if (t5) i4(t5);
            else if (e5) {
              const t6 = {}, r5 = function(t7) {
                return new wm(t7).readFields(Am, {});
              }(e5);
              for (const e6 of r5.glyphs) t6[e6.id] = e6;
              i4(null, { glyphs: t6, ascender: r5.ascender, descender: r5.descender });
            }
          });
        }, oy.TinySDF = class {
          constructor({ fontSize: t4 = 24, buffer: e4 = 3, radius: r4 = 8, cutoff: n3 = 0.25, fontFamily: i4 = "sans-serif", fontWeight: s4 = "normal", fontStyle: a4 = "normal" } = {}) {
            this.buffer = e4, this.cutoff = n3, this.radius = r4;
            const o3 = this.size = t4 + 4 * e4, l4 = this._createCanvas(o3), u5 = this.ctx = l4.getContext("2d", { willReadFrequently: true });
            u5.font = `${a4} ${s4} ${t4}px ${i4}`, u5.textBaseline = "alphabetic", u5.textAlign = "left", u5.fillStyle = "black", this.gridOuter = new Float64Array(o3 * o3), this.gridInner = new Float64Array(o3 * o3), this.f = new Float64Array(o3), this.z = new Float64Array(o3 + 1), this.v = new Uint16Array(o3);
          }
          _createCanvas(t4) {
            const e4 = document.createElement("canvas");
            return e4.width = e4.height = t4, e4;
          }
          draw(t4) {
            const { width: e4, actualBoundingBoxAscent: r4, actualBoundingBoxDescent: n3, actualBoundingBoxLeft: i4, actualBoundingBoxRight: s4 } = this.ctx.measureText(t4), a4 = Math.ceil(r4), o3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s4 - i4))), l4 = Math.min(this.size - this.buffer, a4 + Math.ceil(n3)), u5 = o3 + 2 * this.buffer, c4 = l4 + 2 * this.buffer, h4 = Math.max(u5 * c4, 0), p4 = new Uint8ClampedArray(h4), f4 = { data: p4, width: u5, height: c4, glyphWidth: o3, glyphHeight: l4, glyphTop: a4, glyphLeft: 0, glyphAdvance: e4 };
            if (0 === o3 || 0 === l4) return f4;
            const { ctx: d3, buffer: m4, gridInner: y4, gridOuter: g5 } = this;
            d3.clearRect(m4, m4, o3, l4), d3.fillText(t4, m4, m4 + a4);
            const x5 = d3.getImageData(m4, m4, o3, l4);
            g5.fill(ry, 0, h4), y4.fill(0, 0, h4);
            for (let t5 = 0; t5 < l4; t5++) for (let e5 = 0; e5 < o3; e5++) {
              const r5 = x5.data[4 * (t5 * o3 + e5) + 3] / 255;
              if (0 === r5) continue;
              const n4 = (t5 + m4) * u5 + e5 + m4;
              if (1 === r5) g5[n4] = 0, y4[n4] = ry;
              else {
                const t6 = 0.5 - r5;
                g5[n4] = t6 > 0 ? t6 * t6 : 0, y4[n4] = t6 < 0 ? t6 * t6 : 0;
              }
            }
            ny(g5, 0, 0, u5, c4, u5, this.f, this.v, this.z), ny(y4, m4, m4, o3, l4, u5, this.f, this.v, this.z);
            for (let t5 = 0; t5 < h4; t5++) {
              const e5 = Math.sqrt(g5[t5]) - Math.sqrt(y4[t5]);
              p4[t5] = Math.round(255 - 255 * (e5 / this.radius + this.cutoff));
            }
            return f4;
          }
        };
        const ly = Jm;
        function uy(t4, e4, r4, n3) {
          const i4 = [], s4 = t4.imagePrimary, a4 = s4.pixelRatio, o3 = s4.paddedRect.w - 2 * ly, l4 = s4.paddedRect.h - 2 * ly, u5 = t4.right - t4.left, c4 = t4.bottom - t4.top, h4 = s4.stretchX || [[0, o3]], p4 = s4.stretchY || [[0, l4]], f4 = (t5, e5) => t5 + e5[1] - e5[0], d3 = h4.reduce(f4, 0), m4 = p4.reduce(f4, 0), y4 = o3 - d3, g5 = l4 - m4;
          let x5 = 0, b4 = d3, v4 = 0, _4 = m4, w5 = 0, M3 = y4, A4 = 0, S3 = g5;
          if (s4.content && n3) {
            const t5 = s4.content;
            x5 = cy(h4, 0, t5[0]), v4 = cy(p4, 0, t5[1]), b4 = cy(h4, t5[0], t5[2]), _4 = cy(p4, t5[1], t5[3]), w5 = t5[0] - x5, A4 = t5[1] - v4, M3 = t5[2] - t5[0] - b4, S3 = t5[3] - t5[1] - _4;
          }
          const I4 = (n4, i5, o4, l5) => {
            const h5 = py(n4.stretch - x5, b4, u5, t4.left), p5 = fy(n4.fixed - w5, M3, n4.stretch, d3), f5 = py(i5.stretch - v4, _4, c4, t4.top), y5 = fy(i5.fixed - A4, S3, i5.stretch, m4), g6 = py(o4.stretch - x5, b4, u5, t4.left), I5 = fy(o4.fixed - w5, M3, o4.stretch, d3), k4 = py(l5.stretch - v4, _4, c4, t4.top), P4 = fy(l5.fixed - A4, S3, l5.stretch, m4), E3 = new Ue(h5, f5), z4 = new Ue(g6, f5), T5 = new Ue(g6, k4), B4 = new Ue(h5, k4), C4 = new Ue(p5 / a4, y5 / a4), R2 = new Ue(I5 / a4, P4 / a4), V4 = e4 * Math.PI / 180;
            if (V4) {
              const t5 = Math.sin(V4), e5 = Math.cos(V4), r5 = [e5, -t5, t5, e5];
              E3._matMult(r5), z4._matMult(r5), B4._matMult(r5), T5._matMult(r5);
            }
            const D4 = n4.stretch + n4.fixed, L4 = o4.stretch + o4.fixed, F5 = i5.stretch + i5.fixed, O3 = l5.stretch + l5.fixed, U3 = t4.imageSecondary;
            return { tl: E3, tr: z4, bl: B4, br: T5, texPrimary: { x: s4.paddedRect.x + ly + D4, y: s4.paddedRect.y + ly + F5, w: L4 - D4, h: O3 - F5 }, texSecondary: U3 ? { x: U3.paddedRect.x + ly + D4, y: U3.paddedRect.y + ly + F5, w: L4 - D4, h: O3 - F5 } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: C4, pixelOffsetBR: R2, minFontScaleX: M3 / a4 / u5, minFontScaleY: S3 / a4 / c4, isSDF: r4 };
          };
          if (n3 && (s4.stretchX || s4.stretchY)) {
            const t5 = hy(h4, y4, d3), e5 = hy(p4, g5, m4);
            for (let r5 = 0; r5 < t5.length - 1; r5++) {
              const n4 = t5[r5], s5 = t5[r5 + 1];
              for (let t6 = 0; t6 < e5.length - 1; t6++) i4.push(I4(n4, e5[t6], s5, e5[t6 + 1]));
            }
          } else i4.push(I4({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o3 + 1 }, { fixed: 0, stretch: l4 + 1 }));
          return i4;
        }
        function cy(t4, e4, r4) {
          let n3 = 0;
          for (const i4 of t4) n3 += Math.max(e4, Math.min(r4, i4[1])) - Math.max(e4, Math.min(r4, i4[0]));
          return n3;
        }
        function hy(t4, e4, r4) {
          const n3 = [{ fixed: -ly, stretch: 0 }];
          for (const [e5, r5] of t4) {
            const t5 = n3[n3.length - 1];
            n3.push({ fixed: e5 - t5.stretch, stretch: t5.stretch }), n3.push({ fixed: e5 - t5.stretch, stretch: t5.stretch + (r5 - e5) });
          }
          return n3.push({ fixed: e4 + ly, stretch: r4 }), n3;
        }
        function py(t4, e4, r4, n3) {
          return t4 / e4 * r4 + n3;
        }
        function fy(t4, e4, r4, n3) {
          return t4 - e4 * r4 / n3;
        }
        function dy(t4, e4, r4, n3) {
          const i4 = e4 + t4.positionedLines[n3].lineOffset;
          return 0 === n3 ? r4 + i4 / 2 : r4 + (i4 + (e4 + t4.positionedLines[n3 - 1].lineOffset)) / 2;
        }
        function my(t4, e4 = 1, r4 = false) {
          let n3 = 1 / 0, i4 = 1 / 0, s4 = -1 / 0, a4 = -1 / 0;
          const o3 = t4[0];
          for (let t5 = 0; t5 < o3.length; t5++) {
            const e5 = o3[t5];
            (!t5 || e5.x < n3) && (n3 = e5.x), (!t5 || e5.y < i4) && (i4 = e5.y), (!t5 || e5.x > s4) && (s4 = e5.x), (!t5 || e5.y > a4) && (a4 = e5.y);
          }
          const l4 = Math.min(s4 - n3, a4 - i4);
          let u5 = l4 / 2;
          const c4 = new ns([], yy);
          if (0 === l4) return new Ue(n3, i4);
          for (let e5 = n3; e5 < s4; e5 += l4) for (let r5 = i4; r5 < a4; r5 += l4) c4.push(new gy(e5 + u5, r5 + u5, u5, t4));
          let h4 = function(t5) {
            let e5 = 0, r5 = 0, n4 = 0;
            const i5 = t5[0];
            for (let t6 = 0, s5 = i5.length, a5 = s5 - 1; t6 < s5; a5 = t6++) {
              const s6 = i5[t6], o4 = i5[a5], l5 = s6.x * o4.y - o4.x * s6.y;
              r5 += (s6.x + o4.x) * l5, n4 += (s6.y + o4.y) * l5, e5 += 3 * l5;
            }
            return new gy(r5 / e5, n4 / e5, 0, t5);
          }(t4), p4 = c4.length;
          for (; c4.length; ) {
            const n4 = c4.pop();
            (n4.d > h4.d || !h4.d) && (h4 = n4, r4 && console.log("found best %d after %d probes", Math.round(1e4 * n4.d) / 1e4, p4)), n4.max - h4.d <= e4 || (u5 = n4.h / 2, c4.push(new gy(n4.p.x - u5, n4.p.y - u5, u5, t4)), c4.push(new gy(n4.p.x + u5, n4.p.y - u5, u5, t4)), c4.push(new gy(n4.p.x - u5, n4.p.y + u5, u5, t4)), c4.push(new gy(n4.p.x + u5, n4.p.y + u5, u5, t4)), p4 += 4);
          }
          return r4 && (console.log(`num probes: ${p4}`), console.log(`best distance: ${h4.d}`)), h4.p;
        }
        function yy(t4, e4) {
          return e4.max - t4.max;
        }
        class gy {
          constructor(t4, e4, r4, n3) {
            this.p = new Ue(t4, e4), this.h = r4, this.d = function(t5, e5) {
              let r5 = false, n4 = 1 / 0;
              for (let i4 = 0; i4 < e5.length; i4++) {
                const s4 = e5[i4];
                for (let e6 = 0, i5 = s4.length, a4 = i5 - 1; e6 < i5; a4 = e6++) {
                  const i6 = s4[e6], o3 = s4[a4];
                  i6.y > t5.y != o3.y > t5.y && t5.x < (o3.x - i6.x) * (t5.y - i6.y) / (o3.y - i6.y) + i6.x && (r5 = !r5), n4 = Math.min(n4, Zc(t5, i6, o3));
                }
              }
              return (r5 ? 1 : -1) * Math.sqrt(n4);
            }(this.p, n3), this.max = this.d + this.h * Math.SQRT2;
          }
        }
        const xy = Number.POSITIVE_INFINITY, by = Math.sqrt(2);
        function vy(t4, [e4, r4]) {
          let n3 = 0, i4 = 0;
          if (r4 === xy) {
            e4 < 0 && (e4 = 0);
            const r5 = e4 / by;
            switch (t4) {
              case "top-right":
              case "top-left":
                i4 = r5 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                i4 = 7 - r5;
                break;
              case "bottom":
                i4 = 7 - e4;
                break;
              case "top":
                i4 = e4 - 7;
            }
            switch (t4) {
              case "top-right":
              case "bottom-right":
                n3 = -r5;
                break;
              case "top-left":
              case "bottom-left":
                n3 = r5;
                break;
              case "left":
                n3 = e4;
                break;
              case "right":
                n3 = -e4;
            }
          } else {
            switch (e4 = Math.abs(e4), r4 = Math.abs(r4), t4) {
              case "top-right":
              case "top-left":
              case "top":
                i4 = r4 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i4 = 7 - r4;
            }
            switch (t4) {
              case "top-right":
              case "bottom-right":
              case "right":
                n3 = -e4;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n3 = e4;
            }
          }
          return [n3, i4];
        }
        function _y(t4) {
          switch (t4) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function wy(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3) {
          let m4 = s4.textMaxSize.evaluate(e4, {}, h4);
          void 0 === m4 && (m4 = a4);
          const y4 = t4.layers[0].layout, g5 = y4.get("icon-offset").evaluate(e4, {}, h4), x5 = Iy(r4.horizontal) || r4.vertical, b4 = "globe" === p4.name, v4 = $d, _4 = a4 / v4, w5 = t4.tilePixelRatio * m4 / v4, M3 = (T5 = t4.overscaling, t4.zoom > 18 && T5 > 2 && (T5 >>= 1), Math.max(is / (512 * T5), 1) * y4.get("symbol-spacing")), A4 = y4.get("text-padding") * t4.tilePixelRatio, S3 = y4.get("icon-padding") * t4.tilePixelRatio, I4 = qe(y4.get("text-max-angle")), k4 = "map" === y4.get("text-rotation-alignment") && "point" !== y4.get("symbol-placement"), P4 = "map" === y4.get("icon-rotation-alignment") && "point" !== y4.get("symbol-placement"), E3 = y4.get("symbol-placement"), z4 = M3 / 2;
          var T5;
          const B4 = y4.get("icon-text-fit").evaluate(e4, {}, h4), C4 = y4.get("icon-text-fit-padding").evaluate(e4, {}, h4), R2 = "none" !== B4;
          let V4;
          false === t4.hasAnyIconTextFit && R2 && (t4.hasAnyIconTextFit = true), n3 && R2 && (t4.allowVerticalPlacement && r4.vertical && (V4 = jm(n3, r4.vertical, B4, C4, g5, _4)), x5 && (n3 = jm(n3, x5, B4, C4, g5, _4)));
          const D4 = (a5, o4, m5) => {
            if (o4.x < 0 || o4.x >= is || o4.y < 0 || o4.y >= is) return;
            let y5 = null;
            if (b4) {
              const { x: t5, y: e5, z: r5 } = p4.projectTilePoint(o4.x, o4.y, m5);
              y5 = { anchor: new qm(t5, e5, r5, 0, void 0), up: p4.upVector(m5, o4.x, o4.y) };
            }
            !function(t5, e5, r5, n4, i5, s5, a6, o5, l5, u6, c5, h5, p5, f5, d4, m6, y6, g6, x6, b5, v5, _5, w6, M4, A5, S4, I5) {
              const k5 = t5.addToLineVertexArray(e5, n4);
              let P5, E4, z5, T6, B5, C5, R3, V5 = 0, D5 = 0, L4 = 0, F5 = 0, O3 = -1, U3 = -1;
              const N4 = {};
              let j5 = Tn("");
              const q4 = r5 ? r5.anchor : e5, $4 = "none" !== l5.layout.get("icon-text-fit").evaluate(v5, {}, A5);
              let G4 = 0, Q3 = 0;
              if (void 0 === l5._unevaluatedLayout.getValue("text-radial-offset") ? [G4, Q3] = l5.layout.get("text-offset").evaluate(v5, {}, A5).map((t6) => t6 * $d) : (G4 = l5.layout.get("text-radial-offset").evaluate(v5, {}, A5) * $d, Q3 = xy), t5.allowVerticalPlacement && i5.vertical) {
                const t6 = i5.vertical;
                if (d4) C5 = Py(t6), o5 && (R3 = Py(o5));
                else {
                  const r6 = l5.layout.get("text-rotate").evaluate(v5, {}, A5) + 90;
                  z5 = ky(u6, q4, e5, c5, h5, p5, t6, f5, r6, m6), o5 && (T6 = ky(u6, q4, e5, c5, h5, p5, o5, g6, r6));
                }
              }
              if (s5) {
                const n5 = l5.layout.get("icon-rotate").evaluate(v5, {}, A5), i6 = uy(s5, n5, w6, $4), a7 = o5 ? uy(o5, n5, w6, $4) : void 0;
                E4 = ky(u6, q4, e5, c5, h5, p5, s5, g6, n5), V5 = 4 * i6.length;
                const f6 = t5.iconSizeData;
                let d5 = null;
                "source" === f6.kind ? (d5 = [Gd * l5.layout.get("icon-size").evaluate(v5, {}, A5)], d5[0] > Ay && hr(`${t5.layerIds[0]}: Value for "icon-size" is >= ${My}. Reduce your "icon-size".`)) : "composite" === f6.kind && (d5 = [Gd * _5.compositeIconSizes[0].evaluate(v5, {}, A5), Gd * _5.compositeIconSizes[1].evaluate(v5, {}, A5)], (d5[0] > Ay || d5[1] > Ay) && hr(`${t5.layerIds[0]}: Value for "icon-size" is >= ${My}. Reduce your "icon-size".`)), t5.addSymbols(t5.icon, i6, d5, b5, x6, v5, false, r5, e5, k5.lineStartIndex, k5.lineLength, -1, M4, A5, S4, I5), O3 = t5.icon.placedSymbolArray.length - 1, a7 && (D5 = 4 * a7.length, t5.addSymbols(t5.icon, a7, d5, b5, x6, v5, Pm.vertical, r5, e5, k5.lineStartIndex, k5.lineLength, -1, M4, A5, S4, I5), U3 = t5.icon.placedSymbolArray.length - 1);
              }
              for (const n5 in i5.horizontal) {
                const s6 = i5.horizontal[n5];
                P5 || (j5 = Tn(s6.text), d4 ? B5 = Py(s6) : P5 = ky(u6, q4, e5, c5, h5, p5, s6, f5, l5.layout.get("text-rotate").evaluate(v5, {}, A5), m6));
                const o6 = 1 === s6.positionedLines.length;
                if (L4 += Sy(t5, r5, e5, s6, a6, l5, d4, v5, m6, k5, i5.vertical ? Pm.horizontal : Pm.horizontalOnly, o6 ? Object.keys(i5.horizontal) : [n5], N4, O3, _5, M4, A5, S4), o6) break;
              }
              i5.vertical && (F5 += Sy(t5, r5, e5, i5.vertical, a6, l5, d4, v5, m6, k5, Pm.vertical, ["vertical"], N4, U3, _5, M4, A5, S4));
              let Y2 = -1;
              const X3 = (t6, e6) => t6 ? Math.max(t6, e6) : e6;
              Y2 = X3(B5, Y2), Y2 = X3(C5, Y2), Y2 = X3(R3, Y2);
              const Z3 = Y2 > -1 ? 1 : 0;
              t5.glyphOffsetArray.length >= 65535 && hr("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== v5.sortKey && t5.addToSortKeyRanges(t5.symbolInstances.length, v5.sortKey), t5.symbolInstances.emplaceBack(e5.x, e5.y, q4.x, q4.y, q4.z, N4.right >= 0 ? N4.right : -1, N4.center >= 0 ? N4.center : -1, N4.left >= 0 ? N4.left : -1, N4.vertical >= 0 ? N4.vertical : -1, O3, U3, j5, void 0 !== P5 ? P5 : t5.collisionBoxArray.length, void 0 !== P5 ? P5 + 1 : t5.collisionBoxArray.length, void 0 !== z5 ? z5 : t5.collisionBoxArray.length, void 0 !== z5 ? z5 + 1 : t5.collisionBoxArray.length, void 0 !== E4 ? E4 : t5.collisionBoxArray.length, void 0 !== E4 ? E4 + 1 : t5.collisionBoxArray.length, T6 || t5.collisionBoxArray.length, T6 ? T6 + 1 : t5.collisionBoxArray.length, c5, L4, F5, V5, D5, Z3, 0, G4, Q3, Y2, 0, $4 ? 1 : 0);
            }(t4, o4, y5, a5, r4, n3, i4, V4, t4.layers[0], t4.collisionBoxArray, e4.index, e4.sourceLayerIndex, t4.index, A4, k4, l4, 0, S3, P4, g5, e4, s4, u5, c4, h4, f4, d3);
          };
          if ("line" === E3) for (const i5 of Wm(e4.geometry, 0, 0, is, is)) {
            const e5 = Zm(i5, M3, I4, r4.vertical || x5, n3, v4, w5, t4.overscaling, is);
            for (const r5 of e5) x5 && Ey(t4, x5.text, z4, r5) || D4(i5, r5, h4);
          }
          else if ("line-center" === E3) {
            for (const t5 of e4.geometry) if (t5.length > 1) {
              const e5 = Xm(t5, I4, r4.vertical || x5, n3, v4, w5);
              e5 && D4(t5, e5, h4);
            }
          } else if ("Polygon" === e4.type) for (const t5 of Up(e4.geometry, 0)) {
            const e5 = my(t5, 16);
            D4(t5[0], new qm(e5.x, e5.y, 0, 0, void 0), h4);
          }
          else if ("LineString" === e4.type) for (const t5 of e4.geometry) D4(t5, new qm(t5[0].x, t5[0].y, 0, 0, void 0), h4);
          else if ("Point" === e4.type) for (const t5 of e4.geometry) for (const e5 of t5) D4([e5], new qm(e5.x, e5.y, 0, 0, void 0), h4);
        }
        const My = 255, Ay = My * Gd;
        function Sy(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4, y4, g5) {
          const x5 = function(t5, e5, r5, n4, i5, s5, a5, o4) {
            const l5 = [];
            if (0 === e5.positionedLines.length) return l5;
            const u6 = n4.layout.get("text-rotate").evaluate(s5, {}) * Math.PI / 180, c5 = function(t6) {
              const e6 = t6[0], r6 = t6[1], n5 = e6 * r6;
              return n5 > 0 ? [e6, -r6] : n5 < 0 ? [-e6, r6] : 0 === e6 ? [r6, e6] : [r6, -e6];
            }(r5);
            let h5 = Math.abs(e5.top - e5.bottom);
            for (const t6 of e5.positionedLines) h5 -= t6.lineOffset;
            const p5 = e5.positionedLines.length, f5 = h5 / p5;
            let d4 = e5.top - r5[1];
            for (let t6 = 0; t6 < p5; ++t6) {
              const n5 = e5.positionedLines[t6];
              d4 = dy(e5, f5, d4, t6);
              for (const t7 of n5.positionedGlyphs) {
                if (!t7.rect) continue;
                const n6 = t7.rect || {};
                let s6 = km + 1, h6 = true, p6 = 1, f6 = 0;
                if (t7.imageName) {
                  const e6 = a5[t7.imageName];
                  if (!e6) continue;
                  if (e6.sdf) {
                    hr("SDF images are not supported in formatted text and will be ignored.");
                    continue;
                  }
                  h6 = false, p6 = e6.pixelRatio, s6 = Jm / p6;
                }
                const m5 = (i5 || o4) && t7.vertical, y5 = t7.metrics.advance * t7.scale / 2, g6 = t7.metrics, x6 = t7.rect;
                if (null === x6) continue;
                o4 && e5.verticalizable && (f6 = t7.imageName ? y5 - t7.metrics.width * t7.scale / 2 : 0);
                const b5 = i5 ? [t7.x + y5, t7.y] : [0, 0];
                let v5 = [0, 0], _4 = [0, 0], w5 = false;
                i5 || (m5 ? (_4 = [t7.x + y5 + c5[0], t7.y + c5[1] - f6], w5 = true) : v5 = [t7.x + y5 + r5[0], t7.y + r5[1] - f6]);
                const M3 = x6.w * t7.scale / (p6 * (t7.localGlyph ? sy : 1)), A4 = x6.h * t7.scale / (p6 * (t7.localGlyph ? sy : 1));
                let S3, I4, k4, P4;
                if (m5) {
                  const e6 = t7.y - d4, r6 = new Ue(-y5, y5 - e6), n7 = -Math.PI / 2, i6 = new Ue(..._4);
                  S3 = new Ue(-y5 + v5[0], v5[1]), S3._rotateAround(n7, r6)._add(i6), S3.x += -e6 + y5, S3.y -= (g6.left - s6) * t7.scale;
                  const a6 = t7.imageName ? g6.advance * t7.scale : $d * t7.scale, o5 = String.fromCodePoint(t7.glyph);
                  Hd(o5) ? S3.x += (1 - s6) * t7.scale : Jd(o5) ? S3.x += a6 - g6.height * t7.scale + (-s6 - 1) * t7.scale : S3.x += t7.imageName || g6.width + 2 * s6 === x6.w && g6.height + 2 * s6 === x6.h ? (a6 - A4) / 2 : (a6 - (g6.height + 2 * s6) * t7.scale) / 2, I4 = new Ue(S3.x, S3.y - M3), k4 = new Ue(S3.x + A4, S3.y), P4 = new Ue(S3.x + A4, S3.y - M3);
                } else {
                  const e6 = (g6.left - s6) * t7.scale - y5 + v5[0], r6 = (-g6.top - s6) * t7.scale + v5[1], n7 = e6 + M3, i6 = r6 + A4;
                  S3 = new Ue(e6, r6), I4 = new Ue(n7, r6), k4 = new Ue(e6, i6), P4 = new Ue(n7, i6);
                }
                if (u6) {
                  let t8;
                  t8 = i5 ? new Ue(0, 0) : w5 ? new Ue(c5[0], c5[1]) : new Ue(r5[0], r5[1]), S3._rotateAround(u6, t8), I4._rotateAround(u6, t8), k4._rotateAround(u6, t8), P4._rotateAround(u6, t8);
                }
                const E3 = new Ue(0, 0), z4 = new Ue(0, 0);
                l5.push({ tl: S3, tr: I4, bl: k4, br: P4, texPrimary: n6, texSecondary: void 0, writingMode: e5.writingMode, glyphOffset: b5, sectionIndex: t7.sectionIndex, isSDF: h6, pixelOffsetTL: E3, pixelOffsetBR: z4, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
            return l5;
          }(0, n3, l4, s4, a4, o3, i4, t4.allowVerticalPlacement), b4 = t4.textSizeData;
          let v4 = null;
          "source" === b4.kind ? (v4 = [Gd * s4.layout.get("text-size").evaluate(o3, {}, y4)], v4[0] > Ay && hr(`${t4.layerIds[0]}: Value for "text-size" is >= ${My}. Reduce your "text-size".`)) : "composite" === b4.kind && (v4 = [Gd * d3.compositeTextSizes[0].evaluate(o3, {}, y4), Gd * d3.compositeTextSizes[1].evaluate(o3, {}, y4)], (v4[0] > Ay || v4[1] > Ay) && hr(`${t4.layerIds[0]}: Value for "text-size" is >= ${My}. Reduce your "text-size".`)), t4.addSymbols(t4.text, x5, v4, l4, a4, o3, c4, e4, r4, u5.lineStartIndex, u5.lineLength, f4, m4, y4, g5, false);
          for (const e5 of h4) p4[e5] = t4.text.placedSymbolArray.length - 1;
          return 4 * x5.length;
        }
        function Iy(t4) {
          for (const e4 in t4) return t4[e4];
          return null;
        }
        function ky(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5) {
          let c4 = a4.top, h4 = a4.bottom, p4 = a4.left, f4 = a4.right;
          const d3 = a4.collisionPadding;
          if (d3 && (p4 -= d3[0], c4 -= d3[1], f4 += d3[2], h4 += d3[3]), l4) {
            const t5 = new Ue(p4, c4), e5 = new Ue(f4, c4), r5 = new Ue(p4, h4), n4 = new Ue(f4, h4), i5 = qe(l4);
            let s5 = new Ue(0, 0);
            u5 && (s5 = new Ue(u5[0], u5[1])), t5._rotateAround(i5, s5), e5._rotateAround(i5, s5), r5._rotateAround(i5, s5), n4._rotateAround(i5, s5), p4 = Math.min(t5.x, e5.x, r5.x, n4.x), f4 = Math.max(t5.x, e5.x, r5.x, n4.x), c4 = Math.min(t5.y, e5.y, r5.y, n4.y), h4 = Math.max(t5.y, e5.y, r5.y, n4.y);
          }
          return t4.emplaceBack(e4.x, e4.y, e4.z, r4.x, r4.y, p4, c4, f4, h4, o3, n3, i4, s4), t4.length - 1;
        }
        function Py(t4) {
          t4.collisionPadding && (t4.top -= t4.collisionPadding[1], t4.bottom += t4.collisionPadding[3]);
          const e4 = t4.bottom - t4.top;
          return e4 > 0 ? Math.max(10, e4) : null;
        }
        function Ey(t4, e4, r4, n3) {
          const i4 = t4.compareText;
          if (e4 in i4) {
            const t5 = i4[e4];
            for (let e5 = t5.length - 1; e5 >= 0; e5--) if (n3.dist(t5[e5]) < r4) return true;
          } else i4[e4] = [];
          return i4[e4].push(n3), false;
        }
        function zy(t4, e4) {
          const r4 = t4.fovAboveCenter, n3 = t4.elevation ? t4.elevation.getMinElevationBelowMSL() * e4 : 0, i4 = (t4._camera.position[2] * t4.worldSize - n3) / Math.cos(t4._pitch), s4 = Math.sin(r4) * i4 / Math.sin(Math.max(Math.PI / 2 - t4._pitch - r4, 0.01)), a4 = Math.sin(t4._pitch) * s4 + i4;
          return Math.min(1.01 * a4, i4 * (1 / t4._horizonShift));
        }
        function Ty(t4, e4) {
          if (!e4.isReprojectedInTileSpace) return { scale: 1 << t4.z, x: t4.x, y: t4.y, x2: t4.x + 1, y2: t4.y + 1, projection: e4 };
          const r4 = Math.pow(2, -t4.z), n3 = t4.x * r4, i4 = (t4.x + 1) * r4, s4 = t4.y * r4, a4 = (t4.y + 1) * r4, o3 = _c(n3), l4 = _c(i4), u5 = wc(s4), c4 = wc(a4), h4 = e4.project(o3, u5), p4 = e4.project(l4, u5), f4 = e4.project(l4, c4), d3 = e4.project(o3, c4);
          let m4 = Math.min(h4.x, p4.x, f4.x, d3.x), y4 = Math.min(h4.y, p4.y, f4.y, d3.y), g5 = Math.max(h4.x, p4.x, f4.x, d3.x), x5 = Math.max(h4.y, p4.y, f4.y, d3.y);
          const b4 = r4 / 16;
          function v4(t5, r5, n4, i5, s5, a5) {
            const o4 = (n4 + s5) / 2, l5 = (i5 + a5) / 2, u6 = e4.project(_c(o4), wc(l5)), c5 = Math.max(0, m4 - u6.x, y4 - u6.y, u6.x - g5, u6.y - x5);
            m4 = Math.min(m4, u6.x), g5 = Math.max(g5, u6.x), y4 = Math.min(y4, u6.y), x5 = Math.max(x5, u6.y), c5 > b4 && (v4(t5, u6, n4, i5, o4, l5), v4(u6, r5, o4, l5, s5, a5));
          }
          v4(h4, p4, n3, s4, i4, s4), v4(p4, f4, i4, s4, i4, a4), v4(f4, d3, i4, a4, n3, a4), v4(d3, h4, n3, a4, n3, s4), m4 -= b4, y4 -= b4, g5 += b4, x5 += b4;
          const _4 = 1 / Math.max(g5 - m4, x5 - y4);
          return { scale: _4, x: m4 * _4, y: y4 * _4, x2: g5 * _4, y2: x5 * _4, projection: e4 };
        }
        function By(t4, { x: e4, y: r4 }, n3 = 0) {
          return new Ue(((e4 - n3) * t4.scale - t4.x) * is, (r4 * t4.scale - t4.y) * is);
        }
        const Cy = t3.a9.identity(new Float32Array(16));
        class Ry {
          constructor(t4) {
            this.spec = t4, this.name = t4.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
          }
          project(t4, e4) {
            return { x: 0, y: 0, z: 0 };
          }
          unproject(t4, e4) {
            return new ac(0, 0);
          }
          projectTilePoint(t4, e4, r4) {
            return { x: t4, y: e4, z: 0 };
          }
          locationPoint(t4, e4, r4 = true) {
            return t4._coordinatePoint(t4.locationCoordinate(e4), r4);
          }
          pixelsPerMeter(t4, e4) {
            return vc(1, t4) * e4;
          }
          pixelSpaceConversion(t4, e4, r4) {
            return 1;
          }
          farthestPixelDistance(t4) {
            return zy(t4, t4.pixelsPerMeter);
          }
          pointCoordinate(t4, e4, r4, n3) {
            const i4 = t4.horizonLineFromTop(false), s4 = new Ue(e4, Math.max(i4, r4));
            return t4.rayIntersectionCoordinate(t4.pointRayIntersection(s4, n3));
          }
          pointCoordinate3D(t4, e4, r4) {
            const n3 = new Ue(e4, r4);
            if (t4.elevation) return t4.elevation.pointCoordinate(n3);
            {
              const e5 = this.pointCoordinate(t4, n3.x, n3.y, 0);
              return [e5.x, e5.y, e5.z];
            }
          }
          isPointAboveHorizon(t4, e4) {
            if (t4.elevation) return !this.pointCoordinate3D(t4, e4.x, e4.y);
            const r4 = t4.horizonLineFromTop();
            return e4.y < r4;
          }
          createInversionMatrix(t4, e4) {
            return Cy;
          }
          createTileMatrix(e4, r4, n3) {
            let i4, s4, a4;
            const o3 = n3.canonical, l4 = t3.a9.identity(new Float64Array(16));
            if (this.isReprojectedInTileSpace) {
              const u5 = Ty(o3, this);
              i4 = 1, s4 = u5.x + n3.wrap * u5.scale, a4 = u5.y, t3.a9.scale(l4, l4, [i4 / u5.scale, i4 / u5.scale, e4.pixelsPerMeter / r4]);
            } else i4 = r4 / e4.zoomScale(o3.z), s4 = (o3.x + Math.pow(2, o3.z) * n3.wrap) * i4, a4 = o3.y * i4;
            return t3.a9.translate(l4, l4, [s4, a4, 0]), t3.a9.scale(l4, l4, [i4 / is, i4 / is, 1]), l4;
          }
          upVector(t4, e4, r4) {
            return [0, 0, 1];
          }
          upVectorScale(t4, e4, r4) {
            return { metersToTile: 1 };
          }
        }
        class Vy extends Ry {
          constructor(t4) {
            super(t4), this.range = [4, 7], this.center = t4.center || [-96, 37.5];
            const [e4, r4] = this.parallels = t4.parallels || [29.5, 45.5], n3 = Math.sin(qe(e4));
            this.n = (n3 + Math.sin(qe(r4))) / 2, this.c = 1 + n3 * (2 * this.n - n3), this.r0 = Math.sqrt(this.c) / this.n;
          }
          project(t4, e4) {
            const { n: r4, c: n3, r0: i4 } = this, s4 = qe(t4 - this.center[0]), a4 = qe(e4), o3 = Math.sqrt(n3 - 2 * r4 * Math.sin(a4)) / r4;
            return { x: o3 * Math.sin(s4 * r4), y: o3 * Math.cos(s4 * r4) - i4, z: 0 };
          }
          unproject(t4, e4) {
            const { n: r4, c: n3, r0: i4 } = this, s4 = i4 + e4;
            let a4 = Math.atan2(t4, Math.abs(s4)) * Math.sign(s4);
            s4 * r4 < 0 && (a4 -= Math.PI * Math.sign(t4) * Math.sign(s4));
            const o3 = qe(this.center[0]) * r4;
            a4 = We(a4, -Math.PI - o3, Math.PI - o3);
            const l4 = Ze($e(a4 / r4) + this.center[0], -180, 180), u5 = Math.asin(Ze((n3 - (t4 * t4 + s4 * s4) * r4 * r4) / (2 * r4), -1, 1)), c4 = Ze($e(u5), -Ac, Ac);
            return new ac(l4, c4);
          }
        }
        const Dy = 1.340264, Ly = -0.081106, Fy = 893e-6, Oy = 3796e-6, Uy = Math.sqrt(3) / 2;
        class Ny extends Ry {
          project(t4, e4) {
            e4 = e4 / 180 * Math.PI, t4 = t4 / 180 * Math.PI;
            const r4 = Math.asin(Uy * Math.sin(e4)), n3 = r4 * r4, i4 = n3 * n3 * n3;
            return { x: 0.5 * (t4 * Math.cos(r4) / (Uy * (Dy + 3 * Ly * n3 + i4 * (7 * Fy + 9 * Oy * n3))) / Math.PI + 0.5), y: 1 - 0.5 * (r4 * (Dy + Ly * n3 + i4 * (Fy + Oy * n3)) / Math.PI + 1), z: 0 };
          }
          unproject(t4, e4) {
            t4 = (2 * t4 - 0.5) * Math.PI;
            let r4 = e4 = (2 * (1 - e4) - 1) * Math.PI, n3 = r4 * r4, i4 = n3 * n3 * n3;
            for (let t5, s5, a5, o4 = 0; o4 < 12 && (s5 = r4 * (Dy + Ly * n3 + i4 * (Fy + Oy * n3)) - e4, a5 = Dy + 3 * Ly * n3 + i4 * (7 * Fy + 9 * Oy * n3), t5 = s5 / a5, r4 = Ze(r4 - t5, -Math.PI / 3, Math.PI / 3), n3 = r4 * r4, i4 = n3 * n3 * n3, !(Math.abs(t5) < 1e-12)); ++o4) ;
            const s4 = Uy * t4 * (Dy + 3 * Ly * n3 + i4 * (7 * Fy + 9 * Oy * n3)) / Math.cos(r4), a4 = Math.asin(Math.sin(r4) / Uy), o3 = Ze(180 * s4 / Math.PI, -180, 180), l4 = Ze(180 * a4 / Math.PI, -Ac, Ac);
            return new ac(o3, l4);
          }
        }
        class jy extends Ry {
          constructor(t4) {
            super(t4), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t4, e4) {
            return { x: 0.5 + t4 / 360, y: 0.5 - e4 / 360, z: 0 };
          }
          unproject(t4, e4) {
            const r4 = 360 * (t4 - 0.5), n3 = Ze(360 * (0.5 - e4), -Ac, Ac);
            return new ac(r4, n3);
          }
        }
        const qy = Math.PI / 2;
        function $y(t4) {
          return Math.tan((qy + t4) / 2);
        }
        class Gy extends Ry {
          constructor(t4) {
            super(t4), this.center = t4.center || [0, 30];
            const [e4, r4] = this.parallels = t4.parallels || [30, 30];
            let n3 = qe(e4), i4 = qe(r4);
            this.southernCenter = n3 + i4 < 0, this.southernCenter && (n3 = -n3, i4 = -i4);
            const s4 = Math.cos(n3), a4 = $y(n3);
            this.n = n3 === i4 ? Math.sin(n3) : Math.log(s4 / Math.cos(i4)) / Math.log($y(i4) / a4), this.f = s4 * Math.pow($y(n3), this.n) / this.n;
          }
          project(t4, e4) {
            e4 = qe(e4), this.southernCenter && (e4 = -e4), t4 = qe(t4 - this.center[0]);
            const r4 = 1e-6, { n: n3, f: i4 } = this;
            i4 > 0 ? e4 < -qy + r4 && (e4 = -qy + r4) : e4 > qy - r4 && (e4 = qy - r4);
            const s4 = i4 / Math.pow($y(e4), n3);
            let a4 = s4 * Math.sin(n3 * t4), o3 = i4 - s4 * Math.cos(n3 * t4);
            return a4 = 0.5 * (a4 / Math.PI + 0.5), o3 = 0.5 * (o3 / Math.PI + 0.5), { x: a4, y: this.southernCenter ? o3 : 1 - o3, z: 0 };
          }
          unproject(t4, e4) {
            t4 = (2 * t4 - 0.5) * Math.PI, this.southernCenter && (e4 = 1 - e4), e4 = (2 * (1 - e4) - 0.5) * Math.PI;
            const { n: r4, f: n3 } = this, i4 = n3 - e4, s4 = Math.sign(i4), a4 = Math.sign(r4) * Math.sqrt(t4 * t4 + i4 * i4);
            let o3 = Math.atan2(t4, Math.abs(i4)) * s4;
            i4 * r4 < 0 && (o3 -= Math.PI * Math.sign(t4) * s4);
            const l4 = Ze($e(o3 / r4) + this.center[0], -180, 180), u5 = Ze($e(2 * Math.atan(Math.pow(n3 / a4, 1 / r4)) - qy), -Ac, Ac);
            return new ac(l4, this.southernCenter ? -u5 : u5);
          }
        }
        class Qy extends Ry {
          constructor(t4) {
            super(t4), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
          }
          project(t4, e4) {
            return { x: xc(t4), y: bc(e4), z: 0 };
          }
          unproject(t4, e4) {
            const r4 = _c(t4), n3 = wc(e4);
            return new ac(r4, n3);
          }
        }
        const Yy = qe(Ac);
        class Xy extends Ry {
          project(t4, e4) {
            const r4 = (e4 = qe(e4)) * e4, n3 = r4 * r4;
            return { x: 0.5 * ((t4 = qe(t4)) * (0.8707 - 0.131979 * r4 + n3 * (n3 * (3971e-6 * r4 - 1529e-6 * n3) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e4 * (1.007226 + r4 * (0.015085 + n3 * (0.028874 * r4 - 0.044475 - 5916e-6 * n3))) / Math.PI + 1), z: 0 };
          }
          unproject(t4, e4) {
            t4 = (2 * t4 - 0.5) * Math.PI;
            let r4 = e4 = (2 * (1 - e4) - 1) * Math.PI, n3 = 25, i4 = 0, s4 = r4 * r4;
            do {
              s4 = r4 * r4;
              const t5 = s4 * s4;
              i4 = (r4 * (1.007226 + s4 * (0.015085 + t5 * (0.028874 * s4 - 0.044475 - 5916e-6 * t5))) - e4) / (1.007226 + s4 * (0.045255 + t5 * (0.259866 * s4 - 0.311325 - 5916e-6 * 11 * t5))), r4 = Ze(r4 - i4, -Yy, Yy);
            } while (Math.abs(i4) > 1e-6 && --n3 > 0);
            s4 = r4 * r4;
            const a4 = Ze($e(t4 / (0.8707 + s4 * (s4 * (s4 * s4 * s4 * (3971e-6 - 1529e-6 * s4) - 0.013791) - 0.131979))), -180, 180), o3 = $e(r4);
            return new ac(a4, o3);
          }
        }
        const Zy = qe(Ac);
        class Ky extends Ry {
          project(t4, e4) {
            e4 = qe(e4), t4 = qe(t4);
            const r4 = Math.cos(e4), n3 = 2 / Math.PI, i4 = Math.acos(r4 * Math.cos(t4 / 2)), s4 = Math.sin(i4) / i4, a4 = 0.5 * (t4 * n3 + 2 * r4 * Math.sin(t4 / 2) / s4) || 0, o3 = 0.5 * (e4 + Math.sin(e4) / s4) || 0;
            return { x: 0.5 * (a4 / Math.PI + 0.5), y: 1 - 0.5 * (o3 / Math.PI + 1), z: 0 };
          }
          unproject(t4, e4) {
            let r4 = t4 = (2 * t4 - 0.5) * Math.PI, n3 = e4 = (2 * (1 - e4) - 1) * Math.PI, i4 = 25;
            const s4 = 1e-6;
            let a4 = 0, o3 = 0;
            do {
              const i5 = Math.cos(n3), s5 = Math.sin(n3), l4 = 2 * s5 * i5, u5 = s5 * s5, c4 = i5 * i5, h4 = Math.cos(r4 / 2), p4 = Math.sin(r4 / 2), f4 = 2 * h4 * p4, d3 = p4 * p4, m4 = 1 - c4 * h4 * h4, y4 = m4 ? 1 / m4 : 0, g5 = m4 ? Math.acos(i5 * h4) * Math.sqrt(1 / m4) : 0, x5 = 0.5 * (2 * g5 * i5 * p4 + 2 * r4 / Math.PI) - t4, b4 = 0.5 * (g5 * s5 + n3) - e4, v4 = 0.5 * y4 * (c4 * d3 + g5 * i5 * h4 * u5) + 1 / Math.PI, _4 = y4 * (f4 * l4 / 4 - g5 * s5 * p4), w5 = 0.125 * y4 * (l4 * p4 - g5 * s5 * c4 * f4), M3 = 0.5 * y4 * (u5 * h4 + g5 * d3 * i5) + 0.5, A4 = _4 * w5 - M3 * v4;
              a4 = (b4 * _4 - x5 * M3) / A4, o3 = (x5 * w5 - b4 * v4) / A4, r4 = Ze(r4 - a4, -Math.PI, Math.PI), n3 = Ze(n3 - o3, -Zy, Zy);
            } while ((Math.abs(a4) > s4 || Math.abs(o3) > s4) && --i4 > 0);
            return new ac($e(r4), $e(n3));
          }
        }
        class Wy extends Ry {
          constructor(t4) {
            super(t4), this.center = t4.center || [0, 0], this.parallels = t4.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(qe(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t4, e4) {
            const { scale: r4, cosPhi: n3 } = this;
            return { x: qe(t4) * n3 * r4 + 0.5, y: -Math.sin(qe(e4)) / n3 * r4 + 0.5, z: 0 };
          }
          unproject(t4, e4) {
            const { scale: r4, cosPhi: n3 } = this, i4 = -(e4 - 0.5) / r4, s4 = Ze($e((t4 - 0.5) / r4) / n3, -180, 180), a4 = Math.asin(Ze(i4 * n3, -1, 1)), o3 = Ze($e(a4), -Ac, Ac);
            return new ac(s4, o3);
          }
        }
        class Hy extends Qy {
          constructor(t4) {
            super(t4), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
          }
          projectTilePoint(e4, r4, n3) {
            const i4 = Th(e4, r4, n3), s4 = Rh(Sh(n3));
            return t3.Q.transformMat4(i4, i4, s4), { x: i4[0], y: i4[1], z: i4[2] };
          }
          locationPoint(e4, r4) {
            const n3 = nc(r4.lat, r4.lng), i4 = t3.Q.normalize([], n3), s4 = e4.elevation ? e4.elevation.getAtPointOrZero(e4.locationCoordinate(r4), e4._centerAltitude) : e4._centerAltitude, a4 = vc(1, 0) * is * s4;
            t3.Q.scaleAndAdd(n3, n3, i4, a4);
            const o3 = t3.a9.identity(new Float64Array(16));
            return t3.a9.multiply(o3, e4.pixelMatrix, e4.globeMatrix), t3.Q.transformMat4(n3, n3, o3), new Ue(n3[0], n3[1]);
          }
          pixelsPerMeter(t4, e4) {
            return vc(1, 0) * e4;
          }
          pixelSpaceConversion(t4, e4, r4) {
            const n3 = vc(1, t4) * e4, i4 = qn(vc(1, 45) * e4, n3, r4);
            return this.pixelsPerMeter(t4, e4) / i4;
          }
          createTileMatrix(e4, r4, n3) {
            const i4 = Vh(Sh(n3.canonical));
            return t3.a9.multiply(new Float64Array(16), e4.globeMatrix, i4);
          }
          createInversionMatrix(e4, r4) {
            const { center: n3 } = e4, i4 = Rh(Sh(r4));
            return t3.a9.rotateY(i4, i4, qe(n3.lng)), t3.a9.rotateX(i4, i4, qe(n3.lat)), t3.a9.scale(i4, i4, [e4._pixelsPerMercatorPixel, e4._pixelsPerMercatorPixel, 1]), Float32Array.from(i4);
          }
          pointCoordinate(t4, e4, r4, n3) {
            return wh(t4, e4, r4, true) || new Ec(0, 0);
          }
          pointCoordinate3D(t4, e4, r4) {
            const n3 = this.pointCoordinate(t4, e4, r4, 0);
            return [n3.x, n3.y, n3.z];
          }
          isPointAboveHorizon(t4, e4) {
            return !wh(t4, e4.x, e4.y, false);
          }
          farthestPixelDistance(e4) {
            const r4 = function(e5, r5) {
              const n4 = e5.cameraToCenterDistance, i4 = e5._centerAltitude * r5, s4 = e5._camera, a4 = e5._camera.forward(), o3 = t3.Q.add([], t3.Q.scale([], a4, -n4), [0, 0, i4]), l4 = e5.worldSize / (2 * Math.PI), u5 = [0, 0, -l4], c4 = e5.width / e5.height, h4 = Math.tan(e5.fovAboveCenter), p4 = t3.Q.scale([], s4.up(), h4), f4 = t3.Q.scale([], s4.right(), h4 * c4), d3 = t3.Q.normalize([], t3.Q.add([], t3.Q.add([], a4, p4), f4)), m4 = [];
              let y4;
              if (new lh(o3, d3).closestPointOnSphere(u5, l4, m4)) {
                const r6 = t3.Q.add([], m4, u5), n5 = t3.Q.sub([], r6, o3);
                y4 = Math.cos(e5.fovAboveCenter) * t3.Q.length(n5);
              } else {
                const e6 = t3.Q.sub([], o3, u5), r6 = t3.Q.sub([], u5, o3);
                t3.Q.normalize(r6, r6);
                const n5 = t3.Q.length(e6) - l4;
                y4 = Math.sqrt(n5 * (n5 + 2 * l4));
                const i5 = Math.acos(y4 / (l4 + n5)) - Math.acos(t3.Q.dot(a4, r6));
                y4 *= Math.cos(i5);
              }
              return 1.01 * y4;
            }(e4, this.pixelsPerMeter(e4.center.lat, e4.worldSize)), n3 = Oh(e4.zoom);
            if (n3 > 0) {
              const t4 = zy(e4, vc(1, e4.center.lat) * e4.worldSize), i4 = e4.worldSize / (2 * Math.PI), s4 = Math.max(e4.width, e4.height) / e4.worldSize * Math.PI;
              return qn(r4, t4 + i4 * (1 - Math.cos(s4)), Math.pow(n3, 10));
            }
            return r4;
          }
          upVector(t4, e4, r4) {
            return Th(e4, r4, t4, 1);
          }
          upVectorScale(t4) {
            return { metersToTile: vh(Bh(Sh(t4))) };
          }
        }
        function Jy(t4) {
          const e4 = t4.parallels, r4 = !!e4 && Math.abs(e4[0] + e4[1]) < 0.01;
          switch (t4.name) {
            case "mercator":
              return new Qy(t4);
            case "equirectangular":
              return new jy(t4);
            case "naturalEarth":
              return new Xy(t4);
            case "equalEarth":
              return new Ny(t4);
            case "winkelTripel":
              return new Ky(t4);
            case "albers":
              return r4 ? new Wy(t4) : new Vy(t4);
            case "lambertConformalConic":
              return r4 ? new Wy(t4) : new Gy(t4);
            case "globe":
              return new Hy(t4);
          }
          throw new Error(`Invalid projection name: ${t4.name}`);
        }
        const tg = ff.types, eg = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function rg(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4) {
          const f4 = o3 ? Math.min(Ay, Math.round(o3[0])) : 0, d3 = o3 ? Math.min(Ay, Math.round(o3[1])) : 0;
          t4.emplaceBack(e4, r4, Math.round(32 * n3), Math.round(32 * i4), s4, a4, (f4 << 1) + (l4 ? 1 : 0), d3, 16 * u5, 16 * c4, 256 * h4, 256 * p4);
        }
        function ng(t4, e4, r4) {
          t4.emplaceBack(e4, r4);
        }
        function ig(t4, e4, r4, n3, i4, s4, a4) {
          t4.emplaceBack(e4, r4, n3, i4, s4, a4);
        }
        function sg(t4, e4, r4, n3, i4) {
          t4.emplaceBack(e4, r4, n3, i4), t4.emplaceBack(e4, r4, n3, i4), t4.emplaceBack(e4, r4, n3, i4), t4.emplaceBack(e4, r4, n3, i4);
        }
        function ag(t4) {
          for (const e4 of t4.sections) if (ko(e4.text)) return true;
          return false;
        }
        class og {
          constructor(t4) {
            this.layoutVertexArray = new Vl(), this.indexArray = new ql(), this.programConfigurations = t4, this.segments = new mu(), this.dynamicLayoutVertexArray = new zl(), this.opacityVertexArray = new Ll(), this.placedSymbolArray = new su(), this.iconTransitioningVertexArray = new Fl(), this.globeExtVertexArray = new Dl(), this.zOffsetVertexArray = new Ql();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
          }
          upload(t4, e4, r4, n3, i4) {
            this.isEmpty() || (r4 && (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, Vd.members), this.indexBuffer = t4.createIndexBuffer(this.indexArray, e4), this.dynamicLayoutVertexBuffer = t4.createVertexBuffer(this.dynamicLayoutVertexArray, Ld.members, true), this.opacityVertexBuffer = t4.createVertexBuffer(this.opacityVertexArray, eg, true), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t4.createVertexBuffer(this.iconTransitioningVertexArray, Od.members, true)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t4.createVertexBuffer(this.globeExtVertexArray, Dd.members, true)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i4) && (this.zOffsetVertexBuffer = t4.createVertexBuffer(this.zOffsetVertexArray, Fd.members, true)), this.opacityVertexBuffer.itemSize = 1), (r4 || n3) && this.programConfigurations.upload(t4));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
          }
        }
        fo(og, "SymbolBuffers");
        class lg {
          constructor(t4, e4, r4) {
            this.layoutVertexArray = new t4(), this.layoutAttributes = e4, this.indexArray = new r4(), this.segments = new mu(), this.collisionVertexArray = new jl(), this.collisionVertexArrayExt = new zl();
          }
          upload(t4) {
            this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t4.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t4.createVertexBuffer(this.collisionVertexArray, Ud.members, true), this.collisionVertexBufferExt = t4.createVertexBuffer(this.collisionVertexArrayExt, Nd.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
          }
        }
        fo(lg, "CollisionBuffers");
        class ug {
          constructor(e4) {
            this.collisionBoxArray = e4.collisionBoxArray, this.zoom = e4.zoom, this.overscaling = e4.overscaling, this.layers = e4.layers, this.layerIds = this.layers.map((t4) => t4.fqid), this.index = e4.index, this.pixelRatio = e4.pixelRatio, this.sourceLayerIndex = e4.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.hasAnyIconTextFit = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = t3.a9.identity([]), this.placementViewportMatrix = t3.a9.identity([]);
            const r4 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Qd(this.zoom, r4["text-size"]), this.iconSizeData = Qd(this.zoom, r4["icon-size"]);
            const n3 = this.layers[0].layout, i4 = n3.get("symbol-sort-key"), s4 = n3.get("symbol-z-order");
            this.canOverlap = n3.get("text-allow-overlap") || n3.get("icon-allow-overlap") || n3.get("text-ignore-placement") || n3.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s4 && void 0 !== i4.constantOr(1), this.sortFeaturesByY = ("viewport-y" === s4 || "auto" === s4 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = n3.get("text-writing-mode").map((t4) => Pm[t4]), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.sourceID = e4.sourceID, this.projection = e4.projection, this.hasAnyZOffset = false, this.zOffsetSortDirty = false, this.zOffsetBuffersNeedUpload = n3.get("symbol-z-elevate");
          }
          createArrays() {
            this.text = new og(new ju(this.layers, this.zoom, (t4) => /^text/.test(t4))), this.icon = new og(new ju(this.layers, this.zoom, (t4) => /^icon/.test(t4))), this.glyphOffsetArray = new lu(), this.lineVertexArray = new uu(), this.symbolInstances = new ou();
          }
          calculateGlyphDependencies(t4, e4, r4, n3, i4) {
            for (let r5 = 0; r5 < t4.length; r5++) {
              const s4 = t4.codePointAt(r5);
              if (void 0 === s4) break;
              if (e4[s4] = true, n3 && i4 && s4 <= 65535) {
                const n4 = Wd[t4.charAt(r5)];
                n4 && (e4[n4.charCodeAt(0)] = true);
              }
            }
          }
          populate(e4, r4, n3, i4) {
            const s4 = this.layers[0], a4 = s4.layout, o3 = "globe" === this.projection.name, l4 = a4.get("text-font"), u5 = a4.get("text-field"), c4 = a4.get("icon-image"), h4 = ("constant" !== u5.value.kind || u5.value.value instanceof fi && !u5.value.value.isEmpty() || u5.value.value.toString().length > 0) && ("constant" !== l4.value.kind || l4.value.value.length > 0), p4 = "constant" !== c4.value.kind || !!c4.value.value || Object.keys(c4.parameters).length > 0, f4 = a4.get("symbol-sort-key");
            if (this.features = [], !h4 && !p4) return;
            const d3 = r4.iconDependencies, m4 = r4.glyphDependencies, y4 = r4.availableImages, g5 = new Uo(this.zoom);
            for (const { feature: r5, id: u6, index: c5, sourceLayerIndex: x5 } of e4) {
              const e5 = s4._featureFilter.needGeometry, b4 = Fc(r5, e5);
              if (!s4._featureFilter.filter(g5, b4, n3)) continue;
              if (e5 || (b4.geometry = Lc(r5, n3, i4)), o3 && 1 !== r5.type && n3.z <= 5) {
                const e6 = b4.geometry, r6 = 0.98078528056, i5 = (e7, i6) => {
                  const s5 = Th(e7.x, e7.y, n3, 1), a5 = Th(i6.x, i6.y, n3, 1);
                  return t3.Q.dot(s5, a5) < r6;
                };
                for (let t4 = 0; t4 < e6.length; t4++) e6[t4] = Cc(e6[t4], i5);
              }
              let v4, _4;
              if (h4) {
                const t4 = s4.getValueAndResolveTokens("text-field", b4, n3, y4), e6 = fi.factory(t4);
                ag(e6) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Lo() || this.hasRTLText && Oo.isParsed()) && (v4 = Kd(e6, s4, b4));
              }
              if (p4) {
                const t4 = s4.getValueAndResolveTokens("icon-image", b4, n3, y4);
                _4 = t4 instanceof di ? t4 : di.fromString(t4);
              }
              if (!v4 && !_4) continue;
              const w5 = this.sortFeaturesByKey ? f4.evaluate(b4, {}, n3) : void 0;
              if (this.features.push({ id: u6, text: v4, icon: _4, index: c5, sourceLayerIndex: x5, geometry: b4.geometry, properties: r5.properties, type: tg[r5.type], sortKey: w5 }), _4 && (d3[_4.namePrimary] = true, _4.nameSecondary && (d3[_4.nameSecondary] = true)), v4) {
                const t4 = l4.evaluate(b4, {}, n3).join(","), e6 = "map" === a4.get("text-rotation-alignment") && "point" !== a4.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Pm.vertical) >= 0;
                for (const r6 of v4.sections) if (r6.image) d3[r6.image.namePrimary] = true;
                else {
                  const n4 = vo(v4.toString()), i5 = r6.fontStack || t4, s5 = m4[i5] = m4[i5] || {};
                  this.calculateGlyphDependencies(r6.text, s5, e6, this.allowVerticalPlacement, n4);
                }
              }
            }
            "line" === a4.get("symbol-placement") && (this.features = function(t4) {
              const e5 = {}, r5 = {}, n4 = [];
              let i5 = 0;
              function s5(e6) {
                n4.push(t4[e6]), i5++;
              }
              function a5(t5, e6, i6) {
                const s6 = r5[t5];
                return delete r5[t5], r5[e6] = s6, n4[s6].geometry[0].pop(), n4[s6].geometry[0] = n4[s6].geometry[0].concat(i6[0]), s6;
              }
              function o4(t5, r6, i6) {
                const s6 = e5[r6];
                return delete e5[r6], e5[t5] = s6, n4[s6].geometry[0].shift(), n4[s6].geometry[0] = i6[0].concat(n4[s6].geometry[0]), s6;
              }
              function l5(t5, e6, r6) {
                const n5 = r6 ? e6[0][e6[0].length - 1] : e6[0][0];
                return `${t5}:${n5.x}:${n5.y}`;
              }
              for (let u6 = 0; u6 < t4.length; u6++) {
                const c5 = t4[u6], h5 = c5.geometry, p5 = c5.text ? c5.text.toString() : null;
                if (!p5) {
                  s5(u6);
                  continue;
                }
                const f5 = l5(p5, h5), d4 = l5(p5, h5, true);
                if (f5 in r5 && d4 in e5 && r5[f5] !== e5[d4]) {
                  const t5 = o4(f5, d4, h5), i6 = a5(f5, d4, n4[t5].geometry);
                  delete e5[f5], delete r5[d4], r5[l5(p5, n4[i6].geometry, true)] = i6, n4[t5].geometry = null;
                } else f5 in r5 ? a5(f5, d4, h5) : d4 in e5 ? o4(f5, d4, h5) : (s5(u6), e5[f5] = i5 - 1, r5[d4] = i5 - 1);
              }
              return n4.filter((t5) => t5.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t4, e5) => t4.sortKey - e5.sortKey);
          }
          update(t4, e4, r4, n3, i4) {
            const s4 = 0 !== Object.keys(t4).length;
            if (s4 && !this.stateDependentLayers.length) return;
            const a4 = s4 ? this.stateDependentLayers : this.layers;
            this.text.programConfigurations.updatePaintArrays(t4, e4, a4, r4, n3, i4), this.icon.programConfigurations.updatePaintArrays(t4, e4, a4, r4, n3, i4);
          }
          updateZOffset() {
            const t4 = (t5, e5, n4) => {
              r4 += e5, r4 > t5.length && t5.resize(r4);
              for (let i4 = -e5; i4 < 0; i4++) t5.emplace(i4 + r4, n4);
            }, e4 = (t5, e5, r5) => {
              n3 += e5, n3 > t5.length && t5.resize(n3);
              for (let i4 = -e5; i4 < 0; i4++) t5.emplace(i4 + n3, r5);
            };
            if (!this.zOffsetBuffersNeedUpload) return;
            this.zOffsetBuffersNeedUpload = false;
            let r4 = 0, n3 = 0;
            for (let r5 = 0; r5 < this.symbolInstances.length; r5++) {
              const n4 = this.symbolInstances.get(r5), { numHorizontalGlyphVertices: i4, numVerticalGlyphVertices: s4, numIconVertices: a4 } = n4, o3 = n4.zOffset, l4 = a4 > 0;
              if ((i4 > 0 || s4 > 0) && (t4(this.text.zOffsetVertexArray, i4, o3), t4(this.text.zOffsetVertexArray, s4, o3)), l4) {
                const { placedIconSymbolIndex: t5, verticalPlacedIconSymbolIndex: r6 } = n4;
                t5 >= 0 && e4(this.icon.zOffsetVertexArray, a4, o3), r6 >= 0 && e4(this.icon.zOffsetVertexArray, n4.numVerticalIconVertices, o3);
              }
            }
            this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t4) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t4), this.iconCollisionBox.upload(t4)), this.text.upload(t4, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t4, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          getProjection() {
            return this.projectionInstance || (this.projectionInstance = Jy(this.projection)), this.projectionInstance;
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t4, e4) {
            const r4 = this.lineVertexArray.length;
            if (void 0 !== t4.segment) for (const { x: t5, y: r5 } of e4) this.lineVertexArray.emplaceBack(t5, r5);
            return { lineStartIndex: r4, lineLength: this.lineVertexArray.length - r4 };
          }
          addSymbols(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4, h4, p4, f4, d3, m4) {
            const y4 = t4.indexArray, g5 = t4.layoutVertexArray, x5 = t4.globeExtVertexArray, b4 = t4.segments.prepareSegment(4 * e4.length, g5, y4, this.canOverlap ? s4.sortKey : void 0), v4 = this.glyphOffsetArray.length, _4 = b4.vertexLength, w5 = this.allowVerticalPlacement && a4 === Pm.vertical ? Math.PI / 2 : 0, M3 = s4.text && s4.text.sections;
            for (let n4 = 0; n4 < e4.length; n4++) {
              const { tl: i5, tr: a5, bl: u6, br: c5, texPrimary: h5, texSecondary: v5, pixelOffsetTL: _5, pixelOffsetBR: A5, minFontScaleX: S3, minFontScaleY: I4, glyphOffset: k4, isSDF: P4, sectionIndex: E3 } = e4[n4], z4 = b4.vertexLength, T5 = k4[1];
              if (rg(g5, l4.x, l4.y, i5.x, T5 + i5.y, h5.x, h5.y, r4, P4, _5.x, _5.y, S3, I4), rg(g5, l4.x, l4.y, a5.x, T5 + a5.y, h5.x + h5.w, h5.y, r4, P4, A5.x, _5.y, S3, I4), rg(g5, l4.x, l4.y, u6.x, T5 + u6.y, h5.x, h5.y + h5.h, r4, P4, _5.x, A5.y, S3, I4), rg(g5, l4.x, l4.y, c5.x, T5 + c5.y, h5.x + h5.w, h5.y + h5.h, r4, P4, A5.x, A5.y, S3, I4), o3) {
                const { x: e5, y: r5, z: n5 } = o3.anchor, [i6, s5, a6] = o3.up;
                ig(x5, e5, r5, n5, i6, s5, a6), ig(x5, e5, r5, n5, i6, s5, a6), ig(x5, e5, r5, n5, i6, s5, a6), ig(x5, e5, r5, n5, i6, s5, a6), sg(t4.dynamicLayoutVertexArray, e5, r5, n5, w5);
              } else sg(t4.dynamicLayoutVertexArray, l4.x, l4.y, l4.z, w5);
              if (m4) {
                const e5 = v5 || h5;
                ng(t4.iconTransitioningVertexArray, e5.x, e5.y), ng(t4.iconTransitioningVertexArray, e5.x + e5.w, e5.y), ng(t4.iconTransitioningVertexArray, e5.x, e5.y + e5.h), ng(t4.iconTransitioningVertexArray, e5.x + e5.w, e5.y + e5.h);
              }
              y4.emplaceBack(z4, z4 + 1, z4 + 2), y4.emplaceBack(z4 + 1, z4 + 2, z4 + 3), b4.vertexLength += 4, b4.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(k4[0]), n4 !== e4.length - 1 && E3 === e4[n4 + 1].sectionIndex || t4.programConfigurations.populatePaintArrays(g5.length, s4, s4.index, {}, p4, f4, d3, M3 && M3[E3]);
            }
            const A4 = o3 ? o3.anchor : l4;
            t4.placedSymbolArray.emplaceBack(A4.x, A4.y, A4.z, l4.x, l4.y, v4, this.glyphOffsetArray.length - v4, _4, u5, c4, l4.segment, r4 ? r4[0] : 0, r4 ? r4[1] : 0, n3[0], n3[1], a4, 0, false, 0, h4, 0);
          }
          _commitLayoutVertex(t4, e4, r4, n3, i4, s4, a4) {
            t4.emplaceBack(e4, r4, n3, i4, s4, Math.round(a4.x), Math.round(a4.y));
          }
          _addCollisionDebugVertices(t4, e4, r4, n3, i4, s4, a4) {
            const o3 = r4.segments.prepareSegment(4, r4.layoutVertexArray, r4.indexArray), l4 = o3.vertexLength, u5 = a4.tileAnchorX, c4 = a4.tileAnchorY;
            for (let t5 = 0; t5 < 4; t5++) r4.collisionVertexArray.emplaceBack(0, 0, 0, 0);
            this._commitDebugCollisionVertexUpdate(r4.collisionVertexArrayExt, e4, t4.padding, a4.zOffset), this._commitLayoutVertex(r4.layoutVertexArray, n3, i4, s4, u5, c4, new Ue(t4.x1, t4.y1)), this._commitLayoutVertex(r4.layoutVertexArray, n3, i4, s4, u5, c4, new Ue(t4.x2, t4.y1)), this._commitLayoutVertex(r4.layoutVertexArray, n3, i4, s4, u5, c4, new Ue(t4.x2, t4.y2)), this._commitLayoutVertex(r4.layoutVertexArray, n3, i4, s4, u5, c4, new Ue(t4.x1, t4.y2)), o3.vertexLength += 4;
            const h4 = r4.indexArray;
            h4.emplaceBack(l4, l4 + 1), h4.emplaceBack(l4 + 1, l4 + 2), h4.emplaceBack(l4 + 2, l4 + 3), h4.emplaceBack(l4 + 3, l4), o3.primitiveLength += 4;
          }
          _addTextDebugCollisionBoxes(t4, e4, r4, n3, i4, s4) {
            for (let a4 = n3; a4 < i4; a4++) {
              const n4 = r4.get(a4), i5 = this.getSymbolInstanceTextSize(t4, s4, e4, a4);
              this._addCollisionDebugVertices(n4, i5, this.textCollisionBox, n4.projectedAnchorX, n4.projectedAnchorY, n4.projectedAnchorZ, s4);
            }
          }
          _addIconDebugCollisionBoxes(t4, e4, r4, n3, i4, s4) {
            for (let a4 = n3; a4 < i4; a4++) {
              const n4 = r4.get(a4), i5 = this.getSymbolInstanceIconSize(t4, e4, s4.placedIconSymbolIndex);
              this._addCollisionDebugVertices(n4, i5, this.iconCollisionBox, n4.projectedAnchorX, n4.projectedAnchorY, n4.projectedAnchorZ, s4);
            }
          }
          generateCollisionDebugBuffers(t4, e4) {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new lg(Ul, jd.members, Fl), this.iconCollisionBox = new lg(Ul, jd.members, Fl);
            const r4 = Xd(this.iconSizeData, t4), n3 = Xd(this.textSizeData, t4);
            for (let i4 = 0; i4 < this.symbolInstances.length; i4++) {
              const s4 = this.symbolInstances.get(i4);
              this._addTextDebugCollisionBoxes(n3, t4, e4, s4.textBoxStartIndex, s4.textBoxEndIndex, s4), this._addTextDebugCollisionBoxes(n3, t4, e4, s4.verticalTextBoxStartIndex, s4.verticalTextBoxEndIndex, s4), this._addIconDebugCollisionBoxes(r4, t4, e4, s4.iconBoxStartIndex, s4.iconBoxEndIndex, s4), this._addIconDebugCollisionBoxes(r4, t4, e4, s4.verticalIconBoxStartIndex, s4.verticalIconBoxEndIndex, s4);
            }
          }
          getSymbolInstanceTextSize(t4, e4, r4, n3) {
            const i4 = this.text.placedSymbolArray.get(e4.rightJustifiedTextSymbolIndex >= 0 ? e4.rightJustifiedTextSymbolIndex : e4.centerJustifiedTextSymbolIndex >= 0 ? e4.centerJustifiedTextSymbolIndex : e4.leftJustifiedTextSymbolIndex >= 0 ? e4.leftJustifiedTextSymbolIndex : e4.verticalPlacedTextSymbolIndex >= 0 ? e4.verticalPlacedTextSymbolIndex : n3), s4 = Yd(this.textSizeData, t4, i4) / $d;
            return this.tilePixelRatio * s4;
          }
          getSymbolInstanceIconSize(t4, e4, r4) {
            const n3 = this.icon.placedSymbolArray.get(r4), i4 = Yd(this.iconSizeData, t4, n3);
            return this.tilePixelRatio * i4;
          }
          _commitDebugCollisionVertexUpdate(t4, e4, r4, n3) {
            t4.emplaceBack(e4, -r4, -r4, n3), t4.emplaceBack(e4, r4, -r4, n3), t4.emplaceBack(e4, r4, r4, n3), t4.emplaceBack(e4, -r4, r4, n3);
          }
          _updateTextDebugCollisionBoxes(t4, e4, r4, n3, i4, s4) {
            for (let a4 = n3; a4 < i4; a4++) {
              const n4 = r4.get(a4), i5 = this.getSymbolInstanceTextSize(t4, s4, e4, a4);
              this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i5, n4.padding, s4.zOffset);
            }
          }
          _updateIconDebugCollisionBoxes(t4, e4, r4, n3, i4, s4) {
            for (let a4 = n3; a4 < i4; a4++) {
              const n4 = r4.get(a4), i5 = this.getSymbolInstanceIconSize(t4, e4, s4.placedIconSymbolIndex);
              this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i5, n4.padding, s4.zOffset);
            }
          }
          updateCollisionDebugBuffers(t4, e4) {
            if (!this.hasDebugData()) return;
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
            const r4 = Xd(this.iconSizeData, t4), n3 = Xd(this.textSizeData, t4);
            for (let i4 = 0; i4 < this.symbolInstances.length; i4++) {
              const s4 = this.symbolInstances.get(i4);
              this._updateTextDebugCollisionBoxes(n3, t4, e4, s4.textBoxStartIndex, s4.textBoxEndIndex, s4), this._updateTextDebugCollisionBoxes(n3, t4, e4, s4.verticalTextBoxStartIndex, s4.verticalTextBoxEndIndex, s4), this._updateIconDebugCollisionBoxes(r4, t4, e4, s4.iconBoxStartIndex, s4.iconBoxEndIndex, s4), this._updateIconDebugCollisionBoxes(r4, t4, e4, s4.verticalIconBoxStartIndex, s4.verticalIconBoxEndIndex, s4);
            }
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
          }
          _deserializeCollisionBoxesForSymbol(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
            const u5 = {};
            if (e4 < r4) {
              const { x1: r5, y1: n4, x2: i5, y2: s5, padding: a5, projectedAnchorX: o4, projectedAnchorY: l5, projectedAnchorZ: c4, tileAnchorX: h4, tileAnchorY: p4, featureIndex: f4 } = t4.get(e4);
              u5.textBox = { x1: r5, y1: n4, x2: i5, y2: s5, padding: a5, projectedAnchorX: o4, projectedAnchorY: l5, projectedAnchorZ: c4, tileAnchorX: h4, tileAnchorY: p4 }, u5.textFeatureIndex = f4;
            }
            if (n3 < i4) {
              const { x1: e5, y1: r5, x2: i5, y2: s5, padding: a5, projectedAnchorX: o4, projectedAnchorY: l5, projectedAnchorZ: c4, tileAnchorX: h4, tileAnchorY: p4, featureIndex: f4 } = t4.get(n3);
              u5.verticalTextBox = { x1: e5, y1: r5, x2: i5, y2: s5, padding: a5, projectedAnchorX: o4, projectedAnchorY: l5, projectedAnchorZ: c4, tileAnchorX: h4, tileAnchorY: p4 }, u5.verticalTextFeatureIndex = f4;
            }
            if (s4 < a4) {
              const { x1: e5, y1: r5, x2: n4, y2: i5, padding: a5, projectedAnchorX: o4, projectedAnchorY: l5, projectedAnchorZ: c4, tileAnchorX: h4, tileAnchorY: p4, featureIndex: f4 } = t4.get(s4);
              u5.iconBox = { x1: e5, y1: r5, x2: n4, y2: i5, padding: a5, projectedAnchorX: o4, projectedAnchorY: l5, projectedAnchorZ: c4, tileAnchorX: h4, tileAnchorY: p4 }, u5.iconFeatureIndex = f4;
            }
            if (o3 < l4) {
              const { x1: e5, y1: r5, x2: n4, y2: i5, padding: s5, projectedAnchorX: a5, projectedAnchorY: l5, projectedAnchorZ: c4, tileAnchorX: h4, tileAnchorY: p4, featureIndex: f4 } = t4.get(o3);
              u5.verticalIconBox = { x1: e5, y1: r5, x2: n4, y2: i5, padding: s5, projectedAnchorX: a5, projectedAnchorY: l5, projectedAnchorZ: c4, tileAnchorX: h4, tileAnchorY: p4 }, u5.verticalIconFeatureIndex = f4;
            }
            return u5;
          }
          deserializeCollisionBoxes(t4) {
            this.collisionArrays = [];
            for (let e4 = 0; e4 < this.symbolInstances.length; e4++) {
              const r4 = this.symbolInstances.get(e4);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t4, r4.textBoxStartIndex, r4.textBoxEndIndex, r4.verticalTextBoxStartIndex, r4.verticalTextBoxEndIndex, r4.iconBoxStartIndex, r4.iconBoxEndIndex, r4.verticalIconBoxStartIndex, r4.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          hasIconTextFit() {
            return this.hasAnyIconTextFit;
          }
          addIndicesForPlacedSymbol(t4, e4) {
            const r4 = t4.placedSymbolArray.get(e4), n3 = r4.vertexStartIndex + 4 * r4.numGlyphs;
            for (let e5 = r4.vertexStartIndex; e5 < n3; e5 += 4) t4.indexArray.emplaceBack(e5, e5 + 1, e5 + 2), t4.indexArray.emplaceBack(e5 + 1, e5 + 2, e5 + 3);
          }
          getSortedSymbolIndexes(t4) {
            if (this.sortedAngle === t4 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
            const e4 = Math.sin(t4), r4 = Math.cos(t4), n3 = [], i4 = [], s4 = [];
            for (let t5 = 0; t5 < this.symbolInstances.length; ++t5) {
              s4.push(t5);
              const a4 = this.symbolInstances.get(t5);
              n3.push(0 | Math.round(e4 * a4.tileAnchorX + r4 * a4.tileAnchorY)), i4.push(a4.featureIndex);
            }
            return s4.sort((t5, e5) => n3[t5] - n3[e5] || i4[e5] - i4[t5]), s4;
          }
          getSortedIndexesByZOffset() {
            if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
            if (!this.symbolInstanceIndexesSortedZOffset) {
              this.symbolInstanceIndexesSortedZOffset = [];
              for (let t4 = 0; t4 < this.symbolInstances.length; ++t4) this.symbolInstanceIndexesSortedZOffset.push(t4);
            }
            return this.zOffsetSortDirty = false, this.symbolInstanceIndexesSortedZOffset.sort((t4, e4) => this.symbolInstances.get(e4).zOffset - this.symbolInstances.get(t4).zOffset);
          }
          addToSortKeyRanges(t4, e4) {
            const r4 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r4 && r4.sortKey === e4 ? r4.symbolInstanceEnd = t4 + 1 : this.sortKeyRanges.push({ sortKey: e4, symbolInstanceStart: t4, symbolInstanceEnd: t4 + 1 });
          }
          sortFeatures(t4) {
            if (this.sortFeaturesByY && this.sortedAngle !== t4 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t4), this.sortedAngle = t4, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t5 of this.symbolInstanceIndexes) {
                const e4 = this.symbolInstances.get(t5);
                this.featureSortOrder.push(e4.featureIndex);
                const { rightJustifiedTextSymbolIndex: r4, centerJustifiedTextSymbolIndex: n3, leftJustifiedTextSymbolIndex: i4, verticalPlacedTextSymbolIndex: s4, placedIconSymbolIndex: a4, verticalPlacedIconSymbolIndex: o3 } = e4;
                r4 >= 0 && this.addIndicesForPlacedSymbol(this.text, r4), n3 >= 0 && n3 !== r4 && this.addIndicesForPlacedSymbol(this.text, n3), i4 >= 0 && i4 !== n3 && i4 !== r4 && this.addIndicesForPlacedSymbol(this.text, i4), s4 >= 0 && this.addIndicesForPlacedSymbol(this.text, s4), a4 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a4), o3 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o3);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        fo(ug, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), ug.addDynamicAttributes = sg;
        const cg = new Ho({ "symbol-placement": new Zo(el.layout_symbol["symbol-placement"]), "symbol-spacing": new Zo(el.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Zo(el.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ko(el.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Zo(el.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new Zo(el.layout_symbol["symbol-z-elevate"]), "icon-allow-overlap": new Zo(el.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Zo(el.layout_symbol["icon-ignore-placement"]), "icon-optional": new Zo(el.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Zo(el.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ko(el.layout_symbol["icon-size"]), "icon-text-fit": new Ko(el.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ko(el.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ko(el.layout_symbol["icon-image"]), "icon-rotate": new Ko(el.layout_symbol["icon-rotate"]), "icon-padding": new Zo(el.layout_symbol["icon-padding"]), "icon-keep-upright": new Zo(el.layout_symbol["icon-keep-upright"]), "icon-offset": new Ko(el.layout_symbol["icon-offset"]), "icon-anchor": new Ko(el.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Zo(el.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Zo(el.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Zo(el.layout_symbol["text-rotation-alignment"]), "text-field": new Ko(el.layout_symbol["text-field"]), "text-font": new Ko(el.layout_symbol["text-font"]), "text-size": new Ko(el.layout_symbol["text-size"]), "text-max-width": new Ko(el.layout_symbol["text-max-width"]), "text-line-height": new Ko(el.layout_symbol["text-line-height"]), "text-letter-spacing": new Ko(el.layout_symbol["text-letter-spacing"]), "text-justify": new Ko(el.layout_symbol["text-justify"]), "text-radial-offset": new Ko(el.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Zo(el.layout_symbol["text-variable-anchor"]), "text-anchor": new Ko(el.layout_symbol["text-anchor"]), "text-max-angle": new Zo(el.layout_symbol["text-max-angle"]), "text-writing-mode": new Zo(el.layout_symbol["text-writing-mode"]), "text-rotate": new Ko(el.layout_symbol["text-rotate"]), "text-padding": new Zo(el.layout_symbol["text-padding"]), "text-keep-upright": new Zo(el.layout_symbol["text-keep-upright"]), "text-transform": new Ko(el.layout_symbol["text-transform"]), "text-offset": new Ko(el.layout_symbol["text-offset"]), "text-allow-overlap": new Zo(el.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Zo(el.layout_symbol["text-ignore-placement"]), "text-optional": new Zo(el.layout_symbol["text-optional"]), visibility: new Zo(el.layout_symbol.visibility) });
        var hg = { paint: new Ho({ "icon-opacity": new Ko(el.paint_symbol["icon-opacity"]), "icon-emissive-strength": new Ko(el.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new Ko(el.paint_symbol["text-emissive-strength"]), "icon-color": new Ko(el.paint_symbol["icon-color"]), "icon-halo-color": new Ko(el.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ko(el.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ko(el.paint_symbol["icon-halo-blur"]), "icon-translate": new Zo(el.paint_symbol["icon-translate"]), "icon-translate-anchor": new Zo(el.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new Ko(el.paint_symbol["icon-image-cross-fade"]), "text-opacity": new Ko(el.paint_symbol["text-opacity"]), "text-color": new Ko(el.paint_symbol["text-color"], { runtimeType: Jn, getOverride: (t4) => t4.textColor, hasOverride: (t4) => !!t4.textColor }), "text-halo-color": new Ko(el.paint_symbol["text-halo-color"]), "text-halo-width": new Ko(el.paint_symbol["text-halo-width"]), "text-halo-blur": new Ko(el.paint_symbol["text-halo-blur"]), "text-translate": new Zo(el.paint_symbol["text-translate"]), "text-translate-anchor": new Zo(el.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new Zo(el.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new Zo(el.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new Zo(el.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new Zo(el.paint_symbol["icon-color-brightness-max"]) }), layout: cg };
        class pg {
          constructor(t4) {
            this.type = t4.property.overrides ? t4.property.overrides.runtimeType : Zn, this.defaultValue = t4;
          }
          evaluate(t4) {
            if (t4.formattedSection) {
              const e4 = this.defaultValue.property.overrides;
              if (e4 && e4.hasOverride(t4.formattedSection)) return e4.getOverride(t4.formattedSection);
            }
            return t4.feature && t4.featureState ? this.defaultValue.evaluate(t4.feature, t4.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t4) {
            this.defaultValue.isConstant() || t4(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        fo(pg, "FormatSectionOverride", { omit: ["defaultValue"] });
        class fg extends bl {
          constructor(e4, r4, n3) {
            super(e4, hg, r4, n3), this._colorAdjustmentMatrix = t3.a9.identity([]);
          }
          recalculate(t4, e4) {
            super.recalculate(t4, e4), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
            const r4 = this.layout.get("text-writing-mode");
            if (r4) {
              const t5 = [];
              for (const e5 of r4) t5.indexOf(e5) < 0 && t5.push(e5);
              this.layout._values["text-writing-mode"] = t5;
            } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
            this._setPaintOverrides();
          }
          getColorAdjustmentMatrix(e4, r4, n3, i4) {
            return this._saturation === e4 && this._contrast === r4 && this._brightnessMin === n3 && this._brightnessMax === i4 || (this._colorAdjustmentMatrix = function(e5, r5, n4, i5) {
              e5 = Er(e5), r5 = Pr(r5);
              const s4 = t3.a9.create(), a4 = e5 / 3, o3 = 1 - 2 * a4, l4 = [o3, a4, a4, 0, a4, o3, a4, 0, a4, a4, o3, 0, 0, 0, 0, 1], u5 = 0.5 - 0.5 * r5, c4 = i5 - n4;
              return t3.a9.multiply(s4, [c4, 0, 0, 0, 0, c4, 0, 0, 0, 0, c4, 0, n4, n4, n4, 1], [r5, 0, 0, 0, 0, r5, 0, 0, 0, 0, r5, 0, u5, u5, u5, 1]), t3.a9.multiply(s4, s4, l4), s4;
            }(e4, r4, n3, i4), this._saturation = e4, this._contrast = r4, this._brightnessMin = n3, this._brightnessMax = i4), this._colorAdjustmentMatrix;
          }
          getValueAndResolveTokens(t4, e4, r4, n3) {
            const i4 = this.layout.get(t4).evaluate(e4, {}, r4, n3), s4 = this._unevaluatedLayout._values[t4];
            return s4.isDataDriven() || eo(s4.value) || !i4 ? i4 : function(t5, e5) {
              return e5.replace(/{([^{}]+)}/g, (e6, r5) => r5 in t5 ? String(t5[r5]) : "");
            }(e4.properties, i4);
          }
          createBucket(t4) {
            return new ug(t4);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          _setPaintOverrides() {
            for (const t4 of hg.paint.overridableProperties) {
              if (!fg.hasPaintOverride(this.layout, t4)) continue;
              const e4 = this.paint.get(t4), r4 = new pg(e4), n3 = new to(r4, e4.property.specification, this.scope, this.options);
              let i4 = null;
              i4 = "constant" === e4.value.kind || "source" === e4.value.kind ? new no("source", n3) : new io("composite", n3, e4.value.zoomStops, e4.value._interpolationType), this.paint._values[t4] = new Yo(e4.property, i4, e4.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t4, e4, r4) {
            return !(!this.layout || e4.isDataDriven() || r4.isDataDriven()) && fg.hasPaintOverride(this.layout, t4);
          }
          static hasPaintOverride(t4, e4) {
            const r4 = t4.get("text-field"), n3 = hg.paint.properties[e4];
            let i4 = false;
            const s4 = (t5) => {
              for (const e5 of t5) if (n3.overrides && n3.overrides.hasOverride(e5)) return void (i4 = true);
            };
            if ("constant" === r4.value.kind && r4.value.value instanceof fi) s4(r4.value.value.sections);
            else if ("source" === r4.value.kind) {
              const t5 = (e6) => {
                i4 || (e6 instanceof bi && gi(e6.value) === ni ? s4(e6.value.sections) : e6 instanceof Mi ? s4(e6.sections) : e6.eachChild(t5));
              }, e5 = r4.value;
              e5._styleExpression && t5(e5._styleExpression.expression);
            }
            return i4;
          }
          getProgramIds() {
            const t4 = 0 !== this.paint.get("icon-opacity").constantOr(1), e4 = 0 !== this.paint.get("text-opacity").constantOr(1), r4 = [];
            return t4 && r4.push("symbolIcon"), e4 && r4.push("symbolSDF"), r4;
          }
          getDefaultProgramParams(t4, e4) {
            return { config: new Nu(this, e4), overrideFog: false };
          }
        }
        const dg = new Ho({ visibility: new Zo(el.layout_background.visibility) });
        var mg = { paint: new Ho({ "background-color": new Zo(el.paint_background["background-color"]), "background-pattern": new Zo(el.paint_background["background-pattern"]), "background-opacity": new Zo(el.paint_background["background-opacity"]), "background-emissive-strength": new Zo(el.paint_background["background-emissive-strength"]) }), layout: dg };
        const yg = new Ho({ visibility: new Zo(el.layout_raster.visibility) });
        var gg = { paint: new Ho({ "raster-opacity": new Zo(el.paint_raster["raster-opacity"]), "raster-color": new Wo(el.paint_raster["raster-color"]), "raster-color-mix": new Zo(el.paint_raster["raster-color-mix"]), "raster-color-range": new Zo(el.paint_raster["raster-color-range"]), "raster-hue-rotate": new Zo(el.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Zo(el.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Zo(el.paint_raster["raster-brightness-max"]), "raster-saturation": new Zo(el.paint_raster["raster-saturation"]), "raster-contrast": new Zo(el.paint_raster["raster-contrast"]), "raster-resampling": new Zo(el.paint_raster["raster-resampling"]), "raster-fade-duration": new Zo(el.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new Zo(el.paint_raster["raster-emissive-strength"]), "raster-array-band": new Zo(el.paint_raster["raster-array-band"]), "raster-elevation": new Zo(el.paint_raster["raster-elevation"]) }), layout: yg }, xg = Ml([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class bg {
          constructor(t4, e4, r4, n3) {
            this.context = t4, this.format = r4, this.texture = t4.gl.createTexture(), this.update(e4, n3);
          }
          update(t4, e4, r4) {
            const { width: n3, height: i4 } = t4, { context: s4 } = this, { gl: a4 } = s4;
            if (a4.bindTexture(a4.TEXTURE_2D, this.texture), s4.pixelStoreUnpackFlipY.set(false), s4.pixelStoreUnpack.set(1), s4.pixelStoreUnpackPremultiplyAlpha.set(this.format === a4.RGBA && (!e4 || false !== e4.premultiply)), r4 || this.size && this.size[0] === n3 && this.size[1] === i4) {
              const { x: e5, y: s5 } = r4 || { x: 0, y: 0 };
              if (t4 instanceof HTMLImageElement || t4 instanceof HTMLCanvasElement || t4 instanceof HTMLVideoElement || t4 instanceof ImageData || ImageBitmap && t4 instanceof ImageBitmap) a4.texSubImage2D(a4.TEXTURE_2D, 0, e5, s5, a4.RGBA, a4.UNSIGNED_BYTE, t4);
              else {
                let r5 = this.format, o3 = a4.UNSIGNED_BYTE;
                this.format === a4.R32F && (r5 = a4.RED, o3 = a4.FLOAT), a4.texSubImage2D(a4.TEXTURE_2D, 0, e5, s5, n3, i4, r5, o3, t4.data);
              }
            } else if (this.size = [n3, i4], t4 instanceof HTMLImageElement || t4 instanceof HTMLCanvasElement || t4 instanceof HTMLVideoElement || t4 instanceof ImageData || ImageBitmap && t4 instanceof ImageBitmap) {
              let e5 = this.format;
              this.format === a4.R8 && (e5 = a4.RED), a4.texImage2D(a4.TEXTURE_2D, 0, this.format, e5, a4.UNSIGNED_BYTE, t4);
            } else {
              let e5 = this.format, r5 = this.format, s5 = a4.UNSIGNED_BYTE;
              this.format === a4.DEPTH_COMPONENT && (e5 = a4.DEPTH_COMPONENT16, s5 = a4.UNSIGNED_SHORT), this.format === a4.R8 && (r5 = a4.RED), this.format === a4.R32F && (s5 = a4.FLOAT, r5 = a4.RED), a4.texImage2D(a4.TEXTURE_2D, 0, e5, n3, i4, 0, r5, s5, t4.data);
            }
            this.useMipmap = Boolean(e4 && e4.useMipmap), this.useMipmap && a4.generateMipmap(a4.TEXTURE_2D);
          }
          bind(t4, e4, r4 = false) {
            const { context: n3 } = this, { gl: i4 } = n3;
            i4.bindTexture(i4.TEXTURE_2D, this.texture), t4 !== this.minFilter && (i4.texParameteri(i4.TEXTURE_2D, i4.TEXTURE_MAG_FILTER, t4), i4.texParameteri(i4.TEXTURE_2D, i4.TEXTURE_MIN_FILTER, this.useMipmap && !r4 ? t4 === i4.NEAREST ? i4.NEAREST_MIPMAP_NEAREST : i4.LINEAR_MIPMAP_LINEAR : t4), this.minFilter = t4), e4 !== this.wrapS && (i4.texParameteri(i4.TEXTURE_2D, i4.TEXTURE_WRAP_S, e4), i4.texParameteri(i4.TEXTURE_2D, i4.TEXTURE_WRAP_T, e4), this.wrapS = e4);
          }
          bindExtraParam(t4, e4, r4, n3) {
            const { context: i4 } = this, { gl: s4 } = i4;
            s4.bindTexture(s4.TEXTURE_2D, this.texture), e4 !== this.magFilter && (s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_MAG_FILTER, e4), this.magFilter = e4), t4 !== this.minFilter && (s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_MIN_FILTER, this.useMipmap ? t4 === s4.NEAREST ? s4.NEAREST_MIPMAP_NEAREST : s4.LINEAR_MIPMAP_LINEAR : t4), this.minFilter = t4), r4 !== this.wrapS && (s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_WRAP_S, r4), this.wrapS = r4), n3 !== this.wrapT && (s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_WRAP_T, n3), this.wrapT = n3);
          }
          destroy() {
            const { gl: t4 } = this.context;
            t4.deleteTexture(this.texture), this.texture = null;
          }
        }
        class vg {
          constructor(t4, e4) {
            this.context = t4, this.texture = e4;
          }
          bind(t4, e4) {
            const { context: r4 } = this, { gl: n3 } = r4;
            n3.bindTexture(n3.TEXTURE_2D, this.texture), t4 !== this.minFilter && (n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MAG_FILTER, t4), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MIN_FILTER, t4), this.minFilter = t4), e4 !== this.wrapS && (n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_S, e4), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_T, e4), this.wrapS = e4);
          }
        }
        function _g(e4, r4, n3, i4, s4, a4, o3, l4) {
          const u5 = [e4, r4, 1, n3, i4, 1, s4, a4, 1], c4 = [o3, l4, 1], h4 = t3.ct.adjoint([], u5), [p4, f4, d3] = t3.Q.transformMat3(c4, c4, h4);
          return t3.ct.multiply(u5, u5, [p4, 0, 0, 0, f4, 0, 0, 0, d3]);
        }
        function wg(e4, r4, n3, i4, s4, a4, o3, l4) {
          const u5 = function(e5, r5, n4, i5, s5, a5, o4, l5) {
            const u6 = _g(0, 0, 1, 0, 1, 1, 0, 1), c4 = _g(e5, r5, n4, i5, s5, a5, o4, l5), h4 = t3.ct.adjoint([], u6);
            return t3.ct.multiply(c4, c4, h4);
          }(e4, r4, n3, i4, s4, a4, o3, l4);
          return [u5[2] / u5[8] / is, u5[5] / u5[8] / is];
        }
        function Mg(t4) {
          return [t4[0], Math.min(Math.max(t4[1], -Ac), Ac)];
        }
        class Ag extends Dn {
          constructor(t4, e4, r4, n3) {
            super(), this.id = t4, this.dispatcher = r4, this.coordinates = e4.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.onNorthPole = false, this.onSouthPole = false, this.setEventedParent(n3), this.options = e4, this._dirty = false;
          }
          load(t4, e4) {
            if (this._loaded = e4 || false, this.fire(new Rn("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url) return t4 && (this.coordinates = t4), this._loaded = true, void this._finishLoading();
            this._imageRequest = sn(this.map._requestManager.transformRequest(this.url, Zr.Image), (e5, r4) => {
              this._imageRequest = null, this._loaded = true, e5 ? this.fire(new Vn(e5)) : r4 && (this.image = r4 instanceof HTMLImageElement ? Tr.getImageData(r4) : r4, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t4 && (this.coordinates = t4), this._finishLoading());
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t4) {
            return t4.url ? (this._imageRequest && t4.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t4.url, this.load(t4.coordinates, this._loaded), this) : this;
          }
          setTexture(t4) {
            if (!(t4.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
            return this.texture = new vg(this.map.painter.context, t4.handle), this.width = t4.dimensions[0], this.height = t4.dimensions[1], this._dirty = false, this._loaded = true, this._finishLoading(), this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new Rn("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t4) {
            this.map = t4, this.load();
          }
          onRemove() {
            this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof vg || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
          }
          setCoordinates(t4) {
            if (this.coordinates = t4, this._boundsArray = void 0, this._unsupportedCoords = false, !t4.length) return this;
            this.onNorthPole = false, this.onSouthPole = false;
            let e4 = t4[0][1], r4 = t4[0][1];
            for (const n4 of t4) n4[1] > r4 && (r4 = n4[1]), n4[1] < e4 && (e4 = n4[1]);
            const n3 = (r4 + e4) / 2;
            if (n3 > Ac ? this.onNorthPole = true : n3 < -Ac && (this.onSouthPole = true), !this.onNorthPole && !this.onSouthPole) {
              const e5 = t4.map(Ec.fromLngLat);
              this.tileID = function(t5) {
                let e6 = 1 / 0, r5 = 1 / 0, n4 = -1 / 0, i4 = -1 / 0;
                for (const s5 of t5) e6 = Math.min(e6, s5.x), r5 = Math.min(r5, s5.y), n4 = Math.max(n4, s5.x), i4 = Math.max(i4, s5.y);
                const s4 = Math.max(n4 - e6, i4 - r5), a4 = Math.max(0, Math.floor(-Math.log(s4) / Math.LN2)), o3 = Math.pow(2, a4);
                let l4 = Math.floor((e6 + n4) / 2 * o3);
                return l4 > 1 && (l4 -= 1), new cc(a4, l4, Math.floor((r5 + i4) / 2 * o3));
              }(e5), this.minzoom = this.maxzoom = this.tileID.z;
            }
            return this.fire(new Rn("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          _clear() {
            this._boundsArray = void 0, this._unsupportedCoords = false;
          }
          _prepareData(e4) {
            for (const t4 in this.tiles) {
              const e5 = this.tiles[t4];
              "loaded" !== e5.state && (e5.state = "loaded", e5.texture = this.texture);
            }
            if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
            const r4 = Ty(new cc(0, 0, 0), this.map.transform.projection), n3 = [r4.projection.project(this.coordinates[0][0], this.coordinates[0][1]), r4.projection.project(this.coordinates[1][0], this.coordinates[1][1]), r4.projection.project(this.coordinates[2][0], this.coordinates[2][1]), r4.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
            if (!function(t4) {
              const e5 = t4[1].x - t4[0].x, r5 = t4[1].y - t4[0].y, n4 = t4[2].x - t4[1].x, i5 = t4[2].y - t4[1].y, s5 = t4[3].x - t4[2].x, a5 = t4[3].y - t4[2].y, o4 = t4[0].x - t4[3].x, l5 = t4[0].y - t4[3].y, u6 = e5 * i5 - n4 * r5, c5 = n4 * a5 - s5 * i5, h5 = s5 * l5 - o4 * a5, p5 = o4 * r5 - e5 * l5;
              return u6 > 0 && c5 > 0 && h5 > 0 && p5 > 0 || u6 < 0 && c5 < 0 && h5 < 0 && p5 < 0;
            }(n3)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = true);
            const i4 = Ty(this.tileID, this.map.transform.projection), [s4, a4, o3, l4] = this.coordinates.map((t4) => {
              const e5 = i4.projection.project(t4[0], t4[1]);
              return By(i4, e5)._round();
            });
            this.perspectiveTransform = wg(s4.x, s4.y, a4.x, a4.y, o3.x, o3.y, l4.x, l4.y);
            const u5 = this._boundsArray = new kl();
            u5.emplaceBack(s4.x, s4.y, 0, 0), u5.emplaceBack(a4.x, a4.y, is, 0), u5.emplaceBack(l4.x, l4.y, 0, is), u5.emplaceBack(o3.x, o3.y, is, is), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e4.createVertexBuffer(u5, xg.members), this.boundsSegments = mu.simpleSegment(0, 0, 4, 2);
            const c4 = [], h4 = [Mg((p4 = this.coordinates)[0]), Mg(p4[1]), Mg(p4[2]), Mg(p4[3])];
            var p4;
            const [f4, d3, m4, y4] = function(t4) {
              let e5 = t4[0][0], r5 = e5, n4 = t4[0][1], i5 = n4;
              for (let s5 = 1; s5 < t4.length; s5++) t4[s5][0] < e5 ? e5 = t4[s5][0] : t4[s5][0] > r5 && (r5 = t4[s5][0]), t4[s5][1] < n4 ? n4 = t4[s5][1] : t4[s5][1] > i5 && (i5 = t4[s5][1]);
              return [e5, n4, r5 - e5, i5 - n4];
            }(h4);
            {
              const i5 = new kl(), [s5, a5, o4, l5] = function(t4) {
                let e5 = t4[0].x, r5 = e5, n4 = t4[0].y, i6 = n4;
                for (let s6 = 1; s6 < t4.length; s6++) t4[s6].x < e5 ? e5 = t4[s6].x : t4[s6].x > r5 && (r5 = t4[s6].x), t4[s6].y < n4 ? n4 = t4[s6].y : t4[s6].y > i6 && (i6 = t4[s6].y);
                return [e5, n4, r5 - e5, i6 - n4];
              }(n3), u6 = (t4) => [(t4.x - s5) / o4, (t4.y - a5) / l5], [h5, p5, g5, x5] = n3.map(u6), b4 = function(e5, r5, n4, i6, s6, a6, o5, l6) {
                const u7 = _g(0, 0, 1, 0, 1, 1, 0, 1), c5 = _g(e5, r5, n4, i6, s6, a6, o5, l6), h6 = t3.ct.adjoint([], c5);
                return t3.ct.multiply(u7, u7, h6);
              }(h5[0], h5[1], p5[0], p5[1], g5[0], g5[1], x5[0], x5[1]);
              this.elevatedGlobePerspectiveTransform = wg(h5[0], h5[1], p5[0], p5[1], g5[0], g5[1], x5[0], x5[1]);
              const v4 = (e5, r5) => {
                c4.push(e5.lng);
                const n4 = Math.round((e5.lng - f4) / m4 * is), s6 = Math.round((e5.lat - d3) / y4 * is), a6 = u6(r5), o5 = t3.Q.transformMat3([], [a6[0], a6[1], 1], b4), l6 = Math.round(o5[0] / o5[2] * is), h6 = Math.round(o5[1] / o5[2] * is);
                i5.emplaceBack(n4, s6, l6, h6);
              }, _4 = n3[3].x - n3[0].x, w5 = n3[3].y - n3[0].y, M3 = n3[2].x - n3[1].x, A4 = n3[2].y - n3[1].y;
              for (let t4 = 0; t4 < 65; t4++) {
                const e5 = t4 / 64, i6 = [n3[0].x + e5 * _4, n3[0].y + e5 * w5], s6 = [n3[1].x + e5 * M3, n3[1].y + e5 * A4], a6 = s6[0] - i6[0], o5 = s6[1] - i6[1];
                for (let t5 = 0; t5 < 65; t5++) {
                  const e6 = t5 / 64, n4 = { x: i6[0] + a6 * e6, y: i6[1] + o5 * e6, z: 0 };
                  v4(r4.projection.unproject(n4.x, n4.y), n4);
                }
              }
              this.elevatedGlobeVertexBuffer = e4.createVertexBuffer(i5, xg.members);
            }
            {
              this.maxLongitudeTriangleSize = 0;
              let t4 = [], r5 = new ql();
              const n4 = (e5, n5, i5) => {
                r5.emplaceBack(e5, n5, i5);
                const s5 = c4[e5], a5 = c4[n5], o4 = c4[i5], l5 = Math.min(Math.min(s5, a5), o4), u6 = Math.max(Math.max(s5, a5), o4) - l5;
                u6 > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u6), t4.push(l5 + u6 / 2);
              };
              for (let t5 = 0; t5 < 64; t5++) for (let e5 = 0; e5 < 64; e5++) {
                const r6 = 65 * t5 + e5, i5 = r6 + 1, s5 = r6 + 65, a5 = s5 + 1;
                n4(r6, s5, i5), n4(i5, s5, a5);
              }
              [t4, r5] = function(t5, e5) {
                const r6 = Array.from({ length: t5.length }, (t6, e6) => e6);
                r6.sort((e6, r7) => t5[e6] - t5[r7]);
                const n5 = [], i5 = new ql();
                for (let s5 = 0; s5 < r6.length; s5++) {
                  const a5 = r6[s5];
                  n5.push(t5[a5]);
                  const o4 = 3 * a5, l5 = o4 + 1;
                  i5.emplaceBack(e5.uint16[o4], e5.uint16[l5], e5.uint16[l5 + 1]);
                }
                return [n5, i5];
              }(t4, r5), this.elevatedGlobeTrianglesCenterLongitudes = t4, this.elevatedGlobeIndexBuffer = e4.createIndexBuffer(r5);
            }
            this.elevatedGlobeSegments = mu.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, m4 / is, 0, y4 / is, 0, 0, d3, f4, 0]);
          }
          prepare() {
            const t4 = 0 !== Object.keys(this.tiles).length;
            if (this.tileID && !t4) return;
            const e4 = this.map.painter.context, r4 = e4.gl;
            !this._dirty || this.texture instanceof vg || (this.texture ? this.texture.update(this.image) : (this.texture = new bg(e4, this.image, r4.RGBA), this.texture.bind(r4.LINEAR, r4.CLAMP_TO_EDGE)), this._dirty = false), t4 && this._prepareData(e4);
          }
          loadTile(t4, e4) {
            this.tileID && this.tileID.equals(t4.tileID.canonical) ? (this.tiles[String(t4.tileID.wrap)] = t4, t4.buckets = {}, e4(null)) : (t4.state = "errored", e4(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          getSegmentsForLongitude(t4) {
            const e4 = this.elevatedGlobeSegments;
            if (!this.elevatedGlobeTrianglesCenterLongitudes || !e4) return null;
            const r4 = this.elevatedGlobeTrianglesCenterLongitudes;
            let n3 = ((t5, e5) => t5 + 360 * Math.round((e5 - t5) / 360))(t4 + 180, r4[0]);
            const i4 = new mu(), s4 = (t5, r5) => {
              i4.segments.push({ vertexOffset: 0, primitiveOffset: t5, vertexLength: e4.segments[0].vertexLength, primitiveLength: r5, sortKey: void 0, vaos: {} });
            }, a4 = 0.51 * this.maxLongitudeTriangleSize;
            if (Math.abs(r4[0] - n3) <= a4) {
              const t5 = kr(r4, 0, r4.length, n3 + a4);
              return t5 === r4.length || s4(t5, Ir(r4, t5 + 1, r4.length, n3 + 360 - a4) - t5), i4;
            }
            n3 < r4[0] && (n3 += 360);
            const o3 = Ir(r4, 0, r4.length, n3 - a4);
            if (o3 === r4.length) return s4(0, r4.length), i4;
            s4(0, o3 - 0);
            const l4 = kr(r4, o3 + 1, r4.length, n3 + a4);
            return l4 !== r4.length && s4(l4, r4.length - l4), i4;
          }
        }
        const Sg = (Math.pow(256, 2) - 1) / 16907520;
        class Ig extends bl {
          constructor(t4, e4, r4) {
            super(t4, gg, e4, r4), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
          }
          getProgramIds() {
            return ["raster"];
          }
          hasColorMap() {
            return !!this._transitionablePaint._values["raster-color"].value.value;
          }
          tileCoverLift() {
            return this.paint.get("raster-elevation");
          }
          isDraped(t4) {
            return !(t4 && t4._source instanceof Ag && (t4._source.onNorthPole || t4._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
          }
          _handleSpecialPaintPropertyUpdate(t4) {
            "raster-color" !== t4 && "raster-color-range" !== t4 || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
          }
          updateColorRamp(t4) {
            if (!this.hasColorMap()) return;
            if (!this._curRampRange) return;
            const e4 = this._transitionablePaint._values["raster-color"].value.expression, [r4, n3] = t4 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
            isNaN(r4) && isNaN(n3) || r4 === this._curRampRange[0] && n3 === this._curRampRange[1] || (this.colorRamp = op({ expression: e4, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: r4, end: n3 }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [r4, n3]);
          }
        }
        const kg = new Ho({ visibility: new Zo(el["layout_raster-particle"].visibility) });
        var Pg = { paint: new Ho({ "raster-particle-array-band": new Zo(el["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new Zo(el["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new Wo(el["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new Zo(el["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new Zo(el["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new Zo(el["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new Zo(el["paint_raster-particle"]["raster-particle-reset-rate-factor"]) }), layout: kg };
        class Eg extends bl {
          constructor(t4, e4, r4) {
            super(t4, Pg, e4, r4), this._updateColorRamp(), this.lastInvalidatedAt = Tr.now();
          }
          onRemove(t4) {
            this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
          }
          hasColorMap() {
            return !!this._transitionablePaint._values["raster-particle-color"].value.value;
          }
          getProgramIds() {
            return ["rasterParticle"];
          }
          hasOffscreenPass() {
            return "none" !== this.visibility;
          }
          isDraped(t4) {
            return false;
          }
          _handleSpecialPaintPropertyUpdate(t4) {
            "raster-particle-color" !== t4 && "raster-particle-max-speed" !== t4 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t4 && this._invalidateAnimationState();
          }
          _updateColorRamp() {
            if (!this.hasColorMap()) return;
            const t4 = this._transitionablePaint._values["raster-particle-color"].value.expression, e4 = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
            this.colorRamp = op({ expression: t4, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: e4 }], resolution: 256 }), this.colorRampTexture = null;
          }
          _invalidateAnimationState() {
            this.lastInvalidatedAt = Tr.now();
          }
        }
        class zg extends bl {
          constructor(t4, e4) {
            super(t4, {}, e4), this.implementation = t4, t4.slot && (this.slot = t4.slot);
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          isDraped(t4) {
            return void 0 !== this.implementation.renderToTile;
          }
          shouldRedrape() {
            return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
          }
          onAdd(t4) {
            this.implementation.onAdd && this.implementation.onAdd(t4, t4.painter.context.gl);
          }
          onRemove(t4) {
            this.implementation.onRemove && this.implementation.onRemove(t4, t4.painter.context.gl);
          }
        }
        const Tg = new Ho({ visibility: new Zo(el.layout_sky.visibility) });
        var Bg = { paint: new Ho({ "sky-type": new Zo(el.paint_sky["sky-type"]), "sky-atmosphere-sun": new Zo(el.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Zo(el.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Zo(el.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Zo(el.paint_sky["sky-gradient-radius"]), "sky-gradient": new Wo(el.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Zo(el.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Zo(el.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Zo(el.paint_sky["sky-opacity"]) }), layout: Tg };
        function Cg(e4, r4, n3) {
          const i4 = [0, 0, 1], s4 = t3.bl.identity([]);
          return t3.bl.rotateY(s4, s4, n3 ? -qe(e4) + Math.PI : qe(e4)), t3.bl.rotateX(s4, s4, -qe(r4)), t3.Q.transformQuat(i4, i4, s4), t3.Q.normalize(i4, i4);
        }
        var Rg = { paint: new Ho({}) };
        function Vg(e4, r4) {
          const n3 = Lg(e4.projection, e4.zoom, e4.width, e4.height), i4 = function(e5, r5, n4, i5, s5) {
            const a4 = new ac(n4.lng - 180 * Fg, n4.lat), o3 = new ac(n4.lng + 180 * Fg, n4.lat), l4 = e5.project(a4.lng, a4.lat), u5 = e5.project(o3.lng, o3.lat), c4 = -Math.atan2(u5.y - l4.y, u5.x - l4.x), h4 = Ec.fromLngLat(n4);
            h4.y = Ze(h4.y, -1 + Fg, 1 - Fg);
            const p4 = h4.toLngLat(), f4 = e5.project(p4.lng, p4.lat), d3 = Ec.fromLngLat(p4);
            d3.x += Fg;
            const m4 = d3.toLngLat(), y4 = e5.project(m4.lng, m4.lat), g5 = Ug(y4.x - f4.x, y4.y - f4.y, c4), x5 = Ec.fromLngLat(p4);
            x5.y += Fg;
            const b4 = x5.toLngLat(), v4 = e5.project(b4.lng, b4.lat), _4 = Ug(v4.x - f4.x, v4.y - f4.y, c4), w5 = Math.abs(g5.x) / Math.abs(_4.y), M3 = t3.a9.identity([]);
            t3.a9.rotateZ(M3, M3, -c4 * (1 - (s5 ? 0 : i5)));
            const A4 = t3.a9.identity([]);
            return t3.a9.scale(A4, A4, [1, 1 - (1 - w5) * i5, 1]), A4[4] = -_4.x / _4.y * i5, t3.a9.rotateZ(A4, A4, c4), t3.a9.multiply(A4, M3, A4), A4;
          }(e4.projection, 0, e4.center, n3, r4), s4 = Dg(e4);
          return t3.a9.scale(i4, i4, [s4, s4, 1]), i4;
        }
        function Dg(t4) {
          const e4 = t4.projection, r4 = Lg(t4.projection, t4.zoom, t4.width, t4.height), n3 = Og(e4, t4.center), i4 = Og(e4, ac.convert(e4.center));
          return Math.pow(2, n3 * r4 + (1 - r4) * i4);
        }
        function Lg(t4, e4, r4, n3, i4 = 1 / 0) {
          const s4 = t4.range;
          if (!s4) return 0;
          const a4 = Math.min(i4, Math.max(r4, n3)), o3 = Math.log(a4 / 1024) / Math.LN2;
          return Ke(s4[0] + o3, s4[1] + o3, e4);
        }
        const Fg = 1 / 4e4;
        function Og(t4, e4) {
          const r4 = Ze(e4.lat, -Ac, Ac), n3 = new ac(e4.lng - 180 * Fg, r4), i4 = new ac(e4.lng + 180 * Fg, r4), s4 = t4.project(n3.lng, r4), a4 = t4.project(i4.lng, r4), o3 = Ec.fromLngLat(n3), l4 = Ec.fromLngLat(i4), u5 = a4.x - s4.x, c4 = a4.y - s4.y, h4 = l4.x - o3.x, p4 = l4.y - o3.y, f4 = Math.sqrt((h4 * h4 + p4 * p4) / (u5 * u5 + c4 * c4));
          return Math.log(f4) / Math.LN2;
        }
        function Ug(t4, e4, r4) {
          const n3 = Math.cos(r4), i4 = Math.sin(r4);
          return { x: t4 * n3 - e4 * i4, y: t4 * i4 + e4 * n3 };
        }
        function Ng(e4, r4, n3) {
          t3.a9.identity(e4), t3.a9.rotateZ(e4, e4, qe(r4[2])), t3.a9.rotateX(e4, e4, qe(r4[0])), t3.a9.rotateY(e4, e4, qe(r4[1])), t3.a9.scale(e4, e4, n3), t3.a9.multiply(e4, e4, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        function jg(e4, r4, n3, i4, s4, a4, o3, l4) {
          const u5 = [n3[0] - r4[0], n3[1] - r4[1], 0], c4 = [i4[0] - r4[0], i4[1] - r4[1], 0];
          if (t3.Q.length(u5) < 1e-12 || t3.Q.length(c4) < 1e-12) return t3.bl.identity(e4);
          const h4 = t3.Q.cross([], u5, c4);
          t3.Q.normalize(h4, h4), t3.Q.subtract(c4, i4, r4), u5[2] = (a4 - s4) * l4, c4[2] = (o3 - s4) * l4;
          const p4 = u5;
          return t3.Q.cross(p4, u5, c4), t3.Q.normalize(p4, p4), t3.bl.rotationTo(e4, h4, p4);
        }
        function qg(e4, r4, n3 = false) {
          const i4 = Oh(r4.zoom), s4 = function(e5, r5, n4) {
            const i5 = r5.worldSize, s5 = [e5[12], e5[13], e5[14]], a4 = wc(s5[1] / i5), o3 = _c(s5[0] / i5), l4 = t3.a9.identity([]), u5 = vc(1, a4) * i5, c4 = vc(1, 0) * i5 * Ic(a4, r5.zoom), h4 = 1 / Dh(i5);
            let p4 = c4 * h4;
            if (n4) {
              const t4 = Lg(r5.projection, r5.zoom, r5.width, r5.height, 1024);
              p4 = h4 * r5.projection.pixelSpaceConversion(r5.center.lat, i5, t4);
            }
            const f4 = nc(a4, o3);
            t3.Q.add(f4, f4, t3.Q.scale([], t3.Q.normalize([], f4), u5 * p4 * s5[2]));
            const d3 = function(e6) {
              const r6 = [e6[0], e6[1], e6[2]];
              let n5 = [0, 1, 0];
              const i6 = t3.Q.cross([], n5, r6);
              return t3.Q.cross(n5, r6, i6), 0 === t3.Q.squaredLength(n5) && (n5 = [0, 1, 0], t3.Q.cross(i6, r6, n5)), t3.Q.normalize(i6, i6), t3.Q.normalize(n5, n5), t3.Q.normalize(r6, r6), [i6[0], i6[1], i6[2], 0, n5[0], n5[1], n5[2], 0, r6[0], r6[1], r6[2], 0, e6[0], e6[1], e6[2], 1];
            }(f4);
            t3.a9.scale(l4, l4, [p4, p4, p4 * u5]), t3.a9.translate(l4, l4, [-s5[0], -s5[1], -s5[2]]);
            const m4 = t3.a9.multiply([], r5.globeMatrix, d3);
            return t3.a9.multiply(m4, m4, l4), t3.a9.multiply(m4, m4, e5), m4;
          }(e4, r4, n3);
          if (i4 > 0) {
            const n4 = function(e5, r5) {
              const n5 = r5.worldSize, i5 = vc(1, 0) * n5 * Ic(r5.center.lat, r5.zoom) / Dh(n5), s5 = vc(1, r5.center.lat) * n5, a4 = t3.a9.identity([]);
              return t3.a9.rotateY(a4, a4, qe(r5.center.lng)), t3.a9.rotateX(a4, a4, qe(r5.center.lat)), t3.a9.translate(a4, a4, [0, 0, Xu]), t3.a9.scale(a4, a4, [i5, i5, i5 * s5]), t3.a9.translate(a4, a4, [r5.point.x - 0.5 * n5, r5.point.y - 0.5 * n5, 0]), t3.a9.multiply(a4, a4, e5), t3.a9.multiply(a4, r5.globeMatrix, a4);
            }(e4, r4);
            return function(e5, r5, n5) {
              const i5 = (e6, r6, n6) => {
                const i6 = t3.Q.length(e6), s6 = t3.Q.length(r6), a5 = Ih(e6, r6, n6);
                return t3.Q.scale(a5, a5, 1 / t3.Q.length(a5) * qn(i6, s6, n6));
              }, s5 = i5([e5[0], e5[1], e5[2]], [r5[0], r5[1], r5[2]], n5), a4 = i5([e5[4], e5[5], e5[6]], [r5[4], r5[5], r5[6]], n5), o3 = i5([e5[8], e5[9], e5[10]], [r5[8], r5[9], r5[10]], n5), l4 = Ih([e5[12], e5[13], e5[14]], [r5[12], r5[13], r5[14]], n5);
              return [s5[0], s5[1], s5[2], 0, a4[0], a4[1], a4[2], 0, o3[0], o3[1], o3[2], 0, l4[0], l4[1], l4[2], 1];
            }(s4, n4, i4);
          }
          return s4;
        }
        function $g(t4, e4, r4, n3) {
          const i4 = mh.projectAabbCorners(n3, r4);
          let s4 = Number.MAX_VALUE, a4 = -1;
          for (let t5 = 0; t5 < i4.length; ++t5) {
            const r5 = i4[t5];
            r5[0] = (0.5 * r5[0] + 0.5) * e4.width, r5[1] = (0.5 - 0.5 * r5[1]) * e4.height, r5[2] < s4 && (a4 = t5, s4 = r5[2]);
          }
          const o3 = (t5) => new Ue(i4[t5][0], i4[t5][1]);
          let l4;
          switch (a4) {
            case 0:
            case 6:
              l4 = [o3(1), o3(5), o3(4), o3(7), o3(3), o3(2), o3(1)];
              break;
            case 1:
            case 7:
              l4 = [o3(0), o3(4), o3(5), o3(6), o3(2), o3(3), o3(0)];
              break;
            case 3:
            case 5:
              l4 = [o3(1), o3(0), o3(4), o3(7), o3(6), o3(2), o3(1)];
              break;
            default:
              l4 = [o3(1), o3(5), o3(6), o3(7), o3(3), o3(0), o3(1)];
          }
          if (jc(t4, l4)) return s4;
        }
        const Gg = Ml([{ name: "a_pos_3f", components: 3, type: "Float32" }]), Qg = Ml([{ name: "a_color_3f", components: 3, type: "Float32" }]), Yg = Ml([{ name: "a_color_4f", components: 4, type: "Float32" }]), Xg = Ml([{ name: "a_uv_2f", components: 2, type: "Float32" }]), Zg = Ml([{ name: "a_normal_3f", components: 3, type: "Float32" }]), Kg = Ml([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), Wg = Ml([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]);
        class Hg {
          constructor(t4, e4, r4, n3) {
            this.message = (t4 ? `${t4}: ` : "") + r4, n3 && (this.identifier = n3), null != e4 && e4.__line__ && (this.line = e4.__line__);
          }
        }
        function Jg(t4, e4) {
          const r4 = -1 === t4.indexOf("://");
          try {
            return new URL(t4, r4 && e4 ? "http://example.com" : void 0), true;
          } catch (t5) {
            return false;
          }
        }
        class tx {
          constructor(t4, e4) {
            this.feature = t4, this.instancedDataOffset = e4, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
          }
        }
        class ex {
          constructor() {
            this.instancedDataArray = new Hl(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
          }
        }
        class rx {
          constructor(t4) {
            this.zoom = t4.zoom, this.canonical = t4.canonical, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.fqid), this.projection = t4.projection, this.index = t4.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id), this.hasPattern = false, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = false;
          }
          populate(t4, e4, r4, n3) {
            this.tileToMeter = Pc(r4);
            const i4 = this.layers[0]._featureFilter.needGeometry;
            this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
            for (const { feature: s4, id: a4, index: o3, sourceLayerIndex: l4 } of t4) {
              const t5 = null != a4 ? a4 : s4.properties && s4.properties.hasOwnProperty("id") ? s4.properties.id : void 0, u5 = Fc(s4, i4);
              if (!this.layers[0]._featureFilter.filter(new Uo(this.zoom), u5, r4)) continue;
              const c4 = { id: t5, sourceLayerIndex: l4, index: o3, geometry: i4 ? u5.geometry : Lc(s4, r4, n3), properties: s4.properties, type: s4.type, patterns: {} }, h4 = this.addFeature(c4, c4.geometry, u5);
              h4 && e4.featureIndex.insert(s4, c4.geometry, o3, l4, this.index, this.instancesPerModel[h4].instancedDataArray.length, is / 32);
            }
            this.lookup = null;
          }
          update(t4, e4, r4, n3) {
            for (const e5 in this.instancesPerModel) {
              const r5 = this.instancesPerModel[e5];
              for (const e6 in t4) r5.idToFeaturesIndex.hasOwnProperty(e6) && (this.evaluate(r5.features[r5.idToFeaturesIndex[e6]], t4[e6], r5, true), this.uploaded = false);
            }
            this.maxHeight = 0;
          }
          updateZoomBasedPaintProperties() {
            if (!this.hasZoomDependentProperties) return false;
            let e4 = false;
            for (const r4 in this.instancesPerModel) {
              const n3 = this.instancesPerModel[r4];
              for (const r5 of n3.features) {
                const i4 = this.layers[0], s4 = r5.feature, a4 = this.canonical, o3 = i4.paint.get("model-rotation").evaluate(s4, {}, a4), l4 = i4.paint.get("model-scale").evaluate(s4, {}, a4), u5 = i4.paint.get("model-translation").evaluate(s4, {}, a4);
                t3.Q.exactEquals(r5.rotation, o3) && t3.Q.exactEquals(r5.scale, l4) && t3.Q.exactEquals(r5.translation, u5) || (this.evaluate(r5, r5.featureStates, n3, true), e4 = true);
              }
            }
            return e4;
          }
          isEmpty() {
            for (const t4 in this.instancesPerModel) if (0 !== this.instancesPerModel[t4].instancedDataArray.length) return false;
            return true;
          }
          uploadPending() {
            return !this.uploaded;
          }
          upload(t4) {
            if (!this.uploaded) for (const e4 in this.instancesPerModel) {
              const r4 = this.instancesPerModel[e4];
              r4.instancedDataArray.length < 0 || 0 === r4.instancedDataArray.length || (r4.instancedDataBuffer ? r4.instancedDataBuffer.updateData(r4.instancedDataArray) : r4.instancedDataBuffer = t4.createVertexBuffer(r4.instancedDataArray, Kg.members, true, void 0, this.instanceCount));
            }
            this.uploaded = true;
          }
          destroy() {
            for (const t5 in this.instancesPerModel) {
              const e4 = this.instancesPerModel[t5];
              0 !== e4.instancedDataArray.length && e4.instancedDataBuffer && e4.instancedDataBuffer.destroy();
            }
            const t4 = this.layers[0].modelManager;
            if (t4 && this.modelUris) for (const e4 of this.modelUris) t4.removeModel(e4, "");
          }
          addFeature(t4, e4, r4) {
            const n3 = this.layers[0], i4 = n3.layout.get("model-id").evaluate(r4, {}, this.canonical);
            if (!i4) return hr(`modelId is not evaluated for layer ${n3.id} and it is not going to get rendered.`), i4;
            Jg(i4, false) && (this.modelUris.includes(i4) || this.modelUris.push(i4)), this.instancesPerModel[i4] || (this.instancesPerModel[i4] = new ex());
            const s4 = this.instancesPerModel[i4], a4 = s4.instancedDataArray, o3 = new tx(r4, a4.length);
            for (const t5 of e4) for (const e5 of t5) {
              if (e5.x < 0 || e5.x >= is || e5.y < 0 || e5.y >= is) continue;
              const t6 = (this.lookupDim - 1) / is, r5 = this.lookupDim * (e5.y * t6 | 0) + e5.x * t6 | 0;
              if (this.lookup) {
                if (0 !== this.lookup[r5]) continue;
                this.lookup[r5] = 1;
              }
              this.instanceCount++;
              const n4 = a4.length;
              a4.resize(n4 + 1), s4.instancesEvaluatedElevation.push(0), a4.float32[16 * n4] = e5.x, a4.float32[16 * n4 + 1] = e5.y;
            }
            return o3.instancedDataCount = s4.instancedDataArray.length - o3.instancedDataOffset, o3.instancedDataCount > 0 && (t4.id && (s4.idToFeaturesIndex[t4.id] = s4.features.length), s4.features.push(o3), this.evaluate(o3, {}, s4, false)), i4;
          }
          getModelUris() {
            return this.modelUris;
          }
          evaluate(t4, e4, r4, n3) {
            const i4 = this.layers[0], s4 = t4.feature, a4 = this.canonical, o3 = t4.rotation = i4.paint.get("model-rotation").evaluate(s4, e4, a4), l4 = t4.scale = i4.paint.get("model-scale").evaluate(s4, e4, a4), u5 = t4.translation = i4.paint.get("model-translation").evaluate(s4, e4, a4), c4 = i4.paint.get("model-color").evaluate(s4, e4, a4);
            c4.a = i4.paint.get("model-color-mix-intensity").evaluate(s4, e4, a4);
            const h4 = [];
            this.maxVerticalOffset < u5[2] && (this.maxVerticalOffset = u5[2]), this.maxScale = Math.max(Math.max(this.maxScale, l4[0]), Math.max(l4[1], l4[2])), Ng(h4, o3, l4);
            const p4 = Math.round(100 * c4.a) + c4.b / 1.05;
            for (let e5 = 0; e5 < t4.instancedDataCount; ++e5) {
              const i5 = t4.instancedDataOffset + e5, s5 = 16 * i5, o4 = r4.instancedDataArray.float32;
              let l5 = 0;
              n3 && (l5 = o4[s5 + 6] - r4.instancesEvaluatedElevation[i5]);
              const f4 = 0 | o4[s5 + 1];
              o4[s5] = (0 | o4[s5]) + c4.r / 1.05, o4[s5 + 1] = f4 + c4.g / 1.05, o4[s5 + 2] = p4, o4[s5 + 3] = 1 / (a4.z > 10 ? this.tileToMeter : Pc(a4, f4)), o4[s5 + 4] = u5[0], o4[s5 + 5] = u5[1], o4[s5 + 6] = u5[2] + l5, o4[s5 + 7] = h4[0], o4[s5 + 8] = h4[1], o4[s5 + 9] = h4[2], o4[s5 + 10] = h4[4], o4[s5 + 11] = h4[5], o4[s5 + 12] = h4[6], o4[s5 + 13] = h4[8], o4[s5 + 14] = h4[9], o4[s5 + 15] = h4[10], r4.instancesEvaluatedElevation[i5] = u5[2];
            }
          }
        }
        fo(rx, "ModelBucket", { omit: ["layers"] }), fo(ex, "PerModelAttributes"), fo(tx, "ModelFeature");
        const nx = new Ho({ visibility: new Zo(el.layout_model.visibility), "model-id": new Ko(el.layout_model["model-id"]) });
        var ix = { paint: new Ho({ "model-opacity": new Zo(el.paint_model["model-opacity"]), "model-rotation": new Ko(el.paint_model["model-rotation"]), "model-scale": new Ko(el.paint_model["model-scale"]), "model-translation": new Ko(el.paint_model["model-translation"]), "model-color": new Ko(el.paint_model["model-color"]), "model-color-mix-intensity": new Ko(el.paint_model["model-color-mix-intensity"]), "model-type": new Zo(el.paint_model["model-type"]), "model-cast-shadows": new Zo(el.paint_model["model-cast-shadows"]), "model-receive-shadows": new Zo(el.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new Zo(el.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new Ko(el.paint_model["model-emissive-strength"]), "model-roughness": new Ko(el.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new Ko(el.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new Zo(el.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new Zo(el.paint_model["model-front-cutoff"]) }), layout: nx };
        const sx = 64, ax = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
        function ox(e4, r4, n3, i4, s4, a4, o3, l4, u5, c4 = false) {
          const h4 = n3.zoom, p4 = n3.project(i4), f4 = Ic(i4.lat, h4), d3 = 1 / f4;
          t3.a9.identity(e4), t3.a9.translate(e4, e4, [p4.x + o3[0] * d3, p4.y + o3[1] * d3, o3[2]]);
          let m4 = 1, y4 = 1;
          const g5 = n3.worldSize;
          if (c4) {
            if ("mercator" === n3.projection.name) {
              let e5 = 0;
              n3.elevation && (e5 = n3.elevation.getAtPointOrZero(new Ec(p4.x / g5, p4.y / g5), 0));
              const r5 = t3.aa.transformMat4([], [p4.x, p4.y, e5, 1], n3.projMatrix)[3] / n3.cameraToCenterDistance;
              m4 = r5, y4 = r5 * Ic(n3.center.lat, h4);
            } else if ("globe" === n3.projection.name) {
              const r5 = qg(e4, n3), s5 = t3.a9.multiply([], n3.projMatrix, r5), a5 = [0, 0, 0, 1];
              t3.aa.transformMat4(a5, a5, s5);
              const o4 = a5[3] / n3.cameraToCenterDistance, l5 = Oh(h4), u6 = n3.projection.pixelsPerMeter(i4.lat, g5) * Ic(i4.lat, h4), c5 = n3.projection.pixelsPerMeter(n3.center.lat, g5) * Ic(n3.center.lat, h4);
              m4 = o4 / qn(u6, Sc(n3.center.lat), l5), y4 = o4 * f4 / u6, m4 *= c5, y4 *= c5;
            }
          } else m4 = d3;
          t3.a9.scale(e4, e4, [m4, m4, y4]);
          const x5 = [...e4], b4 = r4.orientation, v4 = [];
          if (Ng(v4, [b4[0] + s4[0], b4[1] + s4[1], b4[2] + s4[2]], a4), t3.a9.multiply(e4, x5, v4), l4 && n3.elevation) {
            let s5 = 0;
            const a5 = [];
            if (u5 && n3.elevation) {
              s5 = function(e5, r5, n4, i5, s6) {
                const a6 = r5.elevation;
                if (!a6) return 0;
                const o5 = mh.projectAabbCorners(n4, i5), l6 = vc(1, s6.lat) * r5.worldSize, u6 = function(e6, r6) {
                  const n5 = [0, 0, 1], i6 = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                  for (const s7 of i6) {
                    const i7 = e6[s7.corners[0]], a7 = e6[s7.corners[1]], o6 = e6[s7.corners[2]], l7 = [a7[0] - i7[0], a7[1] - i7[1], r6 * (a7[2] - i7[2])], u7 = t3.Q.cross(l7, l7, [o6[0] - i7[0], o6[1] - i7[1], r6 * (o6[2] - i7[2])]);
                    t3.Q.normalize(u7, u7), s7.dotProductWithUp = t3.Q.dot(u7, n5);
                  }
                  return i6.sort((t4, e7) => t4.dotProductWithUp - e7.dotProductWithUp), i6[0].corners;
                }(o5, l6), c5 = o5[u6[0]], h5 = o5[u6[1]], p5 = o5[u6[2]], f5 = o5[u6[3]], d4 = a6.getAtPointOrZero(new Ec(c5[0] / r5.worldSize, c5[1] / r5.worldSize), 0), m5 = a6.getAtPointOrZero(new Ec(h5[0] / r5.worldSize, h5[1] / r5.worldSize), 0), y5 = a6.getAtPointOrZero(new Ec(p5[0] / r5.worldSize, p5[1] / r5.worldSize), 0), g6 = a6.getAtPointOrZero(new Ec(f5[0] / r5.worldSize, f5[1] / r5.worldSize), 0), x6 = (d4 + g6) / 2, b5 = (m5 + y5) / 2;
                return x6 > b5 ? m5 < y5 ? jg(e5, h5, f5, c5, m5, g6, d4, l6) : jg(e5, p5, c5, f5, y5, d4, g6, l6) : d4 < g6 ? jg(e5, c5, h5, p5, d4, m5, y5, l6) : jg(e5, f5, p5, h5, g6, y5, m5, l6), Math.max(x6, b5);
              }(a5, n3, r4.aabb, e4, i4);
              const o4 = t3.a9.fromQuat([], a5), l5 = t3.a9.multiply([], o4, v4);
              t3.a9.multiply(e4, x5, l5);
            } else s5 = n3.elevation.getAtPointOrZero(new Ec(p4.x / g5, p4.y / g5), 0);
            0 !== s5 && (e4[14] += s5);
          }
        }
        function lx(t4, e4, r4 = false) {
          t4.uploaded || (t4.gfxTexture = new bg(e4, t4.image, r4 ? e4.gl.R8 : e4.gl.RGBA, { useMipmap: t4.sampler.minFilter >= e4.gl.NEAREST_MIPMAP_NEAREST }), t4.uploaded = true, t4.image = null);
        }
        function ux(t4, e4, r4) {
          t4.indexBuffer = e4.createIndexBuffer(t4.indexArray, false, true), t4.vertexBuffer = e4.createVertexBuffer(t4.vertexArray, Gg.members, false, true), t4.normalArray && (t4.normalBuffer = e4.createVertexBuffer(t4.normalArray, Zg.members, false, true)), t4.texcoordArray && (t4.texcoordBuffer = e4.createVertexBuffer(t4.texcoordArray, Xg.members, false, true)), t4.colorArray && (t4.colorBuffer = e4.createVertexBuffer(t4.colorArray, (12 === t4.colorArray.bytesPerElement ? Qg : Yg).members, false, true)), t4.featureArray && (t4.pbrBuffer = e4.createVertexBuffer(t4.featureArray, Wg.members, true)), t4.segments = mu.simpleSegment(0, 0, t4.vertexArray.length, t4.indexArray.length);
          const n3 = t4.material;
          n3.pbrMetallicRoughness.baseColorTexture && lx(n3.pbrMetallicRoughness.baseColorTexture, e4), n3.pbrMetallicRoughness.metallicRoughnessTexture && lx(n3.pbrMetallicRoughness.metallicRoughnessTexture, e4), n3.normalTexture && lx(n3.normalTexture, e4), n3.occlusionTexture && lx(n3.occlusionTexture, e4, r4), n3.emissionTexture && lx(n3.emissionTexture, e4);
        }
        function cx(t4, e4, r4) {
          if (t4.meshes) for (const n3 of t4.meshes) ux(n3, e4, r4);
          if (t4.children) for (const n3 of t4.children) cx(n3, e4, r4);
        }
        function hx(t4) {
          if (t4.meshes) for (const e4 of t4.meshes) e4.indexArray.destroy(), e4.vertexArray.destroy(), e4.colorArray && e4.colorArray.destroy(), e4.normalArray && e4.normalArray.destroy(), e4.texcoordArray && e4.texcoordArray.destroy(), e4.featureArray && e4.featureArray.destroy();
          if (t4.children) for (const e4 of t4.children) hx(e4);
        }
        function px(t4) {
          if (t4.meshes) for (const r4 of t4.meshes) r4.vertexBuffer && (r4.vertexBuffer.destroy(), r4.indexBuffer.destroy(), r4.normalBuffer && r4.normalBuffer.destroy(), r4.texcoordBuffer && r4.texcoordBuffer.destroy(), r4.colorBuffer && r4.colorBuffer.destroy(), r4.pbrBuffer && r4.pbrBuffer.destroy(), r4.segments.destroy(), r4.material && ((e4 = r4.material).pbrMetallicRoughness.baseColorTexture && e4.pbrMetallicRoughness.baseColorTexture.gfxTexture && e4.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e4.pbrMetallicRoughness.metallicRoughnessTexture && e4.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e4.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e4.normalTexture && e4.normalTexture.gfxTexture && e4.normalTexture.gfxTexture.destroy(), e4.emissionTexture && e4.emissionTexture.gfxTexture && e4.emissionTexture.gfxTexture.destroy(), e4.occlusionTexture && e4.occlusionTexture.gfxTexture && e4.occlusionTexture.gfxTexture.destroy()));
          var e4;
          if (t4.children) for (const e5 of t4.children) px(e5);
        }
        class fx {
          constructor(t4) {
            this._callback = t4, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._callback();
            }, 0));
          }
          remove() {
            this._channel = void 0, this._callback = () => {
            };
          }
        }
        class dx {
          constructor() {
            this.tasks = {}, this.taskQueue = [], sr(["process"], this), this.invoker = new fx(this.process), this.nextId = 0;
          }
          add(t4, e4) {
            const r4 = this.nextId++, n3 = function({ type: t5, isSymbolTile: e5, zoom: r5 }) {
              return r5 = r5 || 0, "message" === t5 ? 0 : "maybePrepare" !== t5 || e5 ? "parseTile" !== t5 || e5 ? "parseTile" === t5 && e5 ? 300 - r5 : "maybePrepare" === t5 && e5 ? 400 - r5 : 500 : 200 - r5 : 100 - r5;
            }(e4);
            if (0 === n3) {
              mr();
              try {
                t4();
              } finally {
              }
              return null;
            }
            return this.tasks[r4] = { fn: t4, metadata: e4, priority: n3, id: r4 }, this.taskQueue.push(r4), this.invoker.trigger(), { cancel: () => {
              delete this.tasks[r4];
            } };
          }
          process() {
            mr();
            try {
              if (this.taskQueue = this.taskQueue.filter((t5) => !!this.tasks[t5]), !this.taskQueue.length) return;
              const t4 = this.pick();
              if (null === t4) return;
              const e4 = this.tasks[t4];
              if (delete this.tasks[t4], this.taskQueue.length && this.invoker.trigger(), !e4) return;
              e4.fn();
            } finally {
            }
          }
          pick() {
            let t4 = null, e4 = 1 / 0;
            for (let r5 = 0; r5 < this.taskQueue.length; r5++) {
              const n3 = this.tasks[this.taskQueue[r5]];
              n3.priority < e4 && (e4 = n3.priority, t4 = r5);
            }
            if (null === t4) return null;
            const r4 = this.taskQueue[t4];
            return this.taskQueue.splice(t4, 1), r4;
          }
          remove() {
            this.invoker.remove();
          }
        }
        class mx {
          constructor(t4, e4, r4) {
            this.target = t4, this.parent = e4, this.mapId = r4, this.callbacks = {}, this.cancelCallbacks = {}, sr(["receive"], this), this.target.addEventListener("message", this.receive, false), this.scheduler = new dx();
          }
          send(t4, e4, r4, n3, i4 = false, s4) {
            const a4 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r4 && (r4.metadata = s4, this.callbacks[a4] = r4);
            const o3 = /* @__PURE__ */ new Set();
            return this.target.postMessage({ id: a4, type: t4, hasCallback: !!r4, targetMapId: n3, mustQueue: i4, sourceMapId: this.mapId, data: go(e4, o3) }, o3), { cancel: () => {
              r4 && delete this.callbacks[a4], this.target.postMessage({ id: a4, type: "<cancel>", targetMapId: n3, sourceMapId: this.mapId });
            } };
          }
          receive(t4) {
            const e4 = t4.data, r4 = e4.id;
            if (r4 && (!e4.targetMapId || this.mapId === e4.targetMapId)) if ("<cancel>" === e4.type) {
              const t5 = this.cancelCallbacks[r4];
              delete this.cancelCallbacks[r4], t5 && t5.cancel();
            } else if (e4.mustQueue || mr()) {
              const t5 = this.callbacks[r4], n3 = this.scheduler.add(() => this.processTask(r4, e4), t5 && t5.metadata || { type: "message" });
              n3 && (this.cancelCallbacks[r4] = n3);
            } else this.processTask(r4, e4);
          }
          processTask(t4, e4) {
            if (delete this.cancelCallbacks[t4], "<response>" === e4.type) {
              const r4 = this.callbacks[t4];
              delete this.callbacks[t4], r4 && (e4.error ? r4(xo(e4.error)) : r4(null, xo(e4.data)));
            } else {
              const r4 = /* @__PURE__ */ new Set(), n3 = e4.hasCallback ? (e5, n4) => {
                this.target.postMessage({ id: t4, type: "<response>", sourceMapId: this.mapId, error: e5 ? go(e5) : null, data: go(n4, r4) }, r4);
              } : (t5) => {
              }, i4 = xo(e4.data);
              if (this.parent[e4.type]) this.parent[e4.type](e4.sourceMapId, i4, n3);
              else if (this.parent.getWorkerSource) {
                const t5 = e4.type.split(".");
                this.parent.getWorkerSource(e4.sourceMapId, t5[0], i4.source, i4.scope)[t5[1]](i4, n3);
              } else n3(new Error(`Could not find function ${e4.type}`));
            }
          }
          remove() {
            this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
          }
        }
        class yx {
          constructor(t4, e4) {
            this.workerPool = t4, this.actors = [], this.currentActor = 0, this.id = er();
            const r4 = this.workerPool.acquire(this.id);
            for (let t5 = 0; t5 < r4.length; t5++) {
              const n3 = new yx.Actor(r4[t5], e4, this.id);
              n3.name = `Worker ${t5}`, this.actors.push(n3);
            }
            this.ready = false, this.broadcast("checkIfReady", null, () => {
              this.ready = true;
            });
          }
          broadcast(t4, e4, r4) {
            He(this.actors, (r5, n3) => {
              r5.send(t4, e4, n3);
            }, r4 = r4 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((t4) => {
              t4.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        yx.Actor = mx;
        var gx = { workerUrl: "", workerClass: null, workerParams: void 0 };
        function xx() {
          return null != gx.workerClass ? new gx.workerClass() : new self.Worker(gx.workerUrl, gx.workerParams);
        }
        const bx = "mapboxgl_preloaded_worker_pool";
        class vx {
          constructor() {
            this.active = {};
          }
          acquire(t4) {
            if (!this.workers) for (this.workers = []; this.workers.length < vx.workerCount; ) this.workers.push(new xx());
            return this.active[t4] = true, this.workers.slice();
          }
          release(t4) {
            delete this.active[t4], this.workers && 0 === this.numActive() && (this.workers.forEach((t5) => {
              t5.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[bx];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        let _x;
        function wx() {
          return _x || (_x = new vx()), _x;
        }
        vx.workerCount = 2;
        let Mx, Ax, Sx, Ix, kx, Px = null;
        function Ex() {
          return mr() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : Ax || n2.DRACO_URL;
        }
        function zx() {
          if (mr() && self.worker && self.worker.meshoptUrl) return self.worker.meshoptUrl;
          if (Ix) return Ix;
          const t4 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
          if ("object" != typeof WebAssembly) throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
          return Ix = WebAssembly.validate(t4) ? n2.MESHOPT_SIMD_URL : n2.MESHOPT_URL, Ix;
        }
        const Tx = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Bx = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, Cx = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
        function Rx(t4, e4, r4) {
          const n3 = r4.json.bufferViews.length, i4 = r4.buffers.length;
          e4.bufferView = n3, r4.json.bufferViews[n3] = { buffer: i4, byteLength: t4.byteLength }, r4.buffers[i4] = t4;
        }
        const Vx = "KHR_draco_mesh_compression";
        function Dx(t4, e4) {
          const r4 = t4.extensions && t4.extensions[Vx];
          if (!r4) return;
          const n3 = new Sx.Decoder(), i4 = qx(e4, r4.bufferView), s4 = new Sx.Mesh();
          if (!n3.DecodeArrayToMesh(i4, i4.byteLength, s4)) throw new Error("Failed to decode Draco mesh");
          const a4 = e4.json.accessors[t4.indices], o3 = Tx[a4.componentType], l4 = a4.count * o3.BYTES_PER_ELEMENT, u5 = Sx._malloc(l4);
          o3 === Uint16Array ? n3.GetTrianglesUInt16Array(s4, l4, u5) : n3.GetTrianglesUInt32Array(s4, l4, u5), Rx(Sx.memory.buffer.slice(u5, u5 + l4), a4, e4), Sx._free(u5);
          for (const i5 of Object.keys(r4.attributes)) {
            const a5 = n3.GetAttributeByUniqueId(s4, r4.attributes[i5]), o4 = e4.json.accessors[t4.attributes[i5]], l5 = Bx[o4.componentType], u6 = o4.count * Cx[o4.type] * Tx[o4.componentType].BYTES_PER_ELEMENT, c4 = Sx._malloc(u6);
            n3.GetAttributeDataArrayForAllPoints(s4, a5, Sx[l5], u6, c4), Rx(Sx.memory.buffer.slice(c4, c4 + u6), o4, e4), Sx._free(c4);
          }
          n3.destroy(), s4.destroy(), delete t4.extensions[Vx];
        }
        const Lx = "EXT_meshopt_compression";
        function Fx(t4, e4) {
          if (!t4.extensions || !t4.extensions[Lx]) return;
          const r4 = t4.extensions[Lx], n3 = new Uint8Array(e4.buffers[r4.buffer], r4.byteOffset || 0, r4.byteLength || 0), i4 = new Uint8Array(r4.count * r4.byteStride);
          kx.decodeGltfBuffer(i4, r4.count, r4.byteStride, n3, r4.mode, r4.filter), t4.buffer = e4.buffers.length, t4.byteOffset = 0, e4.buffers[t4.buffer] = i4.buffer, delete t4.extensions[Lx];
        }
        const Ox = 1179937895, Ux = new TextDecoder("utf8");
        function Nx(t4, e4) {
          return new URL(t4, e4).href;
        }
        function jx(t4, e4, r4, n3) {
          return fetch(Nx(t4.uri, n3)).then((t5) => t5.arrayBuffer()).then((t5) => {
            e4.buffers[r4] = t5;
          });
        }
        function qx(t4, e4) {
          const r4 = t4.json.bufferViews[e4];
          return new Uint8Array(t4.buffers[r4.buffer], r4.byteOffset || 0, r4.byteLength);
        }
        function $x(t4, e4, r4, n3) {
          if (t4.uri) {
            const i4 = Nx(t4.uri, n3);
            return fetch(i4).then((t5) => t5.blob()).then((t5) => createImageBitmap(t5)).then((t5) => {
              e4.images[r4] = t5;
            });
          }
          if (void 0 !== t4.bufferView) {
            const n4 = qx(e4, t4.bufferView), i4 = new Blob([n4], { type: t4.mimeType });
            return createImageBitmap(i4).then((t5) => {
              e4.images[r4] = t5;
            });
          }
        }
        function Gx(t4, e4 = 0, r4) {
          const n3 = { json: null, images: [], buffers: [] };
          if (new Uint32Array(t4, e4, 1)[0] === Ox) {
            const r5 = new Uint32Array(t4, e4);
            let i5 = 2;
            const s5 = (r5[i5++] >> 2) - 3, a5 = r5[i5++] >> 2;
            if (i5++, n3.json = JSON.parse(Ux.decode(r5.subarray(i5, i5 + a5))), i5 += a5, i5 < s5) {
              const s6 = r5[i5++];
              i5++;
              const a6 = e4 + (i5 << 2);
              n3.buffers[0] = t4.slice(a6, a6 + s6);
            }
          } else n3.json = JSON.parse(Ux.decode(new Uint8Array(t4, e4)));
          const { buffers: i4, images: s4, meshes: a4, extensionsUsed: o3, bufferViews: l4 } = n3.json;
          let u5 = Promise.resolve();
          if (i4) {
            const t5 = [];
            for (let e5 = 0; e5 < i4.length; e5++) {
              const s5 = i4[e5];
              s5.uri ? t5.push(jx(s5, n3, e5, r4)) : n3.buffers[e5] || (n3.buffers[e5] = null);
            }
            u5 = Promise.all(t5);
          }
          return u5.then(() => {
            const t5 = [], e5 = o3 && o3.includes(Vx), i5 = o3 && o3.includes(Lx);
            if (e5 && t5.push(function() {
              if (!Sx) return Mx || (Mx = function(t6) {
                let e6, r5 = null;
                function n4() {
                  e6 = new Uint8Array(r5.buffer);
                }
                function i6() {
                  throw new Error("Unexpected Draco error.");
                }
                const s5 = { a: { a: i6, d: function(t7, r6, n5) {
                  return e6.copyWithin(t7, r6, r6 + n5);
                }, c: function(t7) {
                  const i7 = e6.length, s6 = Math.max(t7 >>> 0, Math.ceil(1.2 * i7)), a5 = Math.ceil((s6 - i7) / 65536);
                  try {
                    return r5.grow(a5), n4(), true;
                  } catch (t8) {
                    return false;
                  }
                }, b: i6 } };
                return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t6, s5) : t6.then((t7) => t7.arrayBuffer()).then((t7) => WebAssembly.instantiate(t7, s5))).then((t7) => {
                  const { Rb: i7, Qb: s6, P: a5, T: o4, X: l5, Ja: u6, La: c4, Qa: h4, Va: p4, Wa: f4, eb: d3, jb: m4, f: y4, e: g5, yb: x5, zb: b4, Ab: v4, Bb: _4, Db: w5, Gb: M3 } = t7.instance.exports;
                  r5 = g5;
                  const A4 = /* @__PURE__ */ (() => {
                    let t8 = 0, r6 = 0, n5 = 0, a6 = 0;
                    return (o5) => {
                      n5 && (i7(a6), i7(t8), r6 += n5, n5 = t8 = 0), t8 || (r6 += 128, t8 = s6(r6));
                      const l6 = o5.length + 7 & -8;
                      let u7 = t8;
                      l6 >= r6 && (n5 = l6, u7 = a6 = s6(l6));
                      for (let t9 = 0; t9 < o5.length; t9++) e6[u7 + t9] = o5[t9];
                      return u7;
                    };
                  })();
                  return n4(), y4(), { memory: g5, _free: i7, _malloc: s6, Mesh: class {
                    constructor() {
                      this.ptr = a5();
                    }
                    destroy() {
                      o4(this.ptr);
                    }
                  }, Decoder: class {
                    constructor() {
                      this.ptr = u6();
                    }
                    destroy() {
                      m4(this.ptr);
                    }
                    DecodeArrayToMesh(t8, e7, r6) {
                      const n5 = A4(t8), i8 = c4(this.ptr, n5, e7, r6.ptr);
                      return !!l5(i8);
                    }
                    GetAttributeByUniqueId(t8, e7) {
                      return { ptr: h4(this.ptr, t8.ptr, e7) };
                    }
                    GetTrianglesUInt16Array(t8, e7, r6) {
                      p4(this.ptr, t8.ptr, e7, r6);
                    }
                    GetTrianglesUInt32Array(t8, e7, r6) {
                      f4(this.ptr, t8.ptr, e7, r6);
                    }
                    GetAttributeDataArrayForAllPoints(t8, e7, r6, n5, i8) {
                      d3(this.ptr, t8.ptr, e7.ptr, r6, n5, i8);
                    }
                  }, DT_INT8: x5(), DT_UINT8: b4(), DT_INT16: v4(), DT_UINT16: _4(), DT_UINT32: w5(), DT_FLOAT32: M3() };
                });
              }(fetch(Ex())), Mx.then((t6) => {
                Sx = t6, Mx = void 0;
              }));
            }()), i5 && t5.push(function() {
              if (kx) return;
              const t6 = function(t7) {
                let e6;
                const r5 = WebAssembly.instantiateStreaming(t7, {}).then((t8) => {
                  e6 = t8.instance, e6.exports.__wasm_call_ctors();
                }), n4 = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, i6 = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
                return { ready: r5, supported: true, decodeGltfBuffer(t8, r6, s5, a5, o4, l5) {
                  !function(t9, e7, r7, n5, i7, s6, a6) {
                    const o5 = t9.exports.sbrk, l6 = n5 + 3 & -4, u6 = o5(l6 * i7), c4 = o5(s6.length), h4 = new Uint8Array(t9.exports.memory.buffer);
                    h4.set(s6, c4);
                    const p4 = e7(u6, n5, i7, c4, s6.length);
                    if (0 === p4 && a6 && a6(u6, l6, i7), r7.set(h4.subarray(u6, u6 + n5 * i7)), o5(u6 - o5(0)), 0 !== p4) throw new Error(`Malformed buffer data: ${p4}`);
                  }(e6, e6.exports[i6[o4]], t8, r6, s5, a5, e6.exports[n4[l5]]);
                } };
              }(fetch(zx()));
              return t6.ready.then(() => {
                kx = t6;
              });
            }()), s4) for (let e6 = 0; e6 < s4.length; e6++) t5.push($x(s4[e6], n3, e6, r4));
            return (t5.length ? Promise.all(t5) : Promise.resolve()).then(() => {
              if (e5 && a4) for (const { primitives: t6 } of a4) for (const e6 of t6) Dx(e6, n3);
              if (i5 && a4 && l4) for (const t6 of l4) Fx(t6, n3);
              return n3;
            });
          });
        }
        class Qx {
          constructor(t4, e4, r4, n3) {
            if (this.triangleCount = e4.length / 3, this.min = new Ue(0, 0), this.max = new Ue(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t4.length) return;
            const [i4, s4] = [t4[0].clone(), t4[0].clone()];
            for (let e5 = 1; e5 < t4.length; ++e5) {
              const r5 = t4[e5];
              i4.x = Math.min(i4.x, r5.x), i4.y = Math.min(i4.y, r5.y), s4.x = Math.max(s4.x, r5.x), s4.y = Math.max(s4.y, r5.y);
            }
            if (n3) {
              const t5 = Math.ceil(Math.max(s4.x - i4.x, s4.y - i4.y) / n3);
              r4 = Math.max(r4, t5);
            }
            if (0 === r4) return;
            this.min = i4, this.max = s4;
            const a4 = this.max.sub(this.min);
            a4.x = Math.max(a4.x, 1), a4.y = Math.max(a4.y, 1);
            const o3 = Math.max(a4.x, a4.y) / r4;
            this.cellsX = Math.max(1, Math.ceil(a4.x / o3)), this.cellsY = Math.max(1, Math.ceil(a4.y / o3)), this.xScale = 1 / o3, this.yScale = 1 / o3;
            const l4 = [];
            for (let r5 = 0; r5 < this.triangleCount; r5++) {
              const n4 = t4[e4[3 * r5 + 0]].sub(this.min), i5 = t4[e4[3 * r5 + 1]].sub(this.min), s5 = t4[e4[3 * r5 + 2]].sub(this.min), a5 = Yx(Math.floor(Math.min(n4.x, i5.x, s5.x)), this.xScale, this.cellsX), u6 = Yx(Math.floor(Math.max(n4.x, i5.x, s5.x)), this.xScale, this.cellsX), c4 = Yx(Math.floor(Math.min(n4.y, i5.y, s5.y)), this.yScale, this.cellsY), h4 = Yx(Math.floor(Math.max(n4.y, i5.y, s5.y)), this.yScale, this.cellsY), p4 = new Ue(0, 0), f4 = new Ue(0, 0), d3 = new Ue(0, 0), m4 = new Ue(0, 0);
              for (let t5 = c4; t5 <= h4; ++t5) {
                p4.y = f4.y = t5 * o3, d3.y = m4.y = (t5 + 1) * o3;
                for (let e5 = a5; e5 <= u6; ++e5) p4.x = d3.x = e5 * o3, f4.x = m4.x = (e5 + 1) * o3, (eh(n4, i5, s5, p4, f4, m4) || eh(n4, i5, s5, p4, m4, d3)) && l4.push({ cellIdx: t5 * this.cellsX + e5, triIdx: r5 });
              }
            }
            if (0 === l4.length) return;
            l4.sort((t5, e5) => t5.cellIdx - e5.cellIdx || t5.triIdx - e5.triIdx);
            let u5 = 0;
            for (; u5 < l4.length; ) {
              const t5 = l4[u5].cellIdx, e5 = { start: this.payload.length, len: 0 };
              for (; u5 < l4.length && l4[u5].cellIdx === t5; ) ++e5.len, this.payload.push(l4[u5++].triIdx);
              this.cells[t5] = e5;
            }
          }
          query(t4, e4, r4) {
            if (0 === this.triangleCount || 0 === this.cells.length) return;
            if (t4.x > this.max.x || this.min.x > e4.x) return;
            if (t4.y > this.max.y || this.min.y > e4.y) return;
            this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8)));
            for (let t5 = 0; t5 < this.lookup.length; t5++) this.lookup[t5] = 0;
            const n3 = Yx(t4.x - this.min.x, this.xScale, this.cellsX), i4 = Yx(e4.x - this.min.x, this.xScale, this.cellsX), s4 = Yx(t4.y - this.min.y, this.yScale, this.cellsY), a4 = Yx(e4.y - this.min.y, this.yScale, this.cellsY);
            for (let t5 = s4; t5 <= a4; t5++) for (let e5 = n3; e5 <= i4; e5++) {
              const n4 = this.cells[t5 * this.cellsX + e5];
              if (n4) for (let t6 = 0; t6 < n4.len; t6++) {
                const e6 = this.payload[n4.start + t6], i5 = Math.floor(e6 / 8), s5 = 1 << e6 % 8;
                if (!(this.lookup[i5] & s5) && (this.lookup[i5] |= s5, r4.push(e6), r4.length === this.triangleCount)) return;
              }
            }
          }
        }
        function Yx(t4, e4, r4) {
          return Math.max(0, Math.min(r4 - 1, Math.floor(t4 * e4)));
        }
        function Xx(t4, e4) {
          const r4 = t4.json.bufferViews[e4.bufferView], n3 = Tx[e4.componentType];
          return new n3(t4.buffers[r4.buffer], (e4.byteOffset || 0) + (r4.byteOffset || 0), e4.count * (r4.byteStride && r4.byteStride !== Cx[e4.type] * n3.BYTES_PER_ELEMENT ? r4.byteStride / n3.BYTES_PER_ELEMENT : Cx[e4.type]));
        }
        function Zx(t4, e4, r4, n3) {
          const i4 = Tx[e4.componentType], s4 = function(t5) {
            switch (t5) {
              case Int8Array:
                return 1 / 127;
              case Uint8Array:
                return 1 / 255;
              case Int16Array:
                return 1 / 32767;
              case Uint16Array:
                return 1 / 65535;
              default:
                return 1;
            }
          }(i4), a4 = t4.json.bufferViews[e4.bufferView], o3 = a4.byteStride ? a4.byteStride / i4.BYTES_PER_ELEMENT : Cx[e4.type], l4 = r4.float32, u5 = l4.length / r4.capacity;
          for (let t5 = 0, r5 = 0; t5 < e4.count * o3; t5 += o3, r5 += u5) for (let e5 = 0; e5 < u5; e5++) l4[r5 + e5] = n3[t5 + e5] * s4;
          r4._trim();
        }
        function Kx(t4, e4, r4) {
          const n3 = t4.indices, i4 = t4.attributes, s4 = {};
          s4.indexArray = new ql();
          const a4 = e4.json.accessors[n3], o3 = a4.count / 3;
          s4.indexArray.reserve(o3);
          const l4 = Xx(e4, a4);
          for (let t5 = 0; t5 < o3; t5++) s4.indexArray.emplaceBack(l4[3 * t5], l4[3 * t5 + 1], l4[3 * t5 + 2]);
          s4.indexArray._trim(), s4.vertexArray = new Wl();
          const u5 = e4.json.accessors[i4.POSITION];
          s4.vertexArray.reserve(u5.count);
          const c4 = Xx(e4, u5);
          for (let t5 = 0; t5 < u5.count; t5++) s4.vertexArray.emplaceBack(c4[3 * t5], c4[3 * t5 + 1], c4[3 * t5 + 2]);
          if (s4.vertexArray._trim(), s4.aabb = new mh(u5.min, u5.max), s4.centroid = function(t5, e5) {
            const r5 = [0, 0, 0], n4 = t5.length;
            if (n4 > 0) {
              for (let i5 = 0; i5 < n4; i5++) {
                const n5 = 3 * t5[i5];
                r5[0] += e5[n5], r5[1] += e5[n5 + 1], r5[2] += e5[n5 + 2];
              }
              r5[0] /= n4, r5[1] /= n4, r5[2] /= n4;
            }
            return r5;
          }(l4, c4), void 0 !== i4.COLOR_0) {
            const t5 = e4.json.accessors[i4.COLOR_0], r5 = Cx[t5.type], n4 = Xx(e4, t5);
            s4.colorArray = 3 === r5 ? new Wl() : new zl(), s4.colorArray.resize(t5.count), Zx(e4, t5, s4.colorArray, n4);
          }
          if (void 0 !== i4.NORMAL) {
            s4.normalArray = new Wl();
            const t5 = e4.json.accessors[i4.NORMAL];
            s4.normalArray.resize(t5.count);
            const r5 = Xx(e4, t5);
            Zx(e4, t5, s4.normalArray, r5);
          }
          if (void 0 !== i4.TEXCOORD_0 && r4.length > 0) {
            s4.texcoordArray = new Tl();
            const t5 = e4.json.accessors[i4.TEXCOORD_0];
            s4.texcoordArray.resize(t5.count);
            const r5 = Xx(e4, t5);
            Zx(e4, t5, s4.texcoordArray, r5);
          }
          if (void 0 !== i4._FEATURE_ID_RGBA4444) {
            const t5 = e4.json.accessors[i4._FEATURE_ID_RGBA4444];
            e4.json.extensionsUsed && e4.json.extensionsUsed.includes("EXT_meshopt_compression") && (s4.featureData = Xx(e4, t5));
          }
          void 0 !== i4._FEATURE_RGBA4444 && (s4.featureData = new Uint32Array(Xx(e4, e4.json.accessors[i4._FEATURE_RGBA4444]).buffer));
          const h4 = t4.material;
          return s4.material = function(t5, e5) {
            const { emissiveFactor: r5 = [0, 0, 0], alphaMode: n4 = "OPAQUE", alphaCutoff: i5 = 0.5, normalTexture: s5, occlusionTexture: a5, emissiveTexture: o4, doubleSided: l5 } = t5, { baseColorFactor: u6 = [1, 1, 1, 1], metallicFactor: c5 = 1, roughnessFactor: h5 = 1, baseColorTexture: p4, metallicRoughnessTexture: f4 } = t5.pbrMetallicRoughness || {}, d3 = a5 ? e5[a5.index] : void 0;
            if (a5 && a5.extensions && a5.extensions.KHR_texture_transform && d3) {
              const t6 = a5.extensions.KHR_texture_transform;
              d3.offsetScale = [t6.offset[0], t6.offset[1], t6.scale[0], t6.scale[1]];
            }
            return { pbrMetallicRoughness: { baseColorFactor: new jn(...u6), metallicFactor: c5, roughnessFactor: h5, baseColorTexture: p4 ? e5[p4.index] : void 0, metallicRoughnessTexture: f4 ? e5[f4.index] : void 0 }, doubleSided: l5, emissiveFactor: r5, alphaMode: n4, alphaCutoff: i5, normalTexture: s5 ? e5[s5.index] : void 0, occlusionTexture: d3, emissionTexture: o4 ? e5[o4.index] : void 0, defined: void 0 === t5.defined };
          }(void 0 !== h4 ? e4.json.materials[h4] : { defined: false }, r4), s4;
        }
        function Wx(e4, r4, n3) {
          const { matrix: i4, rotation: s4, translation: a4, scale: o3, mesh: l4, extras: u5, children: c4 } = e4, h4 = {};
          if (h4.matrix = i4 || t3.a9.fromRotationTranslationScale([], s4 || [0, 0, 0, 1], a4 || [0, 0, 0], o3 || [1, 1, 1]), void 0 !== l4) {
            h4.meshes = n3[l4];
            const t4 = h4.anchor = [0, 0];
            for (const e5 of h4.meshes) {
              const { min: r5, max: n4 } = e5.aabb;
              t4[0] += r5[0] + n4[0], t4[1] += r5[1] + n4[1];
            }
            t4[0] = Math.floor(t4[0] / h4.meshes.length / 2), t4[1] = Math.floor(t4[1] / h4.meshes.length / 2);
          }
          if (u5 && (u5.id && (h4.id = u5.id), u5.lights && (h4.lights = function(t4) {
            if (!t4.length) return [];
            const e5 = function(t5) {
              const e6 = atob(t5), r6 = new Uint8Array(e6.length);
              for (let t6 = 0; t6 < e6.length; t6++) r6[t6] = e6.codePointAt(t6);
              return r6;
            }(t4), r5 = [], n4 = e5.length / 24, i5 = new Uint16Array(e5.buffer), s5 = new Float32Array(e5.buffer);
            for (let t5 = 0; t5 < n4; t5++) {
              const e6 = i5[2 * t5 * 6] / 30, n5 = i5[2 * t5 * 6 + 1] / 30, a5 = i5[2 * t5 * 6 + 10] / 100, o4 = s5[6 * t5 + 1], l5 = s5[6 * t5 + 2], u6 = s5[6 * t5 + 3], c5 = s5[6 * t5 + 4], h5 = u6 - o4, p4 = c5 - l5, f4 = Math.hypot(h5, p4);
              r5.push({ pos: [o4 + 0.5 * h5, l5 + 0.5 * p4, n5], normal: [p4 / f4, -h5 / f4, 0], width: f4, height: e6, depth: a5, points: [o4, l5, u6, c5] });
            }
            return r5;
          }(u5.lights))), c4) {
            const t4 = [];
            for (const e5 of c4) t4.push(Wx(r4.json.nodes[e5], r4, n3));
            h4.children = t4;
          }
          return h4;
        }
        function Hx(t4) {
          if (0 === t4.vertices.length || 0 === t4.indices.length) return null;
          const e4 = new Qx(t4.vertices, t4.indices, 8, 256), [r4, n3] = [e4.min.clone(), e4.max.clone()];
          return { vertices: t4.vertices, indices: t4.indices, grid: e4, min: r4, max: n3 };
        }
        function Jx(t4) {
          if (!t4.extras || !t4.extras.ground) return null;
          const e4 = t4.extras.ground;
          if (!e4 || !Array.isArray(e4) || 0 === e4.length) return null;
          const r4 = e4[0];
          if (!r4 || !Array.isArray(r4) || 0 === r4.length) return null;
          const n3 = [];
          for (const t5 of r4) {
            if (!Array.isArray(t5) || 2 !== t5.length) continue;
            const e5 = t5[0], r5 = t5[1];
            "number" == typeof e5 && "number" == typeof r5 && n3.push(new Ue(e5, r5));
          }
          if (n3.length < 3) return null;
          n3.length > 1 && n3[n3.length - 1].equals(n3[0]) && n3.pop();
          let i4 = 0;
          for (let t5 = 0; t5 < n3.length; t5++) {
            const e5 = n3[t5], r5 = n3[(t5 + 1) % n3.length], s5 = n3[(t5 + 2) % n3.length];
            i4 += (e5.x - r5.x) * (s5.y - r5.y) - (s5.x - r5.x) * (e5.y - r5.y);
          }
          i4 > 0 && n3.reverse();
          const s4 = Op(n3.flatMap((t5) => [t5.x, t5.y]), []);
          return 0 === s4.length ? null : { vertices: n3, indices: s4 };
        }
        function tb(e4, r4) {
          const n3 = [], i4 = [];
          let s4 = 0;
          const a4 = [];
          for (const o3 of e4) {
            s4 = n3.length;
            const e5 = o3.vertexArray.float32, l4 = o3.indexArray.uint16;
            for (let i5 = 0; i5 < o3.vertexArray.length; i5++) a4[0] = e5[3 * i5 + 0], a4[1] = e5[3 * i5 + 1], a4[2] = e5[3 * i5 + 2], t3.Q.transformMat4(a4, a4, r4), n3.push(new Ue(a4[0], a4[1]));
            for (let t4 = 0; t4 < 3 * o3.indexArray.length; t4++) i4.push(l4[t4] + s4);
          }
          if (i4.length % 3 != 0) return null;
          for (let t4 = 0; t4 < i4.length; t4 += 3) {
            const e5 = n3[i4[t4 + 0]], r5 = n3[i4[t4 + 1]], s5 = n3[i4[t4 + 2]];
            (e5.x - r5.x) * (s5.y - r5.y) - (s5.x - r5.x) * (e5.y - r5.y) > 0 && ([i4[t4 + 1], i4[t4 + 2]] = [i4[t4 + 2], i4[t4 + 1]]);
          }
          return { vertices: n3, indices: i4 };
        }
        function eb(t4) {
          const e4 = function(t5, e5) {
            const r5 = [], n4 = WebGL2RenderingContext;
            if (t5.json.textures) for (const i5 of t5.json.textures) {
              const s5 = { magFilter: n4.LINEAR, minFilter: n4.NEAREST, wrapS: n4.REPEAT, wrapT: n4.REPEAT };
              void 0 !== i5.sampler && Object.assign(s5, t5.json.samplers[i5.sampler]), r5.push({ image: e5[i5.source], sampler: s5, uploaded: false });
            }
            return r5;
          }(t4, t4.images), r4 = function(t5, e5) {
            const r5 = [];
            for (const n4 of t5.json.meshes) {
              const i5 = [];
              for (const r6 of n4.primitives) i5.push(Kx(r6, t5, e5));
              r5.push(i5);
            }
            return r5;
          }(t4, e4), { scenes: n3, scene: i4, nodes: s4 } = t4.json, a4 = n3 ? n3[i4 || 0].nodes : s4, o3 = [];
          for (const e5 of a4) o3.push(Wx(s4[e5], t4, r4));
          return function(t5, e5, r5) {
            const n4 = {}, i5 = /* @__PURE__ */ new Set();
            for (let s5 = 0; s5 < t5.length; s5++) {
              const t6 = r5[e5[s5]];
              if (!t6.extras) continue;
              const a5 = t6.extras["mapbox:footprint:version"], o4 = t6.extras["mapbox:footprint:id"];
              (a5 || o4) && i5.add(s5), "1.0.0" === a5 && o4 && (n4[o4] = s5);
            }
            for (let s5 = 0; s5 < t5.length; s5++) {
              if (i5.has(s5)) continue;
              const a5 = t5[s5], o4 = r5[e5[s5]];
              if (!o4.extras) continue;
              let l4 = null;
              a5.id in n4 && (l4 = tb(t5[n4[a5.id]].meshes, a5.matrix)), l4 || (l4 = Jx(o4)), l4 && (a5.footprint = Hx(l4));
            }
            if (i5.size > 0) {
              const e6 = Array.from(i5.values()).sort((t6, e7) => t6 - e7);
              for (let r6 = e6.length - 1; r6 >= 0; r6--) t5.splice(e6[r6], 1);
            }
          }(o3, a4, t4.json.nodes), o3;
        }
        function rb(t4) {
          t4.heightmap = new Float32Array(4096), t4.heightmap.fill(-1);
          const e4 = t4.vertexArray.float32, r4 = t4.aabb.min[0] - 1, n3 = t4.aabb.min[1] - 1, i4 = sx / (t4.aabb.max[0] - r4 + 2), s4 = sx / (t4.aabb.max[1] - n3 + 2);
          for (let a4 = 0; a4 < e4.length; a4 += 3) {
            const o3 = e4[a4 + 2], l4 = (e4[a4 + 0] - r4) * i4 | 0, u5 = (e4[a4 + 1] - n3) * s4 | 0;
            o3 > t4.heightmap[u5 * sx + l4] && (t4.heightmap[u5 * sx + l4] = o3);
          }
        }
        function nb(e4, r4) {
          const n3 = {};
          n3.indexArray = new ql(), n3.indexArray.reserve(4 * e4.length), n3.vertexArray = new Wl(), n3.vertexArray.reserve(10 * e4.length), n3.colorArray = new zl(), n3.vertexArray.reserve(10 * e4.length);
          let i4 = 0;
          for (const s5 of e4) {
            const e5 = Math.min(10, Math.max(4, 1.3 * s5.height)) * r4, a5 = [-s5.normal[1], s5.normal[0], 0], o3 = Math.min(0.29, 0.1 * s5.width / s5.depth), l4 = s5.width - 2 * s5.depth * r4 * (o3 + 0.01), u5 = t3.Q.scaleAndAdd([], s5.pos, a5, l4 / 2), c4 = t3.Q.scaleAndAdd([], s5.pos, a5, -l4 / 2), h4 = [u5[0], u5[1], u5[2] + s5.height], p4 = [c4[0], c4[1], c4[2] + s5.height], f4 = t3.Q.scaleAndAdd([], s5.normal, a5, o3);
            t3.Q.scale(f4, f4, e5);
            const d3 = t3.Q.scaleAndAdd([], s5.normal, a5, -o3);
            t3.Q.scale(d3, d3, e5), t3.Q.add(f4, u5, f4), t3.Q.add(d3, c4, d3), u5[2] += 0.1, c4[2] += 0.1, n3.vertexArray.emplaceBack(f4[0], f4[1], f4[2]), n3.vertexArray.emplaceBack(d3[0], d3[1], d3[2]), n3.vertexArray.emplaceBack(u5[0], u5[1], u5[2]), n3.vertexArray.emplaceBack(c4[0], c4[1], c4[2]), n3.vertexArray.emplaceBack(h4[0], h4[1], h4[2]), n3.vertexArray.emplaceBack(p4[0], p4[1], p4[2]), n3.vertexArray.emplaceBack(u5[0], u5[1], u5[2]), n3.vertexArray.emplaceBack(c4[0], c4[1], c4[2]), n3.vertexArray.emplaceBack(f4[0], f4[1], f4[2]), n3.vertexArray.emplaceBack(d3[0], d3[1], d3[2]);
            const m4 = l4 / e5 / 2;
            n3.colorArray.emplaceBack(-m4 - o3, -1, m4, 0.8), n3.colorArray.emplaceBack(m4 + o3, -1, m4, 0.8), n3.colorArray.emplaceBack(-m4, 0, m4, 1.3), n3.colorArray.emplaceBack(m4, 0, m4, 1.3), n3.colorArray.emplaceBack(m4 + o3, -0.8, m4, 0.7), n3.colorArray.emplaceBack(m4 + o3, -0.8, m4, 0.7), n3.colorArray.emplaceBack(0, 0, m4, 1.3), n3.colorArray.emplaceBack(0, 0, m4, 1.3), n3.colorArray.emplaceBack(m4 + o3, -1.2, m4, 0.8), n3.colorArray.emplaceBack(m4 + o3, -1.2, m4, 0.8), n3.indexArray.emplaceBack(6 + i4, 4 + i4, 8 + i4), n3.indexArray.emplaceBack(7 + i4, 9 + i4, 5 + i4), n3.indexArray.emplaceBack(0 + i4, 1 + i4, 2 + i4), n3.indexArray.emplaceBack(1 + i4, 3 + i4, 2 + i4), i4 += 10;
          }
          const s4 = { defined: true, emissiveFactor: [0, 0, 0] }, a4 = {};
          return a4.baseColorFactor = jn.white, s4.pbrMetallicRoughness = a4, n3.material = s4, n3.aabb = new mh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), n3;
        }
        fo(Qx, "TriangleGridIndex");
        class ib {
          constructor(t4) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e4 = 0; e4 < t4.length; e4++) {
              const r4 = t4[e4];
              this._stringToNumber[r4] = e4, this._numberToString[e4] = r4;
            }
          }
          encode(t4) {
            return this._stringToNumber[t4];
          }
          decode(t4) {
            return this._numberToString[t4];
          }
        }
        const sb = ["tile", "layer", "source", "sourceLayer", "state"];
        class ab {
          constructor(t4, e4, r4, n3, i4) {
            this.type = "Feature", this._vectorTileFeature = t4, this._z = e4, this._x = r4, this._y = n3, this.properties = t4.properties, this.id = i4;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
          }
          set geometry(t4) {
            this._geometry = t4;
          }
          toJSON() {
            const t4 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
            void 0 !== this.id && (t4.id = this.id);
            for (const e4 of sb) void 0 !== this[e4] && (t4[e4] = this[e4]);
            return t4;
          }
        }
        class ob {
          constructor(t4, e4) {
            this.tileID = t4, this.x = t4.canonical.x, this.y = t4.canonical.y, this.z = t4.canonical.z, this.grid = new ho(is, 16, 0), this.featureIndexArray = new hu(), this.promoteId = e4, this.is3DTile = false;
          }
          insert(t4, e4, r4, n3, i4, s4 = 0, a4 = 0) {
            const o3 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r4, n3, i4, s4);
            const l4 = this.grid;
            for (let t5 = 0; t5 < e4.length; t5++) {
              const r5 = e4[t5], n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t6 = 0; t6 < r5.length; t6++) {
                const e5 = r5[t6];
                n4[0] = Math.min(n4[0], e5.x), n4[1] = Math.min(n4[1], e5.y), n4[2] = Math.max(n4[2], e5.x), n4[3] = Math.max(n4[3], e5.y);
              }
              0 !== a4 && (n4[0] -= a4, n4[1] -= a4, n4[2] += a4, n4[3] += a4), n4[0] < is && n4[1] < is && n4[2] >= 0 && n4[3] >= 0 && l4.insert(o3, n4[0], n4[1], n4[2], n4[3]);
            }
          }
          loadVTLayers() {
            if (!this.vtLayers) {
              this.vtLayers = new pf(new wm(this.rawTileData)).layers, this.sourceLayerCoder = new ib(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
              for (const t4 in this.vtLayers) this.vtFeatures[t4] = [];
            }
            return this.vtLayers;
          }
          query(t4, e4, r4, n3) {
            this.loadVTLayers();
            const i4 = t4.params || {}, s4 = nl(i4.filter), a4 = t4.tileResult, o3 = t4.transform, l4 = a4.bufferedTilespaceBounds, u5 = this.grid.query(l4.min.x, l4.min.y, l4.max.x, l4.max.y, (t5, e5, r5, n4) => Hc(a4.bufferedTilespaceGeometry, t5, e5, r5, n4));
            u5.sort(ub);
            let c4 = null;
            o3.elevation && u5.length > 0 && (c4 = Rf.create(o3.elevation, this.tileID));
            const h4 = {};
            let p4;
            for (let l5 = 0; l5 < u5.length; l5++) {
              const f4 = u5[l5];
              if (f4 === p4) continue;
              p4 = f4;
              const d3 = this.featureIndexArray.get(f4);
              let m4 = null;
              if (this.is3DTile) {
                const t5 = this.bucketLayerIDs[0][0], r5 = e4[t5];
                if ("model" !== r5.type) continue;
                const { queryFeature: n4, intersectionZ: i5 } = r5.queryIntersectsMatchingFeature(a4, d3.featureIndex, s4, o3);
                n4 && this.appendToResult(h4, t5, d3.featureIndex, n4, i5);
              } else this.loadMatchingFeature(h4, d3, s4, i4.layers, i4.availableImages, e4, r4, n3, (e5, r5, n4, i5 = 0) => (m4 || (m4 = Lc(e5, this.tileID.canonical, t4.tileTransform)), r5.queryIntersectsFeature(a4, e5, n4, m4, this.z, t4.transform, t4.pixelPosMatrix, c4, i5)));
            }
            return h4;
          }
          loadMatchingFeature(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
            const { featureIndex: u5, bucketIndex: c4, sourceLayerIndex: h4, layoutVertexArrayOffset: p4 } = e4, f4 = this.bucketLayerIDs[c4];
            if (n3 && !function(t5, e5) {
              for (let r5 = 0; r5 < t5.length; r5++) if (e5.indexOf(t5[r5]) >= 0) return true;
              return false;
            }(n3, f4)) return;
            const d3 = this.sourceLayerCoder.decode(h4), m4 = this.vtLayers[d3].feature(u5);
            if (r4.needGeometry) {
              const t5 = Fc(m4, true);
              if (!r4.filter(new Uo(this.tileID.overscaledZ), t5, this.tileID.canonical)) return;
            } else if (!r4.filter(new Uo(this.tileID.overscaledZ), m4)) return;
            const y4 = this.getId(m4, d3);
            for (let e5 = 0; e5 < f4.length; e5++) {
              const r5 = f4[e5];
              if (n3 && n3.indexOf(r5) < 0) continue;
              const c5 = s4[r5];
              if (!c5) continue;
              let h5 = {};
              void 0 !== y4 && o3 && (h5 = o3.getState(c5.sourceLayer || "_geojsonTileLayer", y4));
              const d4 = !l4 || l4(m4, c5, h5, p4);
              if (!d4) continue;
              const g5 = new ab(m4, this.z, this.x, this.y, y4), x5 = Je({}, a4[r5]);
              x5.paint = lb(x5.paint, c5.paint, m4, h5, i4), x5.layout = lb(x5.layout, c5.layout, m4, h5, i4), g5.layer = x5, this.appendToResult(t4, r5, u5, g5, d4);
            }
          }
          appendToResult(t4, e4, r4, n3, i4) {
            let s4 = t4[e4];
            void 0 === s4 && (s4 = t4[e4] = []), s4.push({ featureIndex: r4, feature: n3, intersectionZ: i4 });
          }
          lookupSymbolFeatures(t4, e4, r4, n3, i4, s4, a4, o3) {
            const l4 = {};
            this.loadVTLayers();
            const u5 = nl(i4);
            for (const i5 of t4) this.loadMatchingFeature(l4, { bucketIndex: r4, sourceLayerIndex: n3, featureIndex: i5, layoutVertexArrayOffset: 0 }, u5, s4, a4, o3, e4);
            return l4;
          }
          loadFeature(t4) {
            const { featureIndex: e4, sourceLayerIndex: r4 } = t4;
            this.loadVTLayers();
            const n3 = this.sourceLayerCoder.decode(r4), i4 = this.vtFeatures[n3];
            if (i4[e4]) return i4[e4];
            const s4 = this.vtLayers[n3].feature(e4);
            return i4[e4] = s4, s4;
          }
          hasLayer(t4) {
            for (const e4 of this.bucketLayerIDs) for (const r4 of e4) if (t4 === r4) return true;
            return false;
          }
          getId(t4, e4) {
            let r4 = t4.id;
            if (this.promoteId) {
              const n3 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e4];
              null != n3 && (r4 = t4.properties[n3]), "boolean" == typeof r4 && (r4 = Number(r4));
            }
            return r4;
          }
        }
        function lb(t4, e4, r4, n3, i4) {
          return or(t4, (t5, s4) => {
            const a4 = e4 instanceof Xo ? e4.get(s4) : null;
            return a4 && a4.evaluate ? a4.evaluate(r4, n3, i4) : a4;
          });
        }
        function ub(t4, e4) {
          return e4 - t4;
        }
        fo(ob, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
        const cb = new Float32Array(262144), hb = new Uint8Array(262144);
        function pb(t4) {
          let e4 = 0;
          if (t4.meshes) for (const r4 of t4.meshes) e4 = Math.max(e4, r4.aabb.max[2]);
          if (t4.children) for (const r4 of t4.children) e4 = Math.max(e4, pb(r4));
          return e4;
        }
        function fb(t4, e4, r4) {
          if (t4.meshes) for (const n3 of t4.meshes) n3.aabb.min[0] !== 1 / 0 && r4.insert(e4, n3.aabb.min[0], n3.aabb.min[1], n3.aabb.max[0], n3.aabb.max[1]);
          if (t4.children) for (const n3 of t4.children) fb(n3, e4, r4);
        }
        const db = ["", "wall", "door", "roof", "window", "lamp", "logo"];
        class mb {
          constructor(t4) {
            this.node = t4, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = false, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.feature = { type: "Point", id: t4.id, geometry: [], properties: { height: pb(t4) } };
          }
          getLocalBounds() {
            if (!this.node.meshes) return new mh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
            if (!this.aabb) {
              let t4 = 0;
              const e4 = new mh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
              for (const r4 of this.node.meshes) this.node.lightMeshIndex !== t4 && e4.encapsulate(r4.aabb), t4++;
              this.aabb = mh.applyTransform(e4, this.node.matrix);
            }
            return this.aabb;
          }
        }
        class yb {
          constructor(t4, e4, r4, n3, i4, s4) {
            this.id = e4, this.modelTraits |= ax.CoordinateSpaceTile, this.uploaded = false, this.hasPattern = false, r4 && (this.modelTraits |= ax.HasMapboxMeshFeatures), n3 && (this.modelTraits |= ax.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = i4, this.dirty = true, this.needsUpload = false, this.nodesInfo = [];
            for (const e5 of t4) this.nodesInfo.push(new mb(e5)), fb(e5, s4.featureIndexArray.length, s4.grid), s4.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, s4.bucketLayerIDs.length - 1, 0);
          }
          update() {
            console.log("Update 3D model bucket");
          }
          populate() {
            console.log("populate 3D model bucket");
          }
          uploadPending() {
            return !this.uploaded || this.needsUpload;
          }
          upload(t4) {
            if (!this.needsUpload) return;
            const e4 = this.getNodesInfo();
            for (const r4 of e4) {
              const e5 = r4.node;
              this.uploaded ? this.updatePbrBuffer(e5) : cx(e5, t4, true);
            }
            for (const t5 of e4) hx(t5.node);
            this.uploaded = true, this.needsUpload = false;
          }
          updatePbrBuffer(t4) {
            let e4 = false;
            if (!t4.meshes) return e4;
            for (const r4 of t4.meshes) r4.pbrBuffer && (r4.pbrBuffer.updateData(r4.featureArray), e4 = true);
            return e4;
          }
          needsReEvaluation(t4, e4, r4) {
            const n3 = t4.transform.projectionOptions, i4 = t4.style.getBrightness(), s4 = this.brightness !== i4;
            return !!(!this.uploaded || this.dirty || n3.name !== this.projection.name || gb(r4.paint.get("model-color").value, s4) || gb(r4.paint.get("model-color-mix-intensity").value, s4) || gb(r4.paint.get("model-roughness").value, s4) || gb(r4.paint.get("model-emissive-strength").value, s4) || gb(r4.paint.get("model-height-based-emissive-strength-multiplier").value, s4)) && (this.projection = n3, this.brightness = i4, true);
          }
          evaluateScale(t4, e4) {
            if (t4.transform.zoom === this.zoom) return;
            this.zoom = t4.transform.zoom;
            const r4 = this.getNodesInfo(), n3 = this.id.canonical;
            for (const t5 of r4) {
              const r5 = t5.feature;
              t5.evaluatedScale = e4.paint.get("model-scale").evaluate(r5, {}, n3);
            }
          }
          evaluate(t4) {
            const e4 = this.getNodesInfo();
            for (const r4 of e4) {
              if (!r4.node.meshes) continue;
              const e5 = r4.feature, n3 = r4.node.meshes && r4.node.meshes[0].featureData, i4 = r4.evaluatedColor[2], s4 = r4.evaluatedRMEA[2], a4 = this.id.canonical;
              if (r4.hasTranslucentParts = false, n3) {
                for (let n4 = 0; n4 < db.length; n4++) {
                  const i5 = db[n4];
                  i5.length && (e5.properties.part = i5);
                  const s5 = t4.paint.get("model-color").evaluate(e5, {}, a4), o3 = t4.paint.get("model-color-mix-intensity").evaluate(e5, {}, a4);
                  r4.evaluatedColor[n4] = [s5.r, s5.g, s5.b, o3], r4.evaluatedRMEA[n4][0] = t4.paint.get("model-roughness").evaluate(e5, {}, a4), r4.evaluatedRMEA[n4][2] = t4.paint.get("model-emissive-strength").evaluate(e5, {}, a4), r4.evaluatedRMEA[n4][3] = s5.a, r4.emissionHeightBasedParams[n4] = t4.paint.get("model-height-based-emissive-strength-multiplier").evaluate(e5, {}, a4), !r4.hasTranslucentParts && s5.a < 1 && (r4.hasTranslucentParts = true);
                }
                delete e5.properties.part, bb(r4, i4 !== r4.evaluatedColor[2] || s4 !== r4.evaluatedRMEA[2], this.modelTraits);
              } else r4.evaluatedRMEA[0][2] = t4.paint.get("model-emissive-strength").evaluate(e5, {}, a4);
              r4.evaluatedScale = t4.paint.get("model-scale").evaluate(e5, {}, a4), this.updatePbrBuffer(r4.node) || (this.needsUpload = true);
            }
            this.dirty = false;
          }
          elevationUpdate(t4, e4, r4, n3) {
            const i4 = t4.findDEMTileFor(r4);
            if (i4 && (i4.tileID.canonical !== this.terrainTile || e4 !== this.terrainExaggeration)) {
              if (i4.dem && i4.tileID.overscaledZ !== this.elevationReadFromZ) {
                this.elevationReadFromZ = i4.tileID.overscaledZ;
                const e5 = Rf.create(t4, r4, i4);
                if (!e5) return;
                this.modelTraits & ax.HasMapboxMeshFeatures && this.updateDEM(t4, e5, r4, n3);
                for (const t5 of this.getNodesInfo()) {
                  const r5 = t5.node;
                  if (!r5.footprint || !r5.footprint.vertices || !r5.footprint.vertices.length) continue;
                  const n4 = r5.footprint.vertices;
                  let i5 = e5.getElevationAt(n4[0].x, n4[0].y, true, true);
                  for (let t6 = 1; t6 < n4.length; t6++) i5 = Math.min(i5, e5.getElevationAt(n4[t6].x, n4[t6].y, true, true));
                  r5.elevation = i5;
                }
              }
              this.terrainTile = i4.tileID.canonical, this.terrainExaggeration = e4;
            }
          }
          updateDEM(t4, e4, r4, n3) {
            let i4 = e4._dem._modifiedForSources[n3];
            if (void 0 === i4 && (e4._dem._modifiedForSources[n3] = [], i4 = e4._dem._modifiedForSources[n3]), i4.includes(r4.canonical)) return;
            const s4 = e4._dem.dim;
            i4.push(r4.canonical);
            let a4 = false;
            for (const t5 of this.getNodesInfo()) {
              const r5 = t5.node;
              if (!r5.footprint || !r5.footprint.grid) continue;
              const n4 = r5.footprint.grid, i5 = e4.tileCoordToPixel(n4.min.x, n4.min.y), o3 = e4.tileCoordToPixel(n4.max.x, n4.max.y), l4 = Math.min(Math.min(s4 - o3.y, i5.x), Math.min(i5.y, s4 - o3.x));
              if (l4 < 0) continue;
              const u5 = Ze(l4, 2, 5);
              let c4 = Math.max(0, i5.x - u5), h4 = Math.max(0, i5.y - u5), p4 = Math.min(o3.x + u5, s4 - 1), f4 = Math.min(o3.y + u5, s4 - 1);
              for (let t6 = h4; t6 <= f4; ++t6) for (let e5 = c4; e5 <= p4; ++e5) hb[t6 * s4 + e5] = 255;
              let d3 = 0, m4 = 0;
              for (let t6 = 0; t6 < n4.cellsY; ++t6) for (let r6 = 0; r6 < n4.cellsX; ++r6) {
                if (!n4.cells[t6 * n4.cellsX + r6]) continue;
                const i6 = e4.tileCoordToPixel(n4.min.x + r6 / n4.xScale, n4.min.y + t6 / n4.yScale), a5 = e4.tileCoordToPixel(n4.min.x + (r6 + 1) / n4.xScale, n4.min.y + (t6 + 1) / n4.yScale);
                for (let t7 = i6.y; t7 <= Math.min(a5.y + 1, s4 - 1); ++t7) for (let r7 = i6.x; r7 <= Math.min(a5.x + 1, s4 - 1); ++r7) 255 === hb[t7 * s4 + r7] && (hb[t7 * s4 + r7] = 0, d3 += e4.getElevationAtPixel(r7, t7), m4++);
              }
              const y4 = d3 / m4;
              c4 = Math.max(1, i5.x - u5), h4 = Math.max(1, i5.y - u5), p4 = Math.min(o3.x + u5, s4 - 2), f4 = Math.min(o3.y + u5, s4 - 2), a4 = true;
              for (let t6 = h4; t6 <= f4; ++t6) for (let r6 = c4; r6 <= p4; ++r6) 0 === hb[t6 * s4 + r6] && (cb[t6 * s4 + r6] = e4._dem.set(r6, t6, y4));
              for (let t6 = 1; t6 < u5; ++t6) {
                c4 = Math.max(1, i5.x - t6), h4 = Math.max(1, i5.y - t6), p4 = Math.min(o3.x + t6, s4 - 2), f4 = Math.min(o3.y + t6, s4 - 2);
                for (let r6 = h4; r6 <= f4; ++r6) for (let n5 = c4; n5 <= p4; ++n5) {
                  const i6 = r6 * s4 + n5;
                  if (255 === hb[i6]) {
                    let a5 = 0, o4 = 0, l5 = -1, c5 = -1;
                    for (let e5 = -1; e5 <= 1; ++e5) for (let i7 = -1; i7 <= 1; ++i7) {
                      const u6 = (r6 + e5) * s4 + n5 + i7;
                      if (hb[u6] >= t6) continue;
                      const h5 = cb[u6], p5 = Math.abs(h5);
                      p5 > o4 && (a5 = h5, o4 = p5, l5 = i7, c5 = e5);
                    }
                    if (o4 > 0.1) {
                      const s5 = 1 - (t6 + 0.5 * Math.abs(l5 * c5)) / u5;
                      let o5 = e4._dem.get(n5, r6) + a5 * s5;
                      const h5 = e4._dem.get(n5 + l5, r6 + c5), p5 = e4._dem.get(n5 - l5, r6 - c5, true);
                      (o5 - h5) * (o5 - p5) > 0 && (o5 = (h5 + p5) / 2), cb[i6] = e4._dem.set(n5, r6, o5), hb[i6] = t6;
                    }
                  }
                }
              }
            }
            a4 && (e4._demTile.needsDEMTextureUpload = true, e4._dem._timestamp = Tr.now());
          }
          getNodesInfo() {
            return this.nodesInfo;
          }
          destroy() {
            const t4 = this.getNodesInfo();
            for (const e4 of t4) hx(e4.node), px(e4.node);
          }
          isEmpty() {
            return !this.nodesInfo.length;
          }
          updateReplacement(t4, e4) {
            if (e4.updateTime === this.replacementUpdateTime) return;
            this.replacementUpdateTime = e4.updateTime;
            const r4 = e4.getReplacementRegionsForTile(t4.toUnwrapped()), n3 = this.getNodesInfo();
            for (let t5 = 0; t5 < this.nodesInfo.length; t5++) {
              const e5 = n3[t5].node;
              n3[t5].hiddenByReplacement = !!e5.footprint && !r4.find((t6) => t6.footprint === e5.footprint);
            }
          }
          getHeightAtTileCoord(e4, r4) {
            const n3 = this.getNodesInfo(), i4 = [], s4 = [0, 0, 0];
            for (let a4 = 0; a4 < this.nodesInfo.length; a4++) {
              const o3 = n3[a4], l4 = o3.node.meshes[0], u5 = mh.applyTransform(l4.aabb, o3.node.matrix);
              if (e4 < u5.min[0] || r4 < u5.min[1] || e4 > u5.max[0] || r4 > u5.max[1]) continue;
              const c4 = (e4 - l4.aabb.min[0]) / (l4.aabb.max[0] - l4.aabb.min[0]) * sx | 0, h4 = Math.min(63, (r4 - l4.aabb.min[1]) / (l4.aabb.max[1] - l4.aabb.min[1]) * sx | 0) * sx + Math.min(63, c4);
              if (s4[2] = l4.heightmap[h4], t3.Q.transformMat4(s4, s4, o3.node.matrix), !(l4.heightmap[h4] < 0 && o3.node.footprint)) {
                if (o3.hiddenByReplacement) return;
                return { height: s4[2], maxHeight: o3.feature.properties.height, hidden: false, verticalScale: o3.evaluatedScale[2] };
              }
              if (o3.node.footprint.grid.query(new Ue(e4, r4), new Ue(e4, r4), i4), i4.length > 0) return { height: void 0, maxHeight: o3.feature.properties.height, hidden: o3.hiddenByReplacement, verticalScale: o3.evaluatedScale[2] };
            }
          }
        }
        function gb(t4, e4) {
          return !t4.isLightConstant && e4;
        }
        function xb(t4, e4, r4, n3, i4, s4, a4, o3) {
          let l4 = (61440 & e4 | (61440 & e4) >> 4) >> 8, u5 = (3840 & e4 | (3840 & e4) >> 4) >> 4, c4 = 240 & e4 | (240 & e4) >> 4;
          r4[3] > 0 && (l4 = qn(l4, 255 * r4[0], r4[3]), u5 = qn(u5, 255 * r4[1], r4[3]), c4 = qn(c4, 255 * r4[2], r4[3]));
          const h4 = l4 << 8 | u5, p4 = c4 << 8 | Math.floor(255 * n3[3]), f4 = function(t5) {
            const e5 = Ze(t5, 0, 2);
            return Math.min(Math.round(0.5 * e5 * 255), 255);
          }(n3[2]) << 8 | 15 * n3[0] << 4 | 15 * n3[1], d3 = Ze(i4[0], 0, 1), m4 = Ze(i4[1], 0, 1), y4 = Ze(i4[2], 0, 1), g5 = Ze(i4[3], 0, 1);
          let x5, b4, v4, _4;
          if (d3 !== m4 && a4 !== s4 && m4 !== d3) {
            const t5 = a4 - s4;
            b4 = 1 / (t5 * (m4 - d3)), v4 = -(s4 + t5 * d3) / (t5 * (m4 - d3));
            const e5 = Ze(i4[4], -1, 1);
            _4 = Math.pow(10, e5), x5 = 255 * y4 << 8 | 255 * g5;
          } else x5 = 65535, b4 = 0, v4 = 1, _4 = 1;
          if (t4.emplaceBack(h4, p4, f4, x5, b4, v4, _4), o3) {
            const t5 = o3.length;
            o3.clear();
            for (let e5 = 0; e5 < t5; e5++) o3.emplaceBack(h4, p4, f4, x5, b4, v4, _4);
          }
        }
        function bb(t4, e4, r4) {
          const n3 = t4.node;
          let i4 = 0;
          const s4 = r4 & ax.HasMeshoptCompression;
          for (const r5 of n3.meshes) {
            if (n3.lights && n3.lightMeshIndex === i4) continue;
            if (!r5.featureData) continue;
            r5.featureArray = new Jl(), r5.featureArray.reserve(r5.featureData.length);
            let a4 = e4;
            for (const e5 of r5.featureData) {
              const i5 = s4 ? 65535 & e5 : e5 >> 16 & 65535, o3 = s4 ? e5 >> 16 & 65535 : 65535 & e5, l4 = (15 & o3) < 8 ? 15 & o3 : 0, u5 = t4.evaluatedRMEA[l4], c4 = t4.evaluatedColor[l4], h4 = t4.emissionHeightBasedParams[l4];
              let p4;
              if (a4 && 2 === l4 && n3.lights && (p4 = new Jl(), p4.resize(10 * n3.lights.length)), xb(r5.featureArray, i5, c4, u5, h4, r5.aabb.min[2], r5.aabb.max[2], p4), p4 && a4) {
                a4 = false;
                const t5 = n3.meshes[n3.lightMeshIndex];
                t5.featureArray = p4, t5.featureArray._trim();
              }
            }
            r5.featureArray._trim(), i4++;
          }
        }
        function vb(t4, e4, r4, n3) {
          const i4 = 1 << t4.z;
          e4.lat = wc((n3 / is + t4.y) / i4), e4.lng = _c((r4 / is + t4.x) / i4);
        }
        fo(yb, "Tiled3dModelBucket", { omit: ["layers"] }), fo(mb, "Tiled3dModelFeature");
        const _b = { circle: class extends bl {
          constructor(t4, e4, r4) {
            super(t4, oh, e4, r4);
          }
          createBucket(t4) {
            return new Nc(t4);
          }
          queryRadius(t4) {
            const e4 = t4;
            return rh("circle-radius", this, e4) + rh("circle-stroke-width", this, e4) + nh(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t4, e4, r4, n3, i4, s4, a4, o3) {
            const l4 = sh(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s4.angle, t4.pixelToTileUnitsFactor), u5 = this.paint.get("circle-radius").evaluate(e4, r4) + this.paint.get("circle-stroke-width").evaluate(e4, r4);
            return Yh(t4, n3, s4, a4, o3, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l4, u5);
          }
          getProgramIds() {
            return ["circle"];
          }
          getDefaultProgramParams(t4, e4) {
            const r4 = Qh(this);
            return { config: new Nu(this, e4), defines: r4, overrideFog: false };
          }
        }, heatmap: class extends bl {
          createBucket(t4) {
            return new Hh(t4);
          }
          constructor(t4, e4, r4) {
            super(t4, ap, e4, r4), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t4) {
            "heatmap-color" === t4 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = op({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius(t4) {
            return rh("heatmap-radius", this, t4);
          }
          queryIntersectsFeature(t4, e4, r4, n3, i4, s4, a4, o3) {
            const l4 = this.paint.get("heatmap-radius").evaluate(e4, r4);
            return Yh(t4, n3, s4, a4, o3, true, true, new Ue(0, 0), l4);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["heatmap", "heatmapTexture"];
          }
          getDefaultProgramParams(t4, e4) {
            return "heatmap" === t4 ? { config: new Nu(this, e4), overrideFog: false } : {};
          }
        }, hillshade: class extends bl {
          constructor(t4, e4, r4) {
            super(t4, up, e4, r4);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["hillshade", "hillshadePrepare"];
          }
          getDefaultProgramParams(t4, e4) {
            return { overrideFog: false };
          }
        }, fill: class extends bl {
          constructor(t4, e4, r4) {
            super(t4, Qp, e4, r4);
          }
          getProgramIds() {
            const t4 = this.paint.get("fill-pattern"), e4 = t4 && t4.constantOr(1), r4 = [e4 ? "fillPattern" : "fill"];
            return this.paint.get("fill-antialias") && r4.push(e4 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r4;
          }
          getDefaultProgramParams(t4, e4) {
            return { config: new Nu(this, e4), overrideFog: false };
          }
          recalculate(t4, e4) {
            super.recalculate(t4, e4);
            const r4 = this.paint._values["fill-outline-color"];
            "constant" === r4.value.kind && void 0 === r4.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t4) {
            return new $p(t4);
          }
          queryRadius() {
            return nh(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t4, e4, r4, n3, i4, s4) {
            return !t4.queryGeometry.isAboveHorizon && $c(ih(t4.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s4.angle, t4.pixelToTileUnitsFactor), n3);
          }
          isTileClipped() {
            return true;
          }
        }, "fill-extrusion": class extends bl {
          constructor(t4, e4, r4) {
            super(t4, cd, e4, r4), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(t4) {
            return new Hf(t4);
          }
          queryRadius() {
            return nh(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          hasShadowPass() {
            return true;
          }
          cutoffRange() {
            return this.paint.get("fill-extrusion-cutoff-fade-range");
          }
          canCastShadows() {
            return true;
          }
          getProgramIds() {
            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
          }
          queryIntersectsFeature(e4, r4, n3, i4, s4, a4, o3, l4, u5) {
            const c4 = sh(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a4.angle, e4.pixelToTileUnitsFactor), h4 = this.paint.get("fill-extrusion-height").evaluate(r4, n3), p4 = this.paint.get("fill-extrusion-base").evaluate(r4, n3), f4 = [0, 0], d3 = l4 && a4.elevation, m4 = a4.elevation ? a4.elevation.exaggeration() : 1, y4 = e4.tile.getBucket(this);
            if (d3 && y4 instanceof Hf) {
              const t4 = y4.centroidVertexArray, e5 = u5 + 1;
              e5 < t4.length && (f4[0] = t4.geta_centroid_pos0(e5), f4[1] = t4.geta_centroid_pos1(e5));
            }
            if (0 === f4[0] && 1 === f4[1]) return false;
            "globe" === a4.projection.name && (i4 = od([i4], [new Ue(0, 0), new Ue(is, is)], e4.tileID.canonical).map((t4) => t4.polygon).flat());
            const g5 = d3 ? l4 : null, [x5, b4] = function(e5, r5, n4, i5, s5, a5, o4, l5, u6, c5, h5) {
              return "globe" === e5.projection.name ? function(e6, r6, n5, i6, s6, a6, o5, l6, u7, c6, h6) {
                const p5 = [], f5 = [], d4 = e6.projection.upVectorScale(h6, e6.center.lat, e6.worldSize).metersToTile, m5 = [0, 0, 0, 1], y5 = [0, 0, 0, 1], g6 = (t4, e7, r7, n6) => {
                  t4[0] = e7, t4[1] = r7, t4[2] = n6, t4[3] = 1;
                }, x6 = ad();
                n5 > 0 && (n5 += x6), i6 += x6;
                for (const x7 of r6) {
                  const r7 = [], b5 = [];
                  for (const p6 of x7) {
                    const f6 = p6.x + s6.x, x8 = p6.y + s6.y, v5 = e6.projection.projectTilePoint(f6, x8, h6), _4 = e6.projection.upVector(h6, p6.x, p6.y);
                    let w5 = n5, M3 = i6;
                    if (o5) {
                      const t4 = dd(f6, x8, n5, i6, o5, l6, u7, c6);
                      w5 += t4.base, M3 += t4.top;
                    }
                    0 !== n5 ? g6(m5, v5.x + _4[0] * d4 * w5, v5.y + _4[1] * d4 * w5, v5.z + _4[2] * d4 * w5) : g6(m5, v5.x, v5.y, v5.z), g6(y5, v5.x + _4[0] * d4 * M3, v5.y + _4[1] * d4 * M3, v5.z + _4[2] * d4 * M3), t3.Q.transformMat4(m5, m5, a6), t3.Q.transformMat4(y5, y5, a6), r7.push(new hd(m5[0], m5[1], m5[2])), b5.push(new hd(y5[0], y5[1], y5[2]));
                  }
                  p5.push(r7), f5.push(b5);
                }
                return [p5, f5];
              }(e5, r5, n4, i5, s5, a5, o4, l5, u6, c5, h5) : o4 ? function(e6, r6, n5, i6, s6, a6, o5, l6, u7) {
                const c6 = [], h6 = [], p5 = [0, 0, 0, 1];
                for (const f5 of e6) {
                  const e7 = [], d4 = [];
                  for (const c7 of f5) {
                    const h7 = c7.x + i6.x, f6 = c7.y + i6.y, m5 = dd(h7, f6, r6, n5, a6, o5, l6, u7);
                    p5[0] = h7, p5[1] = f6, p5[2] = m5.base, p5[3] = 1, t3.aa.transformMat4(p5, p5, s6), p5[3] = Math.max(p5[3], 1e-5);
                    const y5 = new hd(p5[0] / p5[3], p5[1] / p5[3], p5[2] / p5[3]);
                    p5[0] = h7, p5[1] = f6, p5[2] = m5.top, p5[3] = 1, t3.aa.transformMat4(p5, p5, s6), p5[3] = Math.max(p5[3], 1e-5);
                    const g6 = new hd(p5[0] / p5[3], p5[1] / p5[3], p5[2] / p5[3]);
                    e7.push(y5), d4.push(g6);
                  }
                  c6.push(e7), h6.push(d4);
                }
                return [c6, h6];
              }(r5, n4, i5, s5, a5, o4, l5, u6, c5) : function(t4, e6, r6, n5, i6) {
                const s6 = [], a6 = [], o5 = i6[8] * e6, l6 = i6[9] * e6, u7 = i6[10] * e6, c6 = i6[11] * e6, h6 = i6[8] * r6, p5 = i6[9] * r6, f5 = i6[10] * r6, d4 = i6[11] * r6;
                for (const e7 of t4) {
                  const t5 = [], r7 = [];
                  for (const s7 of e7) {
                    const e8 = s7.x + n5.x, a7 = s7.y + n5.y, m5 = i6[0] * e8 + i6[4] * a7 + i6[12], y5 = i6[1] * e8 + i6[5] * a7 + i6[13], g6 = i6[2] * e8 + i6[6] * a7 + i6[14], x6 = i6[3] * e8 + i6[7] * a7 + i6[15], b5 = m5 + o5, v5 = y5 + l6, _4 = g6 + u7, w5 = Math.max(x6 + c6, 1e-5), M3 = m5 + h6, A4 = y5 + p5, S3 = g6 + f5, I4 = Math.max(x6 + d4, 1e-5);
                    t5.push(new hd(b5 / w5, v5 / w5, _4 / w5)), r7.push(new hd(M3 / I4, A4 / I4, S3 / I4));
                  }
                  s6.push(t5), a6.push(r7);
                }
                return [s6, a6];
              }(r5, n4, i5, s5, a5);
            }(a4, i4, p4, h4, c4, o3, g5, f4, m4, a4.center.lat, e4.tileID.canonical), v4 = e4.queryGeometry;
            return function(t4, e5, r5) {
              let n4 = 1 / 0;
              $c(r5, e5) && (n4 = fd(r5, e5[0]));
              for (let i5 = 0; i5 < e5.length; i5++) {
                const s5 = e5[i5], a5 = t4[i5];
                for (let t5 = 0; t5 < s5.length - 1; t5++) {
                  const e6 = s5[t5], i6 = [e6, s5[t5 + 1], a5[t5 + 1], a5[t5], e6];
                  jc(r5, i6) && (n4 = Math.min(n4, fd(r5, i6)));
                }
              }
              return n4 !== 1 / 0 && n4;
            }(x5, b4, v4.isPointQuery() ? v4.screenBounds : v4.screenGeometry);
          }
        }, line: class extends bl {
          constructor(t4, e4, r4) {
            super(t4, kd, e4, r4), this.gradientVersion = 0;
          }
          _handleSpecialPaintPropertyUpdate(t4) {
            if ("line-gradient" === t4) {
              const t5 = this._transitionablePaint._values["line-gradient"].value.expression;
              this.stepInterpolant = t5._styleExpression && t5._styleExpression.expression instanceof Qs, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          widthExpression() {
            return this._transitionablePaint._values["line-width"].value.expression;
          }
          recalculate(t4, e4) {
            super.recalculate(t4, e4), this.paint._values["line-floorwidth"] = Cd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t4);
          }
          createBucket(t4) {
            return new Sd(t4);
          }
          getProgramIds() {
            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
          }
          getDefaultProgramParams(t4, e4) {
            const r4 = Td(this);
            return { config: new Nu(this, e4), defines: r4, overrideFog: false };
          }
          queryRadius(t4) {
            const e4 = t4, r4 = Rd(rh("line-width", this, e4), rh("line-gap-width", this, e4)), n3 = rh("line-offset", this, e4);
            return r4 / 2 + Math.abs(n3) + nh(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t4, e4, r4, n3, i4, s4) {
            if (t4.queryGeometry.isAboveHorizon) return false;
            const a4 = ih(t4.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s4.angle, t4.pixelToTileUnitsFactor), o3 = t4.pixelToTileUnitsFactor / 2 * Rd(this.paint.get("line-width").evaluate(e4, r4), this.paint.get("line-gap-width").evaluate(e4, r4)), l4 = this.paint.get("line-offset").evaluate(e4, r4);
            return l4 && (n3 = function(t5, e5) {
              const r5 = [], n4 = new Ue(0, 0);
              for (let i5 = 0; i5 < t5.length; i5++) {
                const s5 = t5[i5], a5 = [];
                for (let t6 = 0; t6 < s5.length; t6++) {
                  const r6 = s5[t6], i6 = s5[t6 + 1], o4 = 0 === t6 ? n4 : r6.sub(s5[t6 - 1])._unit()._perp(), l5 = t6 === s5.length - 1 ? n4 : i6.sub(r6)._unit()._perp(), u5 = o4._add(l5)._unit();
                  u5._mult(1 / (u5.x * l5.x + u5.y * l5.y)), a5.push(u5._mult(e5)._add(r6));
                }
                r5.push(a5);
              }
              return r5;
            }(n3, l4 * t4.pixelToTileUnitsFactor)), function(t5, e5, r5) {
              for (let n4 = 0; n4 < e5.length; n4++) {
                const i5 = e5[n4];
                if (t5.length >= 3) {
                  for (let e6 = 0; e6 < i5.length; e6++) if (Wc(t5, i5[e6])) return true;
                }
                if (Gc(t5, i5, r5)) return true;
              }
              return false;
            }(a4, n3, o3);
          }
          isTileClipped() {
            return true;
          }
        }, symbol: fg, background: class extends bl {
          constructor(t4, e4, r4) {
            super(t4, mg, e4, r4);
          }
          getProgramIds() {
            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
          }
          getDefaultProgramParams(t4, e4) {
            return { overrideFog: false };
          }
        }, raster: Ig, "raster-particle": Eg, sky: class extends bl {
          constructor(t4, e4, r4) {
            super(t4, Bg, e4, r4), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t4) {
            "sky-gradient" === t4 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t4 && "sky-atmosphere-halo-color" !== t4 && "sky-atmosphere-color" !== t4 && "sky-atmosphere-sun-intensity" !== t4 || (this._skyboxInvalidated = true);
          }
          _updateColorRamp() {
            this.colorRamp = op({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          needsSkyboxCapture(t4) {
            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return true;
            if (!this.paint.get("sky-atmosphere-sun")) {
              const e4 = t4.style.light.properties.get("position");
              return this._lightPosition.azimuthal !== e4.azimuthal || this._lightPosition.polar !== e4.polar;
            }
            return false;
          }
          getCenter(t4, e4) {
            if ("atmosphere" === this.paint.get("sky-type")) {
              const r5 = this.paint.get("sky-atmosphere-sun"), n3 = !r5, i4 = t4.style.light, s4 = i4.properties.get("position");
              return n3 && "viewport" === i4.properties.get("anchor") && hr("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n3 ? Cg(s4.azimuthal, 90 - s4.polar, e4) : Cg(r5[0], 90 - r5[1], e4);
            }
            const r4 = this.paint.get("sky-gradient-center");
            return Cg(r4[0], 90 - r4[1], e4);
          }
          isSky() {
            return true;
          }
          markSkyboxValid(t4) {
            this._skyboxInvalidated = false, this._lightPosition = t4.style.light.properties.get("position");
          }
          hasOffscreenPass() {
            return true;
          }
          getProgramIds() {
            const t4 = this.paint.get("sky-type");
            return "atmosphere" === t4 ? ["skyboxCapture", "skybox"] : "gradient" === t4 ? ["skyboxGradient"] : null;
          }
        }, slot: class extends bl {
          constructor(t4, e4, r4) {
            super(t4, Rg, e4);
          }
        }, model: class extends bl {
          constructor(t4, e4, r4) {
            super(t4, ix, e4, r4), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(t4) {
            return new rx(t4);
          }
          getProgramIds() {
            return ["model"];
          }
          is3D() {
            return true;
          }
          hasShadowPass() {
            return true;
          }
          canCastShadows() {
            return true;
          }
          hasLightBeamPass() {
            return true;
          }
          cutoffRange() {
            return this.paint.get("model-cutoff-fade-range");
          }
          queryRadius(t4) {
            return t4 instanceof yb ? is - 1 : 0;
          }
          queryIntersectsFeature(e4, r4, n3, i4, s4, a4) {
            if (!this.modelManager) return false;
            const o3 = this.modelManager, l4 = e4.tile.getBucket(this);
            if (!(l4 && l4 instanceof rx)) return false;
            const u5 = l4;
            for (const n4 in u5.instancesPerModel) {
              const i5 = u5.instancesPerModel[n4], s5 = void 0 !== r4.id ? r4.id : r4.properties && r4.properties.hasOwnProperty("id") ? r4.properties.id : void 0;
              if (i5.idToFeaturesIndex.hasOwnProperty(s5)) {
                const r5 = i5.features[i5.idToFeaturesIndex[s5]], l5 = o3.getModel(n4, this.scope);
                if (!l5) return false;
                let c4 = t3.a9.create();
                const h4 = new ac(0, 0), p4 = u5.canonical;
                let f4 = Number.MAX_VALUE;
                for (let n5 = 0; n5 < r5.instancedDataCount; ++n5) {
                  const s6 = 16 * (r5.instancedDataOffset + n5), o4 = i5.instancedDataArray.float32, u6 = [o4[s6 + 4], o4[s6 + 5], o4[s6 + 6]];
                  vb(p4, h4, o4[s6], 0 | o4[s6 + 1]), ox(c4, l5, a4, h4, r5.rotation, r5.scale, u6, false, false, false), "globe" === a4.projection.name && (c4 = qg(c4, a4));
                  const d3 = t3.a9.multiply([], a4.projMatrix, c4), m4 = e4.queryGeometry, y4 = $g(m4.isPointQuery() ? m4.screenBounds : m4.screenGeometry, a4, d3, l5.aabb);
                  null != y4 && (f4 = Math.min(y4, f4));
                }
                return f4 !== Number.MAX_VALUE && f4;
              }
            }
            return false;
          }
          _handleOverridablePaintPropertyUpdate(t4, e4, r4) {
            return !(!this.layout || e4.isDataDriven() || r4.isDataDriven() || "model-color" !== t4 && "model-color-mix-intensity" !== t4 && "model-rotation" !== t4 && "model-scale" !== t4 && "model-translation" !== t4 && "model-emissive-strength" !== t4);
          }
          _isPropertyZoomDependent(t4) {
            const e4 = this._transitionablePaint._values[t4];
            return null != e4 && null != e4.value && null != e4.value.expression && e4.value.expression instanceof io;
          }
          isZoomDependent() {
            return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
          }
          queryIntersectsMatchingFeature(e4, r4, n3, i4) {
            const s4 = e4.tile, a4 = s4.getBucket(this);
            let o3 = null, l4 = Number.MAX_VALUE;
            if (!(a4 && a4 instanceof yb)) return { queryFeature: o3, intersectionZ: l4 };
            const u5 = a4.getNodesInfo()[r4];
            if (u5.hiddenByReplacement || !u5.node.meshes || !n3.filter(new Uo(s4.tileID.overscaledZ), u5.feature, s4.tileID.canonical)) return { queryFeature: o3, intersectionZ: l4 };
            const c4 = u5.node, h4 = i4.calculatePosMatrix(s4.tileID.toUnwrapped(), i4.worldSize), p4 = u5.evaluatedScale;
            let f4 = 0;
            i4.elevation && c4.elevation && (f4 = c4.elevation * i4.elevation.exaggeration()), t3.a9.translate(h4, h4, [(c4.anchor ? c4.anchor[0] : 0) * (p4[0] - 1), (c4.anchor ? c4.anchor[1] : 0) * (p4[1] - 1), f4]), t3.a9.scale(h4, h4, p4), t3.a9.multiply(h4, h4, c4.matrix);
            const d3 = e4.queryGeometry, m4 = d3.isPointQuery() ? d3.screenBounds : d3.screenGeometry, y4 = function(e5) {
              const r5 = t3.a9.multiply([], h4, e5.matrix), n4 = t3.a9.multiply(r5, i4.expandedFarZProjMatrix, r5);
              for (let t4 = 0; t4 < e5.meshes.length; ++t4) {
                const r6 = e5.meshes[t4];
                if (t4 === e5.lightMeshIndex) continue;
                const s5 = $g(m4, i4, n4, r6.aabb);
                null != s5 && (l4 = Math.min(s5, l4));
              }
              if (e5.children) for (const t4 of e5.children) y4(t4);
            };
            if (y4(c4), l4 === Number.MAX_VALUE) return { queryFeature: o3, intersectionZ: l4 };
            const g5 = new ac(0, 0);
            return vb(s4.tileID.canonical, g5, u5.node.anchor[0], u5.node.anchor[1]), o3 = { type: "Feature", geometry: { type: "Point", coordinates: [g5.lng, g5.lat] }, properties: u5.feature.properties, id: u5.feature.id, state: {}, layer: this.serialize() }, { queryFeature: o3, intersectionZ: l4 };
          }
        } }, wb = { read: function(t4, e4) {
          return t4.readFields(wb._readField, { header_length: 0, x: 0, y: 0, z: 0, layers: [] }, e4);
        }, _readField: function(t4, e4, r4) {
          1 === t4 ? e4.header_length = r4.readFixed32() : 2 === t4 ? e4.x = r4.readVarint() : 3 === t4 ? e4.y = r4.readVarint() : 4 === t4 ? e4.z = r4.readVarint() : 5 === t4 && e4.layers.push(wb.Layer.read(r4, r4.readVarint() + r4.pos));
        }, PixelFormat: { PIXEL_FORMAT_UNKNOWN: { value: 0, options: {} }, PIXEL_FORMAT_UINT32: { value: 1, options: {} }, PIXEL_FORMAT_UINT16: { value: 2, options: {} }, PIXEL_FORMAT_UINT8: { value: 3, options: {} } }, Filter: {} };
        wb.Filter.read = function(t4, e4) {
          return t4.readFields(wb.Filter._readField, { delta_filter: null, filter: null, zigzag_filter: null, bitshuffle_filter: null, byteshuffle_filter: null }, e4);
        }, wb.Filter._readField = function(t4, e4, r4) {
          1 === t4 ? (e4.delta_filter = wb.Filter.Delta.read(r4, r4.readVarint() + r4.pos), e4.filter = "delta_filter") : 2 === t4 ? (e4.zigzag_filter = wb.Filter.Zigzag.read(r4, r4.readVarint() + r4.pos), e4.filter = "zigzag_filter") : 3 === t4 ? (e4.bitshuffle_filter = wb.Filter.BitShuffle.read(r4, r4.readVarint() + r4.pos), e4.filter = "bitshuffle_filter") : 4 === t4 && (e4.byteshuffle_filter = wb.Filter.ByteShuffle.read(r4, r4.readVarint() + r4.pos), e4.filter = "byteshuffle_filter");
        }, wb.Filter.Delta = {}, wb.Filter.Delta.read = function(t4, e4) {
          return t4.readFields(wb.Filter.Delta._readField, { block_size: 0 }, e4);
        }, wb.Filter.Delta._readField = function(t4, e4, r4) {
          1 === t4 && (e4.block_size = r4.readVarint());
        }, wb.Filter.Zigzag = {}, wb.Filter.Zigzag.read = function(t4, e4) {
          return t4.readFields(wb.Filter.Zigzag._readField, {}, e4);
        }, wb.Filter.Zigzag._readField = function(t4, e4, r4) {
        }, wb.Filter.BitShuffle = {}, wb.Filter.BitShuffle.read = function(t4, e4) {
          return t4.readFields(wb.Filter.BitShuffle._readField, {}, e4);
        }, wb.Filter.BitShuffle._readField = function(t4, e4, r4) {
        }, wb.Filter.ByteShuffle = {}, wb.Filter.ByteShuffle.read = function(t4, e4) {
          return t4.readFields(wb.Filter.ByteShuffle._readField, {}, e4);
        }, wb.Filter.ByteShuffle._readField = function(t4, e4, r4) {
        }, wb.Codec = {}, wb.Codec.read = function(t4, e4) {
          return t4.readFields(wb.Codec._readField, { gzip_data: null, codec: null, jpeg_image: null, webp_image: null, png_image: null }, e4);
        }, wb.Codec._readField = function(t4, e4, r4) {
          1 === t4 ? (e4.gzip_data = wb.Codec.GzipData.read(r4, r4.readVarint() + r4.pos), e4.codec = "gzip_data") : 2 === t4 ? (e4.jpeg_image = wb.Codec.JpegImage.read(r4, r4.readVarint() + r4.pos), e4.codec = "jpeg_image") : 3 === t4 ? (e4.webp_image = wb.Codec.WebpImage.read(r4, r4.readVarint() + r4.pos), e4.codec = "webp_image") : 4 === t4 && (e4.png_image = wb.Codec.PngImage.read(r4, r4.readVarint() + r4.pos), e4.codec = "png_image");
        }, wb.Codec.GzipData = {}, wb.Codec.GzipData.read = function(t4, e4) {
          return t4.readFields(wb.Codec.GzipData._readField, {}, e4);
        }, wb.Codec.GzipData._readField = function(t4, e4, r4) {
        }, wb.Codec.JpegImage = {}, wb.Codec.JpegImage.read = function(t4, e4) {
          return t4.readFields(wb.Codec.JpegImage._readField, {}, e4);
        }, wb.Codec.JpegImage._readField = function(t4, e4, r4) {
        }, wb.Codec.WebpImage = {}, wb.Codec.WebpImage.read = function(t4, e4) {
          return t4.readFields(wb.Codec.WebpImage._readField, {}, e4);
        }, wb.Codec.WebpImage._readField = function(t4, e4, r4) {
        }, wb.Codec.PngImage = {}, wb.Codec.PngImage.read = function(t4, e4) {
          return t4.readFields(wb.Codec.PngImage._readField, {}, e4);
        }, wb.Codec.PngImage._readField = function(t4, e4, r4) {
        }, wb.DataIndexEntry = {}, wb.DataIndexEntry.read = function(t4, e4) {
          return t4.readFields(wb.DataIndexEntry._readField, { first_byte: 0, last_byte: 0, filters: [], codec: null, offset: 0, scale: 0, bands: [] }, e4);
        }, wb.DataIndexEntry._readField = function(t4, e4, r4) {
          1 === t4 ? e4.first_byte = r4.readFixed64() : 2 === t4 ? e4.last_byte = r4.readFixed64() : 3 === t4 ? e4.filters.push(wb.Filter.read(r4, r4.readVarint() + r4.pos)) : 4 === t4 ? e4.codec = wb.Codec.read(r4, r4.readVarint() + r4.pos) : 5 === t4 ? e4.offset = r4.readFloat() : 6 === t4 ? e4.scale = r4.readFloat() : 7 === t4 && e4.bands.push(r4.readString());
        }, wb.Layer = {}, wb.Layer.read = function(t4, e4) {
          return t4.readFields(wb.Layer._readField, { version: 0, name: "", units: "", tilesize: 0, buffer: 0, pixel_format: 0, data_index: [] }, e4);
        }, wb.Layer._readField = function(t4, e4, r4) {
          1 === t4 ? e4.version = r4.readVarint() : 2 === t4 ? e4.name = r4.readString() : 3 === t4 ? e4.units = r4.readString() : 4 === t4 ? e4.tilesize = r4.readVarint() : 5 === t4 ? e4.buffer = r4.readVarint() : 6 === t4 ? e4.pixel_format = r4.readVarint() : 7 === t4 && e4.data_index.push(wb.DataIndexEntry.read(r4, r4.readVarint() + r4.pos));
        };
        const Mb = { read: function(t4, e4) {
          return t4.readFields(Mb._readField, { uint32_values: null, values: null, fixed32_values: null }, e4);
        }, _readField: function(t4, e4, r4) {
          2 === t4 ? (e4.uint32_values = Mb.Uint32Values.read(r4, r4.readVarint() + r4.pos), e4.values = "uint32_values") : 3 === t4 && (e4.fixed32_values = Mb.Fixed32Values.read(r4, r4.readVarint() + r4.pos), e4.values = "fixed32_values");
        }, Uint32Values: {} };
        Mb.Uint32Values.read = function(t4, e4) {
          return t4.readFields(Mb.Uint32Values._readField, { values: [] }, e4);
        }, Mb.Uint32Values._readField = function(t4, e4, r4) {
          1 === t4 && (e4.readValuesInto = function(t5) {
            if (2 !== t5.type) throw new Error(`Unsupported pbf type "${t5.type}"`);
            const e5 = function(t6) {
              return 2 === t6.type ? t6.readVarint() + t6.pos : t6.pos + 1;
            }(t5), r5 = t5.pos;
            return t5.pos = e5, function(n3) {
              t5.pos = r5;
              let i4 = 0;
              for (; t5.pos < e5; ) {
                const e6 = t5.readVarint();
                n3[i4++] = e6;
              }
              return n3;
            };
          }(r4));
        }, Mb.Fixed32Values = {}, Mb.Fixed32Values.read = function(t4, e4) {
          return t4.readFields(Mb.Fixed32Values._readField, { values: [] }, e4);
        }, Mb.Fixed32Values._readField = function(t4, e4, r4) {
          throw new Error("Not implemented");
        };
        class Ab {
          constructor(t4 = 0, e4 = 0, r4 = false) {
            this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.max = t4, this.resetTtl = r4, this.size = 0, this.ttl = e4;
          }
          clear() {
            return this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this;
          }
          delete(t4) {
            if (this.has(t4)) {
              const e4 = this.items[t4];
              delete this.items[t4], this.size--, null !== e4.prev && (e4.prev.next = e4.next), null !== e4.next && (e4.next.prev = e4.prev), this.first === e4 && (this.first = e4.next), this.last === e4 && (this.last = e4.prev);
            }
            return this;
          }
          entries(t4 = this.keys()) {
            return t4.map((t5) => [t5, this.get(t5)]);
          }
          evict(t4 = false) {
            if (t4 || this.size > 0) {
              const t5 = this.first;
              delete this.items[t5.key], 0 == --this.size ? (this.first = null, this.last = null) : (this.first = t5.next, this.first.prev = null);
            }
            return this;
          }
          expiresAt(t4) {
            let e4;
            return this.has(t4) && (e4 = this.items[t4].expiry), e4;
          }
          get(t4) {
            let e4;
            if (this.has(t4)) {
              const r4 = this.items[t4];
              this.ttl > 0 && r4.expiry <= Date.now() ? this.delete(t4) : (e4 = r4.value, this.set(t4, e4, true));
            }
            return e4;
          }
          has(t4) {
            return t4 in this.items;
          }
          keys() {
            const t4 = [];
            let e4 = this.first;
            for (; null !== e4; ) t4.push(e4.key), e4 = e4.next;
            return t4;
          }
          set(t4, e4, r4 = false, n3 = this.resetTtl) {
            let i4;
            if (r4 || this.has(t4)) {
              if (i4 = this.items[t4], i4.value = e4, false === r4 && n3 && (i4.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl), this.last !== i4) {
                const t5 = this.last, e5 = i4.next, r5 = i4.prev;
                this.first === i4 && (this.first = i4.next), i4.next = null, i4.prev = this.last, t5.next = i4, null !== r5 && (r5.next = e5), null !== e5 && (e5.prev = r5);
              }
            } else this.max > 0 && this.size === this.max && this.evict(true), i4 = this.items[t4] = { expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl, key: t4, prev: this.last, next: null, value: e4 }, 1 == ++this.size ? this.first = i4 : this.last.next = i4;
            return this.last = i4, this;
          }
          values(t4 = this.keys()) {
            return t4.map((t5) => this.get(t5));
          }
        }
        function Sb(t4, e4) {
          if (4 !== e4.length) throw new Error(`Expected data of dimension 4 but got ${e4.length}.`);
          let r4 = e4[3];
          for (let n3 = 2; n3 >= 1; n3--) {
            const i4 = 1 === n3 ? 1 : 0, s4 = 2 === n3 ? 1 : 0;
            for (let n4 = 0; n4 < e4[0]; n4++) {
              const a4 = e4[1] * n4;
              for (let n5 = i4; n5 < e4[1]; n5++) {
                const i5 = e4[2] * (n5 + a4);
                for (let n6 = s4; n6 < e4[2]; n6++) {
                  const s5 = e4[3] * (n6 + i5);
                  for (let n7 = 0; n7 < e4[3]; n7++) {
                    const e5 = s5 + n7;
                    t4[e5] += t4[e5 - r4];
                  }
                }
              }
            }
            r4 *= e4[n3];
          }
          return t4;
        }
        function Ib(t4) {
          for (let e4 = 0, r4 = t4.length; e4 < r4; e4++) t4[e4] = t4[e4] >>> 1 ^ -(1 & t4[e4]);
          return t4;
        }
        function kb(t4, e4) {
          switch (e4) {
            case "uint32":
              return t4;
            case "uint16":
              for (let e5 = 0; e5 < t4.length; e5 += 2) {
                const r4 = t4[e5], n3 = t4[e5 + 1];
                t4[e5] = (240 & r4) >> 4 | (61440 & r4) >> 8 | (240 & n3) << 4 | 61440 & n3, t4[e5 + 1] = 15 & r4 | (3840 & r4) >> 4 | (15 & n3) << 8 | (3840 & n3) << 4;
              }
              return t4;
            case "uint8":
              for (let e5 = 0; e5 < t4.length; e5 += 4) {
                const r4 = t4[e5], n3 = t4[e5 + 1], i4 = t4[e5 + 2], s4 = t4[e5 + 3];
                t4[e5 + 0] = (192 & r4) >> 6 | (192 & n3) >> 4 | (192 & i4) >> 2 | 192 & s4, t4[e5 + 1] = (48 & r4) >> 4 | (48 & n3) >> 2 | 48 & i4 | (48 & s4) << 2, t4[e5 + 2] = (12 & r4) >> 2 | 12 & n3 | (12 & i4) << 2 | (12 & s4) << 4, t4[e5 + 3] = 3 & r4 | (3 & n3) << 2 | (3 & i4) << 4 | (3 & s4) << 6;
              }
              return t4;
            default:
              throw new Error(`Invalid pixel format, "${e4}"`);
          }
        }
        class Pb extends Error {
          constructor(t4) {
            super(t4), this.name = "MRTError";
          }
        }
        var Eb = Uint8Array, zb = Uint16Array, Tb = Int32Array, Bb = new Eb([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), Cb = new Eb([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Rb = new Eb([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Vb = function(t4, e4) {
          for (var r4 = new zb(31), n3 = 0; n3 < 31; ++n3) r4[n3] = e4 += 1 << t4[n3 - 1];
          var i4 = new Tb(r4[30]);
          for (n3 = 1; n3 < 30; ++n3) for (var s4 = r4[n3]; s4 < r4[n3 + 1]; ++s4) i4[s4] = s4 - r4[n3] << 5 | n3;
          return { b: r4, r: i4 };
        }, Db = Vb(Bb, 2), Lb = Db.b, Fb = Db.r;
        Lb[28] = 258, Fb[258] = 28;
        for (var Ob = Vb(Cb, 0).b, Ub = new zb(32768), Nb = 0; Nb < 32768; ++Nb) {
          var jb = (43690 & Nb) >> 1 | (21845 & Nb) << 1;
          Ub[Nb] = ((65280 & (jb = (61680 & (jb = (52428 & jb) >> 2 | (13107 & jb) << 2)) >> 4 | (3855 & jb) << 4)) >> 8 | (255 & jb) << 8) >> 1;
        }
        var qb = function(t4, e4, r4) {
          for (var n3 = t4.length, i4 = 0, s4 = new zb(e4); i4 < n3; ++i4) t4[i4] && ++s4[t4[i4] - 1];
          var a4, o3 = new zb(e4);
          for (i4 = 1; i4 < e4; ++i4) o3[i4] = o3[i4 - 1] + s4[i4 - 1] << 1;
          if (r4) {
            a4 = new zb(1 << e4);
            var l4 = 15 - e4;
            for (i4 = 0; i4 < n3; ++i4) if (t4[i4]) for (var u5 = i4 << 4 | t4[i4], c4 = e4 - t4[i4], h4 = o3[t4[i4] - 1]++ << c4, p4 = h4 | (1 << c4) - 1; h4 <= p4; ++h4) a4[Ub[h4] >> l4] = u5;
          } else for (a4 = new zb(n3), i4 = 0; i4 < n3; ++i4) t4[i4] && (a4[i4] = Ub[o3[t4[i4] - 1]++] >> 15 - t4[i4]);
          return a4;
        }, $b = new Eb(288);
        for (Nb = 0; Nb < 144; ++Nb) $b[Nb] = 8;
        for (Nb = 144; Nb < 256; ++Nb) $b[Nb] = 9;
        for (Nb = 256; Nb < 280; ++Nb) $b[Nb] = 7;
        for (Nb = 280; Nb < 288; ++Nb) $b[Nb] = 8;
        var Gb = new Eb(32);
        for (Nb = 0; Nb < 32; ++Nb) Gb[Nb] = 5;
        var Qb = qb($b, 9, 1), Yb = qb(Gb, 5, 1), Xb = function(t4) {
          for (var e4 = t4[0], r4 = 1; r4 < t4.length; ++r4) t4[r4] > e4 && (e4 = t4[r4]);
          return e4;
        }, Zb = function(t4, e4, r4) {
          var n3 = e4 / 8 | 0;
          return (t4[n3] | t4[n3 + 1] << 8) >> (7 & e4) & r4;
        }, Kb = function(t4, e4) {
          var r4 = e4 / 8 | 0;
          return (t4[r4] | t4[r4 + 1] << 8 | t4[r4 + 2] << 16) >> (7 & e4);
        }, Wb = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], Hb = function(t4, e4, r4) {
          var n3 = new Error(e4 || Wb[t4]);
          if (n3.code = t4, Error.captureStackTrace && Error.captureStackTrace(n3, Hb), !r4) throw n3;
          return n3;
        }, Jb = new Eb(0), tv = "undefined" != typeof TextDecoder && new TextDecoder();
        try {
          tv.decode(Jb, { stream: true });
        } catch (t4) {
        }
        const ev = { gzip_data: "gzip" };
        const rv = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, nv = { uint32: 1, uint16: 2, uint8: 4 }, iv = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
        class sv {
          constructor(t4 = 1) {
            this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t4;
          }
          getLayer(t4) {
            return this.layers[t4];
          }
          getHeaderLength(t4) {
            const e4 = new Uint8Array(t4), r4 = new DataView(t4);
            if (13 !== e4[0]) throw new Pb("File is not a valid MRT.");
            return r4.getUint32(1, true);
          }
          parseHeader(t4) {
            const e4 = new Uint8Array(t4), r4 = this.getHeaderLength(t4);
            if (e4.length < r4) throw new Pb(`Expected header with length >= ${r4} but got buffer of length ${e4.length}`);
            const n3 = new wm(e4.subarray(0, r4)), i4 = wb.read(n3);
            if (!isNaN(this.x) && (this.x !== i4.x || this.y !== i4.y || this.z !== i4.z)) throw new Pb(`Invalid attempt to parse header ${i4.z}/${i4.x}/${i4.y} for tile ${this.z}/${this.x}/${this.y}`);
            this.x = i4.x, this.y = i4.y, this.z = i4.z;
            for (const t5 of i4.layers) this.layers[t5.name] = new av(t5, { cacheSize: this._cacheSize });
            return this;
          }
          createDecodingTask(t4) {
            const e4 = [], r4 = this.getLayer(t4.layerName);
            for (let n3 = 0; n3 < r4.dataIndex.length; n3++) {
              const i4 = r4.dataIndex[n3], s4 = i4.first_byte - t4.firstByte, a4 = i4.last_byte + 1 - t4.firstByte;
              if (n3 < t4.firstBlock || n3 > t4.lastBlock) continue;
              if (r4._blocksInProgress.has(n3)) continue;
              const o3 = { layerName: r4.name, firstByte: s4, lastByte: a4, pixelFormat: r4.pixelFormat, blockIndex: n3, blockShape: [i4.bands.length].concat(r4.bandShape), buffer: r4.buffer, codec: i4.codec.codec, filters: i4.filters.map((t5) => t5.filter) };
              r4._blocksInProgress.add(n3), e4.push(o3);
            }
            return new ov(e4, () => {
              e4.forEach((t5) => r4._blocksInProgress.delete(t5.blockIndex));
            }, (t5, n3) => {
              if (e4.forEach((t6) => r4._blocksInProgress.delete(t6.blockIndex)), t5) throw t5;
              n3.forEach((t6) => {
                this.getLayer(t6.layerName).processDecodedData(t6);
              });
            });
          }
        }
        class av {
          constructor({ version: t4, name: e4, units: r4, tilesize: n3, pixel_format: i4, buffer: s4, data_index: a4 }, o3) {
            if (this.version = t4, 1 !== this.version) throw new Pb(`Cannot parse raster layer encoded with MRT version ${t4}`);
            this.name = e4, this.units = r4, this.tileSize = n3, this.buffer = s4, this.pixelFormat = rv[i4], this.dataIndex = a4, this.bandShape = [n3 + 2 * s4, n3 + 2 * s4, nv[this.pixelFormat]], this._decodedBlocks = function(t5 = 1e3, e5 = 0, r5 = false) {
              if (isNaN(t5) || t5 < 0) throw new TypeError("Invalid max value");
              if (isNaN(e5) || e5 < 0) throw new TypeError("Invalid ttl value");
              if ("boolean" != typeof r5) throw new TypeError("Invalid resetTtl value");
              return new Ab(t5, e5, r5);
            }(o3 ? o3.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
          }
          processDecodedData(t4) {
            const e4 = t4.blockIndex.toString();
            this._decodedBlocks.get(e4) || this._decodedBlocks.set(e4, t4.data);
          }
          getBlockForBand(t4) {
            let e4 = 0;
            switch (typeof t4) {
              case "string":
                for (const [r4, n3] of this.dataIndex.entries()) {
                  for (const [i4, s4] of n3.bands.entries()) if (s4 === t4) return { bandIndex: e4 + i4, blockIndex: r4, blockBandIndex: i4 };
                  e4 += n3.bands.length;
                }
                break;
              case "number":
                for (const [r4, n3] of this.dataIndex.entries()) {
                  if (t4 >= e4 && t4 < e4 + n3.bands.length) return { bandIndex: t4, blockIndex: r4, blockBandIndex: t4 - e4 };
                  e4 += n3.bands.length;
                }
                break;
              default:
                throw new Pb(`Invalid band \`${JSON.stringify(t4)}\`. Expected string or integer.`);
            }
            throw new Pb(`Band not found: ${JSON.stringify(t4)}`);
          }
          getDataRange(t4) {
            let e4 = 1 / 0, r4 = -1 / 0, n3 = 1 / 0, i4 = -1 / 0;
            for (const s4 of t4) {
              const { blockIndex: t5 } = this.getBlockForBand(s4);
              if (t5 < 0) throw new Pb(`Invalid band: ${JSON.stringify(s4)}`);
              const a4 = this.dataIndex[t5];
              n3 = Math.min(n3, t5), i4 = Math.max(i4, t5), e4 = Math.min(e4, a4.first_byte), r4 = Math.max(r4, a4.last_byte);
            }
            return { layerName: this.name, firstByte: e4, lastByte: r4, firstBlock: n3, lastBlock: i4 };
          }
          hasBand(t4) {
            const { blockIndex: e4 } = this.getBlockForBand(t4);
            return e4 >= 0;
          }
          hasDataForBand(t4) {
            const { blockIndex: e4 } = this.getBlockForBand(t4);
            return e4 >= 0 && !!this._decodedBlocks.get(e4.toString());
          }
          getBandView(t4) {
            const { blockIndex: e4, blockBandIndex: r4 } = this.getBlockForBand(t4), n3 = this._decodedBlocks.get(e4.toString());
            if (!n3) throw new Pb(`Data for band ${JSON.stringify(t4)} of layer "${this.name}" not decoded.`);
            const i4 = this.dataIndex[e4], s4 = this.bandShape.reduce((t5, e5) => t5 * e5, 1), a4 = r4 * s4, o3 = n3.subarray(a4, a4 + s4);
            return { data: o3, bytes: new Uint8Array(o3.buffer).subarray(o3.byteOffset, o3.byteOffset + o3.byteLength), tileSize: this.tileSize, buffer: this.buffer, offset: i4.offset, scale: i4.scale };
          }
        }
        class ov {
          constructor(t4, e4, r4) {
            this.tasks = t4, this._onCancel = e4, this._onComplete = r4, this._finalized = false;
          }
          cancel() {
            this._finalized || (this._onCancel(), this._finalized = true);
          }
          complete(t4, e4) {
            this._finalized || (this._onComplete(t4, e4), this._finalized = true);
          }
        }
        sv.performDecoding = function(t4, e4) {
          return Promise.all(e4.tasks.map((e5) => {
            const { layerName: r4, firstByte: n3, lastByte: i4, pixelFormat: s4, blockShape: a4, blockIndex: o3, filters: l4, codec: u5 } = e5, c4 = new Uint8Array(t4).subarray(n3, i4 + 1), h4 = new Uint32Array(a4[0] * a4[1] * a4[2]);
            let p4;
            if ("gzip_data" !== u5) throw new Error(`Unhandled codec: ${u5}`);
            return p4 = function(t5, e6) {
              if (!globalThis.DecompressionStream && "gzip_data" === e6) return Promise.resolve(((s5 = function(t6) {
                31 == t6[0] && 139 == t6[1] && 8 == t6[2] || Hb(6, "invalid gzip data");
                var e7 = t6[3], r6 = 10;
                4 & e7 && (r6 += 2 + (t6[10] | t6[11] << 8));
                for (var n5 = (e7 >> 3 & 1) + (e7 >> 4 & 1); n5 > 0; n5 -= !t6[r6++]) ;
                return r6 + (2 & e7);
              }(i5 = t5)) + 8 > i5.length && Hb(6, "invalid gzip data"), function(t6, e7, r6, n5) {
                var i6 = t6.length;
                if (!i6 || e7.f && !e7.l) return r6 || new Eb(0);
                var s6 = !r6, a6 = s6 || 2 != e7.i, o5 = e7.i;
                s6 && (r6 = new Eb(3 * i6));
                var l5, u6, c5 = function(t7) {
                  var e8 = r6.length;
                  if (t7 > e8) {
                    var n6 = new Eb(Math.max(2 * e8, t7));
                    n6.set(r6), r6 = n6;
                  }
                }, h5 = e7.f || 0, p5 = e7.p || 0, f4 = e7.b || 0, d3 = e7.l, m4 = e7.d, y4 = e7.m, g5 = e7.n, x5 = 8 * i6;
                do {
                  if (!d3) {
                    h5 = Zb(t6, p5, 1);
                    var b4 = Zb(t6, p5 + 1, 3);
                    if (p5 += 3, !b4) {
                      var v4 = t6[(T5 = 4 + ((p5 + 7) / 8 | 0)) - 4] | t6[T5 - 3] << 8, _4 = T5 + v4;
                      if (_4 > i6) {
                        o5 && Hb(0);
                        break;
                      }
                      a6 && c5(f4 + v4), r6.set(t6.subarray(T5, _4), f4), e7.b = f4 += v4, e7.p = p5 = 8 * _4, e7.f = h5;
                      continue;
                    }
                    if (1 == b4) d3 = Qb, m4 = Yb, y4 = 9, g5 = 5;
                    else if (2 == b4) {
                      var w5 = Zb(t6, p5, 31) + 257, M3 = Zb(t6, p5 + 10, 15) + 4, A4 = w5 + Zb(t6, p5 + 5, 31) + 1;
                      p5 += 14;
                      for (var S3 = new Eb(A4), I4 = new Eb(19), k4 = 0; k4 < M3; ++k4) I4[Rb[k4]] = Zb(t6, p5 + 3 * k4, 7);
                      p5 += 3 * M3;
                      var P4 = Xb(I4), E3 = (1 << P4) - 1, z4 = qb(I4, P4, 1);
                      for (k4 = 0; k4 < A4; ) {
                        var T5, B4 = z4[Zb(t6, p5, E3)];
                        if (p5 += 15 & B4, (T5 = B4 >> 4) < 16) S3[k4++] = T5;
                        else {
                          var C4 = 0, R2 = 0;
                          for (16 == T5 ? (R2 = 3 + Zb(t6, p5, 3), p5 += 2, C4 = S3[k4 - 1]) : 17 == T5 ? (R2 = 3 + Zb(t6, p5, 7), p5 += 3) : 18 == T5 && (R2 = 11 + Zb(t6, p5, 127), p5 += 7); R2--; ) S3[k4++] = C4;
                        }
                      }
                      var V4 = S3.subarray(0, w5), D4 = S3.subarray(w5);
                      y4 = Xb(V4), g5 = Xb(D4), d3 = qb(V4, y4, 1), m4 = qb(D4, g5, 1);
                    } else Hb(1);
                    if (p5 > x5) {
                      o5 && Hb(0);
                      break;
                    }
                  }
                  a6 && c5(f4 + 131072);
                  for (var L4 = (1 << y4) - 1, F5 = (1 << g5) - 1, O3 = p5; ; O3 = p5) {
                    var U3 = (C4 = d3[Kb(t6, p5) & L4]) >> 4;
                    if ((p5 += 15 & C4) > x5) {
                      o5 && Hb(0);
                      break;
                    }
                    if (C4 || Hb(2), U3 < 256) r6[f4++] = U3;
                    else {
                      if (256 == U3) {
                        O3 = p5, d3 = null;
                        break;
                      }
                      var N4 = U3 - 254;
                      U3 > 264 && (N4 = Zb(t6, p5, (1 << ($4 = Bb[k4 = U3 - 257])) - 1) + Lb[k4], p5 += $4);
                      var j5 = m4[Kb(t6, p5) & F5], q4 = j5 >> 4;
                      if (j5 || Hb(3), p5 += 15 & j5, D4 = Ob[q4], q4 > 3) {
                        var $4 = Cb[q4];
                        D4 += Kb(t6, p5) & (1 << $4) - 1, p5 += $4;
                      }
                      if (p5 > x5) {
                        o5 && Hb(0);
                        break;
                      }
                      a6 && c5(f4 + 131072);
                      var G4 = f4 + N4;
                      if (f4 < D4) {
                        var Q3 = 0 - D4, Y2 = Math.min(D4, G4);
                        for (Q3 + f4 < 0 && Hb(3); f4 < Y2; ++f4) r6[f4] = (void 0)[Q3 + f4];
                      }
                      for (; f4 < G4; ++f4) r6[f4] = r6[f4 - D4];
                    }
                  }
                  e7.l = d3, e7.p = O3, e7.b = f4, e7.f = h5, d3 && (h5 = 1, e7.m = y4, e7.d = m4, e7.n = g5);
                } while (!h5);
                return f4 != r6.length && s6 ? (l5 = r6, (null == (u6 = f4) || u6 > l5.length) && (u6 = l5.length), new Eb(l5.subarray(0, u6))) : r6.subarray(0, f4);
              }(i5.subarray(s5, -8), { i: 2 }, new Eb(((r5 = i5)[(n4 = r5.length) - 4] | r5[n4 - 3] << 8 | r5[n4 - 2] << 16 | r5[n4 - 1] << 24) >>> 0))));
              var r5, n4, i5, s5;
              const a5 = ev[e6];
              if (!a5) throw new Error(`Unhandled codec: ${e6}`);
              const o4 = new globalThis.DecompressionStream(a5);
              return new Response(new Blob([t5]).stream().pipeThrough(o4)).arrayBuffer().then((t6) => new Uint8Array(t6));
            }(c4, u5).then((t5) => {
              const e6 = Mb.read(new wm(t5));
              if ("uint32_values" === e6.values) return e6.uint32_values.readValuesInto(h4), new (0, iv[s4])(h4.buffer);
              throw new Error(`Unhandled numeric data "${e6.values}"`);
            }), p4.then((t5) => {
              for (let e6 = l4.length - 1; e6 >= 0; e6--) switch (l4[e6]) {
                case "delta_filter":
                  Sb(t5, a4);
                  break;
                case "zigzag_filter":
                  Ib(t5);
                  break;
                case "bitshuffle_filter":
                  kb(t5, s4);
                  break;
                default:
                  throw new Error(`Unhandled filter "${l4[e6]}"`);
              }
              return { layerName: r4, blockIndex: o3, data: t5 };
            }).catch((t5) => {
              throw t5;
            });
          }));
        }, fo(ov, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] });
        const lv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class uv {
          static from(t4) {
            if (!(t4 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [e4, r4] = new Uint8Array(t4, 0, 2);
            if (219 !== e4) throw new Error("Data does not appear to be in a KDBush format.");
            const n3 = r4 >> 4;
            if (1 !== n3) throw new Error(`Got v${n3} data when expected v1.`);
            const i4 = lv[15 & r4];
            if (!i4) throw new Error("Unrecognized array type.");
            const [s4] = new Uint16Array(t4, 2, 1), [a4] = new Uint32Array(t4, 4, 1);
            return new uv(a4, s4, i4, t4);
          }
          constructor(t4, e4 = 64, r4 = Float64Array, n3) {
            if (isNaN(t4) || t4 < 0) throw new Error(`Unpexpected numItems value: ${t4}.`);
            this.numItems = +t4, this.nodeSize = Math.min(Math.max(+e4, 2), 65535), this.ArrayType = r4, this.IndexArrayType = t4 < 65536 ? Uint16Array : Uint32Array;
            const i4 = lv.indexOf(this.ArrayType), s4 = 2 * t4 * this.ArrayType.BYTES_PER_ELEMENT, a4 = t4 * this.IndexArrayType.BYTES_PER_ELEMENT, o3 = (8 - a4 % 8) % 8;
            if (i4 < 0) throw new Error(`Unexpected typed array class: ${r4}.`);
            n3 && n3 instanceof ArrayBuffer ? (this.data = n3, this.ids = new this.IndexArrayType(this.data, 8, t4), this.coords = new this.ArrayType(this.data, 8 + a4 + o3, 2 * t4), this._pos = 2 * t4, this._finished = true) : (this.data = new ArrayBuffer(8 + s4 + a4 + o3), this.ids = new this.IndexArrayType(this.data, 8, t4), this.coords = new this.ArrayType(this.data, 8 + a4 + o3, 2 * t4), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i4]), new Uint16Array(this.data, 2, 1)[0] = e4, new Uint32Array(this.data, 4, 1)[0] = t4);
          }
          add(t4, e4) {
            const r4 = this._pos >> 1;
            return this.ids[r4] = r4, this.coords[this._pos++] = t4, this.coords[this._pos++] = e4, r4;
          }
          finish() {
            const t4 = this._pos >> 1;
            if (t4 !== this.numItems) throw new Error(`Added ${t4} items when expected ${this.numItems}.`);
            return cv(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t4, e4, r4, n3) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i4, coords: s4, nodeSize: a4 } = this, o3 = [0, i4.length - 1, 0], l4 = [];
            for (; o3.length; ) {
              const u5 = o3.pop() || 0, c4 = o3.pop() || 0, h4 = o3.pop() || 0;
              if (c4 - h4 <= a4) {
                for (let a5 = h4; a5 <= c4; a5++) {
                  const o4 = s4[2 * a5], u6 = s4[2 * a5 + 1];
                  o4 >= t4 && o4 <= r4 && u6 >= e4 && u6 <= n3 && l4.push(i4[a5]);
                }
                continue;
              }
              const p4 = h4 + c4 >> 1, f4 = s4[2 * p4], d3 = s4[2 * p4 + 1];
              f4 >= t4 && f4 <= r4 && d3 >= e4 && d3 <= n3 && l4.push(i4[p4]), (0 === u5 ? t4 <= f4 : e4 <= d3) && (o3.push(h4), o3.push(p4 - 1), o3.push(1 - u5)), (0 === u5 ? r4 >= f4 : n3 >= d3) && (o3.push(p4 + 1), o3.push(c4), o3.push(1 - u5));
            }
            return l4;
          }
          within(t4, e4, r4) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n3, coords: i4, nodeSize: s4 } = this, a4 = [0, n3.length - 1, 0], o3 = [], l4 = r4 * r4;
            for (; a4.length; ) {
              const u5 = a4.pop() || 0, c4 = a4.pop() || 0, h4 = a4.pop() || 0;
              if (c4 - h4 <= s4) {
                for (let r5 = h4; r5 <= c4; r5++) dv(i4[2 * r5], i4[2 * r5 + 1], t4, e4) <= l4 && o3.push(n3[r5]);
                continue;
              }
              const p4 = h4 + c4 >> 1, f4 = i4[2 * p4], d3 = i4[2 * p4 + 1];
              dv(f4, d3, t4, e4) <= l4 && o3.push(n3[p4]), (0 === u5 ? t4 - r4 <= f4 : e4 - r4 <= d3) && (a4.push(h4), a4.push(p4 - 1), a4.push(1 - u5)), (0 === u5 ? t4 + r4 >= f4 : e4 + r4 >= d3) && (a4.push(p4 + 1), a4.push(c4), a4.push(1 - u5));
            }
            return o3;
          }
        }
        function cv(t4, e4, r4, n3, i4, s4) {
          if (i4 - n3 <= r4) return;
          const a4 = n3 + i4 >> 1;
          hv(t4, e4, a4, n3, i4, s4), cv(t4, e4, r4, n3, a4 - 1, 1 - s4), cv(t4, e4, r4, a4 + 1, i4, 1 - s4);
        }
        function hv(t4, e4, r4, n3, i4, s4) {
          for (; i4 > n3; ) {
            if (i4 - n3 > 600) {
              const a5 = i4 - n3 + 1, o4 = r4 - n3 + 1, l5 = Math.log(a5), u5 = 0.5 * Math.exp(2 * l5 / 3), c4 = 0.5 * Math.sqrt(l5 * u5 * (a5 - u5) / a5) * (o4 - a5 / 2 < 0 ? -1 : 1);
              hv(t4, e4, r4, Math.max(n3, Math.floor(r4 - o4 * u5 / a5 + c4)), Math.min(i4, Math.floor(r4 + (a5 - o4) * u5 / a5 + c4)), s4);
            }
            const a4 = e4[2 * r4 + s4];
            let o3 = n3, l4 = i4;
            for (pv(t4, e4, n3, r4), e4[2 * i4 + s4] > a4 && pv(t4, e4, n3, i4); o3 < l4; ) {
              for (pv(t4, e4, o3, l4), o3++, l4--; e4[2 * o3 + s4] < a4; ) o3++;
              for (; e4[2 * l4 + s4] > a4; ) l4--;
            }
            e4[2 * n3 + s4] === a4 ? pv(t4, e4, n3, l4) : (l4++, pv(t4, e4, l4, i4)), l4 <= r4 && (n3 = l4 + 1), r4 <= l4 && (i4 = l4 - 1);
          }
        }
        function pv(t4, e4, r4, n3) {
          fv(t4, r4, n3), fv(e4, 2 * r4, 2 * n3), fv(e4, 2 * r4 + 1, 2 * n3 + 1);
        }
        function fv(t4, e4, r4) {
          const n3 = t4[e4];
          t4[e4] = t4[r4], t4[r4] = n3;
        }
        function dv(t4, e4, r4, n3) {
          const i4 = t4 - r4, s4 = e4 - n3;
          return i4 * i4 + s4 * s4;
        }
        t3.$ = class {
          constructor(t4) {
            this.specification = t4;
          }
          possiblyEvaluate(t4, e4) {
            return function([t5, e5]) {
              const r4 = dr([1, t5, e5]);
              return { x: r4.x, y: r4.y, z: r4.z };
            }(t4.expression.evaluate(e4));
          }
          interpolate(t4, e4, r4) {
            return { x: qn(t4.x, e4.x, r4), y: qn(t4.y, e4.y, r4), z: qn(t4.z, e4.z, r4) };
          }
        }, t3.A = rl, t3.B = Qa, t3.C = zi, t3.D = qa, t3.E = Dn, t3.F = function(t4) {
          const e4 = t4.value;
          let r4 = [];
          if (!e4) return r4;
          const n3 = Si(e4);
          return "string" !== n3 ? (r4 = r4.concat([new Hg(t4.key, e4, `string expected, "${n3}" found`)]), r4) : (Jg(e4, true) || (r4 = r4.concat([new Hg(t4.key, e4, `invalid url "${e4}"`)])), r4);
        }, t3.G = el, t3.H = Ho, t3.I = ty, t3.J = Zo, t3.K = class {
          constructor(t4) {
            this.specification = t4;
          }
          possiblyEvaluate(t4, e4) {
            return dr(t4.expression.evaluate(e4));
          }
          interpolate(t4, e4, r4) {
            return { x: qn(t4.x, e4.x, r4), y: qn(t4.y, e4.y, r4), z: qn(t4.z, e4.z, r4), azimuthal: qn(t4.azimuthal, e4.azimuthal, r4), polar: qn(t4.polar, e4.polar, r4) };
          }
        }, t3.L = qo, t3.M = class {
          constructor(t4, e4, r4, n3) {
            this.id = t4, this.position = null != e4 ? new ac(e4[0], e4[1]) : new ac(0, 0), this.orientation = null != r4 ? r4 : [0, 0, 0], this.nodes = n3, this.uploaded = false, this.aabb = new mh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
          }
          _applyTransformations(e4, r4) {
            if (t3.a9.multiply(e4.matrix, r4, e4.matrix), e4.meshes) for (const t4 of e4.meshes) {
              const r5 = mh.applyTransform(t4.aabb, e4.matrix);
              this.aabb.encapsulate(r5);
            }
            if (e4.children) for (const t4 of e4.children) this._applyTransformations(t4, e4.matrix);
          }
          computeBoundsAndApplyParent() {
            const e4 = t3.a9.identity([]);
            for (const t4 of this.nodes) this._applyTransformations(t4, e4);
          }
          computeModelMatrix(t4, e4, r4, n3, i4, s4, a4 = false) {
            ox(this.matrix, this, t4.transform, this.position, e4, r4, n3, i4, s4, a4);
          }
          upload(t4) {
            if (!this.uploaded) {
              for (const e4 of this.nodes) cx(e4, t4);
              for (const t5 of this.nodes) hx(t5);
              this.uploaded = true;
            }
          }
          destroy() {
            for (const t4 of this.nodes) px(t4);
          }
        }, t3.N = Uo, t3.O = Ec, t3.P = Ue, t3.R = Zr, t3.S = Ke, t3.T = bg, t3.U = Xo, t3.V = Hg, t3.W = Oh, t3.X = qn, t3.Y = is, t3.Z = io, t3._ = $n, t3.a = Vn, t3.a$ = sr, t3.a0 = function(t4, e4, r4 = 0, n3 = true) {
          const i4 = new Ue(r4, r4), s4 = t4.sub(i4), a4 = e4.add(i4), o3 = [s4, new Ue(a4.x, s4.y), a4, new Ue(s4.x, a4.y)];
          return n3 && o3.push(s4.clone()), o3;
        }, t3.a1 = function(t4, e4) {
          const r4 = [];
          for (let n3 = 0; n3 < t4.length; n3++) {
            const i4 = We(n3 - 1, -1, t4.length - 1), s4 = We(n3 + 1, -1, t4.length - 1), a4 = t4[n3], o3 = t4[s4], l4 = t4[i4].sub(a4).unit(), u5 = o3.sub(a4).unit(), c4 = u5.angleWithSep(l4.x, l4.y), h4 = l4.add(u5).unit().mult(-1 * e4 / Math.sin(c4 / 2));
            r4.push(a4.add(h4));
          }
          return r4;
        }, t3.a2 = By, t3.a3 = Hc, t3.a4 = function(e4, r4, n3 = 0) {
          return t3.Q.fromValues(((r4.x - n3) * e4.scale - e4.x) * is, (r4.y * e4.scale - e4.y) * is, Mc(r4.z, r4.y));
        }, t3.a5 = lh, t3.a6 = Pd, t3.a7 = function(t4) {
          let e4 = 1 / 0, r4 = 1 / 0, n3 = -1 / 0, i4 = -1 / 0;
          for (const s4 of t4) e4 = Math.min(e4, s4.x), r4 = Math.min(r4, s4.y), n3 = Math.max(n3, s4.x), i4 = Math.max(i4, s4.y);
          return { min: new Ue(e4, r4), max: new Ue(n3, i4) };
        }, t3.a8 = xc, t3.aA = jn, t3.aB = Ml, t3.aC = Ba, t3.aD = tu, t3.aE = mu, t3.aF = er, t3.aG = nu, t3.aH = ug, t3.aI = function() {
          Oo.isLoading() || Oo.isLoaded() || "deferred" !== Lo() || Fo();
        }, t3.aJ = nl, t3.aK = Fc, t3.aL = ab, t3.aM = yr, t3.aN = Sd, t3.aO = $p, t3.aP = Lc, t3.aQ = Sl, t3.aR = Kl, t3.aS = bh, t3.aT = Op, t3.aU = xg, t3.aV = function(e4, r4) {
          const n3 = Oh(r4.zoom);
          if (0 === n3) return Sh(e4);
          const i4 = Eh(e4), s4 = zh(i4), a4 = xc(i4.getWest()) * r4.worldSize, o3 = xc(i4.getEast()) * r4.worldSize, l4 = bc(i4.getNorth()) * r4.worldSize, u5 = bc(i4.getSouth()) * r4.worldSize, c4 = [a4, l4, 0], h4 = [o3, l4, 0], p4 = [a4, u5, 0], f4 = [o3, u5, 0], d3 = t3.a9.invert([], r4.globeMatrix);
          return t3.Q.transformMat4(c4, c4, d3), t3.Q.transformMat4(h4, h4, d3), t3.Q.transformMat4(p4, p4, d3), t3.Q.transformMat4(f4, f4, d3), s4[0] = Ih(s4[0], p4, n3), s4[1] = Ih(s4[1], f4, n3), s4[2] = Ih(s4[2], h4, n3), s4[3] = Ih(s4[3], c4, n3), mh.fromPoints(s4);
        }, t3.aW = Rh, t3.aX = Th, t3.aY = Ih, t3.aZ = Il, t3.a_ = xh, t3.ab = Wc, t3.ac = Tc, t3.ad = Ze, t3.ae = Xu, t3.af = function(t4, e4) {
          const r4 = {};
          for (let n3 = 0; n3 < e4.length; n3++) {
            const i4 = e4[n3];
            i4 in t4 && (r4[i4] = t4[i4]);
          }
          return r4;
        }, t3.ag = oc, t3.ah = bc, t3.ai = class {
          constructor(t4) {
            this.entries = {}, this.scheduler = t4;
          }
          request(t4, e4, r4, n3) {
            const i4 = this.entries[t4] = this.entries[t4] || { callbacks: [] };
            if (i4.result) {
              const [t5, r5] = i4.result;
              return this.scheduler ? this.scheduler.add(() => {
                n3(t5, r5);
              }, e4) : n3(t5, r5), () => {
              };
            }
            return i4.callbacks.push(n3), i4.cancel || (i4.cancel = r4((r5, n4) => {
              i4.result = [r5, n4];
              for (const t5 of i4.callbacks) this.scheduler ? this.scheduler.add(() => {
                t5(r5, n4);
              }, e4) : t5(r5, n4);
              setTimeout(() => delete this.entries[t4], 3e3);
            })), () => {
              i4.result || (i4.callbacks = i4.callbacks.filter((t5) => t5 !== n3), i4.callbacks.length || (i4.cancel(), delete this.entries[t4]));
            };
          }
        }, t3.aj = yl, t3.ak = function(t4, e4, r4) {
          const n3 = JSON.stringify(t4.request);
          return t4.data && (this.deduped.entries[n3] = { result: [null, t4.data] }), this.deduped.request(n3, { type: "parseTile", isSymbolTile: t4.isSymbolTile, zoom: t4.tileZoom }, (e5) => {
            const n4 = Jr(t4.request, (t5, n5, i4, s4) => {
              t5 ? e5(t5) : n5 && e5(null, { vectorTile: r4 ? void 0 : new pf(new wm(n5)), rawData: n5, cacheControl: i4, expires: s4 });
            });
            return () => {
              n4.cancel(), e5();
            };
          }, e4);
        }, t3.al = function(t4) {
          Nr++, Nr > Dr && (t4.getActor().send("enforceCacheSizeLimit", Vr), Nr = 0);
        }, t3.am = mn, t3.an = zr, t3.ao = function(t4) {
          return t4 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t4) / Math.LN2));
        }, t3.ap = pc, t3.aq = Ig, t3.ar = Eg, t3.as = Ag, t3.at = function(t4, e4) {
          const r4 = document.createElement("video");
          r4.muted = true, r4.onloadstart = function() {
            e4(null, r4);
          };
          for (let e5 = 0; e5 < t4.length; e5++) {
            const n3 = document.createElement("source");
            tn2(t4[e5]) || (r4.crossOrigin = "Anonymous"), n3.src = t4[e5], r4.appendChild(n3);
          }
          return { cancel: () => {
          } };
        }, t3.au = vg, t3.av = Ty, t3.aw = _c, t3.ax = wc, t3.ay = kl, t3.az = ql, t3.b = Rn, t3.b$ = oy, t3.b0 = sv, t3.b1 = Jr, t3.b2 = function(t4) {
          const e4 = [];
          for (const r4 in t4) e4.push(t4[r4]);
          return e4;
        }, t3.b3 = function(t4, e4) {
          const r4 = [];
          for (const n3 in t4) n3 in e4 || r4.push(n3);
          return r4;
        }, t3.b4 = He, t3.b5 = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t3.b6 = function(e4, r4) {
          const { x: n3, y: i4 } = e4.point, s4 = Fh(n3, i4, e4.worldSize / e4._pixelsPerMercatorPixel, 0, 0);
          return t3.a9.multiply(s4, s4, Vh(Sh(r4)));
        }, t3.b8 = Xd, t3.b9 = Pm, t3.bA = Ku, t3.bB = function(e4) {
          const r4 = t3.a9.identity(new Float64Array(16));
          t3.a9.multiply(r4, e4.pixelMatrix, e4.globeMatrix);
          const n3 = [0, tc, 0], i4 = [0, ec, 0];
          return t3.Q.transformMat4(n3, n3, r4), t3.Q.transformMat4(i4, i4, r4), [n3[0] > 0 && n3[0] <= e4.width && n3[1] > 0 && n3[1] <= e4.height && !Nh(e4, new ac(e4.center.lat, 90)), i4[0] > 0 && i4[0] <= e4.width && i4[1] > 0 && i4[1] <= e4.height && !Nh(e4, new ac(e4.center.lat, -90))];
        }, t3.bC = function(e4, r4) {
          const { scale: n3 } = e4.tileTransform, i4 = n3 * is / (e4.tileSize * Math.pow(2, r4.zoom - e4.tileID.overscaledZ + e4.tileID.canonical.z));
          return t3.b7.scale(new Float32Array(4), r4.inverseAdjustmentMatrix, [i4, i4]);
        }, t3.bD = Lg, t3.bE = Vg, t3.bF = function(e4) {
          const r4 = Vg(e4, true);
          return t3.b7.invert([], [r4[0], r4[1], r4[4], r4[5]]);
        }, t3.bG = uh, t3.bH = function(t4) {
          const { x: e4, y: r4 } = t4.point, { lng: n3, lat: i4 } = t4._center;
          return Fh(e4, r4, t4.worldSize, n3, i4);
        }, t3.bI = $e, t3.bJ = Zu, t3.bK = function(t4) {
          const e4 = Math.round((t4 + 45 + 360) % 360 / 90) % 4;
          return Ge[e4];
        }, t3.bL = 45, t3.bM = gc, t3.bN = Tu, t3.bO = Iu, t3.bP = ku, t3.bQ = Su, t3.bR = Au, t3.bS = Pu, t3.bT = function(t4, e4, r4) {
          const n3 = Math.sqrt(t4 * t4 + e4 * e4 + r4 * r4), i4 = n3 > 0 ? Math.acos(r4 / n3) * je : 0;
          let s4 = 0 !== t4 || 0 !== e4 ? Math.atan2(-e4, -t4) * je + 90 : 0;
          return s4 < 0 && (s4 += 360), [n3, s4, i4];
        }, t3.bU = Pc, t3.bV = mh, t3.bW = dr, t3.bX = function(t4) {
          return [Math.pow(t4[0], 1 / 2.2), Math.pow(t4[1], 1 / 2.2), Math.pow(t4[2], 1 / 2.2)];
        }, t3.bY = function(t4) {
          return t4({ pluginStatus: Bo, pluginURL: Co }), Do.on("pluginStateChange", t4), t4;
        }, t3.bZ = yx, t3.b_ = wx, t3.ba = Yd, t3.bb = function(t4, e4, r4, n3, i4) {
          const s4 = 5 * e4 + 2;
          t4.float32[s4 + 0] = r4, t4.float32[s4 + 1] = n3, t4.float32[s4 + 2] = i4;
        }, t3.bc = sg, t3.bd = Wm, t3.be = jc, t3.bf = $d, t3.bg = _y, t3.bh = vy, t3.bi = Om, t3.bj = uv, t3.bk = We, t3.bm = qe, t3.bn = Sr, t3.bo = vc, t3.bp = function(t4, e4, r4) {
          t4[4 * e4 + 0] = r4[0], t4[4 * e4 + 1] = r4[1], t4[4 * e4 + 2] = r4[2], t4[4 * e4 + 3] = r4[3];
        }, t3.bq = ac, t3.br = Jy, t3.bs = hc, t3.bt = dh, t3.bu = Dg, t3.bv = cc, t3.bw = Ph, t3.bx = function(t4, e4, r4, n3, i4, s4, a4, o3, l4) {
          if ("globe" === l4.name) return Ph(t4, e4, new cc(r4, n3, i4), false);
          const u5 = Ty({ z: r4, x: n3, y: i4 }, l4);
          return new mh([(s4 + u5.x / u5.scale) * e4, e4 * (u5.y / u5.scale), a4], [(s4 + u5.x2 / u5.scale) * e4, e4 * (u5.y2 / u5.scale), o3]);
        }, t3.by = function(t4, e4, r4) {
          let n3 = 0;
          for (let r5 = 0; r5 < 2; ++r5) {
            const i4 = 0;
            t4[r5] > i4 && (n3 += (t4[r5] - i4) * (t4[r5] - i4)), e4[r5] < i4 && (n3 += (i4 - e4[r5]) * (i4 - e4[r5]));
          }
          return n3;
        }, t3.bz = Ac, t3.c = eb, t3.c$ = [1, 1, 1], t3.c0 = ay, t3.c1 = Wr, t3.c2 = Ro, t3.c3 = s3, t3.c4 = Cr, t3.c5 = Tn, t3.c6 = ur, t3.c7 = function(t4, e4, r4) {
          return "custom" === t4.type ? new zg(t4, e4) : new _b[t4.type](t4, e4, r4);
        }, t3.c8 = function(t4) {
          const e4 = t4.indexOf(ml);
          return e4 >= 0 ? t4.slice(0, e4) : t4;
        }, t3.c9 = function(t4) {
          return t4.indexOf(ml) >= 0;
        }, t3.cA = (t4) => ({ u_matrix: new Tu(t4), u_pixels_to_tile_units: new Ru(t4), u_device_pixel_ratio: new Su(t4), u_units_to_pixels: new Iu(t4), u_dash_image: new Au(t4), u_gradient_image: new Au(t4), u_image_height: new Su(t4), u_texsize: new Iu(t4), u_tile_units_to_pixels: new Su(t4), u_alpha_discard_threshold: new Su(t4), u_trim_offset: new Iu(t4), u_emissive_strength: new Su(t4) }), t3.cB = (t4) => ({ u_matrix: new Tu(t4), u_texsize: new Iu(t4), u_pixels_to_tile_units: new Ru(t4), u_device_pixel_ratio: new Su(t4), u_image: new Au(t4), u_units_to_pixels: new Iu(t4), u_tile_units_to_pixels: new Su(t4), u_alpha_discard_threshold: new Su(t4), u_trim_offset: new Iu(t4) }), t3.cC = Nl, t3.cD = qd, t3.cE = Zd, t3.cF = Qh, t3.cG = (t4, e4, r4, n3, i4, s4) => {
          const a4 = t4.transform, o3 = "globe" === a4.projection.name;
          let l4;
          if ("map" === s4.paint.get("circle-pitch-alignment")) if (o3) {
            const t5 = Lh(a4.zoom, e4.canonical) * a4._pixelsPerMercatorPixel;
            l4 = Float32Array.from([t5, 0, 0, t5]);
          } else l4 = a4.calculatePixelsToTileUnitsMatrix(r4);
          else l4 = new Float32Array([a4.pixelsToGLUnits[0], 0, 0, a4.pixelsToGLUnits[1]]);
          const u5 = { u_camera_to_center_distance: t4.transform.getCameraToCenterDistance(a4.projection), u_matrix: t4.translatePosMatrix(e4.projMatrix, r4, s4.paint.get("circle-translate"), s4.paint.get("circle-translate-anchor")), u_device_pixel_ratio: Tr.devicePixelRatio, u_extrude_scale: l4, u_inv_rot_matrix: Gh, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: s4.paint.get("circle-emissive-strength") };
          if (o3) {
            u5.u_inv_rot_matrix = n3, u5.u_merc_center = i4, u5.u_tile_id = [e4.canonical.x, e4.canonical.y, 1 << e4.canonical.z], u5.u_zoom_transition = Oh(a4.zoom);
            const t5 = i4[0] * is, r5 = i4[1] * is;
            u5.u_up_dir = a4.projection.upVector(new cc(0, 0, 0), t5, r5);
          }
          return u5;
        }, t3.cH = Td, t3.cI = (t4, e4, r4, n3, i4, s4) => {
          const a4 = t4.transform;
          return { u_matrix: zd(t4, e4, r4, n3), u_texsize: e4.imageAtlasTexture ? e4.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: a4.calculatePixelsToTileUnitsMatrix(e4), u_device_pixel_ratio: i4, u_image: 0, u_tile_units_to_pixels: Ed(e4, a4), u_units_to_pixels: [1 / a4.pixelsToGLUnits[0], 1 / a4.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: s4 };
        }, t3.cJ = (t4, e4, r4, n3, i4, s4, a4) => {
          const o3 = t4.transform, l4 = o3.calculatePixelsToTileUnitsMatrix(e4);
          return { u_matrix: zd(t4, e4, r4, n3), u_pixels_to_tile_units: l4, u_device_pixel_ratio: s4, u_units_to_pixels: [1 / o3.pixelsToGLUnits[0], 1 / o3.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: i4, u_texsize: Bd(r4) && e4.lineAtlasTexture ? e4.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Ed(e4, t4.transform), u_alpha_discard_threshold: 0, u_trim_offset: a4, u_emissive_strength: r4.paint.get("line-emissive-strength") };
        }, t3.cK = nr, t3.cL = op, t3.cM = ad, t3.cN = dc, t3.cO = Hf, t3.cP = Nf, t3.cQ = 450, t3.cR = 7, t3.cS = Sg, t3.cT = 256, t3.cU = Vh, t3.cV = Wl, t3.cW = Yl, t3.cX = Xl, t3.cY = function(t4, e4, r4, n3, i4) {
          return Ze((t4 - e4) / (r4 - e4) * (i4 - n3) + n3, n3, i4);
        }, t3.cZ = Ic, t3.c_ = qg, t3.ca = function(t4) {
          const e4 = t4.indexOf(ml);
          return e4 >= 0 ? t4.slice(e4 + 1) : "";
        }, t3.cb = function(t4) {
          const e4 = [], r4 = t4.id;
          return void 0 === r4 && e4.push({ message: `layers.${r4}: missing required property "id"` }), void 0 === t4.render && e4.push({ message: `layers.${r4}: missing required method "render"` }), t4.renderingMode && "2d" !== t4.renderingMode && "3d" !== t4.renderingMode && e4.push({ message: `layers.${r4}: property "renderingMode" must be either "2d" or "3d"` }), e4;
        }, t3.cc = lr, t3.cd = Do, t3.ce = Hr, t3.cf = Eu, t3.cg = class extends Mu {
          constructor(t4) {
            super(t4), this.current = Bu;
          }
          set(t4, e4, r4) {
            if (this.fetchUniformLocation(t4, e4)) {
              for (let t5 = 0; t5 < 9; t5++) if (r4[t5] !== this.current[t5]) {
                this.current = r4, this.gl.uniformMatrix3fv(this.location, false, r4);
                break;
              }
            }
          }
        }, t3.ch = Qe, t3.ci = function(t4, e4, r4) {
          const n3 = Oh(r4.zoom), i4 = t4.style.map._antialias, s4 = e4.options.extStandardDerivativesForceOff || t4.terrain && t4.terrain.exaggeration() > 0;
          return 0 === n3 && !i4 && !s4;
        }, t3.cj = function(e4) {
          const r4 = e4.pixelsPerMeter, n3 = r4 / vc(1, e4.center.lat), i4 = t3.a9.identity(new Float64Array(16));
          return t3.a9.translate(i4, i4, [e4.point.x, e4.point.y, 0]), t3.a9.scale(i4, i4, [n3, n3, r4]), Float32Array.from(i4);
        }, t3.ck = Eh, t3.cl = function(t4) {
          const e4 = Ac - 5;
          t4 = Ze(t4, -e4, e4) / e4 * 90;
          const r4 = Math.pow(Math.abs(Math.sin(qe(t4))), 3);
          return Math.round(r4 * (Ju.length - 1));
        }, t3.cm = function(e4, r4, n3, i4) {
          const s4 = r4.getNorth(), a4 = r4.getSouth(), o3 = r4.getWest(), l4 = r4.getEast(), u5 = 1 << e4.z, c4 = l4 - o3, h4 = s4 - a4, p4 = c4 / Hu, f4 = -h4 / Ju[n3], d3 = [0, p4, 0, f4, 0, 0, s4, o3, 0];
          if (e4.z > 0) {
            const e5 = 180 / i4;
            t3.ct.multiply(d3, d3, [e5 / c4 + 1, 0, 0, 0, e5 / h4 + 1, 0, -0.5 * e5 / p4, 0.5 * e5 / f4, 1]);
          }
          return d3[2] = u5, d3[5] = e4.x, d3[8] = e4.y, d3;
        }, t3.cn = Sh, t3.co = function(e4, r4, n3) {
          const i4 = t3.a9.identity(new Float64Array(16)), s4 = (r4 / (1 << e4) - 0.5) * Math.PI * 2;
          return t3.a9.rotateY(i4, n3.globeMatrix, s4), Float32Array.from(i4);
        }, t3.cp = class {
          isDataAvailableAtPoint(t4) {
            const e4 = this._source();
            if (this.isUsingMockSource() || !e4 || t4.y < 0 || t4.y > 1) return false;
            const r4 = e4.getSource().maxzoom, n3 = 1 << r4, i4 = Math.floor(t4.x), s4 = Math.floor((t4.x - i4) * n3), a4 = Math.floor(t4.y * n3), o3 = this.findDEMTileFor(new pc(r4, i4, r4, s4, a4));
            return !(!o3 || !o3.dem);
          }
          getAtPointOrZero(t4, e4 = 0) {
            return this.getAtPoint(t4, e4) || 0;
          }
          getAtPoint(t4, e4, r4 = true) {
            if (this.isUsingMockSource()) return null;
            null == e4 && (e4 = null);
            const n3 = this._source();
            if (!n3) return e4;
            if (t4.y < 0 || t4.y > 1) return e4;
            const i4 = n3.getSource().maxzoom, s4 = 1 << i4, a4 = Math.floor(t4.x), o3 = t4.x - a4, l4 = new pc(i4, a4, i4, Math.floor(o3 * s4), Math.floor(t4.y * s4)), u5 = this.findDEMTileFor(l4);
            if (!u5 || !u5.dem) return e4;
            const c4 = u5.dem, h4 = 1 << u5.tileID.canonical.z, p4 = (o3 * h4 - u5.tileID.canonical.x) * c4.dim, f4 = (t4.y * h4 - u5.tileID.canonical.y) * c4.dim, d3 = Math.floor(p4), m4 = Math.floor(f4);
            return (r4 ? this.exaggeration() : 1) * qn(qn(c4.get(d3, m4), c4.get(d3, m4 + 1), f4 - m4), qn(c4.get(d3 + 1, m4), c4.get(d3 + 1, m4 + 1), f4 - m4), p4 - d3);
          }
          getAtTileOffset(t4, e4, r4) {
            const n3 = 1 << t4.canonical.z;
            return this.getAtPointOrZero(new Ec(t4.wrap + (t4.canonical.x + e4 / is) / n3, (t4.canonical.y + r4 / is) / n3));
          }
          getAtTileOffsetFunc(e4, r4, n3, i4) {
            return (s4) => {
              const a4 = this.getAtTileOffset(e4, s4.x, s4.y), o3 = i4.upVector(e4.canonical, s4.x, s4.y), l4 = i4.upVectorScale(e4.canonical, r4, n3).metersToTile;
              return t3.Q.scale(o3, o3, a4 * l4), o3;
            };
          }
          getForTilePoints(t4, e4, r4, n3) {
            if (this.isUsingMockSource()) return false;
            const i4 = Rf.create(this, t4, n3);
            return !!i4 && (e4.forEach((t5) => {
              t5[2] = this.exaggeration() * i4.getElevationAt(t5[0], t5[1], r4);
            }), true);
          }
          getMinMaxForTile(t4) {
            if (this.isUsingMockSource()) return null;
            const e4 = this.findDEMTileFor(t4);
            if (!e4 || !e4.dem) return null;
            const r4 = e4.dem.tree, n3 = e4.tileID, i4 = 1 << t4.canonical.z - n3.canonical.z;
            let s4 = t4.canonical.x / i4 - n3.canonical.x, a4 = t4.canonical.y / i4 - n3.canonical.y, o3 = 0;
            for (let e5 = 0; e5 < t4.canonical.z - n3.canonical.z && !r4.leaves[o3]; e5++) {
              s4 *= 2, a4 *= 2;
              const t5 = 2 * Math.floor(a4) + Math.floor(s4);
              o3 = r4.childOffsets[o3] + t5, s4 %= 1, a4 %= 1;
            }
            return { min: this.exaggeration() * r4.minimums[o3], max: this.exaggeration() * r4.maximums[o3] };
          }
          getMinElevationBelowMSL() {
            throw new Error("Pure virtual method called.");
          }
          raycast(t4, e4, r4) {
            throw new Error("Pure virtual method called.");
          }
          pointCoordinate(t4) {
            throw new Error("Pure virtual method called.");
          }
          _source() {
            throw new Error("Pure virtual method called.");
          }
          isUsingMockSource() {
            throw new Error("Pure virtual method called.");
          }
          exaggeration() {
            throw new Error("Pure virtual method called.");
          }
          findDEMTileFor(t4) {
            throw new Error("Pure virtual method called.");
          }
          get visibleDemTiles() {
            throw new Error("Getter must be implemented in subclass.");
          }
          getMinMaxForVisibleTiles() {
            const t4 = this.visibleDemTiles;
            if (0 === t4.length) return null;
            let e4 = false, r4 = Number.MAX_VALUE, n3 = Number.MIN_VALUE;
            for (const i4 of t4) {
              const t5 = this.getMinMaxForTile(i4.tileID);
              t5 && (r4 = Math.min(r4, t5.min), n3 = Math.max(n3, t5.max), e4 = true);
            }
            return e4 ? { min: r4, max: n3 } : null;
          }
        }, t3.cq = vh, t3.cr = ip, t3.cs = function(t4, e4) {
          return [Math.pow(t4[0], 2.2) * e4, Math.pow(t4[1], 2.2) * e4, Math.pow(t4[2], 2.2) * e4];
        }, t3.cu = Lh, t3.cv = Er, t3.cw = Pr, t3.cx = 256, t3.cy = function(e4, r4) {
          const n3 = [0, 0, 0], i4 = Rh(Sh(r4.canonical));
          return t3.Q.transformMat4(n3, n3, i4), t3.Q.transformMat4(n3, n3, e4), n3;
        }, t3.cz = (t4) => ({ u_camera_to_center_distance: new Su(t4), u_extrude_scale: new Ru(t4), u_device_pixel_ratio: new Su(t4), u_matrix: new Tu(t4), u_inv_rot_matrix: new Tu(t4), u_merc_center: new Iu(t4), u_tile_id: new ku(t4), u_zoom_transition: new Su(t4), u_up_dir: new ku(t4), u_emissive_strength: new Su(t4) }), t3.d = sn, t3.d$ = mx, t3.d0 = Rf, t3.d1 = ax, t3.d2 = Fl, t3.d3 = class {
          constructor() {
            this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [];
          }
          clear() {
            this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
          }
          get updateTime() {
            return this._updateTime;
          }
          getReplacementRegionsForTile(t4) {
            const e4 = xf(new Ue(0, 0), new Ue(is, is), t4), r4 = [];
            for (const n3 of this._activeRegions) {
              if (n3.hiddenByOverlap) continue;
              if (!gf(e4, n3)) continue;
              const i4 = bf(n3.min, n3.max, t4);
              r4.push({ min: i4.min, max: i4.max, sourceId: this._sourceIds[n3.priority], footprint: n3.footprint, footprintTileId: n3.tileId });
            }
            return r4;
          }
          setSources(t4) {
            this._setSources(t4.map((t5) => ({ getSourceId: () => t5.cache.id, getFootprints: () => {
              const e4 = [];
              for (const r4 of t5.cache.getVisibleCoordinates()) {
                const n3 = t5.cache.getTile(r4).buckets[t5.layer];
                if (n3) for (const t6 of n3.getNodesInfo()) {
                  const n4 = t6.node;
                  n4.footprint && e4.push({ footprint: n4.footprint, id: r4.toUnwrapped() });
                }
              }
              return e4;
            } })));
          }
          _addSource(t4) {
            const e4 = t4.getFootprints();
            if (0 !== e4.length) {
              for (const t5 of e4) {
                if (!t5.footprint) continue;
                const e5 = xf(t5.footprint.min, t5.footprint.max, t5.id);
                this._activeRegions.push({ min: e5.min, max: e5.max, hiddenByOverlap: false, priority: this._sourceIds.length, tileId: t5.id, footprint: t5.footprint });
              }
              this._sourceIds.push(t4.getSourceId());
            }
          }
          _computeReplacement() {
            this._activeRegions.sort((t5, e4) => t5.priority - e4.priority || mf(t5.min, e4.min) || mf(t5.max, e4.max));
            let t4 = this._activeRegions.length !== this._prevRegions.length;
            if (!t4) {
              let e4 = 0, r4 = 0;
              for (; !t4 && e4 !== this._activeRegions.length; ) {
                const n3 = this._activeRegions[e4], i4 = this._prevRegions[r4];
                t4 = n3.priority !== i4.priority || !yf(n3, i4), ++e4, ++r4;
              }
            }
            if (t4) {
              ++this._updateTime;
              const t5 = (t6) => {
                const e4 = this._activeRegions;
                if (t6 >= e4.length) return t6;
                const r4 = e4[t6].priority;
                for (; t6 < e4.length && e4[t6].priority === r4; ) ++t6;
                return t6;
              };
              if (this._sourceIds.length > 1) {
                let e4 = 0, r4 = t5(e4);
                for (; e4 !== r4; ) {
                  let n3 = e4;
                  const i4 = e4;
                  for (; n3 !== r4; ) {
                    const t6 = this._activeRegions[n3];
                    t6.hiddenByOverlap = false;
                    for (let e5 = 0; e5 < i4; e5++) {
                      const r5 = this._activeRegions[e5];
                      if (!r5.hiddenByOverlap && gf(t6, r5) && (t6.hiddenByOverlap = _f(t6.footprint, t6.tileId, r5.footprint, r5.tileId), t6.hiddenByOverlap)) break;
                    }
                    ++n3;
                  }
                  e4 = r4, r4 = t5(e4);
                }
              }
            }
          }
          _setSources(t4) {
            [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
            for (let e4 = t4.length - 1; e4 >= 0; e4--) this._addSource(t4[e4]);
            this._computeReplacement();
          }
        }, t3.d4 = class {
          constructor(t4) {
            this._createGrid(t4), this._createPoles(t4);
          }
          destroy() {
            this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
            for (const t4 of this._poleSegments) t4.destroy();
            for (const t4 of this._gridSegments) t4.withSkirts.destroy(), t4.withoutSkirts.destroy();
          }
          _fillGridMeshWithLods(t4, e4) {
            const r4 = new Sl(), n3 = new ql(), i4 = [], s4 = t4 + 1 + 2, a4 = e4[0] + 1, o3 = e4[0] + 1 + (1 + e4.length), l4 = (t5, e5, r5) => {
              let n4 = t5 === s4 - 1 ? t5 - 2 : 0 === t5 ? t5 : t5 - 1;
              return n4 += r5 ? 24575 : 0, [n4, e5];
            };
            for (let t5 = 0; t5 < s4; ++t5) r4.emplaceBack(...l4(t5, 0, true));
            for (let t5 = 0; t5 < a4; ++t5) for (let e5 = 0; e5 < s4; ++e5) r4.emplaceBack(...l4(e5, t5, (0 === e5 || e5 === s4 - 1) && true));
            for (let t5 = 0; t5 < e4.length; ++t5) {
              const n4 = e4[t5];
              for (let t6 = 0; t6 < s4; ++t6) r4.emplaceBack(...l4(t6, n4, true));
            }
            for (let t5 = 0; t5 < e4.length; ++t5) {
              const a5 = n3.length, l5 = e4[t5] + 1 + 2, u5 = new ql();
              for (let r5 = 0; r5 < l5 - 1; r5++) {
                const i5 = r5 === l5 - 2, a6 = i5 ? s4 * (o3 - e4.length + t5 - r5) : s4;
                for (let t6 = 0; t6 < s4 - 1; t6++) {
                  const e5 = r5 * s4 + t6;
                  0 === r5 || i5 || 0 === t6 || t6 === s4 - 2 ? (u5.emplaceBack(e5 + 1, e5, e5 + a6), u5.emplaceBack(e5 + a6, e5 + a6 + 1, e5 + 1)) : (n3.emplaceBack(e5 + 1, e5, e5 + a6), n3.emplaceBack(e5 + a6, e5 + a6 + 1, e5 + 1));
                }
              }
              const c4 = mu.simpleSegment(0, a5, r4.length, n3.length - a5);
              for (let t6 = 0; t6 < u5.uint16.length; t6 += 3) n3.emplaceBack(u5.uint16[t6], u5.uint16[t6 + 1], u5.uint16[t6 + 2]);
              const h4 = mu.simpleSegment(0, a5, r4.length, n3.length - a5);
              i4.push({ withoutSkirts: c4, withSkirts: h4 });
            }
            return { vertices: r4, indices: n3, segments: i4 };
          }
          _createGrid(t4) {
            const e4 = this._fillGridMeshWithLods(Hu, Ju);
            this._gridSegments = e4.segments, this._gridBuffer = t4.createVertexBuffer(e4.vertices, bh.members), this._gridIndexBuffer = t4.createIndexBuffer(e4.indices, true);
          }
          _createPoles(t4) {
            const e4 = new ql();
            for (let t5 = 0; t5 <= Hu; t5++) e4.emplaceBack(0, t5 + 1, t5 + 2);
            this._poleIndexBuffer = t4.createIndexBuffer(e4, true);
            const r4 = new Yl(), n3 = new Yl(), i4 = new Yl(), s4 = new Yl();
            this._poleSegments = [];
            for (let t5 = 0, e5 = 0; t5 < Zu; t5++) {
              const a4 = 360 / (1 << t5);
              r4.emplaceBack(0, -Xu, 0, 0.5, 0), n3.emplaceBack(0, -Xu, 0, 0.5, 1), i4.emplaceBack(0, -Xu, 0, 0.5, 0.5), s4.emplaceBack(0, -Xu, 0, 0.5, 0.5);
              for (let t6 = 0; t6 <= Hu; t6++) {
                let e6 = t6 / Hu, o3 = 0;
                const l4 = qn(0, a4, e6), [u5, c4, h4] = rc(qh, $h, l4, Xu);
                r4.emplaceBack(u5, c4, h4, e6, o3), n3.emplaceBack(u5, c4, h4, e6, 1 - o3);
                const p4 = qe(l4);
                e6 = 0.5 + 0.5 * Math.sin(p4), o3 = 0.5 + 0.5 * Math.cos(p4), i4.emplaceBack(u5, c4, h4, e6, o3), s4.emplaceBack(u5, c4, h4, e6, 1 - o3);
              }
              this._poleSegments.push(mu.simpleSegment(e5, 0, 66, 64)), e5 += 66;
            }
            this._poleNorthVertexBuffer = t4.createVertexBuffer(r4, gh, false), this._poleSouthVertexBuffer = t4.createVertexBuffer(n3, gh, false), this._texturedPoleNorthVertexBuffer = t4.createVertexBuffer(i4, gh, false), this._texturedPoleSouthVertexBuffer = t4.createVertexBuffer(s4, gh, false);
          }
          getGridBuffers(t4, e4) {
            return [this._gridBuffer, this._gridIndexBuffer, e4 ? this._gridSegments[t4].withSkirts : this._gridSegments[t4].withoutSkirts];
          }
          getPoleBuffers(t4, e4) {
            return [e4 ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e4 ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t4]];
          }
        }, t3.d5 = function(t4) {
          return An.has(t4);
        }, t3.d6 = Ye, t3.d7 = function() {
          return !!document.fullscreenElement || !!document.webkitFullscreenElement;
        }, t3.d8 = Xe, t3.d9 = kc, t3.dA = vx, t3.dB = function(t4) {
          const e4 = Or();
          if (!e4) return;
          const r4 = e4.delete(Rr);
          t4 && r4.catch(t4).then(() => t4());
        }, t3.dC = gx, t3.dD = Ex, t3.dE = function(t4) {
          Ax = Tr.resolveURL(t4), Px || (Px = new yx(wx(), new Dn())), Px.broadcast("setDracoUrl", Ax);
        }, t3.dF = zx, t3.dG = function(t4) {
          Ix = Tr.resolveURL(t4), Px || (Px = new yx(wx(), new Dn())), Px.broadcast("setMeshoptUrl", Ix);
        }, t3.dH = fo, t3.dI = rp, t3.dJ = sy, t3.dK = ib, t3.dL = ob, t3.dM = _d, t3.dN = or, t3.dO = ey, t3.dP = function(t4, e4, r4, n3, i4, s4, a4, o3, l4, u5, c4) {
          t4.createArrays(), t4.tilePixelRatio = is / (512 * t4.overscaling), t4.compareText = {}, t4.iconsNeedLinear = false;
          const h4 = t4.layers[0].layout, p4 = t4.layers[0]._unevaluatedLayout._values, f4 = {};
          if ("composite" === t4.textSizeData.kind) {
            const { minZoom: e5, maxZoom: r5 } = t4.textSizeData;
            f4.compositeTextSizes = [p4["text-size"].possiblyEvaluate(new Uo(e5), o3), p4["text-size"].possiblyEvaluate(new Uo(r5), o3)];
          }
          if ("composite" === t4.iconSizeData.kind) {
            const { minZoom: e5, maxZoom: r5 } = t4.iconSizeData;
            f4.compositeIconSizes = [p4["icon-size"].possiblyEvaluate(new Uo(e5), o3), p4["icon-size"].possiblyEvaluate(new Uo(r5), o3)];
          }
          f4.layoutTextSize = p4["text-size"].possiblyEvaluate(new Uo(l4 + 1), o3), f4.layoutIconSize = p4["icon-size"].possiblyEvaluate(new Uo(l4 + 1), o3), f4.textMaxSize = p4["text-size"].possiblyEvaluate(new Uo(18), o3);
          const d3 = "map" === h4.get("text-rotation-alignment") && "point" !== h4.get("symbol-placement"), m4 = h4.get("text-size");
          let y4 = false;
          for (const e5 of t4.features) if (e5.icon && e5.icon.nameSecondary) {
            y4 = true;
            break;
          }
          for (const s5 of t4.features) {
            const l5 = h4.get("text-font").evaluate(s5, {}, o3).join(","), p5 = m4.evaluate(s5, {}, o3), g5 = f4.layoutTextSize.evaluate(s5, {}, o3), x5 = (f4.layoutIconSize.evaluate(s5, {}, o3), { horizontal: {}, vertical: void 0 }), b4 = s5.text;
            let v4, _4 = [0, 0];
            if (b4) {
              const n4 = b4.toString(), a5 = h4.get("text-letter-spacing").evaluate(s5, {}, o3) * $d, u6 = h4.get("text-line-height").evaluate(s5, {}, o3) * $d, c5 = _o(n4) ? a5 : 0, f5 = h4.get("text-anchor").evaluate(s5, {}, o3), m5 = h4.get("text-variable-anchor");
              if (!m5) {
                const t5 = h4.get("text-radial-offset").evaluate(s5, {}, o3);
                _4 = t5 ? vy(f5, [t5 * $d, xy]) : h4.get("text-offset").evaluate(s5, {}, o3).map((t6) => t6 * $d);
              }
              let y5 = d3 ? "center" : h4.get("text-justify").evaluate(s5, {}, o3);
              const v5 = "point" === h4.get("symbol-placement"), w6 = v5 ? h4.get("text-max-width").evaluate(s5, {}, o3) * $d : 1 / 0, M4 = (s6) => {
                t4.allowVerticalPlacement && vo(n4) && (x5.vertical = Tm(b4, e4, r4, i4, l5, w6, u6, f5, s6, c5, _4, Pm.vertical, true, g5, p5));
              };
              if (!d3 && m5) {
                const t5 = "auto" === y5 ? m5.map((t6) => _y(t6)) : [y5];
                let n5 = false;
                for (let s6 = 0; s6 < t5.length; s6++) {
                  const a6 = t5[s6];
                  if (!x5.horizontal[a6]) if (n5) x5.horizontal[a6] = x5.horizontal[0];
                  else {
                    const t6 = Tm(b4, e4, r4, i4, l5, w6, u6, "center", a6, c5, _4, Pm.horizontal, false, g5, p5);
                    t6 && (x5.horizontal[a6] = t6, n5 = 1 === t6.positionedLines.length);
                  }
                }
                M4("left");
              } else {
                if ("auto" === y5 && (y5 = _y(f5)), v5 || h4.get("text-writing-mode").indexOf("horizontal") >= 0 || !vo(n4)) {
                  const t5 = Tm(b4, e4, r4, i4, l5, w6, u6, f5, y5, c5, _4, Pm.horizontal, false, g5, p5);
                  t5 && (x5.horizontal[y5] = t5);
                }
                M4(v5 ? "left" : y5);
              }
            }
            let w5 = false;
            if (s5.icon && s5.icon.namePrimary) {
              const e5 = n3[s5.icon.namePrimary];
              e5 && (v4 = Nm(i4[s5.icon.namePrimary], s5.icon.nameSecondary ? i4[s5.icon.nameSecondary] : void 0, h4.get("icon-offset").evaluate(s5, {}, o3), h4.get("icon-anchor").evaluate(s5, {}, o3)), w5 = e5.sdf, void 0 === t4.sdfIcons ? t4.sdfIcons = e5.sdf : t4.sdfIcons !== e5.sdf && hr("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e5.pixelRatio !== t4.pixelRatio || 0 !== h4.get("icon-rotate").constantOr(1)) && (t4.iconsNeedLinear = true));
            }
            const M3 = Iy(x5.horizontal) || x5.vertical;
            t4.iconsInText || (t4.iconsInText = !!M3 && M3.iconsInText), (M3 || v4) && wy(t4, s5, x5, v4, n3, f4, g5, 0, _4, w5, a4, o3, u5, c4, y4);
          }
          s4 && t4.generateCollisionDebugBuffers(l4, t4.collisionBoxArray);
        }, t3.dQ = pf, t3.dR = wm, t3.dS = Cf, t3.dT = ff, t3.dU = Jp, t3.dV = Fe, t3.dW = em, t3.dX = h3, t3.dY = function(t4) {
          let e4 = 0;
          if (new Uint32Array(t4, 0, 1)[0] !== Ox) {
            const r4 = new Uint32Array(t4, 0, 7), [, , n3, i4, s4, a4] = r4;
            e4 = r4.byteLength + i4 + s4 + a4 + s4, (n3 !== t4.byteLength || e4 >= t4.byteLength) && hr("Invalid b3dm header information.");
          }
          return Gx(t4, e4);
        }, t3.dZ = function(t4, e4) {
          const r4 = eb(t4);
          for (const t5 of r4) {
            for (const e5 of t5.meshes) rb(e5);
            t5.lights && (t5.lightMeshIndex = t5.meshes.length, t5.meshes.push(nb(t5.lights, e4)));
          }
          return r4;
        }, t3.d_ = yb, t3.da = nc, t3.db = function([t4, e4, r4]) {
          const n3 = Math.hypot(t4, e4, r4), i4 = Math.atan2(t4, r4), s4 = 0.5 * Math.PI - Math.acos(-e4 / n3);
          return new ac($e(i4), $e(s4));
        }, t3.dc = ic, t3.dd = n2, t3.de = Nh, t3.df = Uh, t3.dg = function(e4) {
          const r4 = [0, 0, 0], n3 = t3.a9.identity(new Float64Array(16));
          return t3.a9.multiply(n3, e4.pixelMatrix, e4.globeMatrix), t3.Q.transformMat4(r4, r4, n3), new Ue(r4[0], r4[1]);
        }, t3.dh = function(t4) {
          const e4 = t4.navigator ? t4.navigator.userAgent : null;
          return !!function(t5) {
            if (null == Mr) {
              const e5 = t5.navigator ? t5.navigator.userAgent : null;
              Mr = !!t5.safari || !(!e5 || !(/\b(iPad|iPhone|iPod)\b/.test(e5) || e5.match("Safari") && !e5.match("Chrome")));
            }
            return Mr;
          }(t4) && e4 && (e4.match("Version/15.4") || e4.match("Version/15.5") || e4.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t3.di = class {
          constructor(t4, e4, r4) {
            this._transformRequestFn = t4, this._customAccessToken = e4, this._silenceAuthErrors = !!r4, this._createSkuToken();
          }
          _createSkuToken() {
            const t4 = function() {
              let t5 = "";
              for (let e4 = 0; e4 < 10; e4++) t5 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
              return { token: ["1", an, t5].join(""), tokenExpiresAt: Date.now() + 432e5 };
            }();
            this._skuToken = t4.token, this._skuTokenExpiresAt = t4.tokenExpiresAt;
          }
          _isSkuTokenExpired() {
            return Date.now() > this._skuTokenExpiresAt;
          }
          transformRequest(t4, e4) {
            return this._transformRequestFn && this._transformRequestFn(t4, e4) || { url: t4 };
          }
          normalizeStyleURL(t4, r4) {
            if (!s3(t4)) return t4;
            const n3 = un(t4);
            return n3.params.push(`sdk=js-${e3}`), n3.path = `/styles/v1${n3.path}`, this._makeAPIURL(n3, this._customAccessToken || r4);
          }
          normalizeGlyphsURL(t4, e4) {
            if (!s3(t4)) return t4;
            const r4 = un(t4);
            return r4.path = `/fonts/v1${r4.path}`, this._makeAPIURL(r4, this._customAccessToken || e4);
          }
          normalizeModelURL(t4, e4) {
            if (!s3(t4)) return t4;
            const r4 = un(t4);
            return r4.path = `/models/v1${r4.path}`, this._makeAPIURL(r4, this._customAccessToken || e4);
          }
          normalizeSourceURL(t4, e4, r4, n3) {
            if (!s3(t4)) return t4;
            const i4 = un(t4);
            return i4.path = `/v4/${i4.authority}.json`, i4.params.push("secure"), r4 && i4.params.push(`language=${r4}`), n3 && i4.params.push(`worldview=${n3}`), this._makeAPIURL(i4, this._customAccessToken || e4);
          }
          normalizeSpriteURL(t4, e4, r4, n3) {
            const i4 = un(t4);
            return s3(t4) ? (i4.path = `/styles/v1${i4.path}/sprite${e4}${r4}`, this._makeAPIURL(i4, this._customAccessToken || n3)) : (i4.path += `${e4}${r4}`, cn(i4));
          }
          normalizeTileURL(t4, e4, r4) {
            if (this._isSkuTokenExpired() && this._createSkuToken(), t4 && !s3(t4)) return t4;
            const i4 = un(t4);
            i4.path = i4.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e4 || r4 && "raster" !== i4.authority && 512 === r4 ? "@2x" : ""}${jr.supported ? ".webp" : "$1"}`), "raster" === i4.authority ? i4.path = `/${n2.RASTER_URL_PREFIX}${i4.path}` : "rasterarrays" === i4.authority ? i4.path = `/${n2.RASTERARRAYS_URL_PREFIX}${i4.path}` : (i4.path = i4.path.replace(/^.+\/v4\//, "/"), i4.path = `/${n2.TILE_URL_VERSION}${i4.path}`);
            const a4 = this._customAccessToken || function(t5) {
              for (const e5 of t5) {
                const t6 = e5.match(/^access_token=(.*)$/);
                if (t6) return t6[1];
              }
              return null;
            }(i4.params) || n2.ACCESS_TOKEN;
            return n2.REQUIRE_ACCESS_TOKEN && a4 && this._skuToken && i4.params.push(`sku=${this._skuToken}`), this._makeAPIURL(i4, a4);
          }
          canonicalizeTileURL(t4, e4) {
            const r4 = un(t4);
            if (!r4.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !r4.path.match(/\.[\w]+$/)) return t4;
            let i4 = "mapbox://";
            r4.path.match(/^\/raster\/v1\//) ? i4 += `raster/${r4.path.replace(`/${n2.RASTER_URL_PREFIX}/`, "")}` : r4.path.match(/^\/rasterarrays\/v1\//) ? i4 += `rasterarrays/${r4.path.replace(`/${n2.RASTERARRAYS_URL_PREFIX}/`, "")}` : i4 += `tiles/${r4.path.replace(`/${n2.TILE_URL_VERSION}/`, "")}`;
            let s4 = r4.params;
            return e4 && (s4 = s4.filter((t5) => !t5.match(/^access_token=/))), s4.length && (i4 += `?${s4.join("&")}`), i4;
          }
          canonicalizeTileset(t4, e4) {
            const r4 = !!e4 && s3(e4), n3 = [];
            for (const e5 of t4.tiles || []) i3(e5) ? n3.push(this.canonicalizeTileURL(e5, r4)) : n3.push(e5);
            return n3;
          }
          _makeAPIURL(t4, e4) {
            const r4 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", i4 = un(n2.API_URL);
            if (t4.protocol = i4.protocol, t4.authority = i4.authority, "http" === t4.protocol) {
              const e5 = t4.params.indexOf("secure");
              e5 >= 0 && t4.params.splice(e5, 1);
            }
            if ("/" !== i4.path && (t4.path = `${i4.path}${t4.path}`), !n2.REQUIRE_ACCESS_TOKEN) return cn(t4);
            if (e4 = e4 || n2.ACCESS_TOKEN, !this._silenceAuthErrors) {
              if (!e4) throw new Error(`An API access token is required to use Mapbox GL. ${r4}`);
              if ("s" === e4[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r4}`);
            }
            return t4.params = t4.params.filter((t5) => -1 === t5.indexOf("access_token")), t4.params.push(`access_token=${e4 || ""}`), cn(t4);
          }
        }, t3.dj = function(t4, e4) {
          e4 ? An.add(t4) : An.delete(t4);
        }, t3.dk = jr, t3.dl = _n, t3.dm = Mn, t3.dn = on, t3.dp = gn, t3.dq = bn, t3.dr = function(t4) {
          An.delete(t4);
        }, t3.ds = wn, t3.dt = yn, t3.du = e3, t3.dv = function(t4, e4) {
          Vr = t4, Dr = e4;
        }, t3.dw = function(t4, e4, r4 = false) {
          if (Bo === Po || Bo === Eo || Bo === zo) throw new Error("setRTLTextPlugin cannot be called multiple times.");
          Co = Tr.resolveURL(t4), Bo = Po, To = e4, Vo(), r4 || Fo();
        }, t3.dx = Lo, t3.dy = function() {
          wx().acquire(bx);
        }, t3.dz = function() {
          const t4 = _x;
          t4 && (t4.isPreloaded() && 1 === t4.numActive() ? (t4.release(bx), _x = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, t3.e = Je, t3.e0 = Oo, t3.e1 = function(t4) {
          Ur(), Lr && Lr.then((e4) => {
            e4.keys().then((r4) => {
              for (let n3 = 0; n3 < r4.length - t4; n3++) e4.delete(r4[n3]);
            });
          });
        }, t3.f = Tr, t3.g = function(t4, e4) {
          return Hr(Je(t4, { type: "json" }), e4);
        }, t3.h = np, t3.i = class extends Hg {
        }, t3.j = Si, t3.k = Qn, t3.l = function(t4) {
          return fetch(t4).then((t5) => t5.arrayBuffer()).then((e4) => Gx(e4, 0, t4));
        }, t3.m = ja, t3.n = $a, t3.o = eo, t3.p = Hm, t3.q = tl, t3.r = so, t3.s = Ga, t3.t = ro, t3.u = Jo, t3.v = Os, t3.w = hr, t3.x = Ns, t3.y = Fs;
      });
      define2(["./shared"], function(e3) {
        "use strict";
        function t3(e4) {
          const t4 = e4 ? e4.url.toString() : void 0;
          return t4 ? performance.getEntriesByName(t4) : [];
        }
        function s3(e4) {
          if ("number" == typeof e4 || "boolean" == typeof e4 || "string" == typeof e4 || null == e4) return JSON.stringify(e4);
          if (Array.isArray(e4)) {
            let t5 = "[";
            for (const i4 of e4) t5 += `${s3(i4)},`;
            return `${t5}]`;
          }
          let t4 = "{";
          for (const i4 of Object.keys(e4).sort()) t4 += `${i4}:${s3(e4[i4])},`;
          return `${t4}}`;
        }
        function i3(t4) {
          let i4 = "";
          for (const o3 of e3.b5) i4 += `/${s3(t4[o3])}`;
          return i4;
        }
        class o2 {
          constructor(e4) {
            this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e4 && this.replace(e4);
          }
          replace(e4, t4) {
            this._layerConfigs = {}, this._layers = {}, this.update(e4, [], t4);
          }
          update(t4, s4, o3) {
            this._options = o3;
            for (const s5 of t4) this._layerConfigs[s5.id] = s5, (this._layers[s5.id] = e3.c7(s5, this.scope, this._options)).compileFilter(), this.keyCache[s5.id] && delete this.keyCache[s5.id];
            for (const e4 of s4) delete this.keyCache[e4], delete this._layerConfigs[e4], delete this._layers[e4];
            this.familiesBySource = {};
            const r4 = function(e4, t5) {
              const s5 = {};
              for (let o5 = 0; o5 < e4.length; o5++) {
                const r5 = t5 && t5[e4[o5].id] || i3(e4[o5]);
                t5 && (t5[e4[o5].id] = r5);
                let n3 = s5[r5];
                n3 || (n3 = s5[r5] = []), n3.push(e4[o5]);
              }
              const o4 = [];
              for (const e5 in s5) o4.push(s5[e5]);
              return o4;
            }(e3.b2(this._layerConfigs), this.keyCache);
            for (const e4 of r4) {
              const t5 = e4.map((e5) => this._layers[e5.id]), s5 = t5[0];
              if ("none" === s5.visibility) continue;
              const i4 = s5.source || "";
              let o4 = this.familiesBySource[i4];
              o4 || (o4 = this.familiesBySource[i4] = {});
              const r5 = s5.sourceLayer || "_geojsonTileLayer";
              let n3 = o4[r5];
              n3 || (n3 = o4[r5] = []), n3.push(t5);
            }
          }
        }
        const r3 = 1 * e3.dJ;
        class n2 {
          constructor(t4) {
            const s4 = {}, i4 = [];
            for (const e4 in t4) {
              const o4 = t4[e4], n4 = s4[e4] = {};
              for (const e5 in o4.glyphs) {
                const t5 = o4.glyphs[+e5];
                if (!t5 || 0 === t5.bitmap.width || 0 === t5.bitmap.height) continue;
                const s5 = t5.metrics.localGlyph ? r3 : 1, a5 = { x: 0, y: 0, w: t5.bitmap.width + 2 * s5, h: t5.bitmap.height + 2 * s5 };
                i4.push(a5), n4[e5] = a5;
              }
            }
            const { w: o3, h: n3 } = e3.p(i4), a4 = new e3.dI({ width: o3 || 1, height: n3 || 1 });
            for (const i5 in t4) {
              const o4 = t4[i5];
              for (const t5 in o4.glyphs) {
                const n4 = o4.glyphs[+t5];
                if (!n4 || 0 === n4.bitmap.width || 0 === n4.bitmap.height) continue;
                const l4 = s4[i5][t5], h4 = n4.metrics.localGlyph ? r3 : 1;
                e3.dI.copy(n4.bitmap, a4, { x: 0, y: 0 }, { x: l4.x + h4, y: l4.y + h4 }, n4.bitmap);
              }
            }
            this.image = a4, this.positions = s4;
          }
        }
        e3.dH(n2, "GlyphAtlas");
        class a3 {
          constructor(t4) {
            this.tileID = new e3.ap(t4.tileID.overscaledZ, t4.tileID.wrap, t4.tileID.canonical.z, t4.tileID.canonical.x, t4.tileID.canonical.y), this.tileZoom = t4.tileZoom, this.uid = t4.uid, this.zoom = t4.zoom, this.canonical = t4.tileID.canonical, this.pixelRatio = t4.pixelRatio, this.tileSize = t4.tileSize, this.source = t4.source, this.scope = t4.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t4.showCollisionBoxes, this.collectResourceTiming = !!t4.collectResourceTiming, this.promoteId = t4.promoteId, this.isSymbolTile = t4.isSymbolTile, this.tileTransform = e3.av(t4.tileID.canonical, t4.projection), this.projection = t4.projection, this.brightness = t4.brightness, this.extraShadowCaster = !!t4.extraShadowCaster;
          }
          parse(t4, s4, i4, o3, r4) {
            this.status = "parsing", this.data = t4, this.collisionBoxArray = new e3.aG();
            const a4 = new e3.dK(Object.keys(t4.layers).sort()), h4 = new e3.dL(this.tileID, this.promoteId);
            h4.bucketLayerIDs = [];
            const c4 = {}, u5 = new e3.dM(256, 256), d3 = { featureIndex: h4, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: u5, availableImages: i4, brightness: this.brightness }, p4 = s4.familiesBySource[this.source];
            for (const s5 in p4) {
              const o4 = t4.layers[s5];
              if (!o4) continue;
              let r5 = false, n3 = false, u6 = false;
              for (const e4 of p4[s5]) "symbol" === e4[0].type ? r5 = true : n3 = true, e4[0].is3D() && "model" !== e4[0].type && (u6 = true);
              if (this.extraShadowCaster && !u6) continue;
              if (true === this.isSymbolTile && !r5) continue;
              if (false === this.isSymbolTile && !n3) continue;
              1 === o4.version && e3.w(`Vector tile source "${this.source}" layer "${s5}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const f5 = a4.encode(s5), g6 = [];
              for (let e4 = 0; e4 < o4.length; e4++) {
                const t5 = o4.feature(e4), i5 = h4.getId(t5, s5);
                g6.push({ feature: t5, id: i5, index: e4, sourceLayerIndex: f5 });
              }
              for (const e4 of p4[s5]) {
                const t5 = e4[0];
                (!this.extraShadowCaster || t5.is3D() && "model" !== t5.type) && (void 0 !== this.isSymbolTile && "symbol" === t5.type !== this.isSymbolTile || t5.minzoom && this.zoom < Math.floor(t5.minzoom) || t5.maxzoom && this.zoom >= t5.maxzoom || "none" !== t5.visibility && (l3(e4, this.zoom, d3.brightness, i4), (c4[t5.id] = t5.createBucket({ index: h4.bucketLayerIDs.length, layers: e4, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: f5, sourceID: this.source, projection: this.projection.spec })).populate(g6, d3, this.tileID.canonical, this.tileTransform), h4.bucketLayerIDs.push(e4.map((e5) => e5.id))));
              }
            }
            let f4, g5, m4, y4;
            u5.trim();
            const v4 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, x5 = () => {
              if (f4) return this.status = "done", r4(f4);
              if (this.extraShadowCaster) this.status = "done", r4(null, { buckets: e3.b2(c4).filter((e4) => !e4.isEmpty()), featureIndex: h4, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: d3.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
              else if (g5 && m4 && y4) {
                const t5 = new n2(g5), s5 = new e3.dO(m4, y4);
                for (const o4 in c4) {
                  const r5 = c4[o4];
                  r5 instanceof e3.aH ? (l3(r5.layers, this.zoom, d3.brightness, i4), e3.dP(r5, g5, t5.positions, m4, s5.iconPositions, this.showCollisionBoxes, i4, this.tileID.canonical, this.tileZoom, this.projection, this.brightness)) : r5.hasPattern && (r5 instanceof e3.aN || r5 instanceof e3.aO || r5 instanceof e3.cO) && (l3(r5.layers, this.zoom, d3.brightness, i4), r5.addFeatures(d3, this.tileID.canonical, s5.patternPositions, i4, this.tileTransform, this.brightness));
                }
                this.status = "done", r4(null, { buckets: e3.b2(c4).filter((e4) => !e4.isEmpty()), featureIndex: h4, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t5.image, lineAtlas: u5, imageAtlas: s5, brightness: d3.brightness });
              }
            };
            if (!this.extraShadowCaster) {
              const t5 = e3.dN(d3.glyphDependencies, (e4) => Object.keys(e4).map(Number));
              Object.keys(t5).length ? o3.send("getGlyphs", { uid: this.uid, stacks: t5, scope: this.scope }, (e4, t6) => {
                f4 || (f4 = e4, g5 = t6, x5());
              }, void 0, false, v4) : g5 = {};
              const s5 = Object.keys(d3.iconDependencies);
              s5.length ? o3.send("getImages", { icons: s5, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (e4, t6) => {
                f4 || (f4 = e4, m4 = t6, x5());
              }, void 0, false, v4) : m4 = {};
              const i5 = Object.keys(d3.patternDependencies);
              i5.length ? o3.send("getImages", { icons: i5, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (e4, t6) => {
                f4 || (f4 = e4, y4 = t6, x5());
              }, void 0, false, v4) : y4 = {};
            }
            x5();
          }
        }
        function l3(t4, s4, i4, o3) {
          const r4 = new e3.N(s4, { brightness: i4 });
          for (const e4 of t4) e4.recalculate(r4, o3);
        }
        class h3 extends e3.E {
          constructor(t4, s4, i4, o3, r4, n3) {
            super(), this.actor = t4, this.layerIndex = s4, this.availableImages = i4, this.loadVectorData = r4 || e3.ak, this.loading = {}, this.loaded = {}, this.deduped = new e3.ai(t4.scheduler), this.isSpriteLoaded = o3, this.scheduler = t4.scheduler, this.brightness = n3;
          }
          loadTile(s4, i4) {
            const o3 = s4.uid, r4 = s4 && s4.request, n3 = r4 && r4.collectResourceTiming, l4 = this.loading[o3] = new a3(s4);
            l4.abort = this.loadVectorData(s4, (a4, h4) => {
              const c4 = !this.loading[o3];
              if (delete this.loading[o3], c4 || a4 || !h4) return l4.status = "done", c4 || (this.loaded[o3] = l4), i4(a4);
              const u5 = h4.rawData, d3 = {};
              h4.expires && (d3.expires = h4.expires), h4.cacheControl && (d3.cacheControl = h4.cacheControl), l4.vectorTile = h4.vectorTile || new e3.dQ(new e3.dR(u5));
              const p4 = () => {
                l4.parse(l4.vectorTile, this.layerIndex, this.availableImages, this.actor, (s5, o4) => {
                  if (s5 || !o4) return i4(s5);
                  const a5 = {};
                  if (n3) {
                    const e4 = t3(r4);
                    e4.length > 0 && (a5.resourceTiming = JSON.parse(JSON.stringify(e4)));
                  }
                  i4(null, e3.e({ rawTileData: u5.slice(0) }, o4, d3, a5));
                });
              };
              this.isSpriteLoaded ? p4() : this.once("isSpriteLoaded", () => {
                this.scheduler ? this.scheduler.add(p4, { type: "parseTile", isSymbolTile: s4.isSymbolTile, zoom: s4.tileZoom }) : p4();
              }), this.loaded = this.loaded || {}, this.loaded[o3] = l4;
            });
          }
          reloadTile(t4, s4) {
            const i4 = this.loaded, o3 = t4.uid, r4 = this;
            if (i4 && i4[o3]) {
              const n3 = i4[o3];
              n3.showCollisionBoxes = t4.showCollisionBoxes, n3.projection = t4.projection, n3.brightness = t4.brightness, n3.tileTransform = e3.av(t4.tileID.canonical, t4.projection), n3.extraShadowCaster = t4.extraShadowCaster;
              const a4 = (e4, t5) => {
                const i5 = n3.reloadCallback;
                i5 && (delete n3.reloadCallback, n3.parse(n3.vectorTile, r4.layerIndex, this.availableImages, r4.actor, i5)), s4(e4, t5);
              };
              "parsing" === n3.status ? n3.reloadCallback = a4 : "done" === n3.status && (n3.vectorTile ? n3.parse(n3.vectorTile, this.layerIndex, this.availableImages, this.actor, a4) : a4());
            } else s4(null, void 0);
          }
          abortTile(e4, t4) {
            const s4 = e4.uid, i4 = this.loading[s4];
            i4 && (i4.abort && i4.abort(), delete this.loading[s4]), t4();
          }
          removeTile(e4, t4) {
            const s4 = this.loaded, i4 = e4.uid;
            s4 && s4[i4] && delete s4[i4], t4();
          }
        }
        class c3 {
          loadTile(t4, s4) {
            const { uid: i4, encoding: o3, rawImageData: r4, padding: n3 } = t4, a4 = ImageBitmap && r4 instanceof ImageBitmap ? this.getImageData(r4, n3) : r4;
            s4(null, new e3.dS(i4, a4, o3, n3 < 1));
          }
          getImageData(e4, t4) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e4.width, e4.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e4.width, this.offscreenCanvas.height = e4.height, this.offscreenCanvasContext.drawImage(e4, 0, 0, e4.width, e4.height);
            const s4 = this.offscreenCanvasContext.getImageData(-t4, -t4, e4.width + 2 * t4, e4.height + 2 * t4);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s4;
          }
        }
        class u4 {
          decodeRasterArray({ task: t4, buffer: s4 }, i4) {
            e3.b0.performDecoding(s4, t4).then((e4) => {
              i4(null, e4);
            }, (e4) => {
              i4(e4);
            });
          }
        }
        const d2 = e3.dT.prototype.toGeoJSON;
        let p3 = class {
          constructor(t4) {
            this._feature = t4, this.extent = e3.Y, this.type = t4.type, this.properties = t4.tags, "id" in t4 && !isNaN(t4.id) && (this.id = parseInt(t4.id, 10));
          }
          loadGeometry() {
            if (1 === this._feature.type) {
              const t4 = [];
              for (const s4 of this._feature.geometry) t4.push([new e3.P(s4[0], s4[1])]);
              return t4;
            }
            {
              const t4 = [];
              for (const s4 of this._feature.geometry) {
                const i4 = [];
                for (const t5 of s4) i4.push(new e3.P(t5[0], t5[1]));
                t4.push(i4);
              }
              return t4;
            }
          }
          toGeoJSON(e4, t4, s4) {
            return d2.call(this, e4, t4, s4);
          }
        }, f3 = class {
          constructor(t4) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e3.Y, this.length = t4.length, this._features = t4;
          }
          feature(e4) {
            return new p3(this._features[e4]);
          }
        };
        var g4 = { exports: {} }, m3 = e3.dV, y3 = e3.dU.VectorTileFeature, v3 = x4;
        function x4(e4, t4) {
          this.options = t4 || {}, this.features = e4, this.length = e4.length;
        }
        function w4(e4, t4) {
          this.id = "number" == typeof e4.id ? e4.id : void 0, this.type = e4.type, this.rawGeometry = 1 === e4.type ? [e4.geometry] : e4.geometry, this.properties = e4.tags, this.extent = t4 || 4096;
        }
        x4.prototype.feature = function(e4) {
          return new w4(this.features[e4], this.options.extent);
        }, w4.prototype.loadGeometry = function() {
          var e4 = this.rawGeometry;
          this.geometry = [];
          for (var t4 = 0; t4 < e4.length; t4++) {
            for (var s4 = e4[t4], i4 = [], o3 = 0; o3 < s4.length; o3++) i4.push(new m3(s4[o3][0], s4[o3][1]));
            this.geometry.push(i4);
          }
          return this.geometry;
        }, w4.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e4 = this.geometry, t4 = 1 / 0, s4 = -1 / 0, i4 = 1 / 0, o3 = -1 / 0, r4 = 0; r4 < e4.length; r4++) for (var n3 = e4[r4], a4 = 0; a4 < n3.length; a4++) {
            var l4 = n3[a4];
            t4 = Math.min(t4, l4.x), s4 = Math.max(s4, l4.x), i4 = Math.min(i4, l4.y), o3 = Math.max(o3, l4.y);
          }
          return [t4, i4, s4, o3];
        }, w4.prototype.toGeoJSON = y3.prototype.toGeoJSON;
        var S2 = e3.dW, b3 = v3;
        function I3(e4) {
          var t4 = new S2();
          return function(e5, t5) {
            for (var s4 in e5.layers) t5.writeMessage(3, M2, e5.layers[s4]);
          }(e4, t4), t4.finish();
        }
        function M2(e4, t4) {
          var s4;
          t4.writeVarintField(15, e4.version || 1), t4.writeStringField(1, e4.name || ""), t4.writeVarintField(5, e4.extent || 4096);
          var i4 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (s4 = 0; s4 < e4.length; s4++) i4.feature = e4.feature(s4), t4.writeMessage(2, k3, i4);
          var o3 = i4.keys;
          for (s4 = 0; s4 < o3.length; s4++) t4.writeStringField(3, o3[s4]);
          var r4 = i4.values;
          for (s4 = 0; s4 < r4.length; s4++) t4.writeMessage(4, L3, r4[s4]);
        }
        function k3(e4, t4) {
          var s4 = e4.feature;
          void 0 !== s4.id && t4.writeVarintField(1, s4.id), t4.writeMessage(2, T4, e4), t4.writeVarintField(3, s4.type), t4.writeMessage(4, C3, s4);
        }
        function T4(e4, t4) {
          var s4 = e4.feature, i4 = e4.keys, o3 = e4.values, r4 = e4.keycache, n3 = e4.valuecache;
          for (var a4 in s4.properties) {
            var l4 = s4.properties[a4], h4 = r4[a4];
            if (null !== l4) {
              void 0 === h4 && (i4.push(a4), r4[a4] = h4 = i4.length - 1), t4.writeVarint(h4);
              var c4 = typeof l4;
              "string" !== c4 && "boolean" !== c4 && "number" !== c4 && (l4 = JSON.stringify(l4));
              var u5 = c4 + ":" + l4, d3 = n3[u5];
              void 0 === d3 && (o3.push(l4), n3[u5] = d3 = o3.length - 1), t4.writeVarint(d3);
            }
          }
        }
        function P3(e4, t4) {
          return (t4 << 3) + (7 & e4);
        }
        function _3(e4) {
          return e4 << 1 ^ e4 >> 31;
        }
        function C3(e4, t4) {
          for (var s4 = e4.loadGeometry(), i4 = e4.type, o3 = 0, r4 = 0, n3 = s4.length, a4 = 0; a4 < n3; a4++) {
            var l4 = s4[a4], h4 = 1;
            1 === i4 && (h4 = l4.length), t4.writeVarint(P3(1, h4));
            for (var c4 = 3 === i4 ? l4.length - 1 : l4.length, u5 = 0; u5 < c4; u5++) {
              1 === u5 && 1 !== i4 && t4.writeVarint(P3(2, c4 - 1));
              var d3 = l4[u5].x - o3, p4 = l4[u5].y - r4;
              t4.writeVarint(_3(d3)), t4.writeVarint(_3(p4)), o3 += d3, r4 += p4;
            }
            3 === i4 && t4.writeVarint(P3(7, 1));
          }
        }
        function L3(e4, t4) {
          var s4 = typeof e4;
          "string" === s4 ? t4.writeStringField(1, e4) : "boolean" === s4 ? t4.writeBooleanField(7, e4) : "number" === s4 && (e4 % 1 != 0 ? t4.writeDoubleField(3, e4) : e4 < 0 ? t4.writeSVarintField(6, e4) : t4.writeVarintField(5, e4));
        }
        g4.exports = I3, g4.exports.fromVectorTileJs = I3, g4.exports.fromGeojsonVt = function(e4, t4) {
          t4 = t4 || {};
          var s4 = {};
          for (var i4 in e4) s4[i4] = new b3(e4[i4].features, t4), s4[i4].name = i4, s4[i4].version = t4.version, s4[i4].extent = t4.extent;
          return I3({ layers: s4 });
        }, g4.exports.GeoJSONWrapper = b3;
        var D3 = e3.dX(g4.exports);
        const j4 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e4) => e4 }, O2 = Math.fround || (z3 = new Float32Array(1), (e4) => (z3[0] = +e4, z3[0]));
        var z3;
        const Z2 = 3, A3 = 5, N3 = 6;
        class E2 {
          constructor(e4) {
            this.options = Object.assign(Object.create(j4), e4), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e4) {
            const { log: t4, minZoom: s4, maxZoom: i4 } = this.options;
            t4 && console.time("total time");
            const o3 = `prepare ${e4.length} points`;
            t4 && console.time(o3), this.points = e4;
            const r4 = [];
            for (let t5 = 0; t5 < e4.length; t5++) {
              const s5 = e4[t5];
              if (!s5.geometry) continue;
              const [i5, o4] = s5.geometry.coordinates, n4 = O2(B3(i5)), a4 = O2(J2(o4));
              r4.push(n4, a4, 1 / 0, t5, -1, 1), this.options.reduce && r4.push(0);
            }
            let n3 = this.trees[i4 + 1] = this._createTree(r4);
            t4 && console.timeEnd(o3);
            for (let e5 = i4; e5 >= s4; e5--) {
              const s5 = +Date.now();
              n3 = this.trees[e5] = this._createTree(this._cluster(n3, e5)), t4 && console.log("z%d: %d clusters in %dms", e5, n3.numItems, +Date.now() - s5);
            }
            return t4 && console.timeEnd("total time"), this;
          }
          getClusters(e4, t4) {
            let s4 = ((e4[0] + 180) % 360 + 360) % 360 - 180;
            const i4 = Math.max(-90, Math.min(90, e4[1]));
            let o3 = 180 === e4[2] ? 180 : ((e4[2] + 180) % 360 + 360) % 360 - 180;
            const r4 = Math.max(-90, Math.min(90, e4[3]));
            if (e4[2] - e4[0] >= 360) s4 = -180, o3 = 180;
            else if (s4 > o3) {
              const e5 = this.getClusters([s4, i4, 180, r4], t4), n4 = this.getClusters([-180, i4, o3, r4], t4);
              return e5.concat(n4);
            }
            const n3 = this.trees[this._limitZoom(t4)], a4 = n3.range(B3(s4), J2(r4), B3(o3), J2(i4)), l4 = n3.data, h4 = [];
            for (const e5 of a4) {
              const t5 = this.stride * e5;
              h4.push(l4[t5 + A3] > 1 ? F4(l4, t5, this.clusterProps) : this.points[l4[t5 + Z2]]);
            }
            return h4;
          }
          getChildren(e4) {
            const t4 = this._getOriginId(e4), s4 = this._getOriginZoom(e4), i4 = "No cluster with the specified id.", o3 = this.trees[s4];
            if (!o3) throw new Error(i4);
            const r4 = o3.data;
            if (t4 * this.stride >= r4.length) throw new Error(i4);
            const n3 = this.options.radius / (this.options.extent * Math.pow(2, s4 - 1)), a4 = o3.within(r4[t4 * this.stride], r4[t4 * this.stride + 1], n3), l4 = [];
            for (const t5 of a4) {
              const s5 = t5 * this.stride;
              r4[s5 + 4] === e4 && l4.push(r4[s5 + A3] > 1 ? F4(r4, s5, this.clusterProps) : this.points[r4[s5 + Z2]]);
            }
            if (0 === l4.length) throw new Error(i4);
            return l4;
          }
          getLeaves(e4, t4, s4) {
            const i4 = [];
            return this._appendLeaves(i4, e4, t4 = t4 || 10, s4 = s4 || 0, 0), i4;
          }
          getTile(e4, t4, s4) {
            const i4 = this.trees[this._limitZoom(e4)], o3 = Math.pow(2, e4), { extent: r4, radius: n3 } = this.options, a4 = n3 / r4, l4 = (s4 - a4) / o3, h4 = (s4 + 1 + a4) / o3, c4 = { features: [] };
            return this._addTileFeatures(i4.range((t4 - a4) / o3, l4, (t4 + 1 + a4) / o3, h4), i4.data, t4, s4, o3, c4), 0 === t4 && this._addTileFeatures(i4.range(1 - a4 / o3, l4, 1, h4), i4.data, o3, s4, o3, c4), t4 === o3 - 1 && this._addTileFeatures(i4.range(0, l4, a4 / o3, h4), i4.data, -1, s4, o3, c4), c4.features.length ? c4 : null;
          }
          getClusterExpansionZoom(e4) {
            let t4 = this._getOriginZoom(e4) - 1;
            for (; t4 <= this.options.maxZoom; ) {
              const s4 = this.getChildren(e4);
              if (t4++, 1 !== s4.length) break;
              e4 = s4[0].properties.cluster_id;
            }
            return t4;
          }
          _appendLeaves(e4, t4, s4, i4, o3) {
            const r4 = this.getChildren(t4);
            for (const t5 of r4) {
              const r5 = t5.properties;
              if (r5 && r5.cluster ? o3 + r5.point_count <= i4 ? o3 += r5.point_count : o3 = this._appendLeaves(e4, r5.cluster_id, s4, i4, o3) : o3 < i4 ? o3++ : e4.push(t5), e4.length === s4) break;
            }
            return o3;
          }
          _createTree(t4) {
            const s4 = new e3.bj(t4.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e4 = 0; e4 < t4.length; e4 += this.stride) s4.add(t4[e4], t4[e4 + 1]);
            return s4.finish(), s4.data = t4, s4;
          }
          _addTileFeatures(e4, t4, s4, i4, o3, r4) {
            for (const n3 of e4) {
              const e5 = n3 * this.stride, a4 = t4[e5 + A3] > 1;
              let l4, h4, c4;
              if (a4) l4 = W2(t4, e5, this.clusterProps), h4 = t4[e5], c4 = t4[e5 + 1];
              else {
                const s5 = this.points[t4[e5 + Z2]];
                l4 = s5.properties;
                const [i5, o4] = s5.geometry.coordinates;
                h4 = B3(i5), c4 = J2(o4);
              }
              const u5 = { type: 1, geometry: [[Math.round(this.options.extent * (h4 * o3 - s4)), Math.round(this.options.extent * (c4 * o3 - i4))]], tags: l4 };
              let d3;
              d3 = a4 || this.options.generateId ? t4[e5 + Z2] : this.points[t4[e5 + Z2]].id, void 0 !== d3 && (u5.id = d3), r4.features.push(u5);
            }
          }
          _limitZoom(e4) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e4), this.options.maxZoom + 1));
          }
          _cluster(e4, t4) {
            const { radius: s4, extent: i4, reduce: o3, minPoints: r4 } = this.options, n3 = s4 / (i4 * Math.pow(2, t4)), a4 = e4.data, l4 = [], h4 = this.stride;
            for (let s5 = 0; s5 < a4.length; s5 += h4) {
              if (a4[s5 + 2] <= t4) continue;
              a4[s5 + 2] = t4;
              const i5 = a4[s5], c4 = a4[s5 + 1], u5 = e4.within(a4[s5], a4[s5 + 1], n3), d3 = a4[s5 + A3];
              let p4 = d3;
              for (const e5 of u5) {
                const s6 = e5 * h4;
                a4[s6 + 2] > t4 && (p4 += a4[s6 + A3]);
              }
              if (p4 > d3 && p4 >= r4) {
                let e5, r5 = i5 * d3, n4 = c4 * d3, f4 = -1;
                const g5 = (s5 / h4 << 5) + (t4 + 1) + this.points.length;
                for (const i6 of u5) {
                  const l5 = i6 * h4;
                  if (a4[l5 + 2] <= t4) continue;
                  a4[l5 + 2] = t4;
                  const c5 = a4[l5 + A3];
                  r5 += a4[l5] * c5, n4 += a4[l5 + 1] * c5, a4[l5 + 4] = g5, o3 && (e5 || (e5 = this._map(a4, s5, true), f4 = this.clusterProps.length, this.clusterProps.push(e5)), o3(e5, this._map(a4, l5)));
                }
                a4[s5 + 4] = g5, l4.push(r5 / p4, n4 / p4, 1 / 0, g5, -1, p4), o3 && l4.push(f4);
              } else {
                for (let e5 = 0; e5 < h4; e5++) l4.push(a4[s5 + e5]);
                if (p4 > 1) for (const e5 of u5) {
                  const s6 = e5 * h4;
                  if (!(a4[s6 + 2] <= t4)) {
                    a4[s6 + 2] = t4;
                    for (let e6 = 0; e6 < h4; e6++) l4.push(a4[s6 + e6]);
                  }
                }
              }
            }
            return l4;
          }
          _getOriginId(e4) {
            return e4 - this.points.length >> 5;
          }
          _getOriginZoom(e4) {
            return (e4 - this.points.length) % 32;
          }
          _map(e4, t4, s4) {
            if (e4[t4 + A3] > 1) {
              const i5 = this.clusterProps[e4[t4 + N3]];
              return s4 ? Object.assign({}, i5) : i5;
            }
            const i4 = this.points[e4[t4 + Z2]].properties, o3 = this.options.map(i4);
            return s4 && o3 === i4 ? Object.assign({}, o3) : o3;
          }
        }
        function F4(e4, t4, s4) {
          return { type: "Feature", id: e4[t4 + Z2], properties: W2(e4, t4, s4), geometry: { type: "Point", coordinates: [(i4 = e4[t4], 360 * (i4 - 0.5)), G3(e4[t4 + 1])] } };
          var i4;
        }
        function W2(e4, t4, s4) {
          const i4 = e4[t4 + A3], o3 = i4 >= 1e4 ? `${Math.round(i4 / 1e3)}k` : i4 >= 1e3 ? Math.round(i4 / 100) / 10 + "k" : i4, r4 = e4[t4 + N3], n3 = -1 === r4 ? {} : Object.assign({}, s4[r4]);
          return Object.assign(n3, { cluster: true, cluster_id: e4[t4 + Z2], point_count: i4, point_count_abbreviated: o3 });
        }
        function B3(e4) {
          return e4 / 360 + 0.5;
        }
        function J2(e4) {
          const t4 = Math.sin(e4 * Math.PI / 180), s4 = 0.5 - 0.25 * Math.log((1 + t4) / (1 - t4)) / Math.PI;
          return s4 < 0 ? 0 : s4 > 1 ? 1 : s4;
        }
        function G3(e4) {
          const t4 = (180 - 360 * e4) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t4)) / Math.PI - 90;
        }
        var Y = { exports: {} };
        Y.exports = function() {
          function e4(s5, i5, o4, r5) {
            for (var n4, a5 = r5, l5 = o4 - i5 >> 1, h5 = o4 - i5, c5 = s5[i5], u6 = s5[i5 + 1], d4 = s5[o4], p5 = s5[o4 + 1], f5 = i5 + 3; f5 < o4; f5 += 3) {
              var g6 = t4(s5[f5], s5[f5 + 1], c5, u6, d4, p5);
              if (g6 > a5) n4 = f5, a5 = g6;
              else if (g6 === a5) {
                var m5 = Math.abs(f5 - l5);
                m5 < h5 && (n4 = f5, h5 = m5);
              }
            }
            a5 > r5 && (n4 - i5 > 3 && e4(s5, i5, n4, r5), s5[n4 + 2] = a5, o4 - n4 > 3 && e4(s5, n4, o4, r5));
          }
          function t4(e5, t5, s5, i5, o4, r5) {
            var n4 = o4 - s5, a5 = r5 - i5;
            if (0 !== n4 || 0 !== a5) {
              var l5 = ((e5 - s5) * n4 + (t5 - i5) * a5) / (n4 * n4 + a5 * a5);
              l5 > 1 ? (s5 = o4, i5 = r5) : l5 > 0 && (s5 += n4 * l5, i5 += a5 * l5);
            }
            return (n4 = e5 - s5) * n4 + (a5 = t5 - i5) * a5;
          }
          function s4(e5, t5, s5, o4) {
            var r5 = { id: void 0 === e5 ? null : e5, type: t5, geometry: s5, tags: o4, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            return function(e6) {
              var t6 = e6.geometry, s6 = e6.type;
              if ("Point" === s6 || "MultiPoint" === s6 || "LineString" === s6) i4(e6, t6);
              else if ("Polygon" === s6 || "MultiLineString" === s6) for (var o5 = 0; o5 < t6.length; o5++) i4(e6, t6[o5]);
              else if ("MultiPolygon" === s6) for (o5 = 0; o5 < t6.length; o5++) for (var r6 = 0; r6 < t6[o5].length; r6++) i4(e6, t6[o5][r6]);
            }(r5), r5;
          }
          function i4(e5, t5) {
            for (var s5 = 0; s5 < t5.length; s5 += 3) e5.minX = Math.min(e5.minX, t5[s5]), e5.minY = Math.min(e5.minY, t5[s5 + 1]), e5.maxX = Math.max(e5.maxX, t5[s5]), e5.maxY = Math.max(e5.maxY, t5[s5 + 1]);
          }
          function o3(e5, t5, i5, l5) {
            if (t5.geometry) {
              var h5 = t5.geometry.coordinates, c5 = t5.geometry.type, u6 = Math.pow(i5.tolerance / ((1 << i5.maxZoom) * i5.extent), 2), d4 = [], p5 = t5.id;
              if (i5.promoteId ? p5 = t5.properties[i5.promoteId] : i5.generateId && (p5 = l5 || 0), "Point" === c5) r4(h5, d4);
              else if ("MultiPoint" === c5) for (var f5 = 0; f5 < h5.length; f5++) r4(h5[f5], d4);
              else if ("LineString" === c5) n3(h5, d4, u6, false);
              else if ("MultiLineString" === c5) {
                if (i5.lineMetrics) {
                  for (f5 = 0; f5 < h5.length; f5++) n3(h5[f5], d4 = [], u6, false), e5.push(s4(p5, "LineString", d4, t5.properties));
                  return;
                }
                a4(h5, d4, u6, false);
              } else if ("Polygon" === c5) a4(h5, d4, u6, true);
              else {
                if ("MultiPolygon" !== c5) {
                  if ("GeometryCollection" === c5) {
                    for (f5 = 0; f5 < t5.geometry.geometries.length; f5++) o3(e5, { id: p5, geometry: t5.geometry.geometries[f5], properties: t5.properties }, i5, l5);
                    return;
                  }
                  throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (f5 = 0; f5 < h5.length; f5++) {
                  var g6 = [];
                  a4(h5[f5], g6, u6, true), d4.push(g6);
                }
              }
              e5.push(s4(p5, c5, d4, t5.properties));
            }
          }
          function r4(e5, t5) {
            t5.push(l4(e5[0])), t5.push(h4(e5[1])), t5.push(0);
          }
          function n3(t5, s5, i5, o4) {
            for (var r5, n4, a5 = 0, c5 = 0; c5 < t5.length; c5++) {
              var u6 = l4(t5[c5][0]), d4 = h4(t5[c5][1]);
              s5.push(u6), s5.push(d4), s5.push(0), c5 > 0 && (a5 += o4 ? (r5 * d4 - u6 * n4) / 2 : Math.sqrt(Math.pow(u6 - r5, 2) + Math.pow(d4 - n4, 2))), r5 = u6, n4 = d4;
            }
            var p5 = s5.length - 3;
            s5[2] = 1, e4(s5, 0, p5, i5), s5[p5 + 2] = 1, s5.size = Math.abs(a5), s5.start = 0, s5.end = s5.size;
          }
          function a4(e5, t5, s5, i5) {
            for (var o4 = 0; o4 < e5.length; o4++) {
              var r5 = [];
              n3(e5[o4], r5, s5, i5), t5.push(r5);
            }
          }
          function l4(e5) {
            return e5 / 360 + 0.5;
          }
          function h4(e5) {
            var t5 = Math.sin(e5 * Math.PI / 180), s5 = 0.5 - 0.25 * Math.log((1 + t5) / (1 - t5)) / Math.PI;
            return s5 < 0 ? 0 : s5 > 1 ? 1 : s5;
          }
          function c4(e5, t5, i5, o4, r5, n4, a5, l5) {
            if (o4 /= t5, n4 >= (i5 /= t5) && a5 < o4) return e5;
            if (a5 < i5 || n4 >= o4) return null;
            for (var h5 = [], c5 = 0; c5 < e5.length; c5++) {
              var p5 = e5[c5], g6 = p5.geometry, m5 = p5.type, y5 = 0 === r5 ? p5.minX : p5.minY, v5 = 0 === r5 ? p5.maxX : p5.maxY;
              if (y5 >= i5 && v5 < o4) h5.push(p5);
              else if (!(v5 < i5 || y5 >= o4)) {
                var x6 = [];
                if ("Point" === m5 || "MultiPoint" === m5) u5(g6, x6, i5, o4, r5);
                else if ("LineString" === m5) d3(g6, x6, i5, o4, r5, false, l5.lineMetrics);
                else if ("MultiLineString" === m5) f4(g6, x6, i5, o4, r5, false);
                else if ("Polygon" === m5) f4(g6, x6, i5, o4, r5, true);
                else if ("MultiPolygon" === m5) for (var w6 = 0; w6 < g6.length; w6++) {
                  var S4 = [];
                  f4(g6[w6], S4, i5, o4, r5, true), S4.length && x6.push(S4);
                }
                if (x6.length) {
                  if (l5.lineMetrics && "LineString" === m5) {
                    for (w6 = 0; w6 < x6.length; w6++) h5.push(s4(p5.id, m5, x6[w6], p5.tags));
                    continue;
                  }
                  "LineString" !== m5 && "MultiLineString" !== m5 || (1 === x6.length ? (m5 = "LineString", x6 = x6[0]) : m5 = "MultiLineString"), "Point" !== m5 && "MultiPoint" !== m5 || (m5 = 3 === x6.length ? "Point" : "MultiPoint"), h5.push(s4(p5.id, m5, x6, p5.tags));
                }
              }
            }
            return h5.length ? h5 : null;
          }
          function u5(e5, t5, s5, i5, o4) {
            for (var r5 = 0; r5 < e5.length; r5 += 3) {
              var n4 = e5[r5 + o4];
              n4 >= s5 && n4 <= i5 && (t5.push(e5[r5]), t5.push(e5[r5 + 1]), t5.push(e5[r5 + 2]));
            }
          }
          function d3(e5, t5, s5, i5, o4, r5, n4) {
            for (var a5, l5, h5 = p4(e5), c5 = 0 === o4 ? m4 : y4, u6 = e5.start, d4 = 0; d4 < e5.length - 3; d4 += 3) {
              var f5 = e5[d4], v5 = e5[d4 + 1], x6 = e5[d4 + 2], w6 = e5[d4 + 3], S4 = e5[d4 + 4], b5 = 0 === o4 ? f5 : v5, I5 = 0 === o4 ? w6 : S4, M4 = false;
              n4 && (a5 = Math.sqrt(Math.pow(f5 - w6, 2) + Math.pow(v5 - S4, 2))), b5 < s5 ? I5 > s5 && (l5 = c5(h5, f5, v5, w6, S4, s5), n4 && (h5.start = u6 + a5 * l5)) : b5 > i5 ? I5 < i5 && (l5 = c5(h5, f5, v5, w6, S4, i5), n4 && (h5.start = u6 + a5 * l5)) : g5(h5, f5, v5, x6), I5 < s5 && b5 >= s5 && (l5 = c5(h5, f5, v5, w6, S4, s5), M4 = true), I5 > i5 && b5 <= i5 && (l5 = c5(h5, f5, v5, w6, S4, i5), M4 = true), !r5 && M4 && (n4 && (h5.end = u6 + a5 * l5), t5.push(h5), h5 = p4(e5)), n4 && (u6 += a5);
            }
            var k5 = e5.length - 3;
            f5 = e5[k5], v5 = e5[k5 + 1], x6 = e5[k5 + 2], (b5 = 0 === o4 ? f5 : v5) >= s5 && b5 <= i5 && g5(h5, f5, v5, x6), k5 = h5.length - 3, r5 && k5 >= 3 && (h5[k5] !== h5[0] || h5[k5 + 1] !== h5[1]) && g5(h5, h5[0], h5[1], h5[2]), h5.length && t5.push(h5);
          }
          function p4(e5) {
            var t5 = [];
            return t5.size = e5.size, t5.start = e5.start, t5.end = e5.end, t5;
          }
          function f4(e5, t5, s5, i5, o4, r5) {
            for (var n4 = 0; n4 < e5.length; n4++) d3(e5[n4], t5, s5, i5, o4, r5, false);
          }
          function g5(e5, t5, s5, i5) {
            e5.push(t5), e5.push(s5), e5.push(i5);
          }
          function m4(e5, t5, s5, i5, o4, r5) {
            var n4 = (r5 - t5) / (i5 - t5);
            return e5.push(r5), e5.push(s5 + (o4 - s5) * n4), e5.push(1), n4;
          }
          function y4(e5, t5, s5, i5, o4, r5) {
            var n4 = (r5 - s5) / (o4 - s5);
            return e5.push(t5 + (i5 - t5) * n4), e5.push(r5), e5.push(1), n4;
          }
          function v4(e5, t5) {
            for (var i5 = [], o4 = 0; o4 < e5.length; o4++) {
              var r5, n4 = e5[o4], a5 = n4.type;
              if ("Point" === a5 || "MultiPoint" === a5 || "LineString" === a5) r5 = x5(n4.geometry, t5);
              else if ("MultiLineString" === a5 || "Polygon" === a5) {
                r5 = [];
                for (var l5 = 0; l5 < n4.geometry.length; l5++) r5.push(x5(n4.geometry[l5], t5));
              } else if ("MultiPolygon" === a5) for (r5 = [], l5 = 0; l5 < n4.geometry.length; l5++) {
                for (var h5 = [], c5 = 0; c5 < n4.geometry[l5].length; c5++) h5.push(x5(n4.geometry[l5][c5], t5));
                r5.push(h5);
              }
              i5.push(s4(n4.id, a5, r5, n4.tags));
            }
            return i5;
          }
          function x5(e5, t5) {
            var s5 = [];
            s5.size = e5.size, void 0 !== e5.start && (s5.start = e5.start, s5.end = e5.end);
            for (var i5 = 0; i5 < e5.length; i5 += 3) s5.push(e5[i5] + t5, e5[i5 + 1], e5[i5 + 2]);
            return s5;
          }
          function w5(e5, t5) {
            if (e5.transformed) return e5;
            var s5, i5, o4, r5 = 1 << e5.z, n4 = e5.x, a5 = e5.y;
            for (s5 = 0; s5 < e5.features.length; s5++) {
              var l5 = e5.features[s5], h5 = l5.geometry, c5 = l5.type;
              if (l5.geometry = [], 1 === c5) for (i5 = 0; i5 < h5.length; i5 += 2) l5.geometry.push(S3(h5[i5], h5[i5 + 1], t5, r5, n4, a5));
              else for (i5 = 0; i5 < h5.length; i5++) {
                var u6 = [];
                for (o4 = 0; o4 < h5[i5].length; o4 += 2) u6.push(S3(h5[i5][o4], h5[i5][o4 + 1], t5, r5, n4, a5));
                l5.geometry.push(u6);
              }
            }
            return e5.transformed = true, e5;
          }
          function S3(e5, t5, s5, i5, o4, r5) {
            return [Math.round(s5 * (e5 * i5 - o4)), Math.round(s5 * (t5 * i5 - r5))];
          }
          function b4(e5, t5, s5, i5, o4) {
            for (var r5 = t5 === o4.maxZoom ? 0 : o4.tolerance / ((1 << t5) * o4.extent), n4 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: s5, y: i5, z: t5, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a5 = 0; a5 < e5.length; a5++) {
              n4.numFeatures++, I4(n4, e5[a5], r5, o4);
              var l5 = e5[a5].minX, h5 = e5[a5].minY, c5 = e5[a5].maxX, u6 = e5[a5].maxY;
              l5 < n4.minX && (n4.minX = l5), h5 < n4.minY && (n4.minY = h5), c5 > n4.maxX && (n4.maxX = c5), u6 > n4.maxY && (n4.maxY = u6);
            }
            return n4;
          }
          function I4(e5, t5, s5, i5) {
            var o4 = t5.geometry, r5 = t5.type, n4 = [];
            if ("Point" === r5 || "MultiPoint" === r5) for (var a5 = 0; a5 < o4.length; a5 += 3) n4.push(o4[a5]), n4.push(o4[a5 + 1]), e5.numPoints++, e5.numSimplified++;
            else if ("LineString" === r5) M3(n4, o4, e5, s5, false, false);
            else if ("MultiLineString" === r5 || "Polygon" === r5) for (a5 = 0; a5 < o4.length; a5++) M3(n4, o4[a5], e5, s5, "Polygon" === r5, 0 === a5);
            else if ("MultiPolygon" === r5) for (var l5 = 0; l5 < o4.length; l5++) {
              var h5 = o4[l5];
              for (a5 = 0; a5 < h5.length; a5++) M3(n4, h5[a5], e5, s5, true, 0 === a5);
            }
            if (n4.length) {
              var c5 = t5.tags || null;
              if ("LineString" === r5 && i5.lineMetrics) {
                for (var u6 in c5 = {}, t5.tags) c5[u6] = t5.tags[u6];
                c5.mapbox_clip_start = o4.start / o4.size, c5.mapbox_clip_end = o4.end / o4.size;
              }
              var d4 = { geometry: n4, type: "Polygon" === r5 || "MultiPolygon" === r5 ? 3 : "LineString" === r5 || "MultiLineString" === r5 ? 2 : 1, tags: c5 };
              null !== t5.id && (d4.id = t5.id), e5.features.push(d4);
            }
          }
          function M3(e5, t5, s5, i5, o4, r5) {
            var n4 = i5 * i5;
            if (i5 > 0 && t5.size < (o4 ? n4 : i5)) s5.numPoints += t5.length / 3;
            else {
              for (var a5 = [], l5 = 0; l5 < t5.length; l5 += 3) (0 === i5 || t5[l5 + 2] > n4) && (s5.numSimplified++, a5.push(t5[l5]), a5.push(t5[l5 + 1])), s5.numPoints++;
              o4 && function(e6, t6) {
                for (var s6 = 0, i6 = 0, o5 = e6.length, r6 = o5 - 2; i6 < o5; r6 = i6, i6 += 2) s6 += (e6[i6] - e6[r6]) * (e6[i6 + 1] + e6[r6 + 1]);
                if (s6 > 0 === t6) for (i6 = 0, o5 = e6.length; i6 < o5 / 2; i6 += 2) {
                  var n5 = e6[i6], a6 = e6[i6 + 1];
                  e6[i6] = e6[o5 - 2 - i6], e6[i6 + 1] = e6[o5 - 1 - i6], e6[o5 - 2 - i6] = n5, e6[o5 - 1 - i6] = a6;
                }
              }(a5, r5), e5.push(a5);
            }
          }
          function k4(e5, t5) {
            var s5 = (t5 = this.options = function(e6, t6) {
              for (var s6 in t6) e6[s6] = t6[s6];
              return e6;
            }(Object.create(this.options), t5)).debug;
            if (s5 && console.time("preprocess data"), t5.maxZoom < 0 || t5.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (t5.promoteId && t5.generateId) throw new Error("promoteId and generateId cannot be used together.");
            var i5 = function(e6, t6) {
              var s6 = [];
              if ("FeatureCollection" === e6.type) for (var i6 = 0; i6 < e6.features.length; i6++) o3(s6, e6.features[i6], t6, i6);
              else o3(s6, "Feature" === e6.type ? e6 : { geometry: e6 }, t6);
              return s6;
            }(e5, t5);
            this.tiles = {}, this.tileCoords = [], s5 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t5.indexMaxZoom, t5.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (i5 = function(e6, t6) {
              var s6 = t6.buffer / t6.extent, i6 = e6, o4 = c4(e6, 1, -1 - s6, s6, 0, -1, 2, t6), r5 = c4(e6, 1, 1 - s6, 2 + s6, 0, -1, 2, t6);
              return (o4 || r5) && (i6 = c4(e6, 1, -s6, 1 + s6, 0, -1, 2, t6) || [], o4 && (i6 = v4(o4, 1).concat(i6)), r5 && (i6 = i6.concat(v4(r5, -1)))), i6;
            }(i5, t5)).length && this.splitTile(i5, 0, 0, 0), s5 && (i5.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          function T5(e5, t5, s5) {
            return 32 * ((1 << e5) * s5 + t5) + e5;
          }
          return k4.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, k4.prototype.splitTile = function(e5, t5, s5, i5, o4, r5, n4) {
            for (var a5 = [e5, t5, s5, i5], l5 = this.options, h5 = l5.debug; a5.length; ) {
              i5 = a5.pop(), s5 = a5.pop(), t5 = a5.pop(), e5 = a5.pop();
              var u6 = 1 << t5, d4 = T5(t5, s5, i5), p5 = this.tiles[d4];
              if (!p5 && (h5 > 1 && console.time("creation"), p5 = this.tiles[d4] = b4(e5, t5, s5, i5, l5), this.tileCoords.push({ z: t5, x: s5, y: i5 }), h5)) {
                h5 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t5, s5, i5, p5.numFeatures, p5.numPoints, p5.numSimplified), console.timeEnd("creation"));
                var f5 = "z" + t5;
                this.stats[f5] = (this.stats[f5] || 0) + 1, this.total++;
              }
              if (p5.source = e5, o4) {
                if (t5 === l5.maxZoom || t5 === o4) continue;
                var g6 = 1 << o4 - t5;
                if (s5 !== Math.floor(r5 / g6) || i5 !== Math.floor(n4 / g6)) continue;
              } else if (t5 === l5.indexMaxZoom || p5.numPoints <= l5.indexMaxPoints) continue;
              if (p5.source = null, 0 !== e5.length) {
                h5 > 1 && console.time("clipping");
                var m5, y5, v5, x6, w6, S4, I5 = 0.5 * l5.buffer / l5.extent, M4 = 0.5 - I5, k5 = 0.5 + I5, P4 = 1 + I5;
                m5 = y5 = v5 = x6 = null, w6 = c4(e5, u6, s5 - I5, s5 + k5, 0, p5.minX, p5.maxX, l5), S4 = c4(e5, u6, s5 + M4, s5 + P4, 0, p5.minX, p5.maxX, l5), e5 = null, w6 && (m5 = c4(w6, u6, i5 - I5, i5 + k5, 1, p5.minY, p5.maxY, l5), y5 = c4(w6, u6, i5 + M4, i5 + P4, 1, p5.minY, p5.maxY, l5), w6 = null), S4 && (v5 = c4(S4, u6, i5 - I5, i5 + k5, 1, p5.minY, p5.maxY, l5), x6 = c4(S4, u6, i5 + M4, i5 + P4, 1, p5.minY, p5.maxY, l5), S4 = null), h5 > 1 && console.timeEnd("clipping"), a5.push(m5 || [], t5 + 1, 2 * s5, 2 * i5), a5.push(y5 || [], t5 + 1, 2 * s5, 2 * i5 + 1), a5.push(v5 || [], t5 + 1, 2 * s5 + 1, 2 * i5), a5.push(x6 || [], t5 + 1, 2 * s5 + 1, 2 * i5 + 1);
              }
            }
          }, k4.prototype.getTile = function(e5, t5, s5) {
            var i5 = this.options, o4 = i5.extent, r5 = i5.debug;
            if (e5 < 0 || e5 > 24) return null;
            var n4 = 1 << e5, a5 = T5(e5, t5 = (t5 % n4 + n4) % n4, s5);
            if (this.tiles[a5]) return w5(this.tiles[a5], o4);
            r5 > 1 && console.log("drilling down to z%d-%d-%d", e5, t5, s5);
            for (var l5, h5 = e5, c5 = t5, u6 = s5; !l5 && h5 > 0; ) h5--, c5 = Math.floor(c5 / 2), u6 = Math.floor(u6 / 2), l5 = this.tiles[T5(h5, c5, u6)];
            return l5 && l5.source ? (r5 > 1 && console.log("found parent tile z%d-%d-%d", h5, c5, u6), r5 > 1 && console.time("drilling down"), this.splitTile(l5.source, h5, c5, u6, e5, t5, s5), r5 > 1 && console.timeEnd("drilling down"), this.tiles[a5] ? w5(this.tiles[a5], o4) : null) : null;
          }, function(e5, t5) {
            return new k4(e5, t5);
          };
        }();
        var R = e3.dX(Y.exports);
        function X2(e4, t4) {
          const s4 = e4.tileID.canonical;
          if (!this._geoJSONIndex) return t4(null, null);
          const i4 = this._geoJSONIndex.getTile(s4.z, s4.x, s4.y);
          if (!i4) return t4(null, null);
          const o3 = new f3(i4.features);
          let r4 = D3(o3);
          0 === r4.byteOffset && r4.byteLength === r4.buffer.byteLength || (r4 = new Uint8Array(r4)), t4(null, { vectorTile: o3, rawData: r4.buffer });
        }
        class V3 extends h3 {
          constructor(e4, t4, s4, i4, o3, r4) {
            super(e4, t4, s4, i4, X2, r4), o3 && (this.loadGeoJSON = o3), this._featureMap = /* @__PURE__ */ new Map();
          }
          loadData(s4, i4) {
            const o3 = s4 && s4.request, r4 = o3 && o3.collectResourceTiming;
            this.loadGeoJSON(s4, (n3, a4) => {
              if (n3 || !a4) return i4(n3);
              if ("object" != typeof a4) return i4(new Error(`Input data given to '${s4.source}' is not a valid GeoJSON object.`));
              {
                try {
                  if (s4.filter) {
                    const t4 = e3.t(s4.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if ("error" === t4.result) throw new Error(t4.value.map((e4) => `${e4.key}: ${e4.message}`).join(", "));
                    a4.features = a4.features.filter((e4) => t4.value.evaluate({ zoom: 0 }, e4));
                  }
                  if (s4.dynamic) {
                    "Feature" === a4.type && (a4 = { type: "FeatureCollection", features: [a4] }), s4.append || this._featureMap.clear();
                    for (const e4 of a4.features || []) {
                      const t4 = e4.id;
                      void 0 !== t4 && (e4.geometry ? this._featureMap.set(t4, e4) : this._featureMap.delete(t4));
                    }
                    a4.features = [...this._featureMap.values()];
                  }
                  this._geoJSONIndex = s4.cluster ? new E2(function({ superclusterOptions: t4, clusterProperties: s5 }) {
                    if (!s5 || !t4) return t4;
                    const i5 = {}, o4 = {}, r5 = { accumulated: null, zoom: 0 }, n4 = { properties: null }, a5 = Object.keys(s5);
                    for (const t5 of a5) {
                      const [r6, n5] = s5[t5], a6 = e3.t(n5), l5 = e3.t("string" == typeof r6 ? [r6, ["accumulated"], ["get", t5]] : r6);
                      i5[t5] = a6.value, o4[t5] = l5.value;
                    }
                    return t4.map = (e4) => {
                      n4.properties = e4;
                      const t5 = {};
                      for (const e5 of a5) t5[e5] = i5[e5].evaluate(r5, n4);
                      return t5;
                    }, t4.reduce = (e4, t5) => {
                      n4.properties = t5;
                      for (const t6 of a5) r5.accumulated = e4[t6], e4[t6] = o4[t6].evaluate(r5, n4);
                    }, t4;
                  }(s4)).load(a4.features) : R(a4, s4.geojsonVtOptions);
                } catch (n4) {
                  return i4(n4);
                }
                this.loaded = {};
                const l4 = {};
                if (r4) {
                  const e4 = t3(o3);
                  e4 && (l4.resourceTiming = {}, l4.resourceTiming[s4.source] = JSON.parse(JSON.stringify(e4)));
                }
                i4(null, l4);
              }
            });
          }
          reloadTile(e4, t4) {
            const s4 = this.loaded;
            return s4 && s4[e4.uid] ? super.reloadTile(e4, t4) : this.loadTile(e4, t4);
          }
          loadGeoJSON(t4, s4) {
            if (t4.request) e3.g(t4.request, s4);
            else {
              if ("string" != typeof t4.data) return s4(new Error(`Input data given to '${t4.source}' is not a valid GeoJSON object.`));
              try {
                return s4(null, JSON.parse(t4.data));
              } catch (e4) {
                return s4(new Error(`Input data given to '${t4.source}' is not a valid GeoJSON object.`));
              }
            }
          }
          getClusterExpansionZoom(e4, t4) {
            try {
              t4(null, this._geoJSONIndex.getClusterExpansionZoom(e4.clusterId));
            } catch (e5) {
              t4(e5);
            }
          }
          getClusterChildren(e4, t4) {
            try {
              t4(null, this._geoJSONIndex.getChildren(e4.clusterId));
            } catch (e5) {
              t4(e5);
            }
          }
          getClusterLeaves(e4, t4) {
            try {
              t4(null, this._geoJSONIndex.getLeaves(e4.clusterId, e4.limit, e4.offset));
            } catch (e5) {
              t4(e5);
            }
          }
        }
        class $3 {
          constructor(t4, s4) {
            this.tileID = new e3.ap(t4.tileID.overscaledZ, t4.tileID.wrap, t4.tileID.canonical.z, t4.tileID.canonical.x, t4.tileID.canonical.y), this.tileZoom = t4.tileZoom, this.uid = t4.uid, this.zoom = t4.zoom, this.canonical = t4.tileID.canonical, this.pixelRatio = t4.pixelRatio, this.tileSize = t4.tileSize, this.source = t4.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t4.projection, this.brightness = s4;
          }
          parse(t4, s4, i4, o3) {
            this.status = "parsing";
            const r4 = new e3.ap(i4.tileID.overscaledZ, i4.tileID.wrap, i4.tileID.canonical.z, i4.tileID.canonical.x, i4.tileID.canonical.y), n3 = {}, a4 = s4.familiesBySource[i4.source], l4 = new e3.dL(r4, i4.promoteId);
            return l4.bucketLayerIDs = [], l4.is3DTile = true, e3.dY(t4).then((t5) => {
              if (!t5) return o3(new Error("Could not parse tile"));
              const s5 = e3.dZ(t5, 1 / e3.bU(i4.tileID.canonical)), h4 = t5.json.extensionsUsed && t5.json.extensionsUsed.includes("MAPBOX_mesh_features") || t5.json.asset.extras && t5.json.asset.extras.MAPBOX_mesh_features, c4 = t5.json.extensionsUsed && t5.json.extensionsUsed.includes("EXT_meshopt_compression"), u5 = new e3.N(this.zoom, { brightness: this.brightness });
              for (const t6 in a4) for (const i5 of a4[t6]) {
                const t7 = i5[0];
                l4.bucketLayerIDs.push(i5.map((e4) => e4.id)), t7.recalculate(u5, []);
                const o4 = new e3.d_(s5, r4, h4, c4, this.brightness, l4);
                h4 || (o4.needsUpload = true), n3[t7.fqid] = o4, o4.evaluate(t7);
              }
              this.status = "done", o3(null, { buckets: n3, featureIndex: l4 });
            }).catch((e4) => o3(new Error(e4.message)));
          }
        }
        class U2 {
          constructor(e4, t4, s4, i4, o3, r4) {
            this.actor = e4, this.layerIndex = t4, this.brightness = r4, this.loading = {}, this.loaded = {};
          }
          loadTile(t4, s4) {
            const i4 = t4.uid, o3 = this.loading[i4] = new $3(t4, this.brightness);
            e3.b1(t4.request, (e4, r4) => {
              const n3 = !this.loading[i4];
              return delete this.loading[i4], n3 || e4 ? (o3.status = "done", n3 || (this.loaded[i4] = o3), s4(e4)) : r4 && 0 !== r4.byteLength ? void o3.parse(r4, this.layerIndex, t4, (e5, t5) => {
                o3.status = "done", this.loaded = this.loaded || {}, this.loaded[i4] = o3, e5 || !t5 ? s4(e5) : s4(null, t5);
              }) : (o3.status = "done", this.loaded[i4] = o3, s4());
            });
          }
          reloadTile(e4, t4) {
            const s4 = this.loaded, i4 = e4.uid;
            if (s4 && s4[i4]) {
              const o3 = s4[i4];
              o3.projection = e4.projection, o3.brightness = e4.brightness;
              const r4 = (s5, i5) => {
                o3.reloadCallback && (delete o3.reloadCallback, this.loadTile(e4, t4)), t4(s5, i5);
              };
              "parsing" === o3.status ? o3.reloadCallback = r4 : "done" === o3.status && this.loadTile(e4, t4);
            }
          }
          abortTile(e4, t4) {
            const s4 = e4.uid;
            this.loading[s4] && delete this.loading[s4], t4();
          }
          removeTile(e4, t4) {
            const s4 = this.loaded, i4 = e4.uid;
            s4 && s4[i4] && delete s4[i4], t4();
          }
        }
        class q3 {
          constructor(t4) {
            this.self = t4, this.actor = new e3.d$(t4, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e3.br({ name: "mercator" }), this.workerSourceTypes = { vector: h3, geojson: V3, "batched-model": U2 }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e4, t5) => {
              if (this.workerSourceTypes[e4]) throw new Error(`Worker source with name "${e4}" already registered.`);
              this.workerSourceTypes[e4] = t5;
            }, this.self.registerRTLTextPlugin = (t5) => {
              if (e3.e0.isParsed()) throw new Error("RTL text plugin already registered.");
              e3.e0.applyArabicShaping = t5.applyArabicShaping, e3.e0.processBidirectionalText = t5.processBidirectionalText, e3.e0.processStyledBidirectionalText = t5.processStyledBidirectionalText;
            };
          }
          clearCaches(e4, t4, s4) {
            delete this.layerIndexes[e4], delete this.availableImages[e4], delete this.workerSources[e4], delete this.demWorkerSources[e4], delete this.rasterArrayWorkerSource, s4();
          }
          checkIfReady(e4, t4, s4) {
            s4();
          }
          setReferrer(e4, t4) {
            this.referrer = t4;
          }
          spriteLoaded(t4, { scope: s4, isLoaded: i4 }) {
            if (this.isSpriteLoaded[t4] || (this.isSpriteLoaded[t4] = {}), this.isSpriteLoaded[t4][s4] = i4, this.workerSources[t4] && this.workerSources[t4][s4]) for (const o3 in this.workerSources[t4][s4]) {
              const r4 = this.workerSources[t4][s4][o3];
              for (const t5 in r4) r4[t5] instanceof h3 && (r4[t5].isSpriteLoaded = i4, r4[t5].fire(new e3.b("isSpriteLoaded")));
            }
          }
          setImages(e4, { scope: t4, images: s4 }, i4) {
            if (this.availableImages[e4] || (this.availableImages[e4] = {}), this.availableImages[e4][t4] = s4, this.workerSources[e4] && this.workerSources[e4][t4]) {
              for (const i5 in this.workerSources[e4][t4]) {
                const o3 = this.workerSources[e4][t4][i5];
                for (const e5 in o3) o3[e5].availableImages = s4;
              }
              i4();
            } else i4();
          }
          setProjection(t4, s4) {
            this.projections[t4] = e3.br(s4);
          }
          setBrightness(e4, t4, s4) {
            this.brightness = t4, s4();
          }
          setLayers(e4, t4, s4) {
            this.getLayerIndex(e4, t4.scope).replace(t4.layers, t4.options), s4();
          }
          updateLayers(e4, t4, s4) {
            this.getLayerIndex(e4, t4.scope).update(t4.layers, t4.removedIds, t4.options), s4();
          }
          loadTile(e4, t4, s4) {
            t4.projection = this.projections[e4] || this.defaultProjection, this.getWorkerSource(e4, t4.type, t4.source, t4.scope).loadTile(t4, s4);
          }
          loadDEMTile(e4, t4, s4) {
            this.getDEMWorkerSource(e4, t4.source, t4.scope).loadTile(t4, s4);
          }
          decodeRasterArray(e4, t4, s4) {
            this.getRasterArrayWorkerSource().decodeRasterArray(t4, s4);
          }
          reloadTile(e4, t4, s4) {
            t4.projection = this.projections[e4] || this.defaultProjection, this.getWorkerSource(e4, t4.type, t4.source, t4.scope).reloadTile(t4, s4);
          }
          abortTile(e4, t4, s4) {
            this.getWorkerSource(e4, t4.type, t4.source, t4.scope).abortTile(t4, s4);
          }
          removeTile(e4, t4, s4) {
            this.getWorkerSource(e4, t4.type, t4.source, t4.scope).removeTile(t4, s4);
          }
          removeSource(e4, t4, s4) {
            if (!(this.workerSources[e4] && this.workerSources[e4][t4.scope] && this.workerSources[e4][t4.scope][t4.type] && this.workerSources[e4][t4.scope][t4.type][t4.source])) return;
            const i4 = this.workerSources[e4][t4.scope][t4.type][t4.source];
            delete this.workerSources[e4][t4.scope][t4.type][t4.source], void 0 !== i4.removeSource ? i4.removeSource(t4, s4) : s4();
          }
          loadWorkerSource(e4, t4, s4) {
            try {
              this.self.importScripts(t4.url), s4();
            } catch (e5) {
              s4(e5.toString());
            }
          }
          syncRTLPluginState(t4, s4, i4) {
            try {
              e3.e0.setState(s4);
              const t5 = e3.e0.getPluginURL();
              if (e3.e0.isLoaded() && !e3.e0.isParsed() && null != t5) {
                this.self.importScripts(t5);
                const s5 = e3.e0.isParsed();
                i4(s5 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t5}`), s5);
              }
            } catch (e4) {
              i4(e4.toString());
            }
          }
          setDracoUrl(e4, t4) {
            this.dracoUrl = t4;
          }
          getAvailableImages(e4, t4) {
            this.availableImages[e4] || (this.availableImages[e4] = {});
            let s4 = this.availableImages[e4][t4];
            return s4 || (s4 = []), s4;
          }
          getLayerIndex(e4, t4) {
            this.layerIndexes[e4] || (this.layerIndexes[e4] = {});
            let s4 = this.layerIndexes[e4][t4];
            return s4 || (s4 = this.layerIndexes[e4][t4] = new o2(), s4.scope = t4), s4;
          }
          getWorkerSource(e4, t4, s4, i4) {
            if (this.workerSources[e4] || (this.workerSources[e4] = {}), this.workerSources[e4][i4] || (this.workerSources[e4][i4] = {}), this.workerSources[e4][i4][t4] || (this.workerSources[e4][i4][t4] = {}), this.isSpriteLoaded[e4] || (this.isSpriteLoaded[e4] = {}), !this.workerSources[e4][i4][t4][s4]) {
              const o3 = { send: (t5, s5, i5, o4, r4, n3) => {
                this.actor.send(t5, s5, i5, e4, r4, n3);
              }, scheduler: this.actor.scheduler };
              this.workerSources[e4][i4][t4][s4] = new this.workerSourceTypes[t4](o3, this.getLayerIndex(e4, i4), this.getAvailableImages(e4, i4), this.isSpriteLoaded[e4][i4], void 0, this.brightness);
            }
            return this.workerSources[e4][i4][t4][s4];
          }
          getDEMWorkerSource(e4, t4, s4) {
            return this.demWorkerSources[e4] || (this.demWorkerSources[e4] = {}), this.demWorkerSources[e4][s4] || (this.demWorkerSources[e4][s4] = {}), this.demWorkerSources[e4][s4][t4] || (this.demWorkerSources[e4][s4][t4] = new c3()), this.demWorkerSources[e4][s4][t4];
          }
          getRasterArrayWorkerSource() {
            return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new u4()), this.rasterArrayWorkerSource;
          }
          enforceCacheSizeLimit(t4, s4) {
            e3.e1(s4);
          }
          getWorkerPerformanceMetrics(e4, t4, s4) {
            s4(void 0, void 0);
          }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new q3(self)), q3;
      });
      define2(["./shared"], function(e3) {
        "use strict";
        function t3(e4, i4) {
          if (Array.isArray(e4)) {
            if (!Array.isArray(i4) || e4.length !== i4.length) return false;
            for (let o3 = 0; o3 < e4.length; o3++) if (!t3(e4[o3], i4[o3])) return false;
            return true;
          }
          if ("object" == typeof e4 && null !== e4 && null !== i4) {
            if ("object" != typeof i4) return false;
            if (Object.keys(e4).length !== Object.keys(i4).length) return false;
            for (const o3 in e4) if (!t3(e4[o3], i4[o3])) return false;
            return true;
          }
          return e4 === i4;
        }
        var i3 = o2;
        function o2(e4) {
          return !function(e5) {
            return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window)) return false;
              var e6, t5, i4 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i4);
              try {
                t5 = new Worker(o3), e6 = true;
              } catch (t6) {
                e6 = false;
              }
              return t5 && t5.terminate(), URL.revokeObjectURL(o3), e6;
            }() ? function() {
              var e6 = document.createElement("canvas");
              e6.width = e6.height = 1;
              var t5 = e6.getContext("2d");
              if (!t5) return false;
              var i4 = t5.getImageData(0, 0, 1, 1);
              return i4 && i4.width === e6.width;
            }() ? (void 0 === r3[t4 = e5 && e5.failIfMajorPerformanceCaveat] && (r3[t4] = function(e6) {
              var t5, i4 = function(e7) {
                var t6 = document.createElement("canvas"), i5 = Object.create(o2.webGLContextAttributes);
                return i5.failIfMajorPerformanceCaveat = e7, t6.getContext("webgl2", i5);
              }(e6);
              if (!i4) return false;
              try {
                t5 = i4.createShader(i4.VERTEX_SHADER);
              } catch (e7) {
                return false;
              }
              return !(!t5 || i4.isContextLost()) && (i4.shaderSource(t5, "void main() {}"), i4.compileShader(t5), true === i4.getShaderParameter(t5, i4.COMPILE_STATUS));
            }(t4)), r3[t4] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
            var t4;
          }(e4);
        }
        var r3 = {};
        function s3(e4, t4, i4) {
          const o3 = document.createElement(e4);
          return null != t4 && (o3.className = t4), i4 && i4.appendChild(o3), o3;
        }
        function n2(e4, t4, i4) {
          const o3 = document.createElementNS("http://www.w3.org/2000/svg", e4);
          for (const e5 of Object.keys(t4)) o3.setAttributeNS(null, e5, String(t4[e5]));
          return i4 && i4.appendChild(o3), o3;
        }
        o2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
        const a3 = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, l3 = a3 && void 0 !== a3.userSelect ? "userSelect" : "WebkitUserSelect";
        let c3;
        function h3() {
          a3 && l3 && (c3 = a3[l3], a3[l3] = "none");
        }
        function u4() {
          a3 && l3 && (a3[l3] = c3);
        }
        function d2(e4) {
          e4.preventDefault(), e4.stopPropagation(), window.removeEventListener("click", d2, true);
        }
        function _3() {
          window.addEventListener("click", d2, true), window.setTimeout(() => {
            window.removeEventListener("click", d2, true);
          }, 0);
        }
        function p3(e4, t4) {
          const i4 = e4.getBoundingClientRect();
          return g4(e4, i4, t4);
        }
        function f3(e4, t4) {
          const i4 = e4.getBoundingClientRect(), o3 = [];
          for (let r4 = 0; r4 < t4.length; r4++) o3.push(g4(e4, i4, t4[r4]));
          return o3;
        }
        function m3(e4) {
          return void 0 !== window.InstallTrigger && 2 === e4.button && e4.ctrlKey && window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e4.button;
        }
        function g4(t4, i4, o3) {
          const r4 = t4.offsetWidth === i4.width ? 1 : t4.offsetWidth / i4.width;
          return new e3.P((o3.clientX - i4.left) * r4, (o3.clientY - i4.top) * r4);
        }
        class v3 {
          constructor() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = /* @__PURE__ */ new Set();
          }
          isDirty() {
            return this._changed;
          }
          setDirty() {
            this._changed = true;
          }
          getUpdatedSourceCaches() {
            return this._updatedSourceCaches;
          }
          updateSourceCache(e4, t4) {
            this._updatedSourceCaches[e4] = t4, this.setDirty();
          }
          discardSourceCacheUpdate(e4) {
            delete this._updatedSourceCaches[e4];
          }
          updateLayer(e4) {
            const t4 = e4.scope;
            this._updatedLayers[t4] = this._updatedLayers[t4] || /* @__PURE__ */ new Set(), this._updatedLayers[t4].add(e4.id), this.setDirty();
          }
          removeLayer(e4) {
            const t4 = e4.scope;
            this._removedLayers[t4] = this._removedLayers[t4] || {}, this._updatedLayers[t4] = this._updatedLayers[t4] || /* @__PURE__ */ new Set(), this._removedLayers[t4][e4.id] = e4, this._updatedLayers[t4].delete(e4.id), this._updatedPaintProps.delete(e4.fqid), this.setDirty();
          }
          getRemovedLayer(e4) {
            return this._removedLayers[e4.scope] ? this._removedLayers[e4.scope][e4.id] : null;
          }
          discardLayerRemoval(e4) {
            this._removedLayers[e4.scope] && delete this._removedLayers[e4.scope][e4.id];
          }
          getLayerUpdatesByScope() {
            const e4 = {};
            for (const t4 in this._updatedLayers) e4[t4] = e4[t4] || {}, e4[t4].updatedIds = Array.from(this._updatedLayers[t4].values());
            for (const t4 in this._removedLayers) e4[t4] = e4[t4] || {}, e4[t4].removedIds = Object.keys(this._removedLayers[t4]);
            return e4;
          }
          getUpdatedPaintProperties() {
            return this._updatedPaintProps;
          }
          updatePaintProperties(e4) {
            this._updatedPaintProps.add(e4.fqid), this.setDirty();
          }
          getUpdatedImages() {
            return Array.from(this._updatedImages.values());
          }
          updateImage(e4) {
            this._updatedImages.add(e4), this.setDirty();
          }
          resetUpdatedImages() {
            this._updatedImages.clear();
          }
          reset() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
          }
        }
        class x4 extends e3.E {
          constructor(e4) {
            super(), this.requestManager = e4, this.models = { "": {} }, this.numModelsLoading = {};
          }
          loadModel(t4, i4) {
            return e3.l(this.requestManager.transformRequest(i4, e3.R.Model).url).then((i5) => {
              if (!i5) return;
              const o3 = e3.c(i5), r4 = new e3.M(t4, void 0, void 0, o3);
              return r4.computeBoundsAndApplyParent(), r4;
            }).catch((o3) => {
              if (o3 && 404 === o3.status) return null;
              this.fire(new e3.a(new Error(`Could not load model ${t4} from ${i4}: ${o3.message}`)));
            });
          }
          load(t4, i4) {
            this.models[i4] || (this.models[i4] = {});
            const o3 = Object.keys(t4);
            this.numModelsLoading[i4] = (this.numModelsLoading[i4] || 0) + o3.length;
            const r4 = [];
            for (const e4 of o3) r4.push(this.loadModel(e4, t4[e4]));
            Promise.allSettled(r4).then((t5) => {
              for (let e4 = 0; e4 < t5.length; e4++) {
                const { status: r5, value: s4 } = t5[e4];
                "fulfilled" === r5 && s4 && (this.models[i4][o3[e4]] = { model: s4, numReferences: 1 });
              }
              this.numModelsLoading[i4] -= o3.length, this.fire(new e3.b("data", { dataType: "style" }));
            }).catch((t5) => {
              this.fire(new e3.a(new Error(`Could not load models: ${t5.message}`)));
            });
          }
          isLoaded() {
            for (const e4 in this.numModelsLoading) if (this.numModelsLoading[e4] > 0) return false;
            return true;
          }
          hasModel(e4, t4) {
            return !!this.getModel(e4, t4);
          }
          getModel(e4, t4) {
            return this.models[t4] || (this.models[t4] = {}), this.models[t4][e4] ? this.models[t4][e4].model : void 0;
          }
          addModel(e4, t4, i4) {
            this.models[i4] || (this.models[i4] = {}), this.hasModel(e4, i4) && this.models[i4][e4].numReferences++, this.load({ [e4]: this.requestManager.normalizeModelURL(t4) }, i4);
          }
          addModels(e4, t4) {
            this.models[t4] || (this.models[t4] = {});
            const i4 = {};
            for (const o3 in e4) this.models[t4][o3] = {}, i4[o3] = this.requestManager.normalizeModelURL(e4[o3]);
            this.load(i4, t4);
          }
          addModelsFromBucket(e4, t4) {
            this.models[t4] || (this.models[t4] = {});
            const i4 = {};
            for (const o3 of e4) this.hasModel(o3, t4) ? this.models[t4][o3].numReferences++ : i4[o3] = this.requestManager.normalizeModelURL(o3);
            this.load(i4, t4);
          }
          removeModel(e4, t4) {
            if (this.models[t4] && this.models[t4][e4] && (this.models[t4][e4].numReferences--, 0 === this.models[t4][e4].numReferences)) {
              const i4 = this.models[t4][e4].model;
              delete this.models[t4][e4], i4.destroy();
            }
          }
          listModels(e4) {
            return this.models[e4] || (this.models[e4] = {}), Object.keys(this.models[e4]);
          }
          upload(e4, t4) {
            this.models[t4] || (this.models[t4] = {});
            for (const i4 in this.models[t4]) this.models[t4][i4].model && this.models[t4][i4].model.upload(e4.context);
          }
        }
        class y3 {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t4, i4, o3) {
            const r4 = String(i4);
            if (this.stateChanges[t4] = this.stateChanges[t4] || {}, this.stateChanges[t4][r4] = this.stateChanges[t4][r4] || {}, e3.e(this.stateChanges[t4][r4], o3), null === this.deletedStates[t4]) {
              this.deletedStates[t4] = {};
              for (const e4 in this.state[t4]) e4 !== r4 && (this.deletedStates[t4][e4] = null);
            } else if (this.deletedStates[t4] && null === this.deletedStates[t4][r4]) {
              this.deletedStates[t4][r4] = {};
              for (const e4 in this.state[t4][r4]) o3[e4] || (this.deletedStates[t4][r4][e4] = null);
            } else for (const e4 in o3) this.deletedStates[t4] && this.deletedStates[t4][r4] && null === this.deletedStates[t4][r4][e4] && delete this.deletedStates[t4][r4][e4];
          }
          removeFeatureState(e4, t4, i4) {
            if (null === this.deletedStates[e4]) return;
            const o3 = String(t4);
            if (this.deletedStates[e4] = this.deletedStates[e4] || {}, i4 && void 0 !== t4) null !== this.deletedStates[e4][o3] && (this.deletedStates[e4][o3] = this.deletedStates[e4][o3] || {}, this.deletedStates[e4][o3][i4] = null);
            else if (void 0 !== t4) if (this.stateChanges[e4] && this.stateChanges[e4][o3]) for (i4 in this.deletedStates[e4][o3] = {}, this.stateChanges[e4][o3]) this.deletedStates[e4][o3][i4] = null;
            else this.deletedStates[e4][o3] = null;
            else this.deletedStates[e4] = null;
          }
          getState(t4, i4) {
            const o3 = String(i4), r4 = e3.e({}, (this.state[t4] || {})[o3], (this.stateChanges[t4] || {})[o3]);
            if (null === this.deletedStates[t4]) return {};
            if (this.deletedStates[t4]) {
              const e4 = this.deletedStates[t4][i4];
              if (null === e4) return {};
              for (const t5 in e4) delete r4[t5];
            }
            return r4;
          }
          initializeTileState(e4, t4) {
            e4.setFeatureState(this.state, t4);
          }
          coalesceChanges(t4, i4) {
            const o3 = {};
            for (const t5 in this.stateChanges) {
              this.state[t5] = this.state[t5] || {};
              const i5 = {};
              for (const o4 in this.stateChanges[t5]) this.state[t5][o4] || (this.state[t5][o4] = {}), e3.e(this.state[t5][o4], this.stateChanges[t5][o4]), i5[o4] = this.state[t5][o4];
              o3[t5] = i5;
            }
            for (const t5 in this.deletedStates) {
              this.state[t5] = this.state[t5] || {};
              const i5 = {};
              if (null === this.deletedStates[t5]) for (const e4 in this.state[t5]) i5[e4] = {}, this.state[t5][e4] = {};
              else for (const e4 in this.deletedStates[t5]) {
                if (null === this.deletedStates[t5][e4]) this.state[t5][e4] = {};
                else if (this.state[t5][e4]) for (const i6 of Object.keys(this.deletedStates[t5][e4])) delete this.state[t5][e4][i6];
                i5[e4] = this.state[t5][e4];
              }
              o3[t5] = o3[t5] || {}, e3.e(o3[t5], i5);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o3).length) for (const e4 in t4) t4[e4].setFeatureState(o3, i4);
          }
        }
        function b3(e4) {
          const { userImage: t4 } = e4;
          return !!(t4 && t4.render && t4.render()) && (e4.data.replace(new Uint8Array(t4.data.buffer)), true);
        }
        class w4 extends e3.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = true;
          }
          createScope(t4) {
            this.images[t4] = {}, this.loaded[t4] = false, this.updatedImages[t4] = {}, this.patterns[t4] = {}, this.callbackDispatchedThisFrame[t4] = {}, this.atlasImage[t4] = new e3.h({ width: 1, height: 1 });
          }
          isLoaded() {
            for (const e4 in this.loaded) if (!this.loaded[e4]) return false;
            return true;
          }
          setLoaded(e4, t4) {
            if (this.loaded[t4] !== e4 && (this.loaded[t4] = e4, e4)) {
              for (const { ids: e5, callback: i4 } of this.requestors) this._notify(e5, t4, i4);
              this.requestors = [];
            }
          }
          hasImage(e4, t4) {
            return !!this.getImage(e4, t4);
          }
          getImage(e4, t4) {
            return this.images[t4][e4];
          }
          addImage(e4, t4, i4) {
            this._validate(e4, i4) && (this.images[t4][e4] = i4);
          }
          _validate(t4, i4) {
            let o3 = true;
            return this._validateStretch(i4.stretchX, i4.data && i4.data.width) || (this.fire(new e3.a(new Error(`Image "${t4}" has invalid "stretchX" value`))), o3 = false), this._validateStretch(i4.stretchY, i4.data && i4.data.height) || (this.fire(new e3.a(new Error(`Image "${t4}" has invalid "stretchY" value`))), o3 = false), this._validateContent(i4.content, i4) || (this.fire(new e3.a(new Error(`Image "${t4}" has invalid "content" value`))), o3 = false), o3;
          }
          _validateStretch(e4, t4) {
            if (!e4) return true;
            let i4 = 0;
            for (const o3 of e4) {
              if (o3[0] < i4 || o3[1] < o3[0] || t4 < o3[1]) return false;
              i4 = o3[1];
            }
            return true;
          }
          _validateContent(e4, t4) {
            return !(e4 && (4 !== e4.length || e4[0] < 0 || t4.data.width < e4[0] || e4[1] < 0 || t4.data.height < e4[1] || e4[2] < 0 || t4.data.width < e4[2] || e4[3] < 0 || t4.data.height < e4[3] || e4[2] < e4[0] || e4[3] < e4[1]));
          }
          updateImage(e4, t4, i4) {
            i4.version = this.images[t4][e4].version + 1, this.images[t4][e4] = i4, this.updatedImages[t4][e4] = true;
          }
          removeImage(e4, t4) {
            const i4 = this.images[t4][e4];
            delete this.images[t4][e4], delete this.patterns[t4][e4], i4.userImage && i4.userImage.onRemove && i4.userImage.onRemove();
          }
          listImages(e4) {
            return Object.keys(this.images[e4]);
          }
          getImages(e4, t4, i4) {
            let o3 = true;
            const r4 = !!this.loaded[t4];
            if (!r4) for (const i5 of e4) this.images[t4][i5] || (o3 = false);
            r4 || o3 ? this._notify(e4, t4, i4) : this.requestors.push({ ids: e4, scope: t4, callback: i4 });
          }
          getUpdatedImages(e4) {
            return this.updatedImages[e4];
          }
          _notify(t4, i4, o3) {
            const r4 = {};
            for (const o4 of t4) {
              this.images[i4][o4] || this.fire(new e3.b("styleimagemissing", { id: o4 }));
              const t5 = this.images[i4][o4];
              t5 ? r4[o4] = { data: t5.data.clone(), pixelRatio: t5.pixelRatio, sdf: t5.sdf, version: t5.version, stretchX: t5.stretchX, stretchY: t5.stretchY, content: t5.content, hasRenderCallback: Boolean(t5.userImage && t5.userImage.render) } : e3.w(`Image "${o4}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            o3(null, r4);
          }
          getPixelSize(e4) {
            const { width: t4, height: i4 } = this.atlasImage[e4];
            return { width: t4, height: i4 };
          }
          getPattern(t4, i4) {
            const o3 = this.patterns[i4][t4], r4 = this.getImage(t4, i4);
            if (!r4) return null;
            if (o3 && o3.position.version === r4.version) return o3.position;
            if (o3) o3.position.version = r4.version;
            else {
              const o4 = { w: r4.data.width + 2, h: r4.data.height + 2, x: 0, y: 0 }, s4 = new e3.I(o4, r4);
              this.patterns[i4][t4] = { bin: o4, position: s4 };
            }
            return this._updatePatternAtlas(i4), this.patterns[i4][t4].position;
          }
          bind(t4, i4) {
            const o3 = t4.gl;
            let r4 = this.atlasTexture[i4];
            r4 ? this.dirty && (r4.update(this.atlasImage[i4]), this.dirty = false) : (r4 = new e3.T(t4, this.atlasImage[i4], o3.RGBA), this.atlasTexture[i4] = r4), r4.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas(t4) {
            const i4 = [];
            for (const e4 in this.patterns[t4]) i4.push(this.patterns[t4][e4].bin);
            const { w: o3, h: r4 } = e3.p(i4), s4 = this.atlasImage[t4];
            s4.resize({ width: o3 || 1, height: r4 || 1 });
            for (const i5 in this.patterns[t4]) {
              const { bin: o4 } = this.patterns[t4][i5], r5 = o4.x + 1, n3 = o4.y + 1, a4 = this.images[t4][i5].data, l4 = a4.width, c4 = a4.height;
              e3.h.copy(a4, s4, { x: 0, y: 0 }, { x: r5, y: n3 }, { width: l4, height: c4 }), e3.h.copy(a4, s4, { x: 0, y: c4 - 1 }, { x: r5, y: n3 - 1 }, { width: l4, height: 1 }), e3.h.copy(a4, s4, { x: 0, y: 0 }, { x: r5, y: n3 + c4 }, { width: l4, height: 1 }), e3.h.copy(a4, s4, { x: l4 - 1, y: 0 }, { x: r5 - 1, y: n3 }, { width: 1, height: c4 }), e3.h.copy(a4, s4, { x: 0, y: 0 }, { x: r5 + l4, y: n3 }, { width: 1, height: c4 });
            }
            this.dirty = true;
          }
          beginFrame() {
            for (const e4 in this.images) this.callbackDispatchedThisFrame[e4] = {};
          }
          dispatchRenderCallbacks(e4, t4) {
            for (const i4 of e4) {
              if (this.callbackDispatchedThisFrame[t4][i4]) continue;
              this.callbackDispatchedThisFrame[t4][i4] = true;
              const e5 = this.images[t4][i4];
              b3(e5) && this.updateImage(i4, t4, e5);
            }
          }
        }
        function T4(t4) {
          const i4 = t4.key, o3 = t4.value, r4 = t4.valueSpec || {}, s4 = t4.objectElementValidators || {}, n3 = t4.style, a4 = t4.styleSpec;
          let l4 = [];
          const c4 = e3.j(o3);
          if ("object" !== c4) return [new e3.V(i4, o3, `object expected, ${c4} found`)];
          for (const t5 in o3) {
            const c5 = t5.split(".")[0];
            let h4;
            s4[c5] ? h4 = s4[c5] : r4[c5] ? h4 = W2 : s4["*"] ? h4 = s4["*"] : r4["*"] && (h4 = W2), h4 ? l4 = l4.concat(h4({ key: (i4 ? `${i4}.` : i4) + t5, value: o3[t5], valueSpec: r4[c5] || r4["*"], style: n3, styleSpec: a4, object: o3, objectKey: t5 }, o3)) : l4.push(new e3.i(i4, o3[t5], `unknown property "${t5}"`));
          }
          for (const t5 in r4) s4[t5] || r4[t5].required && void 0 === r4[t5].default && void 0 === o3[t5] && l4.push(new e3.V(i4, o3, `missing required property "${t5}"`));
          return l4;
        }
        function E2(t4) {
          const i4 = t4.value, o3 = t4.valueSpec, r4 = t4.style, s4 = t4.styleSpec, n3 = t4.key, a4 = t4.arrayElementValidator || W2;
          if ("array" !== e3.j(i4)) return [new e3.V(n3, i4, `array expected, ${e3.j(i4)} found`)];
          if (o3.length && i4.length !== o3.length) return [new e3.V(n3, i4, `array length ${o3.length} expected, length ${i4.length} found`)];
          if (o3["min-length"] && i4.length < o3["min-length"]) return [new e3.V(n3, i4, `array length at least ${o3["min-length"]} expected, length ${i4.length} found`)];
          let l4 = { type: o3.value, values: o3.values, minimum: o3.minimum, maximum: o3.maximum, function: void 0 };
          s4.$version < 7 && (l4.function = o3.function), "object" === e3.j(o3.value) && (l4 = o3.value);
          let c4 = [];
          for (let e4 = 0; e4 < i4.length; e4++) c4 = c4.concat(a4({ array: i4, arrayIndex: e4, value: i4[e4], valueSpec: l4, style: r4, styleSpec: s4, key: `${n3}[${e4}]` }, true));
          return c4;
        }
        function S2(t4) {
          const i4 = t4.key, o3 = t4.value, r4 = t4.valueSpec;
          let s4 = e3.j(o3);
          if ("number" === s4 && o3 != o3 && (s4 = "NaN"), "number" !== s4) return [new e3.V(i4, o3, `number expected, ${s4} found`)];
          if ("minimum" in r4) {
            let s5 = r4.minimum;
            if ("array" === e3.j(r4.minimum) && (s5 = r4.minimum[t4.arrayIndex]), o3 < s5) return [new e3.V(i4, o3, `${o3} is less than the minimum value ${s5}`)];
          }
          if ("maximum" in r4) {
            let s5 = r4.maximum;
            if ("array" === e3.j(r4.maximum) && (s5 = r4.maximum[t4.arrayIndex]), o3 > s5) return [new e3.V(i4, o3, `${o3} is greater than the maximum value ${s5}`)];
          }
          return [];
        }
        function C3(t4) {
          const i4 = t4.valueSpec, o3 = e3.u(t4.value.type);
          let r4, s4, n3, a4 = {};
          const l4 = "categorical" !== o3 && void 0 === t4.value.property, c4 = !l4, h4 = "array" === e3.j(t4.value.stops) && "array" === e3.j(t4.value.stops[0]) && "object" === e3.j(t4.value.stops[0][0]), u5 = T4({ key: t4.key, value: t4.value, valueSpec: t4.styleSpec.function, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { stops: function(t5) {
            if ("identity" === o3) return [new e3.V(t5.key, t5.value, 'identity function may not have a "stops" property')];
            let i5 = [];
            const r5 = t5.value;
            return i5 = i5.concat(E2({ key: t5.key, value: r5, valueSpec: t5.valueSpec, style: t5.style, styleSpec: t5.styleSpec, arrayElementValidator: d3 })), "array" === e3.j(r5) && 0 === r5.length && i5.push(new e3.V(t5.key, r5, "array must have at least one stop")), i5;
          }, default: function(e4) {
            return W2({ key: e4.key, value: e4.value, valueSpec: i4, style: e4.style, styleSpec: e4.styleSpec });
          } } });
          return "identity" === o3 && l4 && u5.push(new e3.V(t4.key, t4.value, 'missing required property "property"')), "identity" === o3 || t4.value.stops || u5.push(new e3.V(t4.key, t4.value, 'missing required property "stops"')), "exponential" === o3 && t4.valueSpec.expression && !e3.s(t4.valueSpec) && u5.push(new e3.V(t4.key, t4.value, "exponential functions not supported")), t4.styleSpec.$version >= 8 && (c4 && !e3.m(t4.valueSpec) ? u5.push(new e3.V(t4.key, t4.value, "property functions not supported")) : l4 && !e3.n(t4.valueSpec) && u5.push(new e3.V(t4.key, t4.value, "zoom functions not supported"))), "categorical" !== o3 && !h4 || void 0 !== t4.value.property || u5.push(new e3.V(t4.key, t4.value, '"property" property is required')), u5;
          function d3(t5) {
            let o4 = [];
            const r5 = t5.value, l5 = t5.key;
            if ("array" !== e3.j(r5)) return [new e3.V(l5, r5, `array expected, ${e3.j(r5)} found`)];
            if (2 !== r5.length) return [new e3.V(l5, r5, `array length 2 expected, length ${r5.length} found`)];
            if (h4) {
              if ("object" !== e3.j(r5[0])) return [new e3.V(l5, r5, `object expected, ${e3.j(r5[0])} found`)];
              if (void 0 === r5[0].zoom) return [new e3.V(l5, r5, "object stop key must have zoom")];
              if (void 0 === r5[0].value) return [new e3.V(l5, r5, "object stop key must have value")];
              const i5 = e3.u(r5[0].zoom);
              if ("number" != typeof i5) return [new e3.V(l5, r5[0].zoom, "stop zoom values must be numbers")];
              if (n3 && n3 > i5) return [new e3.V(l5, r5[0].zoom, "stop zoom values must appear in ascending order")];
              i5 !== n3 && (n3 = i5, s4 = void 0, a4 = {}), o4 = o4.concat(T4({ key: `${l5}[0]`, value: r5[0], valueSpec: { zoom: {} }, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { zoom: S2, value: _4 } }));
            } else o4 = o4.concat(_4({ key: `${l5}[0]`, value: r5[0], valueSpec: {}, style: t5.style, styleSpec: t5.styleSpec }, r5));
            return e3.o(e3.q(r5[1])) ? o4.concat([new e3.V(`${l5}[1]`, r5[1], "expressions are not allowed in function stops.")]) : o4.concat(W2({ key: `${l5}[1]`, value: r5[1], valueSpec: i4, style: t5.style, styleSpec: t5.styleSpec }));
          }
          function _4(t5, n4) {
            const l5 = e3.j(t5.value), c5 = e3.u(t5.value), h5 = null !== t5.value ? t5.value : n4;
            if (r4) {
              if (l5 !== r4) return [new e3.V(t5.key, h5, `${l5} stop domain type must match previous stop domain type ${r4}`)];
            } else r4 = l5;
            if ("number" !== l5 && "string" !== l5 && "boolean" !== l5 && "number" != typeof c5 && "string" != typeof c5 && "boolean" != typeof c5) return [new e3.V(t5.key, h5, "stop domain value must be a number, string, or boolean")];
            if ("number" !== l5 && "categorical" !== o3) {
              let r5 = `number expected, ${l5} found`;
              return e3.m(i4) && void 0 === o3 && (r5 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new e3.V(t5.key, h5, r5)];
            }
            return "categorical" !== o3 || "number" !== l5 || "number" == typeof c5 && isFinite(c5) && Math.floor(c5) === c5 ? "categorical" !== o3 && "number" === l5 && "number" == typeof c5 && "number" == typeof s4 && void 0 !== s4 && c5 < s4 ? [new e3.V(t5.key, h5, "stop domain values must appear in ascending order")] : (s4 = c5, "categorical" === o3 && c5 in a4 ? [new e3.V(t5.key, h5, "stop domain values must be unique")] : (a4[c5] = true, [])) : [new e3.V(t5.key, h5, `integer expected, found ${String(c5)}`)];
          }
        }
        function I3(t4) {
          const i4 = ("property" === t4.expressionContext ? e3.r : e3.t)(e3.q(t4.value), t4.valueSpec);
          if ("error" === i4.result) return i4.value.map((i5) => new e3.V(`${t4.key}${i5.key}`, t4.value, i5.message));
          const o3 = i4.value.expression || i4.value._styleExpression.expression;
          if ("property" === t4.expressionContext && "text-font" === t4.propertyKey && !o3.outputDefined()) return [new e3.V(t4.key, t4.value, `Invalid data expression for "${t4.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t4.expressionContext && "layout" === t4.propertyType && !e3.v(o3)) return [new e3.V(t4.key, t4.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t4.expressionContext) return D3(o3, t4);
          if (t4.expressionContext && 0 === t4.expressionContext.indexOf("cluster")) {
            if (!e3.x(o3, ["zoom", "feature-state"])) return [new e3.V(t4.key, t4.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t4.expressionContext && !e3.y(o3)) return [new e3.V(t4.key, t4.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function D3(t4, i4) {
          const o3 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
          if (i4.valueSpec && i4.valueSpec.expression) for (const e4 of i4.valueSpec.expression.parameters) o3.delete(e4);
          if (0 === o3.size) return [];
          const r4 = [];
          return t4 instanceof e3.C && o3.has(t4.name) ? [new e3.V(i4.key, i4.value, `["${t4.name}"] expression is not supported in a filter for a ${i4.object.type} layer with id: ${i4.object.id}`)] : (t4.eachChild((e4) => {
            r4.push(...D3(e4, i4));
          }), r4);
        }
        function R(t4) {
          const i4 = t4.key, o3 = t4.value, r4 = t4.valueSpec, s4 = [];
          return Array.isArray(r4.values) ? -1 === r4.values.indexOf(e3.u(o3)) && s4.push(new e3.V(i4, o3, `expected one of [${r4.values.join(", ")}], ${JSON.stringify(o3)} found`)) : -1 === Object.keys(r4.values).indexOf(e3.u(o3)) && s4.push(new e3.V(i4, o3, `expected one of [${Object.keys(r4.values).join(", ")}], ${JSON.stringify(o3)} found`)), s4;
        }
        function A3(t4) {
          return e3.A(e3.q(t4.value)) ? I3(e3.k({}, t4, { expressionContext: "filter", valueSpec: t4.styleSpec[`filter_${t4.layerType || "fill"}`] })) : P3(t4);
        }
        function P3(t4) {
          const i4 = t4.value, o3 = t4.key;
          if ("array" !== e3.j(i4)) return [new e3.V(o3, i4, `array expected, ${e3.j(i4)} found`)];
          const r4 = t4.styleSpec;
          let s4, n3 = [];
          if (i4.length < 1) return [new e3.V(o3, i4, "filter array must have at least 1 element")];
          switch (n3 = n3.concat(R({ key: `${o3}[0]`, value: i4[0], valueSpec: r4.filter_operator, style: t4.style, styleSpec: t4.styleSpec })), e3.u(i4[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              i4.length >= 2 && "$type" === e3.u(i4[1]) && n3.push(new e3.V(o3, i4, `"$type" cannot be use with operator "${i4[0]}"`));
            case "==":
            case "!=":
              3 !== i4.length && n3.push(new e3.V(o3, i4, `filter array for operator "${i4[0]}" must have 3 elements`));
            case "in":
            case "!in":
              i4.length >= 2 && (s4 = e3.j(i4[1]), "string" !== s4 && n3.push(new e3.V(`${o3}[1]`, i4[1], `string expected, ${s4} found`)));
              for (let a4 = 2; a4 < i4.length; a4++) s4 = e3.j(i4[a4]), "$type" === e3.u(i4[1]) ? n3 = n3.concat(R({ key: `${o3}[${a4}]`, value: i4[a4], valueSpec: r4.geometry_type, style: t4.style, styleSpec: t4.styleSpec })) : "string" !== s4 && "number" !== s4 && "boolean" !== s4 && n3.push(new e3.V(`${o3}[${a4}]`, i4[a4], `string, number, or boolean expected, ${s4} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let e4 = 1; e4 < i4.length; e4++) n3 = n3.concat(P3({ key: `${o3}[${e4}]`, value: i4[e4], style: t4.style, styleSpec: t4.styleSpec }));
              break;
            case "has":
            case "!has":
              s4 = e3.j(i4[1]), 2 !== i4.length ? n3.push(new e3.V(o3, i4, `filter array for "${i4[0]}" operator must have 2 elements`)) : "string" !== s4 && n3.push(new e3.V(`${o3}[1]`, i4[1], `string expected, ${s4} found`));
          }
          return n3;
        }
        function L3(t4, i4) {
          const o3 = t4.key, r4 = t4.style, s4 = t4.layer, n3 = t4.styleSpec, a4 = t4.value, l4 = t4.objectKey, c4 = n3[`${i4}_${t4.layerType}`];
          if (!c4) return [];
          const h4 = l4.match(/^(.*)-transition$/);
          if ("paint" === i4 && h4 && c4[h4[1]] && c4[h4[1]].transition) return W2({ key: o3, value: a4, valueSpec: n3.transition, style: r4, styleSpec: n3 });
          const u5 = t4.valueSpec || c4[l4];
          if (!u5) return [new e3.i(o3, a4, `unknown property "${l4}"`)];
          let d3;
          if ("string" === e3.j(a4) && e3.m(u5) && !u5.tokens && (d3 = /^{([^}]+)}$/.exec(a4))) {
            const t5 = `\`{ "type": "identity", "property": ${d3 ? JSON.stringify(d3[1]) : '"_"'} }\``;
            return [new e3.V(o3, a4, `"${l4}" does not support interpolation syntax
Use an identity property function instead: ${t5}.`)];
          }
          const _4 = [];
          if ("symbol" === t4.layerType) "text-field" !== l4 || !r4 || r4.glyphs || r4.imports || _4.push(new e3.V(o3, a4, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l4 && e3.B(e3.q(a4)) && "identity" === e3.u(a4.type) && _4.push(new e3.V(o3, a4, '"text-font" does not support identity functions'));
          else if ("model" === t4.layerType && "paint" === i4 && s4 && s4.layout && s4.layout.hasOwnProperty("model-id") && e3.m(u5) && (e3.D(u5) || e3.n(u5))) {
            const t5 = e3.r(e3.q(a4), u5), i5 = t5.value.expression || t5.value._styleExpression.expression;
            i5 && !e3.x(i5, ["measure-light"]) && ("model-emissive-strength" === l4 && e3.y(i5) && e3.v(i5) || _4.push(new e3.V(o3, a4, `${l4} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
          }
          return _4.concat(W2({ key: t4.key, value: a4, valueSpec: u5, style: r4, styleSpec: n3, expressionContext: "property", propertyType: i4, propertyKey: l4 }));
        }
        function M2(e4) {
          return L3(e4, "paint");
        }
        function z3(e4) {
          return L3(e4, "layout");
        }
        function O2(t4) {
          let i4 = [];
          const o3 = t4.value, r4 = t4.key, s4 = t4.style, n3 = t4.styleSpec;
          o3.type || o3.ref || i4.push(new e3.V(r4, o3, 'either "type" or "ref" is required'));
          let a4 = e3.u(o3.type);
          const l4 = e3.u(o3.ref);
          if (o3.id) {
            const n4 = e3.u(o3.id);
            for (let a5 = 0; a5 < t4.arrayIndex; a5++) {
              const t5 = s4.layers[a5];
              e3.u(t5.id) === n4 && i4.push(new e3.V(r4, o3.id, `duplicate layer id "${o3.id}", previously used at line ${t5.id.__line__}`));
            }
          }
          if ("ref" in o3) {
            let t5;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t6) => {
              t6 in o3 && i4.push(new e3.V(r4, o3[t6], `"${t6}" is prohibited for ref layers`));
            }), s4.layers.forEach((i5) => {
              e3.u(i5.id) === l4 && (t5 = i5);
            }), t5 ? t5.ref ? i4.push(new e3.V(r4, o3.ref, "ref cannot reference another ref layer")) : a4 = e3.u(t5.type) : "string" == typeof l4 && i4.push(new e3.V(r4, o3.ref, `ref layer "${l4}" not found`));
          } else if ("background" !== a4 && "sky" !== a4 && "slot" !== a4) if (o3.source) {
            const t5 = s4.sources && s4.sources[o3.source], n4 = t5 && e3.u(t5.type);
            t5 ? "vector" === n4 && "raster" === a4 ? i4.push(new e3.V(r4, o3.source, `layer "${o3.id}" requires a raster source`)) : "raster" === n4 && "raster" !== a4 ? i4.push(new e3.V(r4, o3.source, `layer "${o3.id}" requires a vector source`)) : "vector" !== n4 || o3["source-layer"] ? "raster-dem" === n4 && "hillshade" !== a4 ? i4.push(new e3.V(r4, o3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== n4 || ["raster", "raster-particle"].includes(a4) ? "line" !== a4 || !o3.paint || !o3.paint["line-gradient"] && !o3.paint["line-trim-offset"] || "geojson" === n4 && t5.lineMetrics ? "raster-particle" === a4 && "raster-array" !== n4 && i4.push(new e3.V(r4, o3.source, `layer "${o3.id}" requires a 'raster-array' source.`)) : i4.push(new e3.V(r4, o3, `layer "${o3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : i4.push(new e3.V(r4, o3.source, "raster-array source can only be used with layer type 'raster'.")) : i4.push(new e3.V(r4, o3, `layer "${o3.id}" must specify a "source-layer"`)) : i4.push(new e3.V(r4, o3.source, `source "${o3.source}" not found`));
          } else i4.push(new e3.V(r4, o3, 'missing required property "source"'));
          return i4 = i4.concat(T4({ key: r4, value: o3, valueSpec: n3.layer, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { "*": () => [], type: () => W2({ key: `${r4}.type`, value: o3.type, valueSpec: n3.layer.type, style: t4.style, styleSpec: t4.styleSpec, object: o3, objectKey: "type" }), filter: (t5) => A3(e3.k({ layerType: a4 }, t5)), layout: (t5) => T4({ layer: o3, key: t5.key, value: t5.value, valueSpec: {}, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { "*": (t6) => z3(e3.k({ layerType: a4 }, t6)) } }), paint: (t5) => T4({ layer: o3, key: t5.key, value: t5.value, valueSpec: {}, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { "*": (t6) => M2(e3.k({ layerType: a4, layer: o3 }, t6)) } }) } })), i4;
        }
        function F4(t4) {
          const i4 = t4.value, o3 = t4.key, r4 = e3.j(i4);
          return "string" !== r4 ? [new e3.V(o3, i4, `string expected, ${r4} found`)] : [];
        }
        const B3 = { promoteId: function({ key: t4, value: i4 }) {
          if ("string" === e3.j(i4)) return F4({ key: t4, value: i4 });
          {
            const e4 = [];
            for (const o3 in i4) e4.push(...F4({ key: `${t4}.${o3}`, value: i4[o3] }));
            return e4;
          }
        } };
        function k3(t4) {
          const i4 = t4.value, o3 = t4.key, r4 = t4.styleSpec, s4 = t4.style;
          if (!i4.type) return [new e3.V(o3, i4, '"type" is required')];
          const n3 = e3.u(i4.type);
          let a4 = [];
          switch (["vector", "raster", "raster-dem", "raster-array"].includes(n3) && (i4.url || i4.tiles || a4.push(new e3.i(o3, i4, 'Either "url" or "tiles" is required.'))), n3) {
            case "vector":
            case "raster":
            case "raster-dem":
            case "raster-array":
              return a4 = a4.concat(T4({ key: o3, value: i4, valueSpec: r4[`source_${n3.replace("-", "_")}`], style: t4.style, styleSpec: r4, objectElementValidators: B3 })), a4;
            case "geojson":
              if (a4 = T4({ key: o3, value: i4, valueSpec: r4.source_geojson, style: s4, styleSpec: r4, objectElementValidators: B3 }), i4.cluster) for (const e4 in i4.clusterProperties) {
                const [t5, r5] = i4.clusterProperties[e4], s5 = "string" == typeof t5 ? [t5, ["accumulated"], ["get", e4]] : t5;
                a4.push(...I3({ key: `${o3}.${e4}.map`, value: r5, expressionContext: "cluster-map" })), a4.push(...I3({ key: `${o3}.${e4}.reduce`, value: s5, expressionContext: "cluster-reduce" }));
              }
              return a4;
            case "video":
              return T4({ key: o3, value: i4, valueSpec: r4.source_video, style: s4, styleSpec: r4 });
            case "image":
              return T4({ key: o3, value: i4, valueSpec: r4.source_image, style: s4, styleSpec: r4 });
            case "canvas":
              return [new e3.V(o3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return R({ key: `${o3}.type`, value: i4.type, valueSpec: { values: N3(r4) }, style: s4, styleSpec: r4 });
          }
        }
        function N3(e4) {
          return e4.source.reduce((t4, i4) => {
            const o3 = e4[i4];
            return "enum" === o3.type.type && (t4 = t4.concat(Object.keys(o3.type.values))), t4;
          }, []);
        }
        function U2(t4) {
          const i4 = t4.value, o3 = t4.styleSpec, r4 = o3.light, s4 = t4.style;
          let n3 = [];
          const a4 = e3.j(i4);
          if (void 0 === i4) return n3;
          if ("object" !== a4) return n3 = n3.concat([new e3.V("light", i4, `object expected, ${a4} found`)]), n3;
          for (const t5 in i4) {
            const a5 = t5.match(/^(.*)-transition$/);
            n3 = n3.concat(a5 && r4[a5[1]] && r4[a5[1]].transition ? W2({ key: t5, value: i4[t5], valueSpec: o3.transition, style: s4, styleSpec: o3 }) : r4[t5] ? W2({ key: t5, value: i4[t5], valueSpec: r4[t5], style: s4, styleSpec: o3 }) : [new e3.V(t5, i4[t5], `unknown property "${t5}"`)]);
          }
          return n3;
        }
        function G3(t4) {
          const i4 = t4.value;
          let o3 = [];
          if (!i4) return o3;
          const r4 = e3.j(i4);
          if ("object" !== r4) return o3 = o3.concat([new e3.V("light-3d", i4, `object expected, ${r4} found`)]), o3;
          const s4 = t4.styleSpec, n3 = s4["light-3d"], a4 = t4.key, l4 = t4.style, c4 = t4.style.lights;
          for (const t5 of ["type", "id"]) if (!(t5 in i4)) return o3 = o3.concat([new e3.V("light-3d", i4, `missing property ${t5} on light`)]), o3;
          if (i4.type && c4) for (let r5 = 0; r5 < t4.arrayIndex; r5++) {
            const t5 = e3.u(i4.type), s5 = c4[r5];
            e3.u(s5.type) === t5 && o3.push(new e3.V(a4, i4.id, `duplicate light type "${i4.type}", previously defined at line ${s5.id.__line__}`));
          }
          const h4 = `properties_light_${i4.type}`;
          if (!(h4 in s4)) return o3 = o3.concat([new e3.V("light-3d", i4, `Invalid light type ${i4.type}`)]), o3;
          const u5 = s4[h4];
          for (const r5 in i4) if ("properties" === r5) {
            const n4 = i4[r5], a5 = e3.j(n4);
            if ("object" !== a5) return o3 = o3.concat([new e3.V("properties", n4, `object expected, ${a5} found`)]), o3;
            for (const i5 in n4) o3 = o3.concat(u5[i5] ? W2({ key: i5, value: n4[i5], valueSpec: u5[i5], style: l4, styleSpec: s4 }) : [new e3.i(t4.key, n4[i5], `unknown property "${i5}"`)]);
          } else {
            const t5 = r5.match(/^(.*)-transition$/);
            o3 = o3.concat(t5 && n3[t5[1]] && n3[t5[1]].transition ? W2({ key: r5, value: i4[r5], valueSpec: s4.transition, style: l4, styleSpec: s4 }) : n3[r5] ? W2({ key: r5, value: i4[r5], valueSpec: n3[r5], style: l4, styleSpec: s4 }) : [new e3.i(r5, i4[r5], `unknown property "${r5}"`)]);
          }
          return o3;
        }
        function j4(t4) {
          const i4 = t4.value, o3 = t4.key, r4 = t4.style, s4 = t4.styleSpec, n3 = s4.terrain;
          let a4 = [];
          const l4 = e3.j(i4);
          if (void 0 === i4) return a4;
          if ("null" === l4) return a4;
          if ("object" !== l4) return a4 = a4.concat([new e3.V("terrain", i4, `object expected, ${l4} found`)]), a4;
          for (const t5 in i4) {
            const o4 = t5.match(/^(.*)-transition$/);
            a4 = a4.concat(o4 && n3[o4[1]] && n3[o4[1]].transition ? W2({ key: t5, value: i4[t5], valueSpec: s4.transition, style: r4, styleSpec: s4 }) : n3[t5] ? W2({ key: t5, value: i4[t5], valueSpec: n3[t5], style: r4, styleSpec: s4 }) : [new e3.i(t5, i4[t5], `unknown property "${t5}"`)]);
          }
          if (i4.source) {
            const t5 = r4.sources && r4.sources[i4.source], s5 = t5 && e3.u(t5.type);
            t5 ? "raster-dem" !== s5 && a4.push(new e3.V(o3, i4.source, `terrain cannot be used with a source of type ${String(s5)}, it only be used with a "raster-dem" source type`)) : a4.push(new e3.V(o3, i4.source, `source "${i4.source}" not found`));
          } else a4.push(new e3.V(o3, i4, 'terrain is missing required property "source"'));
          return a4;
        }
        function V3(t4) {
          const i4 = t4.value, o3 = t4.style, r4 = t4.styleSpec, s4 = r4.fog;
          let n3 = [];
          const a4 = e3.j(i4);
          if (void 0 === i4) return n3;
          if ("object" !== a4) return n3 = n3.concat([new e3.V("fog", i4, `object expected, ${a4} found`)]), n3;
          for (const t5 in i4) {
            const a5 = t5.match(/^(.*)-transition$/);
            n3 = n3.concat(a5 && s4[a5[1]] && s4[a5[1]].transition ? W2({ key: t5, value: i4[t5], valueSpec: r4.transition, style: o3, styleSpec: r4 }) : s4[t5] ? W2({ key: t5, value: i4[t5], valueSpec: s4[t5], style: o3, styleSpec: r4 }) : [new e3.i(t5, i4[t5], `unknown property "${t5}"`)]);
          }
          return n3;
        }
        const Z2 = { "*": () => [], array: E2, boolean: function(t4) {
          const i4 = t4.value, o3 = t4.key, r4 = e3.j(i4);
          return "boolean" !== r4 ? [new e3.V(o3, i4, `boolean expected, ${r4} found`)] : [];
        }, number: S2, color: function(t4) {
          const i4 = t4.key, o3 = t4.value, r4 = e3.j(o3);
          return "string" !== r4 ? [new e3.V(i4, o3, `color expected, ${r4} found`)] : null === e3.z(o3) ? [new e3.V(i4, o3, `color expected, "${o3}" found`)] : [];
        }, enum: R, filter: A3, function: C3, layer: O2, object: T4, source: k3, model: e3.F, light: U2, "light-3d": G3, terrain: j4, fog: V3, string: F4, formatted: function(e4) {
          return 0 === F4(e4).length ? [] : I3(e4);
        }, resolvedImage: function(e4) {
          return 0 === F4(e4).length ? [] : I3(e4);
        }, projection: function(t4) {
          const i4 = t4.value, o3 = t4.styleSpec, r4 = o3.projection, s4 = t4.style;
          let n3 = [];
          const a4 = e3.j(i4);
          if ("object" === a4) for (const e4 in i4) n3 = n3.concat(W2({ key: e4, value: i4[e4], valueSpec: r4[e4], style: s4, styleSpec: o3 }));
          else "string" !== a4 && (n3 = n3.concat([new e3.V("projection", i4, `object or string expected, ${a4} found`)]));
          return n3;
        }, import: function(t4) {
          const { value: i4, styleSpec: o3 } = t4, _a2 = i4, { data: r4 } = _a2, s4 = __objRest(_a2, ["data"]);
          Object.defineProperty(s4, "__line__", { value: i4.__line__, enumerable: false });
          let n3 = T4(e3.k({}, t4, { value: s4, valueSpec: o3.import }));
          return "" === e3.u(s4.id) && n3.push(new e3.V(`${t4.key}.id`, s4, "import id can't be an empty string")), r4 && (n3 = n3.concat(q3(r4, o3, { key: `${t4.key}.data` }))), n3;
        } };
        function W2(t4, i4 = false) {
          const o3 = t4.value, r4 = t4.valueSpec, s4 = t4.styleSpec;
          if (r4.expression && e3.B(e3.u(o3))) return C3(t4);
          if (r4.expression && e3.o(e3.q(o3))) return I3(t4);
          if (r4.type && Z2[r4.type]) {
            const o4 = Z2[r4.type](t4);
            return true === i4 && o4.length > 0 && "array" === e3.j(t4.value) ? I3(t4) : o4;
          }
          return T4(e3.k({}, t4, { valueSpec: r4.type ? s4[r4.type] : r4 }));
        }
        function H3(t4) {
          const i4 = t4.value, o3 = t4.key, r4 = F4(t4);
          return r4.length || (-1 === i4.indexOf("{fontstack}") && r4.push(new e3.V(o3, i4, '"glyphs" url must include a "{fontstack}" token')), -1 === i4.indexOf("{range}") && r4.push(new e3.V(o3, i4, '"glyphs" url must include a "{range}" token'))), r4;
        }
        function q3(t4, i4 = e3.G, o3 = {}) {
          return W2({ key: o3.key || "", value: t4, valueSpec: i4.$root, styleSpec: i4, style: t4, objectElementValidators: { glyphs: H3, "*": () => [] } });
        }
        function Q2(t4, i4 = e3.G) {
          return se(q3(t4, i4));
        }
        const $3 = (e4) => se(k3(e4)), X2 = (e4) => se(U2(e4)), Y = (e4) => se(G3(e4)), J2 = (e4) => se(j4(e4)), K2 = (e4) => se(V3(e4)), ee = (e4) => se(O2(e4)), te = (e4) => se(A3(e4)), ie = (e4) => se(M2(e4)), oe = (e4) => se(z3(e4)), re = (t4) => se(e3.F(t4));
        function se(e4) {
          return e4.slice().sort((e5, t4) => e5.line && t4.line ? e5.line - t4.line : 0);
        }
        function ne(t4, i4) {
          let o3 = false;
          if (i4 && i4.length) for (const r4 of i4) r4 instanceof e3.i ? e3.w(r4.message) : (t4.fire(new e3.a(new Error(r4.message))), o3 = true);
          return o3;
        }
        const ae = new e3.H({ anchor: new e3.J(e3.G.light.anchor), position: new e3.K(e3.G.light.position), color: new e3.J(e3.G.light.color), intensity: new e3.J(e3.G.light.intensity) });
        class le extends e3.E {
          constructor(t4, i4 = "flat") {
            super(), this._transitionable = new e3.L(ae), this.setLight(t4, i4), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e4, t4, i4 = {}) {
            this._validate(X2, e4, i4) || (this._transitionable.setTransitionOrValue(e4), this.id = t4);
          }
          updateTransitions(e4) {
            this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e4) {
            this.properties = this._transitioning.possiblyEvaluate(e4);
          }
          _validate(t4, i4, o3) {
            return (!o3 || false !== o3.validate) && ne(this, t4.call(Q2, e3.e({ value: i4, style: { glyphs: true, sprite: true }, styleSpec: e3.G })));
          }
        }
        const ce = new e3.H({ source: new e3.J(e3.G.terrain.source), exaggeration: new e3.J(e3.G.terrain.exaggeration) });
        let he = class extends e3.E {
          constructor(t4, i4, o3, r4) {
            super(), this.scope = o3, this._transitionable = new e3.L(ce, o3, r4), this._transitionable.setTransitionOrValue(t4, r4), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i4;
          }
          get() {
            return this._transitionable.serialize();
          }
          set(e4, t4) {
            this._transitionable.setTransitionOrValue(e4, t4);
          }
          updateTransitions(e4) {
            this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e4) {
            this.properties = this._transitioning.possiblyEvaluate(e4);
          }
          getExaggeration(t4) {
            return this._transitioning.possiblyEvaluate(new e3.N(t4)).get("exaggeration");
          }
          isZoomDependent() {
            const t4 = this._transitionable._values.exaggeration;
            return null != t4 && null != t4.value && null != t4.value.expression && t4.value.expression instanceof e3.Z;
          }
        };
        const ue = 45, de = 65, _e = 0.05;
        function pe(t4, i4, o3, r4) {
          const s4 = e3.S(ue, de, o3), [n3, a4] = fe(t4, r4);
          let l4 = 1 - Math.min(1, Math.exp((i4 - n3) / (a4 - n3) * -6));
          return l4 *= l4 * l4, l4 = Math.min(1, 1.00747 * l4), l4 * s4 * t4.alpha;
        }
        function fe(e4, t4) {
          const i4 = 0.5 / Math.tan(0.5 * t4);
          return [e4.range[0] + i4, e4.range[1] + i4];
        }
        function me(t4, i4, o3, r4, s4) {
          const n3 = e3.Q.transformMat4([], [i4, o3, r4], s4.mercatorFogMatrix);
          return pe(t4, e3.Q.length(n3), s4.pitch, s4._fov);
        }
        function ge(t4, i4, o3, r4, s4, n3, a4) {
          const l4 = [[o3, r4, 0], [s4, r4, 0], [s4, n3, 0], [o3, n3, 0]];
          let c4 = Number.MAX_VALUE, h4 = -Number.MAX_VALUE;
          for (const t5 of l4) {
            const o4 = e3.Q.transformMat4([], t5, i4), r5 = e3.Q.length(o4);
            c4 = Math.min(c4, r5), h4 = Math.max(h4, r5);
          }
          return [pe(t4, c4, a4.pitch, a4._fov), pe(t4, h4, a4.pitch, a4._fov)];
        }
        const ve = new e3.H({ range: new e3.J(e3.G.fog.range), color: new e3.J(e3.G.fog.color), "high-color": new e3.J(e3.G.fog["high-color"]), "space-color": new e3.J(e3.G.fog["space-color"]), "horizon-blend": new e3.J(e3.G.fog["horizon-blend"]), "star-intensity": new e3.J(e3.G.fog["star-intensity"]), "vertical-range": new e3.J(e3.G.fog["vertical-range"]) });
        class xe extends e3.E {
          constructor(t4, i4, o3, r4) {
            super(), this._transitionable = new e3.L(ve, o3, new Map(r4)), this.set(t4, r4), this._transitioning = this._transitionable.untransitioned(), this._transform = i4, this.properties = new e3.U(ve);
          }
          get state() {
            const t4 = this._transform, i4 = "globe" === t4.projection.name, o3 = e3.W(t4.zoom), r4 = this.properties.get("range"), s4 = [0.5, 3];
            return { range: i4 ? [e3.X(s4[0], r4[0], o3), e3.X(s4[1], r4[1], o3)] : r4, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t4, i4, o3 = {}) {
            if (this._validate(K2, t4, o3)) return;
            const r4 = e3.e({}, t4);
            for (const t5 of Object.keys(e3.G.fog)) void 0 === r4[t5] && (r4[t5] = e3.G.fog[t5].default);
            this._options = r4, this._transitionable.setTransitionOrValue(this._options, i4);
          }
          getOpacity(t4) {
            if (!this._transform.projection.supportsFog) return 0;
            const i4 = this.properties && this.properties.get("color") || 1;
            return ("globe" === this._transform.projection.name ? 1 : e3.S(ue, de, t4)) * i4.a;
          }
          getOpacityAtLatLng(t4, i4) {
            return this._transform.projection.supportsFog ? function(t5, i5, o3) {
              const r4 = e3.O.fromLngLat(i5), s4 = o3.elevation ? o3.elevation.getAtPointOrZero(r4) : 0;
              return me(t5, r4.x, r4.y, s4, o3);
            }(this.state, t4, i4) : 0;
          }
          getOpacityForTile(t4) {
            if (!this._transform.projection.supportsFog) return [1, 1];
            const i4 = this._transform.calculateFogTileMatrix(t4.toUnwrapped());
            return ge(this.state, i4, 0, 0, e3.Y, e3.Y, this._transform);
          }
          getOpacityForBounds(e4, t4, i4, o3, r4) {
            return this._transform.projection.supportsFog ? ge(this.state, e4, t4, i4, o3, r4, this._transform) : [1, 1];
          }
          getFovAdjustedRange(e4) {
            return this._transform.projection.supportsFog ? fe(this.state, e4) : [0, 1];
          }
          isVisibleOnFrustum(t4) {
            if (!this._transform.projection.supportsFog) return false;
            const i4 = [4, 5, 6, 7];
            for (const o3 of i4) {
              const i5 = t4.points[o3];
              let r4;
              if (i5[2] >= 0) r4 = i5;
              else {
                const s4 = t4.points[o3 - 4];
                r4 = e3._(s4, i5, s4[2] / (s4[2] - i5[2]));
              }
              if (me(this.state, r4[0], r4[1], 0, this._transform) >= _e) return true;
            }
            return false;
          }
          updateConfig(e4) {
            this._transitionable.setTransitionOrValue(this._options, new Map(e4));
          }
          updateTransitions(e4) {
            this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e4) {
            this.properties = this._transitioning.possiblyEvaluate(e4);
          }
          _validate(t4, i4, o3) {
            return (!o3 || false !== o3.validate) && ne(this, t4.call(Q2, e3.e({ value: i4, style: { glyphs: true, sprite: true }, styleSpec: e3.G })));
          }
        }
        class ye extends e3.E {
          constructor(t4, i4, o3, r4) {
            super(), this.scope = o3, this._options = t4, this.properties = new e3.U(i4), this._transitionable = new e3.L(i4, o3, new Map(r4)), this._transitionable.setTransitionOrValue(t4.properties), this._transitioning = this._transitionable.untransitioned();
          }
          updateConfig(e4) {
            this._transitionable.setTransitionOrValue(this._options.properties, new Map(e4));
          }
          updateTransitions(e4) {
            this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e4) {
            this.properties = this._transitioning.possiblyEvaluate(e4);
          }
          get() {
            return this._options.properties = this._transitionable.serialize(), this._options;
          }
          set(e4, t4) {
            this._options = e4, this._transitionable.setTransitionOrValue(e4.properties, t4);
          }
          shadowsEnabled() {
            return !!this.properties && true === this.properties.get("cast-shadows");
          }
        }
        const be = new e3.H({ color: new e3.J(e3.G.properties_light_ambient.color), intensity: new e3.J(e3.G.properties_light_ambient.intensity) }), we = new e3.H({ direction: new e3.$(e3.G.properties_light_directional.direction), color: new e3.J(e3.G.properties_light_directional.color), intensity: new e3.J(e3.G.properties_light_directional.intensity), "cast-shadows": new e3.J(e3.G.properties_light_directional["cast-shadows"]), "shadow-intensity": new e3.J(e3.G.properties_light_directional["shadow-intensity"]) });
        class Te {
          constructor(e4, t4, i4, o3) {
            this.screenBounds = e4, this.cameraPoint = t4, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i4, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o3);
          }
          static createFromScreenPoints(t4, i4) {
            let o3, r4;
            if (t4 instanceof e3.P || "number" == typeof t4[0]) {
              const s4 = e3.P.convert(t4);
              o3 = [s4], r4 = i4.isPointAboveHorizon(s4);
            } else {
              const s4 = e3.P.convert(t4[0]), n3 = e3.P.convert(t4[1]);
              o3 = [s4, n3], r4 = e3.a0(s4, n3).every((e4) => i4.isPointAboveHorizon(e4));
            }
            return new Te(o3, i4.getCameraPoint(), r4, i4);
          }
          isPointQuery() {
            return 1 === this.screenBounds.length;
          }
          bufferedScreenGeometry(t4) {
            return e3.a0(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t4);
          }
          bufferedCameraGeometry(t4) {
            const i4 = this.screenBounds[0], o3 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e3.P(1, 1)) : this.screenBounds[1], r4 = e3.a0(i4, o3, 0, false);
            return this.cameraPoint.y > o3.y && (this.cameraPoint.x > i4.x && this.cameraPoint.x < o3.x ? r4.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o3.x ? r4[2] = this.cameraPoint : this.cameraPoint.x <= i4.x && (r4[3] = this.cameraPoint)), e3.a1(r4, t4);
          }
          bufferedCameraGeometryGlobe(t4) {
            const i4 = this.screenBounds[0], o3 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e3.P(1, 1)) : this.screenBounds[1], r4 = e3.a0(i4, o3, t4), s4 = this.cameraPoint.clone();
            switch (3 * ((s4.y > i4.y) + (s4.y > o3.y)) + ((s4.x > i4.x) + (s4.x > o3.x))) {
              case 0:
                r4[0] = s4, r4[4] = s4.clone();
                break;
              case 1:
                r4.splice(1, 0, s4);
                break;
              case 2:
                r4[1] = s4;
                break;
              case 3:
                r4.splice(4, 0, s4);
                break;
              case 5:
                r4.splice(2, 0, s4);
                break;
              case 6:
                r4[3] = s4;
                break;
              case 7:
                r4.splice(3, 0, s4);
                break;
              case 8:
                r4[2] = s4;
            }
            return r4;
          }
          containsTile(t4, i4, o3, r4 = 0) {
            const s4 = t4.queryPadding / i4._pixelsPerMercatorPixel + 1, n3 = o3 ? this._bufferedCameraMercator(s4, i4) : this._bufferedScreenMercator(s4, i4);
            let a4 = t4.tileID.wrap + (n3.unwrapped ? r4 : 0);
            const l4 = n3.polygon.map((i5) => e3.a2(t4.tileTransform, i5, a4));
            if (!e3.a3(l4, 0, 0, e3.Y, e3.Y)) return;
            a4 = t4.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r4 : 0);
            const c4 = this.screenGeometryMercator.polygon.map((i5) => e3.a4(t4.tileTransform, i5, a4)), h4 = c4.map((t5) => new e3.P(t5[0], t5[1])), u5 = i4.getFreeCameraOptions().position || new e3.O(0, 0, 0), d3 = e3.a4(t4.tileTransform, u5, a4), _4 = c4.map((t5) => {
              const i5 = e3.Q.sub(t5, t5, d3);
              return e3.Q.normalize(i5, i5), new e3.a5(d3, i5);
            }), p4 = e3.a6(t4, 1, i4.zoom) * i4._pixelsPerMercatorPixel;
            return { queryGeometry: this, tilespaceGeometry: h4, tilespaceRays: _4, bufferedTilespaceGeometry: l4, bufferedTilespaceBounds: (f4 = e3.a7(l4), f4.min.x = e3.ad(f4.min.x, 0, e3.Y), f4.min.y = e3.ad(f4.min.y, 0, e3.Y), f4.max.x = e3.ad(f4.max.x, 0, e3.Y), f4.max.y = e3.ad(f4.max.y, 0, e3.Y), f4), tile: t4, tileID: t4.tileID, pixelToTileUnitsFactor: p4 };
            var f4;
          }
          _bufferedScreenMercator(e4, t4) {
            const i4 = Ce(e4);
            if (this._screenRaycastCache[i4]) return this._screenRaycastCache[i4];
            {
              let o3;
              return o3 = "globe" === t4.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e4), t4) : { polygon: this.bufferedScreenGeometry(e4).map((e5) => t4.pointCoordinate3D(e5)), unwrapped: true }, this._screenRaycastCache[i4] = o3, o3;
            }
          }
          _bufferedCameraMercator(e4, t4) {
            const i4 = Ce(e4);
            if (this._cameraRaycastCache[i4]) return this._cameraRaycastCache[i4];
            {
              let o3;
              return o3 = "globe" === t4.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e4), t4) : { polygon: this.bufferedCameraGeometry(e4).map((e5) => t4.pointCoordinate3D(e5)), unwrapped: true }, this._cameraRaycastCache[i4] = o3, o3;
            }
          }
          _projectAndResample(t4, i4) {
            const o3 = function(t5, i5) {
              const o4 = e3.a9.multiply([], i5.pixelMatrix, i5.globeMatrix), r5 = [0, -e3.ae, 0, 1], s4 = [0, e3.ae, 0, 1], n3 = [0, 0, 0, 1];
              e3.aa.transformMat4(r5, r5, o4), e3.aa.transformMat4(s4, s4, o4), e3.aa.transformMat4(n3, n3, o4);
              const a4 = new e3.P(r5[0] / r5[3], r5[1] / r5[3]), l4 = new e3.P(s4[0] / s4[3], s4[1] / s4[3]), c4 = e3.ab(t5, a4) && r5[3] < n3[3], h4 = e3.ab(t5, l4) && s4[3] < n3[3];
              if (!c4 && !h4) return null;
              const u5 = function(e4, t6, i6) {
                for (let o5 = 1; o5 < e4.length; o5++) {
                  const r6 = Se(t6.pointCoordinate3D(e4[o5 - 1]).x), s5 = Se(t6.pointCoordinate3D(e4[o5]).x);
                  if (i6 < 0) {
                    if (r6 < s5) return { idx: o5, t: -r6 / (s5 - 1 - r6) };
                  } else if (s5 < r6) return { idx: o5, t: (1 - r6) / (s5 + 1 - r6) };
                }
                return null;
              }(t5, i5, c4 ? -1 : 1);
              if (!u5) return null;
              const { idx: d3, t: _4 } = u5;
              let p4 = d3 > 1 ? Ee(t5.slice(0, d3), i5) : [], f4 = d3 < t5.length ? Ee(t5.slice(d3), i5) : [];
              p4 = p4.map((t6) => new e3.P(Se(t6.x), t6.y)), f4 = f4.map((t6) => new e3.P(Se(t6.x), t6.y));
              const m4 = [...p4];
              0 === m4.length && m4.push(f4[f4.length - 1]);
              const g5 = e3.X(m4[m4.length - 1].y, (0 === f4.length ? p4[0] : f4[0]).y, _4);
              let v4;
              return v4 = c4 ? [new e3.P(0, g5), new e3.P(0, 0), new e3.P(1, 0), new e3.P(1, g5)] : [new e3.P(1, g5), new e3.P(1, 1), new e3.P(0, 1), new e3.P(0, g5)], m4.push(...v4), 0 === f4.length ? m4.push(p4[0]) : m4.push(...f4), { polygon: m4.map((t6) => new e3.O(t6.x, t6.y)), unwrapped: false };
            }(t4, i4);
            if (o3) return o3;
            const r4 = function(t5, i5) {
              let o4 = false, r5 = -1 / 0, s4 = 0;
              for (let e4 = 0; e4 < t5.length - 1; e4++) t5[e4].x > r5 && (r5 = t5[e4].x, s4 = e4);
              for (let e4 = 0; e4 < t5.length - 1; e4++) {
                const i6 = (s4 + e4) % (t5.length - 1), r6 = t5[i6], n4 = t5[i6 + 1];
                Math.abs(r6.x - n4.x) > 0.5 && (r6.x < n4.x ? (r6.x += 1, 0 === i6 && (t5[t5.length - 1].x += 1)) : (n4.x += 1, i6 + 1 === t5.length - 1 && (t5[0].x += 1)), o4 = true);
              }
              const n3 = e3.a8(i5.center.lng);
              return o4 && n3 < Math.abs(n3 - 1) && t5.forEach((e4) => {
                e4.x -= 1;
              }), { polygon: t5, unwrapped: o4 };
            }(Ee(t4, i4).map((t5) => new e3.P(Se(t5.x), t5.y)), i4);
            return { polygon: r4.polygon.map((t5) => new e3.O(t5.x, t5.y)), unwrapped: r4.unwrapped };
          }
        }
        function Ee(t4, i4) {
          return e3.ac(t4, (e4) => {
            const t5 = i4.pointCoordinate3D(e4);
            e4.x = t5.x, e4.y = t5.y;
          }, 1 / 256);
        }
        function Se(e4) {
          return e4 < 0 ? 1 + e4 % 1 : e4 % 1;
        }
        function Ce(e4) {
          return 100 * e4 | 0;
        }
        function Ie(t4, i4, o3, r4, s4) {
          const n3 = function(o4, r5) {
            if (o4) return s4(o4);
            if (r5) {
              t4.url && r5.tiles && t4.tiles && delete t4.tiles;
              const o5 = e3.af(e3.e(r5, t4), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
              r5.vector_layers && (o5.vectorLayers = r5.vector_layers, o5.vectorLayerIds = o5.vectorLayers.map((e4) => e4.id)), r5.raster_layers && (o5.rasterLayers = r5.raster_layers, o5.rasterLayerIds = o5.rasterLayers.map((e4) => e4.id)), o5.tiles = i4.canonicalizeTileset(o5, t4.url), s4(null, o5);
            }
          };
          return t4.url ? e3.g(i4.transformRequest(i4.normalizeSourceURL(t4.url, null, o3, r4), e3.R.Source), n3) : e3.f.frame(() => n3(null, t4));
        }
        class De {
          constructor(t4, i4, o3) {
            this.bounds = e3.ag.convert(this.validateBounds(t4)), this.minzoom = i4 || 0, this.maxzoom = o3 || 24;
          }
          validateBounds(e4) {
            return Array.isArray(e4) && 4 === e4.length ? [Math.max(-180, e4[0]), Math.max(-90, e4[1]), Math.min(180, e4[2]), Math.min(90, e4[3])] : [-180, -90, 180, 90];
          }
          contains(t4) {
            const i4 = Math.pow(2, t4.z), o3 = Math.floor(e3.a8(this.bounds.getWest()) * i4), r4 = Math.floor(e3.ah(this.bounds.getNorth()) * i4), s4 = Math.ceil(e3.a8(this.bounds.getEast()) * i4), n3 = Math.ceil(e3.ah(this.bounds.getSouth()) * i4);
            return t4.x >= o3 && t4.x < s4 && t4.y >= r4 && t4.y < n3;
          }
        }
        class Re extends e3.E {
          constructor(t4, i4, o3, r4) {
            if (super(), this.id = t4, this.dispatcher = o3, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e3.e(this, e3.af(i4, ["url", "scheme", "tileSize", "promoteId"])), this._options = e3.e({ type: "vector" }, i4), this._collectResourceTiming = !!i4.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(r4), this._tileWorkers = {}, this._deduped = new e3.ai();
          }
          load(t4) {
            this._loaded = false, this.fire(new e3.b("dataloading", { dataType: "source" }));
            const i4 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o3 = this.map._worldview;
            this._tileJSONRequest = Ie(this._options, this.map._requestManager, i4, o3, (r4, s4) => {
              this._tileJSONRequest = null, this._loaded = true, r4 ? (i4 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i4}`), o3 && 2 !== o3.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o3}`), this.fire(new e3.a(r4))) : s4 && (e3.e(this, s4), s4.bounds && (this.tileBounds = new De(s4.bounds, this.minzoom, this.maxzoom)), e3.am(s4.tiles, this.map._requestManager._customAccessToken), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "content" }))), t4 && t4(r4);
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e4) {
            return !this.tileBounds || this.tileBounds.contains(e4.canonical);
          }
          onAdd(e4) {
            this.map = e4, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t4 = e3.aj(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t4));
          }
          setTiles(e4) {
            return this._options.tiles = e4, this.reload(), this;
          }
          setUrl(e4) {
            return this.url = e4, this._options.url = e4, this.reload(), this;
          }
          onRemove() {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return e3.e({}, this._options);
          }
          loadTile(t4, i4) {
            const o3 = this.map._requestManager.normalizeTileURL(t4.tileID.canonical.url(this.tiles, this.scheme)), r4 = { request: this.map._requestManager.transformRequest(o3, e3.R.Tile), data: void 0, uid: t4.uid, tileID: t4.tileID, tileZoom: t4.tileZoom, zoom: t4.tileID.overscaledZ, tileSize: this.tileSize * t4.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: e3.f.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t4.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t4.isExtraShadowCaster };
            if (r4.request.collectResourceTiming = this._collectResourceTiming, t4.actor && "expired" !== t4.state) "loading" === t4.state ? t4.reloadCallback = i4 : t4.request = t4.actor.send("reloadTile", r4, s4.bind(this));
            else if (t4.actor = this._tileWorkers[o3] = this._tileWorkers[o3] || this.dispatcher.getActor(), this.dispatcher.ready) t4.request = t4.actor.send("loadTile", r4, s4.bind(this), void 0, true);
            else {
              const i5 = e3.ak.call({ deduped: this._deduped }, r4, (e4, i6) => {
                e4 || !i6 ? s4.call(this, e4) : (r4.data = { cacheControl: i6.cacheControl, expires: i6.expires, rawData: i6.rawData.slice(0) }, t4.actor && t4.actor.send("loadTile", r4, s4.bind(this), void 0, true));
              }, true);
              t4.request = { cancel: i5 };
            }
            function s4(o4, r5) {
              return delete t4.request, t4.aborted ? i4(null) : o4 && 404 !== o4.status ? i4(o4) : (r5 && r5.resourceTiming && (t4.resourceTiming = r5.resourceTiming), this.map._refreshExpiredTiles && r5 && t4.setExpiryData(r5), t4.loadVectorData(r5, this.map.painter), e3.al(this.dispatcher), i4(null), void (t4.reloadCallback && (this.loadTile(t4, t4.reloadCallback), t4.reloadCallback = null)));
            }
          }
          abortTile(e4) {
            e4.request && (e4.request.cancel(), delete e4.request), e4.actor && e4.actor.send("abortTile", { uid: e4.uid, type: this.type, source: this.id, scope: this.scope });
          }
          unloadTile(e4) {
            e4.actor && e4.actor.send("removeTile", { uid: e4.uid, type: this.type, source: this.id, scope: this.scope }), e4.destroy();
          }
          hasTransition() {
            return false;
          }
          afterUpdate() {
            this._tileWorkers = {};
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class Ae extends e3.E {
          constructor(t4, i4, o3, r4) {
            super(), this.id = t4, this.dispatcher = o3, this.setEventedParent(r4), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e3.e({ type: "raster" }, i4), e3.e(this, e3.af(i4, ["url", "scheme", "tileSize"]));
          }
          load(t4) {
            this._loaded = false, this.fire(new e3.b("dataloading", { dataType: "source" })), this._tileJSONRequest = Ie(this._options, this.map._requestManager, null, null, (i4, o3) => {
              this._tileJSONRequest = null, this._loaded = true, i4 ? this.fire(new e3.a(i4)) : o3 && (e3.e(this, o3), o3.bounds && (this.tileBounds = new De(o3.bounds, this.minzoom, this.maxzoom)), e3.am(o3.tiles), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "content" }))), t4 && t4(i4);
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e4) {
            this.map = e4, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t4 = e3.aj(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t4));
          }
          setTiles(e4) {
            return this._options.tiles = e4, this.reload(), this;
          }
          setUrl(e4) {
            return this.url = e4, this._options.url = e4, this.reload(), this;
          }
          onRemove() {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return e3.e({}, this._options);
          }
          hasTile(e4) {
            return !this.tileBounds || this.tileBounds.contains(e4.canonical);
          }
          loadTile(t4, i4) {
            const o3 = e3.f.devicePixelRatio >= 2, r4 = this.map._requestManager.normalizeTileURL(t4.tileID.canonical.url(this.tiles, this.scheme), o3, this.tileSize);
            t4.request = e3.d(this.map._requestManager.transformRequest(r4, e3.R.Tile), (o4, r5, s4, n3) => (delete t4.request, t4.aborted ? (t4.state = "unloaded", i4(null)) : o4 ? (t4.state = "errored", i4(o4)) : r5 ? (this.map._refreshExpiredTiles && t4.setExpiryData({ cacheControl: s4, expires: n3 }), t4.setTexture(r5, this.map.painter), t4.state = "loaded", e3.al(this.dispatcher), void i4(null)) : i4(null)));
          }
          abortTile(e4, t4) {
            e4.request && (e4.request.cancel(), delete e4.request), t4();
          }
          unloadTile(t4, i4) {
            t4.texture && t4.texture instanceof e3.T ? (t4.destroy(true), t4.texture && t4.texture instanceof e3.T && this.map.painter.saveTileTexture(t4.texture)) : t4.destroy(), i4();
          }
          hasTransition() {
            return false;
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class Pe extends Ae {
          constructor(t4, i4, o3, r4) {
            super(t4, i4, o3, r4), this.type = "raster-array", this.maxzoom = 22, this._options = e3.e({ type: "raster-array" }, i4);
          }
          triggerRepaint(e4) {
            const t4 = this.map.painter._terrain, i4 = this.map.style.getSourceCache(this.id);
            t4 && t4.enabled && i4 && t4._clearRenderCacheForTile(i4.id, e4.tileID), this.map.triggerRepaint();
          }
          loadTile(t4, i4) {
            const o3 = this.map._requestManager.normalizeTileURL(t4.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize), r4 = this.map._requestManager.transformRequest(o3, e3.R.Tile);
            t4.requestParams = r4, t4.actor || (t4.actor = this.dispatcher.getActor()), t4.request = t4.fetchHeader(void 0, (e4, o4, r5, s4) => {
              if (delete t4.request, t4.aborted) return t4.state = "unloaded", i4(null);
              if (e4) {
                if (20 === e4.code) return;
                return t4.state = "errored", i4(e4);
              }
              this.map._refreshExpiredTiles && t4.setExpiryData({ cacheControl: r5, expires: s4 }), t4.state = "empty", i4(null);
            });
          }
          unloadTile(t4) {
            const i4 = t4.texture;
            i4 && i4 instanceof e3.T ? (t4.destroy(true), this.map.painter.saveTileTexture(i4)) : (t4.destroy(), t4.flushQueues(), t4._isHeaderLoaded = false, delete t4._mrt, delete t4.textureDescriptor), t4.fbo && (t4.fbo.destroy(), delete t4.fbo), delete t4.request, delete t4.requestParams, delete t4.neighboringTiles, t4.state = "unloaded";
          }
          prepareTile(t4, i4, o3) {
            t4._isHeaderLoaded && ("empty" !== t4.state && (t4.state = "reloading"), t4.fetchBand(i4, o3, (i5, o4) => {
              if (i5) return t4.state = "errored", this.fire(new e3.a(i5)), void this.triggerRepaint(t4);
              o4 && (t4.setTexture(o4, this.map.painter), t4.state = "loaded", this.triggerRepaint(t4));
            }));
          }
          getInitialBand(e4) {
            if (!this.rasterLayers) return 0;
            const t4 = this.rasterLayers.find(({ id: t5 }) => t5 === e4), i4 = t4 && t4.fields, o3 = i4 && i4.bands && i4.bands;
            return o3 ? o3[0] : 0;
          }
          getTextureDescriptor(t4, i4, o3) {
            if (!t4) return;
            const r4 = i4.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
            if (!r4) return;
            let s4 = null;
            i4 instanceof e3.aq ? s4 = i4.paint.get("raster-array-band") : i4 instanceof e3.ar && (s4 = i4.paint.get("raster-particle-array-band"));
            const n3 = s4 || this.getInitialBand(r4);
            if (null != n3) if (t4.textureDescriptor) {
              if (!t4.updateNeeded(r4, n3) || o3) return Object.assign({}, t4.textureDescriptor, { texture: t4.texture });
            } else this.prepareTile(t4, r4, n3);
          }
        }
        const Le = 32, Me = 33, ze = new Uint16Array(8184);
        for (let e4 = 0; e4 < 2046; e4++) {
          let t4 = e4 + 2, i4 = 0, o3 = 0, r4 = 0, s4 = 0, n3 = 0, a4 = 0;
          for (1 & t4 ? r4 = s4 = n3 = Le : i4 = o3 = a4 = Le; (t4 >>= 1) > 1; ) {
            const e5 = i4 + r4 >> 1, l5 = o3 + s4 >> 1;
            1 & t4 ? (r4 = i4, s4 = o3, i4 = n3, o3 = a4) : (i4 = r4, o3 = s4, r4 = n3, s4 = a4), n3 = e5, a4 = l5;
          }
          const l4 = 4 * e4;
          ze[l4 + 0] = i4, ze[l4 + 1] = o3, ze[l4 + 2] = r4, ze[l4 + 3] = s4;
        }
        const Oe = new Uint16Array(2178), Fe = new Uint8Array(1089), Be = new Uint16Array(1089);
        function ke(e4) {
          return 0 === e4 ? -0.03125 : 32 === e4 ? 0.03125 : 0;
        }
        class Ne {
          constructor(e4, t4, i4, o3) {
            this.id = Ne.uniqueIdxCounter, Ne.uniqueIdxCounter++, this.context = e4;
            const r4 = e4.gl;
            this.buffer = r4.createBuffer(), this.dynamicDraw = Boolean(i4), this.context.unbindVAO(), e4.bindElementBuffer.set(this.buffer), r4.bufferData(r4.ELEMENT_ARRAY_BUFFER, t4.arrayBuffer, this.dynamicDraw ? r4.DYNAMIC_DRAW : r4.STATIC_DRAW), this.dynamicDraw || o3 || t4.destroy();
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e4) {
            this.id = Ne.uniqueIdxCounter, Ne.uniqueIdxCounter++;
            const t4 = this.context.gl;
            this.context.unbindVAO(), this.bind(), t4.bufferSubData(t4.ELEMENT_ARRAY_BUFFER, 0, e4.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        Ne.uniqueIdxCounter = 0;
        const Ue = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Ge {
          constructor(e4, t4, i4, o3, r4, s4) {
            this.length = t4.length, this.attributes = i4, this.itemSize = t4.bytesPerElement, this.dynamicDraw = o3, this.instanceCount = s4, this.context = e4;
            const n3 = e4.gl;
            this.buffer = n3.createBuffer(), e4.bindVertexBuffer.set(this.buffer), n3.bufferData(n3.ARRAY_BUFFER, t4.arrayBuffer, this.dynamicDraw ? n3.DYNAMIC_DRAW : n3.STATIC_DRAW), this.dynamicDraw || r4 || t4.destroy();
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e4) {
            const t4 = this.context.gl;
            this.bind(), t4.bufferSubData(t4.ARRAY_BUFFER, 0, e4.arrayBuffer);
          }
          enableAttributes(e4, t4) {
            for (let i4 = 0; i4 < this.attributes.length; i4++) {
              const o3 = t4.attributes[this.attributes[i4].name];
              void 0 !== o3 && e4.enableVertexAttribArray(o3);
            }
          }
          setVertexAttribPointers(e4, t4, i4) {
            for (let o3 = 0; o3 < this.attributes.length; o3++) {
              const r4 = this.attributes[o3], s4 = t4.attributes[r4.name];
              void 0 !== s4 && e4.vertexAttribPointer(s4, r4.components, e4[Ue[r4.type]], false, this.itemSize, r4.offset + this.itemSize * (i4 || 0));
            }
          }
          setVertexAttribDivisor(e4, t4, i4) {
            for (let o3 = 0; o3 < this.attributes.length; o3++) {
              const r4 = t4.attributes[this.attributes[o3].name];
              void 0 !== r4 && this.instanceCount && this.instanceCount > 0 && e4.vertexAttribDivisor(r4, i4);
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class je {
          constructor(e4) {
            this.gl = e4.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e4) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Ve extends je {
          getDefault() {
            return e3.aA.transparent;
          }
          set(e4) {
            const t4 = this.current;
            (e4.r !== t4.r || e4.g !== t4.g || e4.b !== t4.b || e4.a !== t4.a || this.dirty) && (this.gl.clearColor(e4.r, e4.g, e4.b, e4.a), this.current = e4, this.dirty = false);
          }
        }
        class Ze extends je {
          getDefault() {
            return 1;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.clearDepth(e4), this.current = e4, this.dirty = false);
          }
        }
        class We extends je {
          getDefault() {
            return 0;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.clearStencil(e4), this.current = e4, this.dirty = false);
          }
        }
        class He extends je {
          getDefault() {
            return [true, true, true, true];
          }
          set(e4) {
            const t4 = this.current;
            (e4[0] !== t4[0] || e4[1] !== t4[1] || e4[2] !== t4[2] || e4[3] !== t4[3] || this.dirty) && (this.gl.colorMask(e4[0], e4[1], e4[2], e4[3]), this.current = e4, this.dirty = false);
          }
        }
        class qe extends je {
          getDefault() {
            return true;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.depthMask(e4), this.current = e4, this.dirty = false);
          }
        }
        class Qe extends je {
          getDefault() {
            return 255;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.stencilMask(e4), this.current = e4, this.dirty = false);
          }
        }
        class $e extends je {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e4) {
            const t4 = this.current;
            (e4.func !== t4.func || e4.ref !== t4.ref || e4.mask !== t4.mask || this.dirty) && (this.gl.stencilFunc(e4.func, e4.ref, e4.mask), this.current = e4, this.dirty = false);
          }
        }
        class Xe extends je {
          getDefault() {
            const e4 = this.gl;
            return [e4.KEEP, e4.KEEP, e4.KEEP];
          }
          set(e4) {
            const t4 = this.current;
            (e4[0] !== t4[0] || e4[1] !== t4[1] || e4[2] !== t4[2] || this.dirty) && (this.gl.stencilOp(e4[0], e4[1], e4[2]), this.current = e4, this.dirty = false);
          }
        }
        class Ye extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            e4 ? t4.enable(t4.STENCIL_TEST) : t4.disable(t4.STENCIL_TEST), this.current = e4, this.dirty = false;
          }
        }
        class Je extends je {
          getDefault() {
            return [0, 1];
          }
          set(e4) {
            const t4 = this.current;
            (e4[0] !== t4[0] || e4[1] !== t4[1] || this.dirty) && (this.gl.depthRange(e4[0], e4[1]), this.current = e4, this.dirty = false);
          }
        }
        class Ke extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            e4 ? t4.enable(t4.DEPTH_TEST) : t4.disable(t4.DEPTH_TEST), this.current = e4, this.dirty = false;
          }
        }
        class et extends je {
          getDefault() {
            return this.gl.LESS;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.depthFunc(e4), this.current = e4, this.dirty = false);
          }
        }
        class tt extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            e4 ? t4.enable(t4.BLEND) : t4.disable(t4.BLEND), this.current = e4, this.dirty = false;
          }
        }
        class it extends je {
          getDefault() {
            const e4 = this.gl;
            return [e4.ONE, e4.ZERO, e4.ONE, e4.ZERO];
          }
          set(e4) {
            const t4 = this.current;
            (e4[0] !== t4[0] || e4[1] !== t4[1] || e4[2] !== t4[2] || e4[3] !== t4[3] || this.dirty) && (this.gl.blendFuncSeparate(e4[0], e4[1], e4[2], e4[3]), this.current = e4, this.dirty = false);
          }
        }
        class ot extends je {
          getDefault() {
            return e3.aA.transparent;
          }
          set(e4) {
            const t4 = this.current;
            (e4.r !== t4.r || e4.g !== t4.g || e4.b !== t4.b || e4.a !== t4.a || this.dirty) && (this.gl.blendColor(e4.r, e4.g, e4.b, e4.a), this.current = e4, this.dirty = false);
          }
        }
        class rt extends je {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e4, e4), this.current = e4, this.dirty = false);
          }
        }
        class st extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            e4 ? t4.enable(t4.CULL_FACE) : t4.disable(t4.CULL_FACE), this.current = e4, this.dirty = false;
          }
        }
        class nt extends je {
          getDefault() {
            return this.gl.BACK;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.cullFace(e4), this.current = e4, this.dirty = false);
          }
        }
        class at extends je {
          getDefault() {
            return this.gl.CCW;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.frontFace(e4), this.current = e4, this.dirty = false);
          }
        }
        let lt = class extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.useProgram(e4), this.current = e4, this.dirty = false);
          }
        };
        class ct extends je {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e4) {
            (e4 !== this.current || this.dirty) && (this.gl.activeTexture(e4), this.current = e4, this.dirty = false);
          }
        }
        class ht extends je {
          getDefault() {
            const e4 = this.gl;
            return [0, 0, e4.drawingBufferWidth, e4.drawingBufferHeight];
          }
          set(e4) {
            const t4 = this.current;
            (e4[0] !== t4[0] || e4[1] !== t4[1] || e4[2] !== t4[2] || e4[3] !== t4[3] || this.dirty) && (this.gl.viewport(e4[0], e4[1], e4[2], e4[3]), this.current = e4, this.dirty = false);
          }
        }
        class ut extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            t4.bindFramebuffer(t4.FRAMEBUFFER, e4), this.current = e4, this.dirty = false;
          }
        }
        class dt extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            t4.bindRenderbuffer(t4.RENDERBUFFER, e4), this.current = e4, this.dirty = false;
          }
        }
        class _t extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            t4.bindTexture(t4.TEXTURE_2D, e4), this.current = e4, this.dirty = false;
          }
        }
        class pt extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            t4.bindBuffer(t4.ARRAY_BUFFER, e4), this.current = e4, this.dirty = false;
          }
        }
        class ft extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            const t4 = this.gl;
            t4.bindBuffer(t4.ELEMENT_ARRAY_BUFFER, e4), this.current = e4, this.dirty = false;
          }
        }
        class mt extends je {
          getDefault() {
            return null;
          }
          set(e4) {
            this.gl && (e4 !== this.current || this.dirty) && (this.gl.bindVertexArray(e4), this.current = e4, this.dirty = false);
          }
        }
        class gt extends je {
          getDefault() {
            return 4;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            t4.pixelStorei(t4.UNPACK_ALIGNMENT, e4), this.current = e4, this.dirty = false;
          }
        }
        class vt extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            t4.pixelStorei(t4.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e4), this.current = e4, this.dirty = false;
          }
        }
        class xt extends je {
          getDefault() {
            return false;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            const t4 = this.gl;
            t4.pixelStorei(t4.UNPACK_FLIP_Y_WEBGL, e4), this.current = e4, this.dirty = false;
          }
        }
        class yt extends je {
          constructor(e4, t4) {
            super(e4), this.context = e4, this.parent = t4;
          }
          getDefault() {
            return null;
          }
        }
        class bt extends yt {
          setDirty() {
            this.dirty = true;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t4 = this.gl;
            t4.framebufferTexture2D(t4.FRAMEBUFFER, t4.COLOR_ATTACHMENT0, t4.TEXTURE_2D, e4, 0), this.current = e4, this.dirty = false;
          }
        }
        class wt extends yt {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t4 = this.gl;
            t4.framebufferRenderbuffer(t4.FRAMEBUFFER, this.attachment(), t4.RENDERBUFFER, e4), this.current = e4, this.dirty = false;
          }
        }
        class Tt extends yt {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(e4) {
            if (e4 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t4 = this.gl;
            t4.framebufferTexture2D(t4.FRAMEBUFFER, this.attachment(), t4.TEXTURE_2D, e4, 0), this.current = e4, this.dirty = false;
          }
        }
        class Et extends wt {
          attachment() {
            return this.gl.DEPTH_STENCIL_ATTACHMENT;
          }
        }
        class St {
          constructor(e4, t4, i4, o3, r4) {
            this.context = e4, this.width = t4, this.height = i4;
            const s4 = this.framebuffer = e4.gl.createFramebuffer();
            o3 && (this.colorAttachment = new bt(e4, s4)), r4 && (this.depthAttachmentType = r4, this.depthAttachment = "renderbuffer" === r4 ? new wt(e4, s4) : new Tt(e4, s4));
          }
          destroy() {
            const e4 = this.context.gl;
            if (this.colorAttachment) {
              const t4 = this.colorAttachment.get();
              t4 && e4.deleteTexture(t4);
            }
            if (this.depthAttachment && this.depthAttachmentType) if ("renderbuffer" === this.depthAttachmentType) {
              const t4 = this.depthAttachment.get();
              t4 && e4.deleteRenderbuffer(t4);
            } else {
              const t4 = this.depthAttachment.get();
              t4 && e4.deleteTexture(t4);
            }
            e4.deleteFramebuffer(this.framebuffer);
          }
        }
        class Ct {
          constructor(e4, t4, i4) {
            this.func = e4, this.mask = t4, this.range = i4;
          }
        }
        Ct.ReadOnly = false, Ct.ReadWrite = true, Ct.disabled = new Ct(519, Ct.ReadOnly, [0, 1]);
        const It = 7680;
        class Dt {
          constructor(e4, t4, i4, o3, r4, s4) {
            this.test = e4, this.ref = t4, this.mask = i4, this.fail = o3, this.depthFail = r4, this.pass = s4;
          }
        }
        Dt.disabled = new Dt({ func: 519, mask: 0 }, 0, 0, It, It, It);
        const Rt = 771;
        class At {
          constructor(e4, t4, i4, o3) {
            this.blendFunction = e4, this.blendColor = t4, this.mask = i4, this.blendEquation = o3;
          }
        }
        At.Replace = [1, 0, 1, 0], At.disabled = new At(At.Replace, e3.aA.transparent, [false, false, false, false]), At.unblended = new At(At.Replace, e3.aA.transparent, [true, true, true, true]), At.alphaBlended = new At([1, Rt, 1, Rt], e3.aA.transparent, [true, true, true, true]), At.multiply = new At([774, 0, 774, 0], e3.aA.transparent, [true, true, true, true]);
        const Pt = 1029, Lt = 2305;
        class Mt {
          constructor(e4, t4, i4) {
            this.enable = e4, this.mode = t4, this.frontFace = i4;
          }
        }
        Mt.disabled = new Mt(false, Pt, Lt), Mt.backCCW = new Mt(true, Pt, Lt), Mt.backCW = new Mt(true, Pt, 2304), Mt.frontCW = new Mt(true, 1028, 2304), Mt.frontCCW = new Mt(true, 1028, Lt);
        class zt {
          constructor(e4, t4) {
            this.gl = e4, this.clearColor = new Ve(this), this.clearDepth = new Ze(this), this.clearStencil = new We(this), this.colorMask = new He(this), this.depthMask = new qe(this), this.stencilMask = new Qe(this), this.stencilFunc = new $e(this), this.stencilOp = new Xe(this), this.stencilTest = new Ye(this), this.depthRange = new Je(this), this.depthTest = new Ke(this), this.depthFunc = new et(this), this.blend = new tt(this), this.blendFunc = new it(this), this.blendColor = new ot(this), this.blendEquation = new rt(this), this.cullFace = new st(this), this.cullFaceSide = new nt(this), this.frontFace = new at(this), this.program = new lt(this), this.activeTexture = new ct(this), this.viewport = new ht(this), this.bindFramebuffer = new ut(this), this.bindRenderbuffer = new dt(this), this.bindTexture = new _t(this), this.bindVertexBuffer = new pt(this), this.bindElementBuffer = new ft(this), this.bindVertexArrayOES = new mt(this), this.pixelStoreUnpack = new gt(this), this.pixelStoreUnpackPremultiplyAlpha = new vt(this), this.pixelStoreUnpackFlipY = new xt(this), this.options = t4 ? __spreadValues({}, t4) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e4.getExtension("EXT_texture_filter_anisotropic") || e4.getExtension("MOZ_EXT_texture_filter_anisotropic") || e4.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e4.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e4.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e4.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e4.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e4.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e4.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e4.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e4.getParameter(e4.MAX_TEXTURE_SIZE), this.maxPointSize = e4.getParameter(e4.ALIASED_POINT_SIZE_RANGE)[1];
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArrayOES.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e4, t4, i4) {
            return new Ne(this, e4, t4, i4);
          }
          createVertexBuffer(e4, t4, i4, o3, r4) {
            return new Ge(this, e4, t4, i4, o3, r4);
          }
          createRenderbuffer(e4, t4, i4) {
            const o3 = this.gl, r4 = o3.createRenderbuffer();
            return this.bindRenderbuffer.set(r4), o3.renderbufferStorage(o3.RENDERBUFFER, e4, t4, i4), this.bindRenderbuffer.set(null), r4;
          }
          createFramebuffer(e4, t4, i4, o3) {
            return new St(this, e4, t4, i4, o3);
          }
          clear({ color: e4, depth: t4, stencil: i4, colorMask: o3 }) {
            const r4 = this.gl;
            let s4 = 0;
            e4 && (s4 |= r4.COLOR_BUFFER_BIT, this.clearColor.set(e4), this.colorMask.set(o3 || [true, true, true, true])), void 0 !== t4 && (s4 |= r4.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t4), this.depthMask.set(true)), void 0 !== i4 && (s4 |= r4.STENCIL_BUFFER_BIT, this.clearStencil.set(i4), this.stencilMask.set(255)), r4.clear(s4);
          }
          setCullFace(e4) {
            false === e4.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e4.mode), this.frontFace.set(e4.frontFace));
          }
          setDepthMode(e4) {
            e4.func !== this.gl.ALWAYS || e4.mask ? (this.depthTest.set(true), this.depthFunc.set(e4.func), this.depthMask.set(e4.mask), this.depthRange.set(e4.range)) : this.depthTest.set(false);
          }
          setStencilMode(e4) {
            e4.test.func !== this.gl.ALWAYS || e4.mask ? (this.stencilTest.set(true), this.stencilMask.set(e4.mask), this.stencilOp.set([e4.fail, e4.depthFail, e4.pass]), this.stencilFunc.set({ func: e4.test.func, ref: e4.ref, mask: e4.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e4) {
            t3(e4.blendFunction, At.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e4.blendFunction), this.blendColor.set(e4.blendColor), e4.blendEquation ? this.blendEquation.set(e4.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(e4.mask);
          }
          unbindVAO() {
            this.bindVertexArrayOES.set(null);
          }
        }
        var Ot = e3.aB([{ name: "a_index", type: "Int16", components: 1 }]);
        const Ft = 0.15000000000000002;
        class Bt {
          constructor(t4, i4, o3, r4) {
            const s4 = { width: o3[0], height: o3[1], data: null }, n3 = t4.gl;
            this.targetColorTexture = new e3.T(t4, s4, n3.RGBA, { useMipmap: false }), this.backgroundColorTexture = new e3.T(t4, s4, n3.RGBA, { useMipmap: false }), this.context = t4, this.setParticleTextureDimension(i4, r4), this.lastInvalidatedAt = 0;
          }
          setParticleTextureDimension(t4, i4) {
            if (this.particleTextureDimension === i4) return;
            (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
            const o3 = this.context.gl, r4 = i4 * i4, s4 = new Uint8Array(4 * r4), n3 = 0.7692307692307692, a4 = e3.aC(t4.key);
            for (let e4 = 0; e4 < s4.length; e4 += 4) {
              const t5 = n3 * (a4() + Ft), i5 = n3 * (a4() + Ft), o4 = 255 * t5 % 1, r5 = 255 * i5 % 1, l5 = o4, c5 = i5 - r5 / 255, h4 = r5;
              s4[e4 + 0] = Math.floor(255 * (t5 - o4 / 255)), s4[e4 + 1] = Math.floor(255 * l5), s4[e4 + 2] = Math.floor(255 * c5), s4[e4 + 3] = Math.floor(255 * h4);
            }
            const l4 = new e3.h({ width: i4, height: i4 }, s4);
            this.particleTexture0 = new e3.T(this.context, l4, o3.RGBA, { premultiply: false, useMipmap: false }), this.particleTexture1 = new e3.T(this.context, l4, o3.RGBA, { premultiply: false, useMipmap: false });
            const c4 = new e3.aD();
            c4.reserve(r4);
            for (let e4 = 0; e4 < r4; e4++) c4.emplaceBack(e4);
            this.particleIndexBuffer = this.context.createVertexBuffer(c4, Ot.members, true), this.particleSegment = e3.aE.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i4;
          }
          update(t4) {
            return !(this.lastInvalidatedAt < t4 && (this.lastInvalidatedAt = e3.f.now(), 1));
          }
          destroy() {
            this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
          }
        }
        const kt = { type: 2, extent: e3.Y, loadGeometry: () => [[new e3.P(0, 0), new e3.P(e3.Y + 1, 0), new e3.P(e3.Y + 1, e3.Y + 1), new e3.P(0, e3.Y + 1), new e3.P(0, 0)]] };
        class Nt {
          constructor(t4, i4, o3, r4, s4) {
            this.tileID = t4, this.uid = e3.aF(), this.uses = 0, this.tileSize = i4, this.tileZoom = o3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = s4, r4 && r4.style && (this._lastUpdatedBrightness = r4.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", r4 && r4.transform && (this.projection = r4.transform.projection);
          }
          registerFadeDuration(t4) {
            const i4 = t4 + this.timeAdded;
            i4 < e3.f.now() || this.fadeEndTime && i4 < this.fadeEndTime || (this.fadeEndTime = i4);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          get tileTransform() {
            return this._tileTransform || (this._tileTransform = e3.av(this.tileID.canonical, this.projection)), this._tileTransform;
          }
          loadVectorData(t4, i4, o3) {
            if (this.unloadVectorData(), this.state = "loaded", t4) {
              t4.featureIndex && (this.latestFeatureIndex = t4.featureIndex, t4.rawTileData ? (this.latestRawTileData = t4.rawTileData, this.latestFeatureIndex.rawTileData = t4.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t4.collisionBoxArray, this.buckets = function(e4, t5) {
                const i5 = {};
                if (!t5) return i5;
                for (const o4 of e4) {
                  const e5 = o4.layerIds.map((e6) => t5.getLayer(e6)).filter(Boolean);
                  if (0 !== e5.length) {
                    o4.layers = e5, o4.stateDependentLayerIds && (o4.stateDependentLayers = o4.stateDependentLayerIds.map((t6) => e5.filter((e6) => e6.id === t6)[0]));
                    for (const t6 of e5) i5[t6.fqid] = o4;
                  }
                }
                return i5;
              }(t4.buckets, i4.style), this.hasSymbolBuckets = false;
              for (const t5 in this.buckets) {
                const i5 = this.buckets[t5];
                if (i5 instanceof e3.aH) {
                  if (this.hasSymbolBuckets = true, !o3) break;
                  i5.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const t5 in this.buckets) {
                const i5 = this.buckets[t5];
                if (i5 instanceof e3.aH && i5.hasRTLText) {
                  this.hasRTLText = true, e3.aI();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const e4 in this.buckets) {
                const t5 = this.buckets[e4], o4 = i4.style.getOwnLayer(e4);
                if (!o4) continue;
                const r4 = o4.queryRadius(t5);
                this.queryPadding = Math.max(this.queryPadding, r4);
              }
              t4.imageAtlas && (this.imageAtlas = t4.imageAtlas), t4.glyphAtlasImage && (this.glyphAtlasImage = t4.glyphAtlasImage), t4.lineAtlas && (this.lineAtlas = t4.lineAtlas), this._lastUpdatedBrightness = t4.brightness;
            } else this.collisionBoxArray = new e3.aG();
          }
          unloadVectorData() {
            if (this.hasData()) {
              for (const e4 in this.buckets) this.buckets[e4].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          getBucket(e4) {
            return this.buckets[e4.fqid];
          }
          upload(t4) {
            for (const e4 in this.buckets) {
              const i5 = this.buckets[e4];
              i5.uploadPending() && i5.upload(t4);
            }
            const i4 = t4.gl, o3 = this.imageAtlas;
            if (o3 && !o3.uploaded) {
              const r4 = !!Object.keys(o3.patternPositions).length;
              this.imageAtlasTexture = new e3.T(t4, o3.image, i4.RGBA, { useMipmap: r4 }), this.imageAtlas.uploaded = true;
            }
            this.glyphAtlasImage && (this.glyphAtlasTexture = new e3.T(t4, this.glyphAtlasImage, i4.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e3.T(t4, this.lineAtlas.image, i4.R8), this.lineAtlas.uploaded = true);
          }
          prepare(e4, t4, i4) {
            if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e4, this.imageAtlasTexture, i4), !t4 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
            const o3 = t4.style.getBrightness();
            (this._lastUpdatedBrightness || o3) && (this._lastUpdatedBrightness && o3 && Math.abs(this._lastUpdatedBrightness - o3) < 1e-3 || (this._lastUpdatedBrightness = o3, this.updateBuckets(void 0, t4)));
          }
          queryRenderedFeatures(e4, t4, i4, o3, r4, s4, n3, a4) {
            return this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) ? this.latestFeatureIndex.query({ tileResult: o3, pixelPosMatrix: n3, transform: s4, params: r4, tileTransform: this.tileTransform }, e4, t4, i4) : {};
          }
          querySourceFeatures(t4, i4) {
            const o3 = this.latestFeatureIndex;
            if (!o3 || !o3.rawTileData) return;
            const r4 = o3.loadVTLayers(), s4 = i4 ? i4.sourceLayer : "", n3 = r4._geojsonTileLayer || r4[s4];
            if (!n3) return;
            const a4 = e3.aJ(i4 && i4.filter), { z: l4, x: c4, y: h4 } = this.tileID.canonical, u5 = { z: l4, x: c4, y: h4 };
            for (let i5 = 0; i5 < n3.length; i5++) {
              const r5 = n3.feature(i5);
              if (a4.needGeometry) {
                const t5 = e3.aK(r5, true);
                if (!a4.filter(new e3.N(this.tileID.overscaledZ), t5, this.tileID.canonical)) continue;
              } else if (!a4.filter(new e3.N(this.tileID.overscaledZ), r5)) continue;
              const d3 = o3.getId(r5, s4), _4 = new e3.aL(r5, l4, c4, h4, d3);
              _4.tile = u5, t4.push(_4);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          bucketsLoaded() {
            for (const e4 in this.buckets) if (this.buckets[e4].uploadPending()) return false;
            return true;
          }
          patternsLoaded() {
            return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t4) {
            const i4 = this.expirationTime;
            if (t4.cacheControl) {
              const i5 = e3.aM(t4.cacheControl);
              i5["max-age"] && (this.expirationTime = Date.now() + 1e3 * i5["max-age"]);
            } else t4.expires && (this.expirationTime = new Date(t4.expires).getTime());
            if (this.expirationTime) {
              const e4 = Date.now();
              let t5 = false;
              if (this.expirationTime > e4) t5 = false;
              else if (i4) if (this.expirationTime < i4) t5 = true;
              else {
                const o3 = this.expirationTime - i4;
                o3 ? this.expirationTime = e4 + Math.max(o3, 3e4) : t5 = true;
              }
              else t5 = true;
              t5 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e4, t4) {
            this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(e4).length && t4 && this.updateBuckets(e4, t4);
          }
          updateBuckets(t4, i4) {
            if (!this.latestFeatureIndex) return;
            const o3 = this.latestFeatureIndex.loadVTLayers(), r4 = i4.style.listImages(), s4 = i4.style.getBrightness();
            for (const n3 in this.buckets) {
              if (!i4.style.hasLayer(n3)) continue;
              const a4 = this.buckets[n3], l4 = a4.layers[0].sourceLayer || "_geojsonTileLayer", c4 = o3[l4];
              let h4 = {};
              if (t4 && (h4 = t4[l4], !c4 || !h4 || 0 === Object.keys(h4).length)) continue;
              if (a4.update(h4, c4, r4, this.imageAtlas && this.imageAtlas.patternPositions || {}, s4), a4 instanceof e3.aN || a4 instanceof e3.aO) {
                const e4 = i4.style.getOwnSourceCache(a4.layers[0].source);
                i4._terrain && i4._terrain.enabled && e4 && a4.programConfigurations.needsUpload && i4._terrain._clearRenderCacheForTile(e4.id, this.tileID);
              }
              const u5 = i4 && i4.style && i4.style.getOwnLayer(n3);
              u5 && (this.queryPadding = Math.max(this.queryPadding, u5.queryRadius(a4)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e3.f.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t4) {
            this.symbolFadeHoldUntil = e3.f.now() + t4;
          }
          setTexture(t4, i4) {
            const o3 = i4.context, r4 = o3.gl;
            this.texture = this.texture || i4.getTileTexture(t4.width), this.texture && this.texture instanceof e3.T ? this.texture.update(t4, { useMipmap: true }) : (this.texture = new e3.T(o3, t4, r4.RGBA, { useMipmap: true }), this.texture.bind(r4.LINEAR, r4.CLAMP_TO_EDGE));
          }
          setDependencies(e4, t4) {
            const i4 = {};
            for (const e5 of t4) i4[e5] = true;
            this.dependencies[e4] = i4;
          }
          hasDependency(e4, t4) {
            for (const i4 of e4) {
              const e5 = this.dependencies[i4];
              if (e5) {
                for (const i5 of t4) if (e5[i5]) return true;
              }
            }
            return false;
          }
          clearQueryDebugViz() {
          }
          _makeDebugTileBoundsBuffers(t4, i4) {
            if (!i4 || "mercator" === i4.name || this._tileDebugBuffer) return;
            const o3 = e3.aP(kt, this.tileID.canonical, this.tileTransform)[0], r4 = new e3.aQ(), s4 = new e3.aR();
            for (let e4 = 0; e4 < o3.length; e4++) {
              const { x: t5, y: i5 } = o3[e4];
              r4.emplaceBack(t5, i5), s4.emplaceBack(e4);
            }
            s4.emplaceBack(0), this._tileDebugIndexBuffer = t4.createIndexBuffer(s4), this._tileDebugBuffer = t4.createVertexBuffer(r4, e3.aS.members), this._tileDebugSegments = e3.aE.simpleSegment(0, 0, r4.length, s4.length);
          }
          _makeTileBoundsBuffers(t4, i4) {
            if (this._tileBoundsBuffer || !i4 || "mercator" === i4.name) return;
            const o3 = e3.aP(kt, this.tileID.canonical, this.tileTransform)[0];
            let r4, s4;
            if (this.isRaster) {
              const t5 = function(t6, i5) {
                const o4 = e3.av(t6, i5), r5 = Math.pow(2, t6.z);
                for (let s6 = 0; s6 < Me; s6++) for (let n4 = 0; n4 < Me; n4++) {
                  const a5 = e3.aw((t6.x + (n4 + ke(n4)) / Le) / r5), l5 = e3.ax((t6.y + (s6 + ke(s6)) / Le) / r5), c5 = i5.project(a5, l5), h4 = s6 * Me + n4;
                  Oe[2 * h4 + 0] = Math.round((c5.x * o4.scale - o4.x) * e3.Y), Oe[2 * h4 + 1] = Math.round((c5.y * o4.scale - o4.y) * e3.Y);
                }
                Fe.fill(0), Be.fill(0);
                for (let e4 = 2045; e4 >= 0; e4--) {
                  const t7 = 4 * e4, i6 = ze[t7 + 0], o5 = ze[t7 + 1], r6 = ze[t7 + 2], s6 = ze[t7 + 3], n4 = i6 + r6 >> 1, a5 = o5 + s6 >> 1, l5 = n4 + a5 - o5, c5 = a5 + i6 - n4, h4 = o5 * Me + i6, u5 = s6 * Me + r6, d3 = a5 * Me + n4, _4 = Math.hypot((Oe[2 * h4 + 0] + Oe[2 * u5 + 0]) / 2 - Oe[2 * d3 + 0], (Oe[2 * h4 + 1] + Oe[2 * u5 + 1]) / 2 - Oe[2 * d3 + 1]) >= 16;
                  Fe[d3] = Fe[d3] || (_4 ? 1 : 0), e4 < 1022 && (Fe[d3] = Fe[d3] || Fe[(o5 + c5 >> 1) * Me + (i6 + l5 >> 1)] || Fe[(s6 + c5 >> 1) * Me + (r6 + l5 >> 1)]);
                }
                const s5 = new e3.ay(), n3 = new e3.az();
                let a4 = 0;
                function l4(t7, i6) {
                  const o5 = i6 * Me + t7;
                  return 0 === Be[o5] && (s5.emplaceBack(Oe[2 * o5 + 0], Oe[2 * o5 + 1], t7 * e3.Y / Le, i6 * e3.Y / Le), Be[o5] = ++a4), Be[o5] - 1;
                }
                function c4(e4, t7, i6, o5, r6, s6) {
                  const a5 = e4 + i6 >> 1, h4 = t7 + o5 >> 1;
                  if (Math.abs(e4 - r6) + Math.abs(t7 - s6) > 1 && Fe[h4 * Me + a5]) c4(r6, s6, e4, t7, a5, h4), c4(i6, o5, r6, s6, a5, h4);
                  else {
                    const a6 = l4(e4, t7), c5 = l4(i6, o5), h5 = l4(r6, s6);
                    n3.emplaceBack(a6, c5, h5);
                  }
                }
                return c4(0, 0, Le, Le, Le, 0), c4(Le, Le, 0, 0, 0, Le), { vertices: s5, indices: n3 };
              }(this.tileID.canonical, i4);
              r4 = t5.vertices, s4 = t5.indices;
            } else {
              r4 = new e3.ay(), s4 = new e3.az();
              for (const { x: e4, y: t6 } of o3) r4.emplaceBack(e4, t6, 0, 0);
              const t5 = e3.aT(r4.int16, void 0, 4);
              for (let e4 = 0; e4 < t5.length; e4 += 3) s4.emplaceBack(t5[e4], t5[e4 + 1], t5[e4 + 2]);
            }
            this._tileBoundsBuffer = t4.createVertexBuffer(r4, e3.aU.members), this._tileBoundsIndexBuffer = t4.createIndexBuffer(s4), this._tileBoundsSegments = e3.aE.simpleSegment(0, 0, r4.length, s4.length);
          }
          _makeGlobeTileDebugBuffers(t4, i4) {
            const o3 = i4.projection;
            if (!o3 || "globe" !== o3.name || i4.freezeTileCoverage) return;
            const r4 = this.tileID.canonical, s4 = e3.aV(r4, i4), n3 = e3.aW(s4), a4 = e3.W(i4.zoom);
            let l4;
            a4 > 0 && (l4 = e3.a9.invert(new Float64Array(16), i4.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t4, r4, i4, n3, l4, a4), this._makeGlobeTileDebugTextBuffer(t4, r4, i4, n3, l4, a4);
          }
          _globePoint(t4, i4, o3, r4, s4, n3, a4) {
            let l4 = e3.aX(t4, i4, o3);
            if (n3) {
              const s5 = 1 << o3.z, c4 = e3.a8(r4.center.lng), h4 = e3.ah(r4.center.lat), u5 = (o3.x + 0.5) / s5 - c4;
              let d3 = 0;
              u5 > 0.5 ? d3 = -1 : u5 < -0.5 && (d3 = 1);
              let _4 = (t4 / e3.Y + o3.x) / s5 + d3, p4 = (i4 / e3.Y + o3.y) / s5;
              _4 = (_4 - c4) * r4._pixelsPerMercatorPixel + c4, p4 = (p4 - h4) * r4._pixelsPerMercatorPixel + h4;
              const f4 = [_4 * r4.worldSize, p4 * r4.worldSize, 0];
              e3.Q.transformMat4(f4, f4, n3), l4 = e3.aY(l4, f4, a4);
            }
            return e3.Q.transformMat4(l4, l4, s4);
          }
          _makeGlobeTileDebugBorderBuffer(t4, i4, o3, r4, s4, n3) {
            const a4 = new e3.aQ(), l4 = new e3.aR(), c4 = new e3.aZ(), h4 = (e4, t5, h5, u6, d3) => {
              const _4 = (h5 - e4) / (d3 - 1), p4 = (u6 - t5) / (d3 - 1), f4 = a4.length;
              for (let h6 = 0; h6 < d3; h6++) {
                const u7 = e4 + h6 * _4, d4 = t5 + h6 * p4;
                a4.emplaceBack(u7, d4);
                const m4 = this._globePoint(u7, d4, i4, o3, r4, s4, n3);
                c4.emplaceBack(m4[0], m4[1], m4[2]), l4.emplaceBack(f4 + h6);
              }
            }, u5 = e3.Y;
            h4(0, 0, u5, 0, 16), h4(u5, 0, u5, u5, 16), h4(u5, u5, 0, u5, 16), h4(0, u5, 0, 0, 16), this._tileDebugIndexBuffer = t4.createIndexBuffer(l4), this._tileDebugBuffer = t4.createVertexBuffer(a4, e3.aS.members), this._globeTileDebugBorderBuffer = t4.createVertexBuffer(c4, e3.a_.members), this._tileDebugSegments = e3.aE.simpleSegment(0, 0, a4.length, l4.length);
          }
          _makeGlobeTileDebugTextBuffer(t4, i4, o3, r4, s4, n3) {
            const a4 = e3.Y / 4, l4 = new e3.aQ(), c4 = new e3.az(), h4 = new e3.aZ(), u5 = 25;
            c4.reserve(32), l4.reserve(u5), h4.reserve(u5);
            const d3 = (e4, t5) => u5 * e4 + t5;
            for (let e4 = 0; e4 < u5; e4++) {
              const t5 = e4 * a4;
              for (let e5 = 0; e5 < u5; e5++) {
                const c5 = e5 * a4;
                l4.emplaceBack(c5, t5);
                const u6 = this._globePoint(c5, t5, i4, o3, r4, s4, n3);
                h4.emplaceBack(u6[0], u6[1], u6[2]);
              }
            }
            for (let e4 = 0; e4 < 4; e4++) for (let t5 = 0; t5 < 4; t5++) {
              const i5 = d3(e4, t5), o4 = d3(e4, t5 + 1), r5 = d3(e4 + 1, t5), s5 = d3(e4 + 1, t5 + 1);
              c4.emplaceBack(i5, o4, r5), c4.emplaceBack(r5, o4, s5);
            }
            this._tileDebugTextIndexBuffer = t4.createIndexBuffer(c4), this._tileDebugTextBuffer = t4.createVertexBuffer(l4, e3.aS.members), this._globeTileDebugTextBuffer = t4.createVertexBuffer(h4, e3.a_.members), this._tileDebugTextSegments = e3.aE.simpleSegment(0, 0, u5, 32);
          }
          destroy(t4 = false) {
            for (const e4 in this.buckets) this.buckets[e4].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t4 && this.texture && this.texture instanceof e3.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        const Ut = { vector: Re, raster: Ae, "raster-dem": class extends Ae {
          constructor(t4, i4, o3, r4) {
            super(t4, i4, o3, r4), this.type = "raster-dem", this.maxzoom = 22, this._options = e3.e({ type: "raster-dem" }, i4), this.encoding = i4.encoding || "mapbox";
          }
          loadTile(t4, i4) {
            const o3 = this.map._requestManager.normalizeTileURL(t4.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
            function r4(e4, o4) {
              e4 && (t4.state = "errored", i4(e4)), o4 && (t4.dem = o4, t4.dem.onDeserialize(), t4.needsHillshadePrepare = true, t4.needsDEMTextureUpload = true, t4.state = "loaded", i4(null));
            }
            t4.request = e3.d(this.map._requestManager.transformRequest(o3, e3.R.Tile), (function(o4, s4, n3, a4) {
              if (delete t4.request, t4.aborted) t4.state = "unloaded", i4(null);
              else if (o4) t4.state = "errored", i4(o4);
              else if (s4) {
                this.map._refreshExpiredTiles && t4.setExpiryData({ cacheControl: n3, expires: a4 });
                const i5 = ImageBitmap && s4 instanceof ImageBitmap && e3.an(), o5 = 1 - (s4.width - e3.ao(s4.width)) / 2;
                o5 < 1 || t4.neighboringTiles || (t4.neighboringTiles = this._getNeighboringTiles(t4.tileID));
                const l4 = i5 ? s4 : e3.f.getImageData(s4, o5), c4 = { uid: t4.uid, coord: t4.tileID, source: this.id, scope: this.scope, rawImageData: l4, encoding: this.encoding, padding: o5 };
                t4.actor && "expired" !== t4.state || (t4.actor = this.dispatcher.getActor(), t4.actor.send("loadDEMTile", c4, r4.bind(this), void 0, true));
              }
            }).bind(this));
          }
          _getNeighboringTiles(t4) {
            const i4 = t4.canonical, o3 = Math.pow(2, i4.z), r4 = (i4.x - 1 + o3) % o3, s4 = 0 === i4.x ? t4.wrap - 1 : t4.wrap, n3 = (i4.x + 1 + o3) % o3, a4 = i4.x + 1 === o3 ? t4.wrap + 1 : t4.wrap, l4 = {};
            return l4[new e3.ap(t4.overscaledZ, s4, i4.z, r4, i4.y).key] = { backfilled: false }, l4[new e3.ap(t4.overscaledZ, a4, i4.z, n3, i4.y).key] = { backfilled: false }, i4.y > 0 && (l4[new e3.ap(t4.overscaledZ, s4, i4.z, r4, i4.y - 1).key] = { backfilled: false }, l4[new e3.ap(t4.overscaledZ, t4.wrap, i4.z, i4.x, i4.y - 1).key] = { backfilled: false }, l4[new e3.ap(t4.overscaledZ, a4, i4.z, n3, i4.y - 1).key] = { backfilled: false }), i4.y + 1 < o3 && (l4[new e3.ap(t4.overscaledZ, s4, i4.z, r4, i4.y + 1).key] = { backfilled: false }, l4[new e3.ap(t4.overscaledZ, t4.wrap, i4.z, i4.x, i4.y + 1).key] = { backfilled: false }, l4[new e3.ap(t4.overscaledZ, a4, i4.z, n3, i4.y + 1).key] = { backfilled: false }), l4;
          }
        }, "raster-array": Pe, geojson: class extends e3.E {
          constructor(t4, i4, o3, r4) {
            super(), this.id = t4, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o3.getActor(), this.setEventedParent(r4), this._data = i4.data, this._options = e3.e({}, i4), this._collectResourceTiming = i4.collectResourceTiming, void 0 !== i4.maxzoom && (this.maxzoom = i4.maxzoom), void 0 !== i4.minzoom && (this.minzoom = i4.minzoom), i4.type && (this.type = i4.type), i4.attribution && (this.attribution = i4.attribution), this.promoteId = i4.promoteId;
            const s4 = e3.Y / this.tileSize;
            this.workerOptions = e3.e({ source: this.id, scope: this.scope, cluster: i4.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i4.buffer ? i4.buffer : 128) * s4, tolerance: (void 0 !== i4.tolerance ? i4.tolerance : 0.375) * s4, extent: e3.Y, maxZoom: this.maxzoom, lineMetrics: i4.lineMetrics || false, generateId: i4.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i4.clusterMaxZoom ? i4.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i4.clusterMinPoints || 2), extent: e3.Y, radius: (void 0 !== i4.clusterRadius ? i4.clusterRadius : 50) * s4, log: false, generateId: i4.generateId || false }, clusterProperties: i4.clusterProperties, filter: i4.filter, dynamic: i4.dynamic }, i4.workerOptions);
          }
          onAdd(e4) {
            this.map = e4, this.setData(this._data);
          }
          setData(e4) {
            return this._data = e4, this._updateWorkerData(), this;
          }
          updateData(t4) {
            return this._options.dynamic ? (this._data = t4, this._updateWorkerData(true), this) : this.fire(new e3.a(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
          }
          getClusterExpansionZoom(e4, t4) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e4, source: this.id, scope: this.scope }, t4), this;
          }
          getClusterChildren(e4, t4) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: e4, source: this.id, scope: this.scope }, t4), this;
          }
          getClusterLeaves(e4, t4, i4, o3) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: e4, limit: t4, offset: i4 }, o3), this;
          }
          _updateWorkerData(t4 = false) {
            if (this._pendingLoad) return void (this._coalesce = true);
            this.fire(new e3.b("dataloading", { dataType: "source" })), this._loaded = false;
            const i4 = e3.e({ append: t4 }, this.workerOptions);
            i4.scope = this.scope;
            const o3 = this._data;
            "string" == typeof o3 ? (i4.request = this.map._requestManager.transformRequest(e3.f.resolveURL(o3), e3.R.Source), i4.request.collectResourceTiming = this._collectResourceTiming) : i4.data = JSON.stringify(o3), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i4, (i5, o4) => {
              if (this._loaded = true, this._pendingLoad = null, i5) this.fire(new e3.a(i5));
              else {
                const t5 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                this._collectResourceTiming && o4 && o4.resourceTiming && o4.resourceTiming[this.id] && (t5.resourceTiming = o4.resourceTiming[this.id]), this.fire(new e3.b("data", t5)), this._metadataFired = true;
              }
              this._coalesce && (this._updateWorkerData(t4), this._coalesce = false);
            });
          }
          loaded() {
            return this._loaded;
          }
          loadTile(t4, i4) {
            const o3 = t4.actor ? "reloadTile" : "loadTile";
            t4.actor = this.actor;
            const r4 = { type: this.type, uid: t4.uid, tileID: t4.tileID, tileZoom: t4.tileZoom, zoom: t4.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, scope: this.scope, pixelRatio: e3.f.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0 };
            t4.request = this.actor.send(o3, r4, (e4, r5) => (delete t4.request, t4.destroy(), t4.aborted ? i4(null) : e4 ? i4(e4) : (t4.loadVectorData(r5, this.map.painter, "reloadTile" === o3), i4(null))), void 0, "loadTile" === o3);
          }
          abortTile(e4) {
            e4.request && (e4.request.cancel(), delete e4.request), e4.aborted = true;
          }
          unloadTile(e4) {
            this.actor.send("removeTile", { uid: e4.uid, type: this.type, source: this.id, scope: this.scope }), e4.destroy();
          }
          onRemove() {
            this._pendingLoad && this._pendingLoad.cancel();
          }
          serialize() {
            return e3.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }, video: class extends e3.as {
          constructor(e4, t4, i4, o3) {
            super(e4, t4, i4, o3), this.roundZoom = true, this.type = "video", this.options = t4;
          }
          load() {
            this._loaded = false;
            const t4 = this.options;
            this.urls = [];
            for (const i4 of t4.urls) this.urls.push(this.map._requestManager.transformRequest(i4, e3.R.Source).url);
            e3.at(this.urls, (t5, i4) => {
              this._loaded = true, t5 ? this.fire(new e3.a(t5)) : i4 && (this.video = i4, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t4) {
            if (this.video) {
              const i4 = this.video.seekable;
              t4 < i4.start(0) || t4 > i4.end(0) ? this.fire(new e3.a(new e3.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i4.start(0)} and ${i4.end(0)}-second mark.`))) : this.video.currentTime = t4;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e4) {
            this.map || (this.map = e4, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
            const t4 = this.map.painter.context, i4 = t4.gl;
            this.texture ? this.video.paused || (this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE), i4.texSubImage2D(i4.TEXTURE_2D, 0, 0, 0, i4.RGBA, i4.UNSIGNED_BYTE, this.video)) : (this.texture = new e3.T(t4, this.video, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t4);
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }, image: e3.as, model: class extends e3.E {
          constructor(e4, t4, i4, o3) {
            super(), this.id = e4, this.type = "model", this.models = [], this._loaded = false, this._options = t4;
          }
          load() {
            const t4 = [];
            for (const i4 in this._options.models) {
              const o3 = this._options.models[i4], r4 = e3.l(this.map._requestManager.transformRequest(o3.uri, e3.R.Model).url).then((t5) => {
                if (!t5) return;
                const r5 = e3.c(t5), s4 = new e3.M(i4, o3.position, o3.orientation, r5);
                s4.computeBoundsAndApplyParent(), this.models.push(s4);
              }).catch((t5) => {
                this.fire(new e3.a(new Error(`Could not load model ${i4} from ${o3.uri}: ${t5.message}`)));
              });
              t4.push(r4);
            }
            return Promise.allSettled(t4).then(() => {
              this._loaded = true, this.fire(new e3.b("data", { dataType: "source", sourceDataType: "metadata" }));
            }).catch((t5) => {
              this.fire(new e3.a(new Error(`Could not load models: ${t5.message}`)));
            });
          }
          onAdd(e4) {
            this.map = e4, this.load();
          }
          hasTransition() {
            return false;
          }
          loaded() {
            return this._loaded;
          }
          getModels() {
            return this.models;
          }
          loadTile(e4, t4) {
          }
          serialize() {
            return { type: "model" };
          }
        }, "batched-model": class extends e3.E {
          constructor(e4, t4, i4, o3) {
            super(), this.type = "batched-model", this.id = e4, this.tileSize = 512, this._options = t4, this.tiles = this._options.tiles, this.maxzoom = t4.maxzoom || 19, this.minzoom = t4.minzoom || 0, this.roundZoom = true, this.usedInConflation = true, this.dispatcher = i4, this.reparseOverscaled = false, this.scheme = "xyz", this._loaded = false, this.setEventedParent(o3);
          }
          onAdd(e4) {
            this.map = e4, this.load();
          }
          load(t4) {
            this._loaded = false, this.fire(new e3.b("dataloading", { dataType: "source" }));
            const i4 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o3 = this.map._worldview;
            this._tileJSONRequest = Ie(this._options, this.map._requestManager, i4, o3, (r4, s4) => {
              this._tileJSONRequest = null, this._loaded = true, r4 ? (i4 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i4}`), o3 && 2 !== o3.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o3}`), this.fire(new e3.a(r4))) : s4 && (e3.e(this, s4), s4.bounds && (this.tileBounds = new De(s4.bounds, this.minzoom, this.maxzoom)), e3.am(s4.tiles, this.map._requestManager._customAccessToken), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "content" }))), t4 && t4(r4);
            });
          }
          hasTransition() {
            return false;
          }
          hasTile(e4) {
            return !this.tileBounds || this.tileBounds.contains(e4.canonical);
          }
          loaded() {
            return this._loaded;
          }
          loadTile(t4, i4) {
            const o3 = this.map._requestManager.normalizeTileURL(t4.tileID.canonical.url(this.tiles, this.scheme)), r4 = { request: this.map._requestManager.transformRequest(o3, e3.R.Tile), data: void 0, uid: t4.uid, tileID: t4.tileID, tileZoom: t4.tileZoom, zoom: t4.tileID.overscaledZ, tileSize: this.tileSize * t4.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: t4.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0 };
            if (t4.actor && "expired" !== t4.state) if ("loading" === t4.state) t4.reloadCallback = i4;
            else {
              if (t4.buckets) {
                const e4 = Object.values(t4.buckets);
                for (const t5 of e4) t5.dirty = true;
                return void (t4.state = "loaded");
              }
              t4.request = t4.actor.send("reloadTile", r4, s4.bind(this));
            }
            else t4.actor = this.dispatcher.getActor(), t4.request = t4.actor.send("loadTile", r4, s4.bind(this), void 0, true);
            function s4(e4, o4) {
              return t4.aborted ? i4(null) : e4 && 404 !== e4.status ? i4(e4) : (o4 && (o4.resourceTiming && (t4.resourceTiming = o4.resourceTiming), this.map._refreshExpiredTiles && t4.setExpiryData(o4), t4.buckets = __spreadValues(__spreadValues({}, t4.buckets), o4.buckets), o4.featureIndex && (t4.latestFeatureIndex = o4.featureIndex)), t4.state = "loaded", void i4(null));
            }
          }
          serialize() {
            return e3.e({}, this._options);
          }
        }, canvas: class extends e3.as {
          constructor(t4, i4, o3, r4) {
            super(t4, i4, o3, r4), i4.coordinates ? Array.isArray(i4.coordinates) && 4 === i4.coordinates.length && !i4.coordinates.some((e4) => !Array.isArray(e4) || 2 !== e4.length || e4.some((e5) => "number" != typeof e5)) || this.fire(new e3.a(new e3.V(`sources.${t4}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e3.a(new e3.V(`sources.${t4}`, null, 'missing required property "coordinates"'))), i4.animate && "boolean" != typeof i4.animate && this.fire(new e3.a(new e3.V(`sources.${t4}`, null, 'optional "animate" property must be a boolean value'))), i4.canvas ? "string" == typeof i4.canvas || i4.canvas instanceof HTMLCanvasElement || this.fire(new e3.a(new e3.V(`sources.${t4}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e3.a(new e3.V(`sources.${t4}`, null, 'missing required property "canvas"'))), this.options = i4, this.animate = void 0 === i4.animate || i4.animate;
          }
          load() {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e3.a(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e4) {
            this.map = e4, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t4 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t4 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t4 = true), this._hasInvalidDimensions()) return;
            if (0 === Object.keys(this.tiles).length) return;
            const i4 = this.map.painter.context;
            this.texture ? !t4 && !this._playing || this.texture instanceof e3.au || this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e3.T(i4, this.canvas, i4.gl.RGBA, { premultiply: true }), this._prepareData(i4);
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e4 of [this.canvas.width, this.canvas.height]) if (isNaN(e4) || e4 <= 0) return true;
            return false;
          }
        }, custom: class extends e3.E {
          constructor(t4, i4, o3, r4) {
            super(), this.id = t4, this.type = "custom", this._dataType = "raster", this._dispatcher = o3, this._implementation = i4, this.setEventedParent(r4), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e3.a(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e3.a(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new De(this._implementation.bounds, this.minzoom, this.maxzoom)), i4.update = this._update.bind(this), i4.clearTiles = this._clearTiles.bind(this), i4.coveringTiles = this._coveringTiles.bind(this), e3.e(this, e3.af(i4, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
          }
          serialize() {
            return e3.af(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
          }
          load() {
            this._loaded = true, this.fire(new e3.b("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e3.b("data", { dataType: "source", sourceDataType: "content" }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t4) {
            this._map = t4, this._loaded = false, this.fire(new e3.b("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t4), this.load();
          }
          onRemove(e4) {
            this._implementation.onRemove && this._implementation.onRemove(e4);
          }
          hasTile(e4) {
            if (this._implementation.hasTile) {
              const { x: t4, y: i4, z: o3 } = e4.canonical;
              return this._implementation.hasTile({ x: t4, y: i4, z: o3 });
            }
            return !this.tileBounds || this.tileBounds.contains(e4.canonical);
          }
          loadTile(e4, t4) {
            const { x: i4, y: o3, z: r4 } = e4.tileID.canonical, s4 = new AbortController();
            e4.request = Promise.resolve(this._implementation.loadTile({ x: i4, y: o3, z: r4 }, { signal: s4.signal })).then((function(i5) {
              return delete e4.request, e4.aborted ? (e4.state = "unloaded", t4(null)) : void 0 === i5 ? (e4.state = "errored", t4(null)) : null === i5 ? (this.loadTileData(e4, { width: this.tileSize, height: this.tileSize, data: null }), e4.state = "loaded", t4(null)) : function(e5) {
                return e5 instanceof ImageData || e5 instanceof HTMLCanvasElement || e5 instanceof ImageBitmap || e5 instanceof HTMLImageElement;
              }(i5) ? (this.loadTileData(e4, i5), e4.state = "loaded", void t4(null)) : (e4.state = "errored", t4(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
            }).bind(this)).catch((i5) => {
              20 !== i5.code && (e4.state = "errored", t4(i5));
            }), e4.request.cancel = () => s4.abort();
          }
          loadTileData(e4, t4) {
            e4.setTexture(t4, this._map.painter);
          }
          unloadTile(t4, i4) {
            if (t4.texture && t4.texture instanceof e3.T ? (t4.destroy(true), t4.texture && t4.texture instanceof e3.T && this._map.painter.saveTileTexture(t4.texture)) : t4.destroy(), this._implementation.unloadTile) {
              const { x: e4, y: i5, z: o3 } = t4.tileID.canonical;
              this._implementation.unloadTile({ x: e4, y: i5, z: o3 });
            }
            i4();
          }
          abortTile(e4, t4) {
            e4.request && e4.request.cancel && (e4.request.cancel(), delete e4.request), t4();
          }
          hasTransition() {
            return false;
          }
          _coveringTiles() {
            return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e4) => ({ x: e4.canonical.x, y: e4.canonical.y, z: e4.canonical.z }));
          }
          _clearTiles() {
            const t4 = e3.aj(this.id, this.scope);
            this._map.style.clearSource(t4);
          }
          _update() {
            this.fire(new e3.b("data", { dataType: "source", sourceDataType: "content" }));
          }
        } }, Gt = function(t4, i4, o3, r4) {
          const s4 = new Ut[i4.type](t4, i4, o3, r4);
          if (s4.id !== t4) throw new Error(`Expected Source id to be ${t4} instead of ${s4.id}`);
          return e3.a$(["load", "abort", "unload", "serialize", "prepare"], s4), s4;
        };
        function jt(t4, i4) {
          const o3 = e3.a9.identity([]);
          return e3.a9.scale(o3, o3, [0.5 * t4.width, 0.5 * -t4.height, 1]), e3.a9.translate(o3, o3, [1, -1, 0]), e3.a9.multiply(o3, o3, t4.calculateProjMatrix(i4.toUnwrapped())), Float32Array.from(o3);
        }
        function Vt(e4, t4, i4, o3, r4, s4, n3, a4 = false) {
          const l4 = e4.tilesIn(o3, n3, a4);
          l4.sort(Wt);
          const c4 = [];
          for (const o4 of l4) c4.push({ wrappedTileID: o4.tile.tileID.wrapped().key, queryResults: o4.tile.queryRenderedFeatures(t4, i4, e4._state, o4, r4, s4, jt(e4.transform, o4.tile.tileID), a4) });
          const h4 = function(e5) {
            const t5 = {}, i5 = {};
            for (const o4 of e5) {
              const e6 = o4.queryResults, r5 = o4.wrappedTileID, s5 = i5[r5] = i5[r5] || {};
              for (const i6 in e6) {
                const o5 = e6[i6], r6 = s5[i6] = s5[i6] || {}, n4 = t5[i6] = t5[i6] || [];
                for (const e7 of o5) r6[e7.featureIndex] || (r6[e7.featureIndex] = true, n4.push(e7));
              }
            }
            return t5;
          }(c4);
          for (const t5 in h4) h4[t5].forEach((t6) => {
            const i5 = t6.feature, o4 = i5.layer;
            o4 && "background" !== o4.type && "sky" !== o4.type && "slot" !== o4.type && (i5.source = o4.source, o4["source-layer"] && (i5.sourceLayer = o4["source-layer"]), i5.state = void 0 !== i5.id ? e4.getFeatureState(o4["source-layer"], i5.id) : {});
          });
          return h4;
        }
        function Zt(e4, t4) {
          const i4 = e4.getRenderableIds().map((t5) => e4.getTileByID(t5)), o3 = [], r4 = {};
          for (let e5 = 0; e5 < i4.length; e5++) {
            const s4 = i4[e5], n3 = s4.tileID.canonical.key;
            r4[n3] || (r4[n3] = true, s4.querySourceFeatures(o3, t4));
          }
          return o3;
        }
        function Wt(e4, t4) {
          const i4 = e4.tileID, o3 = t4.tileID;
          return i4.overscaledZ - o3.overscaledZ || i4.canonical.y - o3.canonical.y || i4.wrap - o3.wrap || i4.canonical.x - o3.canonical.x;
        }
        class Ht extends Nt {
          constructor(e4, t4, i4, o3, r4) {
            super(e4, t4, i4, o3, r4), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = false;
          }
          setTexture(t4, i4) {
            const o3 = i4.context, r4 = o3.gl;
            this.texture = this.texture || i4.getTileTexture(t4.width), this.texture && this.texture instanceof e3.T ? this.texture.update(t4, { useMipmap: false, premultiply: false }) : this.texture = new e3.T(o3, t4, r4.RGBA, { useMipmap: false, premultiply: false });
          }
          flushQueues() {
            for (; this._workQueue.length; ) this._workQueue.pop()();
            for (; this._fetchQueue.length; ) this._fetchQueue.pop()();
          }
          fetchHeader(t4 = 16384, i4) {
            const o3 = this._mrt = new e3.b0(30), r4 = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t4 - 1) } });
            return this.entireBuffer = null, this.request = e3.b1(r4, (e4, r5, s4, n3) => {
              if (e4) i4(e4);
              else try {
                const e5 = o3.getHeaderLength(r5);
                if (e5 > t4) return void (this.request = this.fetchHeader(e5, i4));
                o3.parseHeader(r5), this._isHeaderLoaded = true;
                let a4 = 0;
                for (const e6 of Object.values(o3.layers)) a4 = Math.max(a4, e6.dataIndex[e6.dataIndex.length - 1].last_byte);
                r5.byteLength >= a4 && (this.entireBuffer = r5), i4(null, this.entireBuffer || r5, s4, n3);
              } catch (e5) {
                i4(e5);
              }
            }), this.request;
          }
          fetchBand(t4, i4, o3) {
            const r4 = this._mrt;
            if (!this._isHeaderLoaded || !r4) return void o3(new Error("Tile header is not ready"));
            const s4 = this.actor;
            if (!s4) return void o3(new Error("Can't fetch tile band without an actor"));
            let n3;
            const a4 = (e4, r5) => {
              n3.complete(e4, r5), e4 ? o3(e4) : (this.updateTextureDescriptor(t4, i4), o3(null, this.textureDescriptor && this.textureDescriptor.img));
            }, l4 = (e4, t5) => {
              if (e4) return o3(e4);
              const i5 = s4.send("decodeRasterArray", { buffer: t5, task: n3 }, a4, void 0, true);
              this._workQueue.push(() => {
                i5 && i5.cancel(), n3.cancel();
              });
            }, c4 = r4.getLayer(t4);
            if (!c4) return void o3(new Error(`Unknown sourceLayer "${t4}"`));
            if (c4.hasDataForBand(i4)) return this.updateTextureDescriptor(t4, i4), void o3(null, this.textureDescriptor ? this.textureDescriptor.img : null);
            const h4 = c4.getDataRange([i4]);
            if (n3 = r4.createDecodingTask(h4), !n3 || n3.tasks.length) if (this.flushQueues(), this.entireBuffer) l4(null, this.entireBuffer.slice(h4.firstByte, h4.lastByte + 1));
            else {
              const t5 = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${h4.firstByte}-${h4.lastByte}` } }), i5 = e3.b1(t5, l4);
              this._fetchQueue.push(() => {
                i5.cancel(), n3.cancel();
              });
            }
            else o3(null);
          }
          updateNeeded(e4, t4) {
            return (!this.textureDescriptor || this.textureDescriptor.band !== t4 || this.textureDescriptor.layer !== e4) && "errored" !== this.state;
          }
          updateTextureDescriptor(t4, i4) {
            if (!this._mrt) return;
            const o3 = this._mrt.getLayer(t4);
            if (!o3 || !o3.hasBand(i4) || !o3.hasDataForBand(i4)) return;
            const { bytes: r4, tileSize: s4, buffer: n3, offset: a4, scale: l4 } = o3.getBandView(i4), c4 = s4 + 2 * n3, h4 = { data: r4, width: c4, height: c4 }, u5 = this.texture;
            u5 && u5 instanceof e3.T && u5.update(h4, { useMipmap: false, premultiply: false }), this.textureDescriptor = { layer: t4, band: i4, img: h4, buffer: n3, offset: a4, tileSize: s4, format: o3.pixelFormat, mix: [l4, 256 * l4, 65536 * l4, 16777216 * l4] };
          }
        }
        class qt {
          constructor(e4, t4) {
            this.max = e4, this.onRemove = t4, this.reset();
          }
          reset() {
            for (const e4 in this.data) for (const t4 of this.data[e4]) t4.timeout && clearTimeout(t4.timeout), this.onRemove(t4.value);
            return this.data = {}, this.order = [], this;
          }
          add(e4, t4, i4) {
            const o3 = e4.wrapped().key;
            void 0 === this.data[o3] && (this.data[o3] = []);
            const r4 = { value: t4, timeout: void 0 };
            if (void 0 !== i4 && (r4.timeout = setTimeout(() => {
              this.remove(e4, r4);
            }, i4)), this.data[o3].push(r4), this.order.push(o3), this.order.length > this.max) {
              const e5 = this._getAndRemoveByKey(this.order[0]);
              e5 && this.onRemove(e5);
            }
            return this;
          }
          has(e4) {
            return e4.wrapped().key in this.data;
          }
          getAndRemove(e4) {
            return this.has(e4) ? this._getAndRemoveByKey(e4.wrapped().key) : null;
          }
          _getAndRemoveByKey(e4) {
            const t4 = this.data[e4].shift();
            return t4.timeout && clearTimeout(t4.timeout), 0 === this.data[e4].length && delete this.data[e4], this.order.splice(this.order.indexOf(e4), 1), t4.value;
          }
          getByKey(e4) {
            const t4 = this.data[e4];
            return t4 ? t4[0].value : null;
          }
          get(e4) {
            return this.has(e4) ? this.data[e4.wrapped().key][0].value : null;
          }
          remove(e4, t4) {
            if (!this.has(e4)) return this;
            const i4 = e4.wrapped().key, o3 = void 0 === t4 ? 0 : this.data[i4].indexOf(t4), r4 = this.data[i4][o3];
            return this.data[i4].splice(o3, 1), r4.timeout && clearTimeout(r4.timeout), 0 === this.data[i4].length && delete this.data[i4], this.onRemove(r4.value), this.order.splice(this.order.indexOf(i4), 1), this;
          }
          setMaxSize(e4) {
            for (this.max = e4; this.order.length > this.max; ) {
              const e5 = this._getAndRemoveByKey(this.order[0]);
              e5 && this.onRemove(e5);
            }
            return this;
          }
          filter(e4) {
            const t4 = [];
            for (const i4 in this.data) for (const o3 of this.data[i4]) e4(o3.value) || t4.push(o3);
            for (const e5 of t4) this.remove(e5.value.tileID, e5);
          }
        }
        class Qt extends e3.E {
          constructor(e4, t4, i4) {
            super(), this.id = e4, this._onlySymbols = i4, t4.on("data", (e5) => {
              "source" === e5.dataType && "metadata" === e5.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e5.dataType && "content" === e5.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
            }), t4.on("error", () => {
              this._sourceErrored = true;
            }), this._source = t4, this._tiles = {}, this._cache = new qt(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t4.minTileCacheSize, this._maxTileCacheSize = t4.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = false, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new y3(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
          }
          onAdd(e4) {
            this.map = e4, this._minTileCacheSize = void 0 === this._minTileCacheSize && e4 ? e4._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e4 ? e4._maxTileCacheSize : this._maxTileCacheSize;
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded) return false;
            if (!this._source.loaded()) return false;
            for (const e4 in this._tiles) {
              const t4 = this._tiles[e4];
              if ("errored" !== t4.state && ("loaded" !== t4.state || !t4.bucketsLoaded())) return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const e4 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, e4 && this.reload(), this.transform && this.update(this.transform);
          }
          _loadTile(e4, t4) {
            return e4.isSymbolTile = this._onlySymbols, e4.isExtraShadowCaster = this._shadowCasterTiles[e4.tileID.key], this._source.loadTile(e4, t4);
          }
          _unloadTile(e4) {
            if (this._source.unloadTile) return this._source.unloadTile(e4, () => {
            });
          }
          _abortTile(e4) {
            if (this._source.abortTile) return this._source.abortTile(e4, () => {
            });
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e4) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const t4 in this._tiles) {
              const i4 = this._tiles[t4];
              i4.upload(e4), i4.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
            }
          }
          getIds() {
            return e3.b2(this._tiles).map((e4) => e4.tileID).sort($t).map((e4) => e4.key);
          }
          getRenderableIds(t4, i4) {
            const o3 = [];
            for (const e4 in this._tiles) this._isIdRenderable(+e4, t4, i4) && o3.push(this._tiles[e4]);
            return t4 ? o3.sort((t5, i5) => {
              const o4 = t5.tileID, r4 = i5.tileID, s4 = new e3.P(o4.canonical.x, o4.canonical.y)._rotate(this.transform.angle), n3 = new e3.P(r4.canonical.x, r4.canonical.y)._rotate(this.transform.angle);
              return o4.overscaledZ - r4.overscaledZ || n3.y - s4.y || n3.x - s4.x;
            }).map((e4) => e4.tileID.key) : o3.map((e4) => e4.tileID).sort($t).map((e4) => e4.key);
          }
          hasRenderableParent(e4) {
            const t4 = this.findLoadedParent(e4, 0);
            return !!t4 && this._isIdRenderable(t4.tileID.key);
          }
          _isIdRenderable(e4, t4, i4) {
            return this._tiles[e4] && this._tiles[e4].hasData() && !this._coveredTiles[e4] && (t4 || !this._tiles[e4].holdingForFade()) && (i4 || !this._shadowCasterTiles[e4]);
          }
          reload() {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const e4 in this._tiles) "errored" !== this._tiles[e4].state && this._reloadTile(+e4, "reloading");
            }
          }
          _reloadTile(e4, t4) {
            const i4 = this._tiles[e4];
            i4 && ("loading" !== i4.state && (i4.state = t4), this._loadTile(i4, this._tileLoaded.bind(this, i4, e4, t4)));
          }
          _tileLoaded(t4, i4, o3, r4) {
            if (r4) if (t4.state = "errored", 404 !== r4.status) this._source.fire(new e3.a(r4, { tile: t4 }));
            else {
              if (!(t4.tileID.key in this._loadedParentTiles)) return void this._source.fire(new e3.b("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id }));
              if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                const e4 = this.map.painter.terrain;
                this.update(this.transform, e4.getScaledDemTileSize(), true), e4.resetTileLookupCache(this.id);
              } else this.update(this.transform);
            }
            else t4.timeAdded = e3.f.now(), "expired" === o3 && (t4.refreshedUponExpiration = true), this._setTileReloadTimer(i4, t4), "raster-dem" === this._source.type && t4.dem && this._backfillDEM(t4), this._state.initializeTileState(t4, this.map ? this.map.painter : null), this._source.fire(new e3.b("data", { dataType: "source", tile: t4, coord: t4.tileID, sourceCacheId: this.id }));
          }
          _backfillDEM(e4) {
            const t4 = this.getRenderableIds();
            for (let o3 = 0; o3 < t4.length; o3++) {
              const r4 = t4[o3];
              if (e4.neighboringTiles && e4.neighboringTiles[r4]) {
                const t5 = this.getTileByID(r4);
                i4(e4, t5), i4(t5, e4);
              }
            }
            function i4(e5, t5) {
              if (!e5.dem || e5.dem.borderReady) return;
              e5.needsHillshadePrepare = true, e5.needsDEMTextureUpload = true;
              let i5 = t5.tileID.canonical.x - e5.tileID.canonical.x;
              const o3 = t5.tileID.canonical.y - e5.tileID.canonical.y, r4 = Math.pow(2, e5.tileID.canonical.z), s4 = t5.tileID.key;
              0 === i5 && 0 === o3 || Math.abs(o3) > 1 || (Math.abs(i5) > 1 && (1 === Math.abs(i5 + r4) ? i5 += r4 : 1 === Math.abs(i5 - r4) && (i5 -= r4)), t5.dem && e5.dem && (e5.dem.backfillBorder(t5.dem, i5, o3), e5.neighboringTiles && e5.neighboringTiles[s4] && (e5.neighboringTiles[s4].backfilled = true)));
            }
          }
          getTile(e4) {
            return this.getTileByID(e4.key);
          }
          getTileByID(e4) {
            return this._tiles[e4];
          }
          _retainLoadedChildren(e4, t4, i4, o3) {
            for (const r4 in this._tiles) {
              let s4 = this._tiles[r4];
              if (o3[r4] || !s4.hasData() || s4.tileID.overscaledZ <= t4 || s4.tileID.overscaledZ > i4) continue;
              let n3 = s4.tileID;
              for (; s4 && s4.tileID.overscaledZ > t4 + 1; ) {
                const e5 = s4.tileID.scaledTo(s4.tileID.overscaledZ - 1);
                s4 = this._tiles[e5.key], s4 && s4.hasData() && (n3 = e5);
              }
              let a4 = n3;
              for (; a4.overscaledZ > t4; ) if (a4 = a4.scaledTo(a4.overscaledZ - 1), e4[a4.key]) {
                o3[n3.key] = n3;
                break;
              }
            }
          }
          findLoadedParent(e4, t4) {
            if (e4.key in this._loadedParentTiles) {
              const i4 = this._loadedParentTiles[e4.key];
              return i4 && i4.tileID.overscaledZ >= t4 ? i4 : null;
            }
            for (let i4 = e4.overscaledZ - 1; i4 >= t4; i4--) {
              const t5 = e4.scaledTo(i4), o3 = this._getLoadedTile(t5);
              if (o3) return o3;
            }
          }
          _getLoadedTile(e4) {
            const t4 = this._tiles[e4.key];
            return t4 && t4.hasData() ? t4 : this._cache.getByKey(this._source.reparseOverscaled ? e4.wrapped().key : e4.canonical.key);
          }
          updateCacheSize(e4, t4) {
            t4 = t4 || this._source.tileSize;
            const i4 = Math.ceil(e4.width / t4) + 1, o3 = Math.ceil(e4.height / t4) + 1, r4 = Math.floor(i4 * o3 * 5), s4 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, r4) : r4, n3 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s4) : s4;
            this._cache.setMaxSize(n3);
          }
          handleWrapJump(e4) {
            const t4 = Math.round((e4 - (void 0 === this._prevLng ? e4 : this._prevLng)) / 360);
            if (this._prevLng = e4, t4) {
              const e5 = {};
              for (const i4 in this._tiles) {
                const o3 = this._tiles[i4];
                o3.tileID = o3.tileID.unwrapTo(o3.tileID.wrap + t4), e5[o3.tileID.key] = o3;
              }
              this._tiles = e5;
              for (const e6 in this._timers) clearTimeout(this._timers[e6]), delete this._timers[e6];
              for (const e6 in this._tiles) this._setTileReloadTimer(+e6, this._tiles[e6]);
            }
          }
          update(t4, i4, o3, r4) {
            if (this.transform = t4, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
            if (this.usedForTerrain && !o3) return;
            let s4;
            if (this.updateCacheSize(t4, i4), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {}, this.used || this.usedForTerrain) if (this._source.tileID) s4 = t4.getVisibleUnwrappedCoordinates(this._source.tileID).map((t5) => new e3.ap(t5.canonical.z, t5.wrap, t5.canonical.z, t5.canonical.x, t5.canonical.y));
            else if (0 !== this.tileCoverLift) {
              const r5 = t4.clone();
              r5.tileCoverLift = this.tileCoverLift, s4 = r5.coveringTiles({ tileSize: i4 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !o3, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.minzoom <= 1 && "globe" === t4.projection.name && (s4.push(new e3.ap(1, 0, 1, 0, 0)), s4.push(new e3.ap(1, 0, 1, 1, 0)), s4.push(new e3.ap(1, 0, 1, 0, 1)), s4.push(new e3.ap(1, 0, 1, 1, 1)));
            } else s4 = t4.coveringTiles({ tileSize: i4 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !o3, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (s4 = s4.filter((e4) => this._source.hasTile(e4)));
            else s4 = [];
            if (s4.length > 0 && this.castsShadows && r4 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !Xt(this._source.type)) {
              const e4 = t4.coveringZoomLevel({ tileSize: i4 || this._source.tileSize, roundZoom: this._source.roundZoom && !o3 }), n4 = Math.min(e4, this._source.maxzoom), a5 = t4.extendTileCoverForShadows(s4, r4, n4);
              for (const e5 of a5) this._shadowCasterTiles[e5.key] = true, s4.push(e5);
            }
            const n3 = this._updateRetainedTiles(s4);
            if (Xt(this._source.type) && 0 !== s4.length) {
              const t5 = {}, i5 = {}, o4 = Object.keys(n3);
              for (const r6 of o4) {
                const o5 = n3[r6], s5 = this._tiles[r6];
                if (!s5 || s5.fadeEndTime && s5.fadeEndTime <= e3.f.now()) continue;
                const a5 = this.findLoadedParent(o5, Math.max(o5.overscaledZ - Qt.maxOverzooming, this._source.minzoom));
                a5 && (this._addTile(a5.tileID), t5[a5.tileID.key] = a5.tileID), i5[r6] = o5;
              }
              const r5 = s4[s4.length - 1].overscaledZ;
              for (const e4 in this._tiles) {
                const t6 = this._tiles[e4];
                if (n3[e4] || !t6.hasData()) continue;
                let o5 = t6.tileID;
                for (; o5.overscaledZ > r5; ) {
                  o5 = o5.scaledTo(o5.overscaledZ - 1);
                  const r6 = this._tiles[o5.key];
                  if (r6 && r6.hasData() && i5[o5.key]) {
                    n3[e4] = t6.tileID;
                    break;
                  }
                }
              }
              for (const e4 in t5) n3[e4] || (this._coveredTiles[e4] = true, n3[e4] = t5[e4]);
            }
            for (const e4 in n3) this._tiles[e4].clearFadeHold();
            const a4 = e3.b3(this._tiles, n3);
            for (const e4 of a4) {
              const t5 = this._tiles[e4];
              t5.hasSymbolBuckets && !t5.holdingForFade() ? t5.setHoldDuration(this.map._fadeDuration) : t5.hasSymbolBuckets && !t5.symbolFadeFinished() || this._removeTile(+e4);
            }
            this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
          }
          releaseSymbolFadeTiles() {
            for (const e4 in this._tiles) this._tiles[e4].holdingForFade() && this._removeTile(+e4);
          }
          _updateRetainedTiles(e4) {
            const t4 = {};
            if (0 === e4.length) return t4;
            const i4 = {}, o3 = e4.reduce((e5, t5) => Math.min(e5, t5.overscaledZ), 1 / 0), r4 = e4[0].overscaledZ, s4 = Math.max(r4 - Qt.maxOverzooming, this._source.minzoom), n3 = Math.max(r4 + Qt.maxUnderzooming, this._source.minzoom), a4 = {};
            for (const i5 of e4) {
              const e5 = this._addTile(i5);
              t4[i5.key] = i5, e5.hasData() || o3 < this._source.maxzoom && (a4[i5.key] = i5);
            }
            this._retainLoadedChildren(a4, o3, n3, t4);
            for (const o4 of e4) {
              let e5 = this._tiles[o4.key];
              if (e5.hasData()) continue;
              if (o4.canonical.z >= this._source.maxzoom) {
                const e6 = o4.children(this._source.maxzoom)[0], i5 = this.getTile(e6);
                if (i5 && i5.hasData()) {
                  t4[e6.key] = e6;
                  continue;
                }
              } else {
                const e6 = o4.children(this._source.maxzoom);
                if (t4[e6[0].key] && t4[e6[1].key] && t4[e6[2].key] && t4[e6[3].key]) continue;
              }
              let r5 = e5.wasRequested();
              for (let n4 = o4.overscaledZ - 1; n4 >= s4; --n4) {
                const s5 = o4.scaledTo(n4);
                if (i4[s5.key]) break;
                if (i4[s5.key] = true, e5 = this.getTile(s5), !e5 && r5 && (e5 = this._addTile(s5)), e5 && (t4[s5.key] = s5, r5 = e5.wasRequested(), e5.hasData())) break;
              }
            }
            return t4;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e4 in this._tiles) {
              const t4 = [];
              let i4, o3 = this._tiles[e4].tileID;
              for (; o3.overscaledZ > 0; ) {
                if (o3.key in this._loadedParentTiles) {
                  i4 = this._loadedParentTiles[o3.key];
                  break;
                }
                t4.push(o3.key);
                const e5 = o3.scaledTo(o3.overscaledZ - 1);
                if (i4 = this._getLoadedTile(e5), i4) break;
                o3 = e5;
              }
              for (const e5 of t4) this._loadedParentTiles[e5] = i4;
            }
          }
          _addTile(t4) {
            let i4 = this._tiles[t4.key];
            if (i4) return true !== i4.isExtraShadowCaster || !!this._shadowCasterTiles[t4.key] || this._reloadTile(t4.key, "reloading"), i4;
            i4 = this._cache.getAndRemove(t4), i4 && (this._setTileReloadTimer(t4.key, i4), i4.tileID = t4, this._state.initializeTileState(i4, this.map ? this.map.painter : null), this._cacheTimers[t4.key] && (clearTimeout(this._cacheTimers[t4.key]), delete this._cacheTimers[t4.key], this._setTileReloadTimer(t4.key, i4)));
            const o3 = Boolean(i4);
            if (!o3) {
              const e4 = this.map ? this.map.painter : null, o4 = this._source.tileSize * t4.overscaleFactor();
              i4 = "raster-array" === this._source.type ? new Ht(t4, o4, this.transform.tileZoom, e4, this._isRaster) : new Nt(t4, o4, this.transform.tileZoom, e4, this._isRaster), this._loadTile(i4, this._tileLoaded.bind(this, i4, t4.key, i4.state));
            }
            return i4 ? (i4.uses++, this._tiles[t4.key] = i4, o3 || this._source.fire(new e3.b("dataloading", { tile: i4, coord: i4.tileID, dataType: "source" })), i4) : null;
          }
          _setTileReloadTimer(e4, t4) {
            e4 in this._timers && (clearTimeout(this._timers[e4]), delete this._timers[e4]);
            const i4 = t4.getExpiryTimeout();
            i4 && (this._timers[e4] = setTimeout(() => {
              this._reloadTile(e4, "expired"), delete this._timers[e4];
            }, i4));
          }
          _removeTile(e4) {
            const t4 = this._tiles[e4];
            t4 && (t4.uses--, delete this._tiles[e4], this._timers[e4] && (clearTimeout(this._timers[e4]), delete this._timers[e4]), t4.uses > 0 || (t4.hasData() && "reloading" !== t4.state || "empty" === t4.state ? this._cache.add(t4.tileID, t4, t4.getExpiryTimeout()) : (t4.aborted = true, this._abortTile(t4), this._unloadTile(t4))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const e4 in this._tiles) this._removeTile(+e4);
            this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
          }
          tilesIn(t4, i4, o3) {
            const r4 = [], s4 = this.transform;
            if (!s4) return r4;
            const n3 = "globe" === s4.projection.name, a4 = e3.a8(s4.center.lng);
            for (const l4 in this._tiles) {
              const c4 = this._tiles[l4];
              if (o3 && c4.clearQueryDebugViz(), c4.holdingForFade()) continue;
              let h4;
              if (n3) {
                const t5 = c4.tileID.canonical;
                if (0 === t5.z) {
                  const i5 = [Math.abs(e3.ad(a4, ...Yt(t5, -1)) - a4), Math.abs(e3.ad(a4, ...Yt(t5, 1)) - a4)];
                  h4 = [0, 2 * i5.indexOf(Math.min(...i5)) - 1];
                } else {
                  const i5 = [Math.abs(e3.ad(a4, ...Yt(t5, -1)) - a4), Math.abs(e3.ad(a4, ...Yt(t5, 0)) - a4), Math.abs(e3.ad(a4, ...Yt(t5, 1)) - a4)];
                  h4 = [i5.indexOf(Math.min(...i5)) - 1];
                }
              } else h4 = [0];
              for (const e4 of h4) {
                const o4 = t4.containsTile(c4, s4, i4, e4);
                o4 && r4.push(o4);
              }
            }
            return r4;
          }
          getShadowCasterCoordinates() {
            return this._getRenderableCoordinates(false, true);
          }
          getVisibleCoordinates(e4) {
            return this._getRenderableCoordinates(e4);
          }
          _getRenderableCoordinates(e4, t4) {
            const i4 = this.getRenderableIds(e4, t4).map((e5) => this._tiles[e5].tileID), o3 = "globe" === this.transform.projection.name;
            for (const e5 of i4) e5.projMatrix = this.transform.calculateProjMatrix(e5.toUnwrapped()), e5.expandedProjMatrix = o3 ? this.transform.calculateProjMatrix(e5.toUnwrapped(), false, true) : e5.projMatrix;
            return i4;
          }
          sortCoordinatesByDistance(e4) {
            const t4 = e4.slice(), i4 = this.transform._camera.position, o3 = this.transform._camera.forward(), r4 = {};
            for (const e5 of t4) {
              const t5 = 1 / (1 << e5.canonical.z);
              r4[e5.key] = ((e5.canonical.x + 0.5) * t5 + e5.wrap - i4[0]) * o3[0] + ((e5.canonical.y + 0.5) * t5 - i4[1]) * o3[1] - i4[2] * o3[2];
            }
            return t4.sort((e5, t5) => r4[e5.key] - r4[t5.key]), t4;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (Xt(this._source.type)) for (const t4 in this._tiles) {
              const i4 = this._tiles[t4];
              if (void 0 !== i4.fadeEndTime && i4.fadeEndTime >= e3.f.now()) return true;
            }
            return false;
          }
          setFeatureState(e4, t4, i4) {
            this._state.updateState(e4 = e4 || "_geojsonTileLayer", t4, i4);
          }
          removeFeatureState(e4, t4, i4) {
            this._state.removeFeatureState(e4 = e4 || "_geojsonTileLayer", t4, i4);
          }
          getFeatureState(e4, t4) {
            return this._state.getState(e4 = e4 || "_geojsonTileLayer", t4);
          }
          setDependencies(e4, t4, i4) {
            const o3 = this._tiles[e4];
            o3 && o3.setDependencies(t4, i4);
          }
          reloadTilesForDependencies(e4, t4) {
            for (const i4 in this._tiles) this._tiles[i4].hasDependency(e4, t4) && this._reloadTile(+i4, "reloading");
            this._cache.filter((i4) => !i4.hasDependency(e4, t4));
          }
          _preloadTiles(t4, i4) {
            if (!this._sourceLoaded) {
              const e4 = () => {
                this._sourceLoaded && (this._source.off("data", e4), this._preloadTiles(t4, i4));
              };
              return void this._source.on("data", e4);
            }
            const o3 = /* @__PURE__ */ new Map(), r4 = Array.isArray(t4) ? t4 : [t4], s4 = this.map.painter.terrain, n3 = this.usedForTerrain && s4 ? s4.getScaledDemTileSize() : this._source.tileSize;
            for (const e4 of r4) {
              const t5 = e4.coveringTiles({ tileSize: n3, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
              for (const e5 of t5) o3.set(e5.key, e5);
              this.usedForTerrain && e4.updateElevation(false);
            }
            const a4 = Array.from(o3.values());
            e3.b4(a4, (e4, t5) => {
              const i5 = new Nt(e4, this._source.tileSize * e4.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
              this._loadTile(i5, (e5) => {
                "raster-dem" === this._source.type && i5.dem && this._backfillDEM(i5), t5(e5, i5);
              });
            }, i4);
          }
        }
        function $t(e4, t4) {
          const i4 = Math.abs(2 * e4.wrap) - +(e4.wrap < 0), o3 = Math.abs(2 * t4.wrap) - +(t4.wrap < 0);
          return e4.overscaledZ - t4.overscaledZ || o3 - i4 || t4.canonical.y - e4.canonical.y || t4.canonical.x - e4.canonical.x;
        }
        function Xt(e4) {
          return "raster" === e4 || "image" === e4 || "video" === e4 || "custom" === e4;
        }
        function Yt(e4, t4) {
          const i4 = 1 << e4.z;
          return [e4.x / i4 + t4, (e4.x + 1) / i4 + t4];
        }
        Qt.maxOverzooming = 10, Qt.maxUnderzooming = 3;
        class Jt {
          constructor(e4) {
            this.style = e4, this.layersGotHidden = false, this.layers = [];
          }
          processLayersChanged() {
            this.layers = [];
            const e4 = false, t4 = false;
            for (const i4 in this.style._mergedLayers) {
              const o3 = this.style._mergedLayers[i4];
              if ("fill-extrusion" === o3.type) this.layers.push({ layer: o3, visible: e4, visibilityChanged: t4 });
              else if ("model" === o3.type) {
                const i5 = this.style.getLayerSource(o3);
                i5 && "batched-model" === i5.type && this.layers.push({ layer: o3, visible: e4, visibilityChanged: t4 });
              }
            }
          }
          onNewFrame(e4) {
            this.layersGotHidden = false;
            for (const t4 of this.layers) {
              const i4 = t4.layer;
              let o3 = false;
              "fill-extrusion" === i4.type ? o3 = !i4.isHidden(e4) && i4.paint.get("fill-extrusion-opacity") > 0 : "model" === i4.type && (o3 = !i4.isHidden(e4) && i4.paint.get("model-opacity") > 0), this.layersGotHidden = this.layersGotHidden || !o3 && t4.visible, t4.visible = o3;
            }
          }
          updateZOffset(e4, t4) {
            this.currentBuildingBuckets = [];
            for (const e5 of this.layers) {
              const i5 = e5.layer, o3 = this.style.getLayerSourceCache(i5);
              let r4 = 1;
              "fill-extrusion" === i5.type && (r4 = e5.visible ? i5.paint.get("fill-extrusion-vertical-scale") : 0);
              let s4 = o3 ? o3.getTile(t4) : null;
              if (!s4 && o3 && t4.canonical.z > o3.getSource().minzoom) {
                let e6 = t4.scaledTo(Math.min(o3.getSource().maxzoom, t4.overscaledZ - 1));
                for (; e6.overscaledZ >= o3.getSource().minzoom && (s4 = o3.getTile(e6), !s4 && 0 !== e6.overscaledZ); ) e6 = e6.scaledTo(e6.overscaledZ - 1);
              }
              this.currentBuildingBuckets.push({ bucket: s4 ? s4.getBucket(i5) : null, tileID: s4 ? s4.tileID : t4, verticalScale: r4 });
            }
            e4.hasAnyZOffset = false;
            let i4 = false;
            for (let o3 = 0; o3 < e4.symbolInstances.length; o3++) {
              const r4 = e4.symbolInstances.get(o3), s4 = r4.zOffset, n3 = this._getHeightAtTileOffset(t4, r4.tileAnchorX, r4.tileAnchorY);
              r4.zOffset = n3 !== Number.NEGATIVE_INFINITY ? n3 : s4, i4 || s4 === r4.zOffset || (i4 = true), e4.hasAnyZOffset || 0 === r4.zOffset || (e4.hasAnyZOffset = true);
            }
            i4 && (e4.zOffsetBuffersNeedUpload = true, e4.zOffsetSortDirty = true);
          }
          _mapCoordToOverlappingTile(t4, i4, o3, r4) {
            let s4 = i4, n3 = o3;
            if (t4.canonical.z !== r4.canonical.z) {
              const a4 = r4.canonical, l4 = 1 / (1 << t4.canonical.z - a4.z);
              s4 = (i4 + t4.canonical.x * e3.Y) * l4 - a4.x * e3.Y | 0, n3 = (o3 + t4.canonical.y * e3.Y) * l4 - a4.y * e3.Y | 0;
            }
            return { tileX: s4, tileY: n3 };
          }
          _getHeightAtTileOffset(e4, t4, i4) {
            let o3, r4;
            for (let s4 = 0; s4 < this.layers.length; ++s4) {
              if ("fill-extrusion" !== this.layers[s4].layer.type) continue;
              const { bucket: n3, tileID: a4, verticalScale: l4 } = this.currentBuildingBuckets[s4];
              if (!n3) continue;
              const { tileX: c4, tileY: h4 } = this._mapCoordToOverlappingTile(e4, t4, i4, a4), u5 = n3.getHeightAtTileCoord(c4, h4);
              u5 && void 0 !== u5.height && (u5.hidden ? o3 = u5.height : r4 = Math.max(u5.height * l4, r4 || 0));
            }
            if (void 0 !== r4) return r4;
            for (let r5 = 0; r5 < this.layers.length; ++r5) {
              const s4 = this.layers[r5];
              if ("model" !== s4.layer.type || !s4.visible) continue;
              const { bucket: n3, tileID: a4 } = this.currentBuildingBuckets[r5];
              if (!n3) continue;
              const { tileX: l4, tileY: c4 } = this._mapCoordToOverlappingTile(e4, t4, i4, a4), h4 = n3.getHeightAtTileCoord(l4, c4);
              if (h4 && !h4.hidden) return void 0 === h4.height && void 0 !== o3 ? Math.min(h4.maxHeight, o3) * h4.verticalScale : h4.height ? h4.height * h4.verticalScale : Number.NEGATIVE_INFINITY;
            }
            return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
          }
        }
        function Kt(t4, i4) {
          const o3 = {};
          for (const e4 in t4) "ref" !== e4 && (o3[e4] = t4[e4]);
          return e3.b5.forEach((e4) => {
            e4 in i4 && (o3[e4] = i4[e4]);
          }), o3;
        }
        function ei(e4) {
          e4 = e4.slice();
          const t4 = /* @__PURE__ */ Object.create(null);
          for (let i4 = 0; i4 < e4.length; i4++) t4[e4[i4].id] = e4[i4];
          for (let i4 = 0; i4 < e4.length; i4++) "ref" in e4[i4] && (e4[i4] = Kt(e4[i4], t4[e4[i4].ref]));
          return e4;
        }
        const ti = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport" };
        function ii(e4, t4, i4) {
          i4.push({ command: ti.addSource, args: [e4, t4[e4]] });
        }
        function oi(e4, t4, i4) {
          t4.push({ command: ti.removeSource, args: [e4] }), i4[e4] = true;
        }
        function ri(e4, t4, i4, o3) {
          oi(e4, i4, o3), ii(e4, t4, i4);
        }
        function si(e4, i4, o3) {
          let r4;
          for (r4 in e4[o3]) if (e4[o3].hasOwnProperty(r4) && "data" !== r4 && !t3(e4[o3][r4], i4[o3][r4])) return false;
          for (r4 in i4[o3]) if (i4[o3].hasOwnProperty(r4) && "data" !== r4 && !t3(e4[o3][r4], i4[o3][r4])) return false;
          return true;
        }
        function ni(e4, i4, o3, r4, s4, n3) {
          let a4;
          for (a4 in i4 = i4 || {}, e4 = e4 || {}) e4.hasOwnProperty(a4) && (t3(e4[a4], i4[a4]) || o3.push({ command: n3, args: [r4, a4, i4[a4], s4] }));
          for (a4 in i4) i4.hasOwnProperty(a4) && !e4.hasOwnProperty(a4) && (t3(e4[a4], i4[a4]) || o3.push({ command: n3, args: [r4, a4, i4[a4], s4] }));
        }
        function ai(e4) {
          return e4.id;
        }
        function li(e4, t4) {
          return e4[t4.id] = t4, e4;
        }
        class ci {
          constructor(e4, t4) {
            this.reset(e4, t4);
          }
          reset(e4, t4) {
            this.points = e4 || [], this._distances = [0];
            for (let e5 = 1; e5 < this.points.length; e5++) this._distances[e5] = this._distances[e5 - 1] + this.points[e5].dist(this.points[e5 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t4 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t4) {
            if (1 === this.points.length) return this.points[0];
            t4 = e3.ad(t4, 0, 1);
            let i4 = 1, o3 = this._distances[i4];
            const r4 = t4 * this.paddedLength + this.padding;
            for (; o3 < r4 && i4 < this._distances.length; ) o3 = this._distances[++i4];
            const s4 = i4 - 1, n3 = this._distances[s4], a4 = o3 - n3, l4 = a4 > 0 ? (r4 - n3) / a4 : 0;
            return this.points[s4].mult(1 - l4).add(this.points[i4].mult(l4));
          }
        }
        class hi {
          constructor(e4, t4, i4) {
            const o3 = this.boxCells = [], r4 = this.circleCells = [];
            this.xCellCount = Math.ceil(e4 / i4), this.yCellCount = Math.ceil(t4 / i4);
            for (let e5 = 0; e5 < this.xCellCount * this.yCellCount; e5++) o3.push([]), r4.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e4, this.height = t4, this.xScale = this.xCellCount / e4, this.yScale = this.yCellCount / t4, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e4, t4, i4, o3, r4) {
            this._forEachCell(t4, i4, o3, r4, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e4), this.bboxes.push(t4), this.bboxes.push(i4), this.bboxes.push(o3), this.bboxes.push(r4);
          }
          insertCircle(e4, t4, i4, o3) {
            this._forEachCell(t4 - o3, i4 - o3, t4 + o3, i4 + o3, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e4), this.circles.push(t4), this.circles.push(i4), this.circles.push(o3);
          }
          _insertBoxCell(e4, t4, i4, o3, r4, s4) {
            this.boxCells[r4].push(s4);
          }
          _insertCircleCell(e4, t4, i4, o3, r4, s4) {
            this.circleCells[r4].push(s4);
          }
          _query(e4, t4, i4, o3, r4, s4) {
            if (i4 < 0 || e4 > this.width || o3 < 0 || t4 > this.height) return !r4 && [];
            const n3 = [];
            if (e4 <= 0 && t4 <= 0 && this.width <= i4 && this.height <= o3) {
              if (r4) return true;
              for (let e5 = 0; e5 < this.boxKeys.length; e5++) n3.push({ key: this.boxKeys[e5], x1: this.bboxes[4 * e5], y1: this.bboxes[4 * e5 + 1], x2: this.bboxes[4 * e5 + 2], y2: this.bboxes[4 * e5 + 3] });
              for (let e5 = 0; e5 < this.circleKeys.length; e5++) {
                const t5 = this.circles[3 * e5], i5 = this.circles[3 * e5 + 1], o4 = this.circles[3 * e5 + 2];
                n3.push({ key: this.circleKeys[e5], x1: t5 - o4, y1: i5 - o4, x2: t5 + o4, y2: i5 + o4 });
              }
              return s4 ? n3.filter(s4) : n3;
            }
            return this._forEachCell(e4, t4, i4, o3, this._queryCell, n3, { hitTest: r4, seenUids: { box: {}, circle: {} } }, s4), r4 ? n3.length > 0 : n3;
          }
          _queryCircle(e4, t4, i4, o3, r4) {
            const s4 = e4 - i4, n3 = e4 + i4, a4 = t4 - i4, l4 = t4 + i4;
            if (n3 < 0 || s4 > this.width || l4 < 0 || a4 > this.height) return !o3 && [];
            const c4 = [];
            return this._forEachCell(s4, a4, n3, l4, this._queryCellCircle, c4, { hitTest: o3, circle: { x: e4, y: t4, radius: i4 }, seenUids: { box: {}, circle: {} } }, r4), o3 ? c4.length > 0 : c4;
          }
          query(e4, t4, i4, o3, r4) {
            return this._query(e4, t4, i4, o3, false, r4);
          }
          hitTest(e4, t4, i4, o3, r4) {
            return this._query(e4, t4, i4, o3, true, r4);
          }
          hitTestCircle(e4, t4, i4, o3) {
            return this._queryCircle(e4, t4, i4, true, o3);
          }
          _queryCell(e4, t4, i4, o3, r4, s4, n3, a4) {
            const l4 = n3.seenUids, c4 = this.boxCells[r4];
            if (null !== c4) {
              const r5 = this.bboxes;
              for (const h5 of c4) if (!l4.box[h5]) {
                l4.box[h5] = true;
                const c5 = 4 * h5;
                if (e4 <= r5[c5 + 2] && t4 <= r5[c5 + 3] && i4 >= r5[c5 + 0] && o3 >= r5[c5 + 1] && (!a4 || a4(this.boxKeys[h5]))) {
                  if (n3.hitTest) return s4.push(true), true;
                  s4.push({ key: this.boxKeys[h5], x1: r5[c5], y1: r5[c5 + 1], x2: r5[c5 + 2], y2: r5[c5 + 3] });
                }
              }
            }
            const h4 = this.circleCells[r4];
            if (null !== h4) {
              const r5 = this.circles;
              for (const c5 of h4) if (!l4.circle[c5]) {
                l4.circle[c5] = true;
                const h5 = 3 * c5;
                if (this._circleAndRectCollide(r5[h5], r5[h5 + 1], r5[h5 + 2], e4, t4, i4, o3) && (!a4 || a4(this.circleKeys[c5]))) {
                  if (n3.hitTest) return s4.push(true), true;
                  {
                    const e5 = r5[h5], t5 = r5[h5 + 1], i5 = r5[h5 + 2];
                    s4.push({ key: this.circleKeys[c5], x1: e5 - i5, y1: t5 - i5, x2: e5 + i5, y2: t5 + i5 });
                  }
                }
              }
            }
          }
          _queryCellCircle(e4, t4, i4, o3, r4, s4, n3, a4) {
            const l4 = n3.circle, c4 = n3.seenUids, h4 = this.boxCells[r4];
            if (null !== h4) {
              const e5 = this.bboxes;
              for (const t5 of h4) if (!c4.box[t5]) {
                c4.box[t5] = true;
                const i5 = 4 * t5;
                if (this._circleAndRectCollide(l4.x, l4.y, l4.radius, e5[i5 + 0], e5[i5 + 1], e5[i5 + 2], e5[i5 + 3]) && (!a4 || a4(this.boxKeys[t5]))) return s4.push(true), true;
              }
            }
            const u5 = this.circleCells[r4];
            if (null !== u5) {
              const e5 = this.circles;
              for (const t5 of u5) if (!c4.circle[t5]) {
                c4.circle[t5] = true;
                const i5 = 3 * t5;
                if (this._circlesCollide(e5[i5], e5[i5 + 1], e5[i5 + 2], l4.x, l4.y, l4.radius) && (!a4 || a4(this.circleKeys[t5]))) return s4.push(true), true;
              }
            }
          }
          _forEachCell(e4, t4, i4, o3, r4, s4, n3, a4) {
            const l4 = this._convertToXCellCoord(e4), c4 = this._convertToYCellCoord(t4), h4 = this._convertToXCellCoord(i4), u5 = this._convertToYCellCoord(o3);
            for (let d3 = l4; d3 <= h4; d3++) for (let l5 = c4; l5 <= u5; l5++) if (r4.call(this, e4, t4, i4, o3, this.xCellCount * l5 + d3, s4, n3, a4)) return;
          }
          _convertToXCellCoord(e4) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e4 * this.xScale)));
          }
          _convertToYCellCoord(e4) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e4 * this.yScale)));
          }
          _circlesCollide(e4, t4, i4, o3, r4, s4) {
            const n3 = o3 - e4, a4 = r4 - t4, l4 = i4 + s4;
            return l4 * l4 > n3 * n3 + a4 * a4;
          }
          _circleAndRectCollide(e4, t4, i4, o3, r4, s4, n3) {
            const a4 = (s4 - o3) / 2, l4 = Math.abs(e4 - (o3 + a4));
            if (l4 > a4 + i4) return false;
            const c4 = (n3 - r4) / 2, h4 = Math.abs(t4 - (r4 + c4));
            if (h4 > c4 + i4) return false;
            if (l4 <= a4 || h4 <= c4) return true;
            const u5 = l4 - a4, d3 = h4 - c4;
            return u5 * u5 + d3 * d3 <= i4 * i4;
          }
        }
        const ui = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, di = Math.tan(85 * Math.PI / 180);
        function _i(t4, i4, o3, r4, s4, n3, a4) {
          const l4 = e3.a9.create();
          if (o3) if ("globe" === n3.name) {
            const t5 = e3.b6(s4, i4);
            e3.a9.multiply(l4, l4, t5);
          } else {
            const t5 = e3.b7.invert([], a4);
            l4[0] = t5[0], l4[1] = t5[1], l4[4] = t5[2], l4[5] = t5[3], r4 || e3.a9.rotateZ(l4, l4, s4.angle);
          }
          else e3.a9.multiply(l4, s4.labelPlaneMatrix, t4);
          return l4;
        }
        function pi(e4, t4, i4, o3, r4, s4, n3) {
          const a4 = _i(e4, t4, i4, o3, r4, s4, n3);
          return "globe" === s4.name && i4 || (a4[2] = a4[6] = a4[10] = a4[14] = 0), a4;
        }
        function fi(t4, i4, o3, r4, s4, n3, a4) {
          if (o3) {
            if ("globe" === n3.name) {
              const l4 = _i(t4, i4, o3, r4, s4, n3, a4);
              return e3.a9.invert(l4, l4), e3.a9.multiply(l4, t4, l4), l4;
            }
            {
              const i5 = e3.a9.clone(t4), o4 = e3.a9.identity([]);
              return o4[0] = a4[0], o4[1] = a4[1], o4[4] = a4[2], o4[5] = a4[3], e3.a9.multiply(i5, i5, o4), r4 || e3.a9.rotateZ(i5, i5, -s4.angle), i5;
            }
          }
          return s4.glCoordMatrix;
        }
        function mi(t4, i4, o3, r4) {
          const s4 = [t4, i4, o3, 1];
          o3 ? e3.aa.transformMat4(s4, s4, r4) : Ii(s4, s4, r4);
          const n3 = s4[3];
          return s4[0] /= n3, s4[1] /= n3, s4[2] /= n3, s4;
        }
        function gi(e4, t4) {
          return Math.min(0.5 + e4 / t4 * 0.5, 1.5);
        }
        function vi(e4, t4) {
          const i4 = e4[0] / e4[3], o3 = e4[1] / e4[3];
          return i4 >= -t4[0] && i4 <= t4[0] && o3 >= -t4[1] && o3 <= t4[1];
        }
        function xi(t4, i4, o3, r4, s4, n3, a4, l4, c4, h4) {
          const u5 = o3.transform, d3 = r4 ? t4.textSizeData : t4.iconSizeData, _4 = e3.b8(d3, o3.transform.zoom), p4 = "globe" === u5.projection.name, f4 = [256 / o3.width * 2 + 1, 256 / o3.height * 2 + 1], m4 = r4 ? t4.text.dynamicLayoutVertexArray : t4.icon.dynamicLayoutVertexArray;
          m4.clear();
          let g5 = null;
          p4 && (g5 = r4 ? t4.text.globeExtVertexArray : t4.icon.globeExtVertexArray);
          const v4 = t4.lineVertexArray, x5 = r4 ? t4.text.placedSymbolArray : t4.icon.placedSymbolArray, y4 = o3.transform.width / o3.transform.height;
          let b4, w5 = false;
          for (let r5 = 0; r5 < x5.length; r5++) {
            const p5 = x5.get(r5), { numGlyphs: T5, writingMode: E3 } = p5;
            if (E3 !== e3.b9.vertical || w5 || b4 === e3.b9.horizontal || (w5 = true), b4 = E3, (p5.hidden || E3 === e3.b9.vertical) && !w5) {
              Ci(T5, m4);
              continue;
            }
            w5 = false;
            const S3 = new e3.P(p5.tileAnchorX, p5.tileAnchorY);
            let { x: C4, y: I4, z: D4 } = u5.projection.projectTilePoint(S3.x, S3.y, h4.canonical);
            if (c4) {
              const [e4, t5, i5] = c4(S3);
              C4 += e4, I4 += t5, D4 += i5;
            }
            const R2 = [C4, I4, D4, 1];
            if (e3.aa.transformMat4(R2, R2, i4), !vi(R2, f4)) {
              Ci(T5, m4);
              continue;
            }
            const A4 = R2[3], P4 = gi(o3.transform.getCameraToCenterDistance(u5.projection), A4), L4 = e3.ba(d3, _4, p5), M3 = a4 ? L4 / P4 : L4 * P4, z4 = mi(C4, I4, D4, s4);
            if (z4[3] <= 0) {
              Ci(T5, m4);
              continue;
            }
            let O3 = {};
            const F5 = a4 ? null : c4, B4 = wi(p5, M3, false, l4, i4, s4, n3, t4.glyphOffsetArray, v4, m4, g5, z4, S3, O3, y4, F5, u5.projection, h4, a4);
            w5 = B4.useVertical, F5 && B4.needsFlipping && (O3 = {}), (B4.notEnoughRoom || w5 || B4.needsFlipping && wi(p5, M3, true, l4, i4, s4, n3, t4.glyphOffsetArray, v4, m4, g5, z4, S3, O3, y4, F5, u5.projection, h4, a4).notEnoughRoom) && Ci(T5, m4);
          }
          r4 ? (t4.text.dynamicLayoutVertexBuffer.updateData(m4), g5 && t4.text.globeExtVertexBuffer && t4.text.globeExtVertexBuffer.updateData(g5)) : (t4.icon.dynamicLayoutVertexBuffer.updateData(m4), g5 && t4.icon.globeExtVertexBuffer && t4.icon.globeExtVertexBuffer.updateData(g5));
        }
        function yi(e4, t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4) {
          const { lineStartIndex: m4, glyphStartIndex: g5, segment: v4 } = a4, x5 = g5 + a4.numGlyphs, y4 = m4 + a4.lineLength, b4 = t4.getoffsetX(g5), w5 = t4.getoffsetX(x5 - 1), T5 = Si(e4 * b4, i4, o3, r4, s4, n3, v4, m4, y4, l4, c4, h4, u5, d3, true, _4, p4, f4);
          if (!T5) return null;
          const E3 = Si(e4 * w5, i4, o3, r4, s4, n3, v4, m4, y4, l4, c4, h4, u5, d3, true, _4, p4, f4);
          return E3 ? { first: T5, last: E3 } : null;
        }
        function bi(t4, i4, o3, r4) {
          return t4 === e3.b9.horizontal && Math.abs(r4) > Math.abs(o3) ? { useVertical: true } : t4 === e3.b9.vertical ? r4 > 0 ? { needsFlipping: true } : null : i4 !== ui.unknown && function(e4, t5) {
            return 0 === e4 || Math.abs(t5 / e4) > di;
          }(o3, r4) ? i4 === ui.flipRequired ? { needsFlipping: true } : null : o3 < 0 ? { needsFlipping: true } : null;
        }
        function wi(t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4, m4, g5, v4, x5) {
          const y4 = i4 / 24, b4 = t4.lineOffsetX * y4, w5 = t4.lineOffsetY * y4, { lineStartIndex: T5, glyphStartIndex: E3, numGlyphs: S3, segment: C4, writingMode: I4, flipState: D4 } = t4, R2 = T5 + t4.lineLength, A4 = (t5) => {
            if (u5) {
              const [i6, o5, r6] = t5.up, s5 = h4.length;
              e3.bb(u5, s5 + 0, i6, o5, r6), e3.bb(u5, s5 + 1, i6, o5, r6), e3.bb(u5, s5 + 2, i6, o5, r6), e3.bb(u5, s5 + 3, i6, o5, r6);
            }
            const [i5, o4, r5] = t5.point;
            e3.bc(h4, i5, o4, r5, t5.angle);
          };
          if (S3 > 1) {
            const e4 = yi(y4, l4, b4, w5, o3, d3, _4, t4, c4, n3, p4, m4, false, g5, v4, x5);
            if (!e4) return { notEnoughRoom: true };
            if (r4 && !o3) {
              let [i5, o4, r5] = e4.first.point, [s5, n4, l5] = e4.last.point;
              [i5, o4] = mi(i5, o4, r5, a4), [s5, n4] = mi(s5, n4, l5, a4);
              const c5 = bi(I4, D4, (s5 - i5) * f4, n4 - o4);
              if (t4.flipState = c5 && c5.needsFlipping ? ui.flipRequired : ui.flipNotRequired, c5) return c5;
            }
            A4(e4.first);
            for (let e5 = E3 + 1; e5 < E3 + S3 - 1; e5++) {
              const t5 = Si(y4 * l4.getoffsetX(e5), b4, w5, o3, d3, _4, C4, T5, R2, c4, n3, p4, m4, false, false, g5, v4, x5);
              if (!t5) return h4.length -= 4 * (e5 - E3), { notEnoughRoom: true };
              A4(t5);
            }
            A4(e4.last);
          } else {
            if (r4 && !o3) {
              const i6 = mi(_4.x, _4.y, 0, s4), o4 = T5 + C4 + 1, r5 = new e3.P(c4.getx(o4), c4.gety(o4)), n4 = mi(r5.x, r5.y, 0, s4), a5 = n4[3] > 0 ? n4 : Ei(_4, r5, i6, 1, s4, void 0, g5, v4.canonical), l5 = bi(I4, D4, (a5[0] - i6[0]) * f4, a5[1] - i6[1]);
              if (t4.flipState = l5 && l5.needsFlipping ? ui.flipRequired : ui.flipNotRequired, l5) return l5;
            }
            const i5 = Si(y4 * l4.getoffsetX(E3), b4, w5, o3, d3, _4, C4, T5, R2, c4, n3, p4, m4, false, false, g5, v4, x5);
            if (!i5) return { notEnoughRoom: true };
            A4(i5);
          }
          return {};
        }
        function Ti(e4, t4, i4, o3, r4) {
          const { x: s4, y: n3, z: a4 } = o3.projectTilePoint(e4.x, e4.y, t4);
          if (!r4) return mi(s4, n3, a4, i4);
          const [l4, c4, h4] = r4(e4);
          return mi(s4 + l4, n3 + c4, a4 + h4, i4);
        }
        function Ei(t4, i4, o3, r4, s4, n3, a4, l4) {
          const c4 = Ti(t4.sub(i4)._unit()._add(t4), l4, s4, a4, n3);
          return e3.Q.sub(c4, o3, c4), e3.Q.normalize(c4, c4), e3.Q.scaleAndAdd(c4, o3, c4, r4);
        }
        function Si(t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4, m4, g5, v4) {
          const x5 = r4 ? t4 - i4 : t4 + i4;
          let y4 = x5 > 0 ? 1 : -1, b4 = 0;
          r4 && (y4 *= -1, b4 = Math.PI), y4 < 0 && (b4 += Math.PI);
          let w5 = l4 + a4 + (y4 > 0 ? 0 : 1) | 0, T5 = s4, E3 = s4, S3 = 0, C4 = 0;
          const I4 = Math.abs(x5), D4 = [], R2 = [];
          let A4 = n3, P4 = A4;
          const L4 = () => Ei(P4, A4, E3, I4 - S3 + 1, u5, _4, m4, g5.canonical);
          for (; S3 + C4 <= I4; ) {
            if (w5 += y4, w5 < l4 || w5 >= c4) return null;
            if (E3 = T5, P4 = A4, D4.push(E3), p4 && R2.push(P4), A4 = new e3.P(h4.getx(w5), h4.gety(w5)), T5 = d3[w5], !T5) {
              const e4 = Ti(A4, g5.canonical, u5, m4, _4);
              T5 = e4[3] > 0 ? d3[w5] = e4 : L4();
            }
            S3 += C4, C4 = e3.Q.distance(E3, T5);
          }
          f4 && _4 && (d3[w5] && (T5 = L4(), C4 = e3.Q.distance(E3, T5)), d3[w5] = T5);
          const M3 = (I4 - S3) / C4, z4 = A4.sub(P4)._mult(M3)._add(P4), O3 = e3.Q.sub([], T5, E3), F5 = e3.Q.scaleAndAdd([], E3, O3, M3);
          let B4 = [0, 0, 1], k4 = O3[0], N4 = O3[1];
          if (v4 && (B4 = m4.upVector(g5.canonical, z4.x, z4.y), 0 !== B4[0] || 0 !== B4[1] || 1 !== B4[2])) {
            const t5 = [B4[2], 0, -B4[0]], i5 = e3.Q.cross([], B4, t5);
            e3.Q.normalize(t5, t5), e3.Q.normalize(i5, i5), k4 = e3.Q.dot(O3, t5), N4 = e3.Q.dot(O3, i5);
          }
          if (o3) {
            const t5 = e3.Q.cross([], B4, O3);
            e3.Q.normalize(t5, t5), e3.Q.scaleAndAdd(F5, F5, t5, o3 * y4);
          }
          const U3 = b4 + Math.atan2(N4, k4);
          return D4.push(F5), p4 && R2.push(z4), { point: F5, angle: U3, path: D4, tilePath: R2, up: B4 };
        }
        function Ci(e4, t4) {
          const i4 = t4.length, o3 = i4 + 4 * e4;
          t4.resize(o3), t4.float32.fill(-1 / 0, 4 * i4, 4 * o3);
        }
        function Ii(e4, t4, i4) {
          const o3 = t4[0], r4 = t4[1];
          return e4[0] = i4[0] * o3 + i4[4] * r4 + i4[12], e4[1] = i4[1] * o3 + i4[5] * r4 + i4[13], e4[3] = i4[3] * o3 + i4[7] * r4 + i4[15], e4;
        }
        const Di = 100;
        class Ri {
          constructor(e4, t4, i4 = new hi(e4.width + 200, e4.height + 200, 25), o3 = new hi(e4.width + 200, e4.height + 200, 25)) {
            this.transform = e4, this.grid = i4, this.ignoredGrid = o3, this.pitchfactor = Math.cos(e4._pitch) * e4.cameraToCenterDistance, this.screenRightBoundary = e4.width + Di, this.screenBottomBoundary = e4.height + Di, this.gridRightBoundary = e4.width + 200, this.gridBottomBoundary = e4.height + 200, this.fogState = t4;
          }
          placeCollisionBox(e4, t4, i4, o3, r4, s4, n3, a4) {
            let l4 = i4.projectedAnchorX, c4 = i4.projectedAnchorY, h4 = i4.projectedAnchorZ;
            const u5 = i4.elevation, d3 = i4.tileID, _4 = e4.getProjection();
            if (u5 && d3) {
              const [e5, t5, o4] = _4.upVector(d3.canonical, i4.tileAnchorX, i4.tileAnchorY), r5 = _4.upVectorScale(d3.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
              l4 += e5 * u5 * r5, c4 += t5 * u5 * r5, h4 += o4 * u5 * r5;
            }
            const p4 = this.projectAndGetPerspectiveRatio(n3, l4, c4, h4, i4.tileID, "globe" === _4.name || !!u5 || this.transform.pitch > 0, _4), f4 = s4 * p4.perspectiveRatio, m4 = (i4.x1 * t4 + o3.x - i4.padding) * f4 + p4.point.x, g5 = (i4.y1 * t4 + o3.y - i4.padding) * f4 + p4.point.y, v4 = (i4.x2 * t4 + o3.x + i4.padding) * f4 + p4.point.x, x5 = (i4.y2 * t4 + o3.y + i4.padding) * f4 + p4.point.y, y4 = p4.perspectiveRatio <= 0.55 || p4.occluded;
            return !this.isInsideGrid(m4, g5, v4, x5) || !r4 && this.grid.hitTest(m4, g5, v4, x5, a4) || y4 ? { box: [], offscreen: false, occluded: p4.occluded } : { box: [m4, g5, v4, x5], offscreen: this.isOffscreen(m4, g5, v4, x5), occluded: false };
          }
          placeCollisionCircles(t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4) {
            const m4 = [], g5 = this.transform.elevation, v4 = t4.getProjection(), x5 = g5 ? g5.getAtTileOffsetFunc(f4, this.transform.center.lat, this.transform.worldSize, v4) : null, y4 = new e3.P(o3.tileAnchorX, o3.tileAnchorY);
            let { x: b4, y: w5, z: T5 } = v4.projectTilePoint(y4.x, y4.y, f4.canonical);
            if (x5) {
              const [e4, t5, i5] = x5(y4);
              b4 += e4, w5 += t5, T5 += i5;
            }
            const E3 = "globe" === v4.name, S3 = this.projectAndGetPerspectiveRatio(a4, b4, w5, T5, f4, E3 || !!g5 || this.transform.pitch > 0, v4), { perspectiveRatio: C4 } = S3, I4 = (u5 ? n3 / C4 : n3 * C4) / e3.bf, D4 = mi(b4, w5, T5, l4), R2 = S3.signedDistanceFromCamera > 0 ? yi(I4, s4, o3.lineOffsetX * I4, o3.lineOffsetY * I4, false, D4, y4, o3, r4, l4, {}, g5 && !u5 ? x5 : null, u5 && !!g5, v4, f4, u5) : null;
            let A4 = false, P4 = false, L4 = true;
            if (R2 && !S3.occluded) {
              const t5 = 0.5 * _4 * C4 + p4, o4 = new e3.P(-100, -100), r5 = new e3.P(this.screenRightBoundary, this.screenBottomBoundary), s5 = new ci(), { first: n4, last: a5 } = R2, l5 = n4.path.length;
              let u6 = [];
              for (let e4 = l5 - 1; e4 >= 1; e4--) u6.push(n4.path[e4]);
              for (let e4 = 1; e4 < a5.path.length; e4++) u6.push(a5.path[e4]);
              const f5 = 2.5 * t5;
              c4 && (u6 = u6.map(([e4, t6, i5], o5) => (x5 && !E3 && (i5 = x5(o5 < l5 - 1 ? n4.tilePath[l5 - 1 - o5] : a5.tilePath[o5 - l5 + 2])[2]), mi(e4, t6, i5, c4))), u6.some((e4) => e4[3] <= 0) && (u6 = []));
              let g6 = [];
              if (u6.length > 0) {
                let t6 = 1 / 0, i5 = -1 / 0, s6 = 1 / 0, n5 = -1 / 0;
                for (const e4 of u6) t6 = Math.min(t6, e4[0]), s6 = Math.min(s6, e4[1]), i5 = Math.max(i5, e4[0]), n5 = Math.max(n5, e4[1]);
                i5 >= o4.x && t6 <= r5.x && n5 >= o4.y && s6 <= r5.y && (g6 = [u6.map((t7) => new e3.P(t7[0], t7[1]))], (t6 < o4.x || i5 > r5.x || s6 < o4.y || n5 > r5.y) && (g6 = e3.bd(g6, o4.x, o4.y, r5.x, r5.y)));
              }
              for (const e4 of g6) {
                s5.reset(e4, 0.25 * t5);
                let o5 = 0;
                o5 = s5.length <= 0.5 * t5 ? 1 : Math.ceil(s5.paddedLength / f5) + 1;
                for (let e5 = 0; e5 < o5; e5++) {
                  const r6 = e5 / Math.max(o5 - 1, 1), n5 = s5.lerp(r6), a6 = n5.x + Di, l6 = n5.y + Di;
                  m4.push(a6, l6, t5, 0);
                  const c5 = a6 - t5, u7 = l6 - t5, _5 = a6 + t5, p5 = l6 + t5;
                  if (L4 = L4 && this.isOffscreen(c5, u7, _5, p5), P4 = P4 || this.isInsideGrid(c5, u7, _5, p5), !i4 && this.grid.hitTestCircle(a6, l6, t5, d3) && (A4 = true, !h4)) return { circles: [], offscreen: false, collisionDetected: A4, occluded: false };
                }
              }
            }
            return { circles: !h4 && A4 || !P4 ? [] : m4, offscreen: L4, collisionDetected: A4, occluded: S3.occluded };
          }
          queryRenderedSymbols(t4) {
            if (0 === t4.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
            const i4 = [];
            let o3 = 1 / 0, r4 = 1 / 0, s4 = -1 / 0, n3 = -1 / 0;
            for (const a5 of t4) {
              const t5 = new e3.P(a5.x + Di, a5.y + Di);
              o3 = Math.min(o3, t5.x), r4 = Math.min(r4, t5.y), s4 = Math.max(s4, t5.x), n3 = Math.max(n3, t5.y), i4.push(t5);
            }
            const a4 = this.grid.query(o3, r4, s4, n3).concat(this.ignoredGrid.query(o3, r4, s4, n3)), l4 = {}, c4 = {};
            for (const t5 of a4) {
              const o4 = t5.key;
              if (void 0 === l4[o4.bucketInstanceId] && (l4[o4.bucketInstanceId] = {}), l4[o4.bucketInstanceId][o4.featureIndex]) continue;
              const r5 = [new e3.P(t5.x1, t5.y1), new e3.P(t5.x2, t5.y1), new e3.P(t5.x2, t5.y2), new e3.P(t5.x1, t5.y2)];
              e3.be(i4, r5) && (l4[o4.bucketInstanceId][o4.featureIndex] = true, void 0 === c4[o4.bucketInstanceId] && (c4[o4.bucketInstanceId] = []), c4[o4.bucketInstanceId].push(o4.featureIndex));
            }
            return c4;
          }
          insertCollisionBox(e4, t4, i4, o3, r4) {
            (t4 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i4, featureIndex: o3, collisionGroupID: r4 }, e4[0], e4[1], e4[2], e4[3]);
          }
          insertCollisionCircles(e4, t4, i4, o3, r4) {
            const s4 = t4 ? this.ignoredGrid : this.grid, n3 = { bucketInstanceId: i4, featureIndex: o3, collisionGroupID: r4 };
            for (let t5 = 0; t5 < e4.length; t5 += 4) s4.insertCircle(n3, e4[t5], e4[t5 + 1], e4[t5 + 2]);
          }
          projectAndGetPerspectiveRatio(t4, i4, o3, r4, s4, n3, a4) {
            const l4 = [i4, o3, r4, 1];
            let c4 = false;
            if (r4 || this.transform.pitch > 0) {
              if (e3.aa.transformMat4(l4, l4, t4), this.fogState && s4 && "globe" !== a4.name) {
                const t5 = function(t6, i5, o4, r5, s5, n4) {
                  const a5 = n4.calculateFogTileMatrix(s5), l5 = [i5, o4, r5];
                  return e3.Q.transformMat4(l5, l5, a5), pe(t6, e3.Q.length(l5), n4.pitch, n4._fov);
                }(this.fogState, i4, o3, r4, s4.toUnwrapped(), this.transform);
                c4 = t5 > 0.9;
              }
            } else Ii(l4, l4, t4);
            const h4 = l4[3];
            return { point: new e3.P((l4[0] / h4 + 1) / 2 * this.transform.width + Di, (-l4[1] / h4 + 1) / 2 * this.transform.height + Di), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a4) / h4 * 0.5, 1.5), signedDistanceFromCamera: h4, occluded: n3 && l4[2] > h4 || c4 };
          }
          isOffscreen(e4, t4, i4, o3) {
            return i4 < Di || e4 >= this.screenRightBoundary || o3 < Di || t4 > this.screenBottomBoundary;
          }
          isInsideGrid(e4, t4, i4, o3) {
            return i4 >= 0 && e4 < this.gridRightBoundary && o3 >= 0 && t4 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t4 = e3.a9.identity([]);
            return e3.a9.translate(t4, t4, [-100, -100, 0]), t4;
          }
        }
        function Ai(t4, i4, o3) {
          const r4 = i4.createTileMatrix(t4, t4.worldSize, o3.toUnwrapped());
          return e3.a9.multiply(new Float32Array(16), t4.projMatrix, r4);
        }
        function Pi(e4, t4, i4) {
          if (t4.projection.name === i4.projection.name) return e4.projMatrix;
          const o3 = i4.clone();
          return o3.setProjection(t4.projection), Ai(o3, t4.getProjection(), e4);
        }
        function Li(e4, t4, i4) {
          return t4.name === i4.projection.name ? e4.projMatrix : Ai(i4, t4, e4);
        }
        class Mi {
          constructor(e4, t4, i4, o3) {
            this.opacity = e4 ? Math.max(0, Math.min(1, e4.opacity + (e4.placed ? t4 : -t4))) : o3 && i4 ? 1 : 0, this.placed = i4;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class zi {
          constructor(e4, t4, i4, o3, r4, s4 = false) {
            this.text = new Mi(e4 ? e4.text : null, t4, i4, r4), this.icon = new Mi(e4 ? e4.icon : null, t4, o3, r4), this.clipped = s4;
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Oi {
          constructor(e4, t4, i4, o3 = false) {
            this.text = e4, this.icon = t4, this.skipFade = i4, this.clipped = o3;
          }
        }
        class Fi {
          constructor() {
            this.invProjMatrix = e3.a9.create(), this.viewportMatrix = e3.a9.create(), this.circles = [];
          }
        }
        class Bi {
          constructor(e4, t4, i4, o3, r4) {
            this.bucketInstanceId = e4, this.featureIndex = t4, this.sourceLayerIndex = i4, this.bucketIndex = o3, this.tileID = r4;
          }
        }
        class ki {
          constructor(e4) {
            this.crossSourceCollisions = e4, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e4) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e4]) {
              const t4 = ++this.maxGroupID;
              this.collisionGroups[e4] = { ID: t4, predicate: (e5) => e5.collisionGroupID === t4 };
            }
            return this.collisionGroups[e4];
          }
        }
        function Ni(t4, i4, o3, r4, s4) {
          const { horizontalAlign: n3, verticalAlign: a4 } = e3.bi(t4), l4 = -(n3 - 0.5) * i4, c4 = -(a4 - 0.5) * o3, h4 = e3.bh(t4, r4);
          return new e3.P(l4 + h4[0] * s4, c4 + h4[1] * s4);
        }
        function Ui(t4, i4, o3, r4, s4) {
          const n3 = new e3.P(t4, i4);
          return o3 && n3._rotate(r4 ? s4 : -s4), n3;
        }
        class Gi {
          constructor(e4, t4, i4, o3, r4, s4) {
            this.transform = e4.clone(), this.projection = e4.projection.name, this.collisionIndex = new Ri(this.transform, r4), this.buildingIndex = s4, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t4, this.retainedQueryData = {}, this.collisionGroups = new ki(i4), this.collisionCircleArrays = {}, this.prevPlacement = o3, o3 && (o3.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t4, i4, o3, r4) {
            const s4 = o3.getBucket(i4), n3 = o3.latestFeatureIndex;
            if (!s4 || !n3 || i4.fqid !== s4.layerIds[0]) return;
            const a4 = s4.layers[0].layout, l4 = o3.collisionBoxArray, c4 = Math.pow(2, this.transform.zoom - o3.tileID.overscaledZ), h4 = o3.tileSize / e3.Y, u5 = o3.tileID.toUnwrapped();
            this.transform.setProjection(s4.projection);
            const d3 = (_4 = o3.tileID, p4 = s4.getProjection(), f4 = this.transform, p4.name === this.projection ? f4.calculateProjMatrix(_4.toUnwrapped()) : Ai(f4, p4, _4));
            var _4, p4, f4;
            const m4 = "map" === a4.get("text-pitch-alignment"), g5 = "map" === a4.get("text-rotation-alignment");
            i4.compileFilter();
            const v4 = i4.dynamicFilter(), x5 = i4.dynamicFilterNeedsFeature(), y4 = this.transform.calculatePixelsToTileUnitsMatrix(o3), b4 = pi(d3, o3.tileID.canonical, m4, g5, this.transform, s4.getProjection(), y4);
            let w5 = null;
            if (m4) {
              const t5 = fi(d3, o3.tileID.canonical, m4, g5, this.transform, s4.getProjection(), y4);
              w5 = e3.a9.multiply([], this.transform.labelPlaneMatrix, t5);
            }
            let T5 = null;
            v4 && o3.latestFeatureIndex && (T5 = { unwrappedTileID: u5, dynamicFilter: v4, dynamicFilterNeedsFeature: x5, featureIndex: o3.latestFeatureIndex }), this.retainedQueryData[s4.bucketInstanceId] = new Bi(s4.bucketInstanceId, n3, s4.sourceLayerIndex, s4.index, o3.tileID);
            const E3 = { bucket: s4, layout: a4, posMatrix: d3, textLabelPlaneMatrix: b4, labelToScreenMatrix: w5, clippingData: T5, scale: c4, textPixelRatio: h4, holdingForFade: o3.holdingForFade(), collisionBoxArray: l4, partiallyEvaluatedTextSize: e3.b8(s4.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e3.b8(s4.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(s4.sourceID) };
            if (r4) for (const e4 of s4.sortKeyRanges) {
              const { sortKey: i5, symbolInstanceStart: o4, symbolInstanceEnd: r5 } = e4;
              t4.push({ sortKey: i5, symbolInstanceStart: o4, symbolInstanceEnd: r5, parameters: E3 });
            }
            else t4.push({ symbolInstanceStart: 0, symbolInstanceEnd: s4.symbolInstances.length, parameters: E3 });
          }
          attemptAnchorPlacement(e4, t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4, m4, g5) {
            const { textOffset0: v4, textOffset1: x5, crossTileID: y4 } = u5, b4 = [v4, x5], w5 = Ni(e4, i4, o3, b4, r4), T5 = this.collisionIndex.placeCollisionBox(_4, r4, t4, Ui(w5.x, w5.y, s4, n3, this.transform.angle), h4, a4, l4, c4.predicate);
            if (f4) {
              const e5 = _4.getSymbolInstanceIconSize(g5, this.transform.zoom, u5.placedIconSymbolIndex);
              if (0 === this.collisionIndex.placeCollisionBox(_4, e5, f4, Ui(w5.x, w5.y, s4, n3, this.transform.angle), h4, a4, l4, c4.predicate).box.length) return;
            }
            if (T5.box.length > 0) {
              let t5;
              return this.prevPlacement && this.prevPlacement.variableOffsets[y4] && this.prevPlacement.placements[y4] && this.prevPlacement.placements[y4].text && (t5 = this.prevPlacement.variableOffsets[y4].anchor), this.variableOffsets[y4] = { textOffset: b4, width: i4, height: o3, anchor: e4, textScale: r4, prevAnchor: t5 }, this.markUsedJustification(_4, e4, u5, p4), _4.allowVerticalPlacement && (this.markUsedOrientation(_4, p4, u5), this.placedOrientations[y4] = p4), { shift: w5, placedGlyphBoxes: T5 };
            }
          }
          placeLayerBucketPart(t4, i4, o3, r4) {
            const { bucket: s4, layout: n3, posMatrix: a4, textLabelPlaneMatrix: l4, labelToScreenMatrix: c4, clippingData: h4, textPixelRatio: u5, holdingForFade: d3, collisionBoxArray: _4, partiallyEvaluatedTextSize: p4, partiallyEvaluatedIconSize: f4, collisionGroup: m4 } = t4.parameters, g5 = n3.get("text-optional"), v4 = n3.get("icon-optional"), x5 = n3.get("text-allow-overlap"), y4 = n3.get("icon-allow-overlap"), b4 = "map" === n3.get("text-rotation-alignment"), w5 = "map" === n3.get("text-pitch-alignment"), T5 = "viewport-y" === n3.get("symbol-z-order"), E3 = n3.get("symbol-z-elevate");
            this.transform.setProjection(s4.projection);
            let S3 = x5 && (y4 || !s4.hasIconData() || v4), C4 = y4 && (x5 || !s4.hasTextData() || g5);
            !s4.collisionArrays && _4 && s4.deserializeCollisionBoxes(_4), o3 && r4 && s4.updateCollisionDebugBuffers(this.transform.zoom, _4);
            const I4 = (t5, r5, _5) => {
              const { crossTileID: T6, numVerticalGlyphVertices: E4 } = t5;
              if (h4) {
                const o4 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
                let r6 = null;
                if (h4.dynamicFilterNeedsFeature) {
                  const e4 = this.retainedQueryData[s4.bucketInstanceId];
                  r6 = h4.featureIndex.loadFeature({ featureIndex: t5.featureIndex, bucketIndex: e4.bucketIndex, sourceLayerIndex: e4.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                }
                if (!(0, h4.dynamicFilter)(o4, r6, this.retainedQueryData[s4.bucketInstanceId].tileID.canonical, new e3.P(t5.tileAnchorX, t5.tileAnchorY), this.transform.calculateDistanceTileData(h4.unwrappedTileID))) return this.placements[T6] = new Oi(false, false, false, true), void i4.add(T6);
              }
              if (i4.has(T6)) return;
              if (d3) return void (this.placements[T6] = new Oi(false, false, false));
              let I5 = false, D4 = false, R2 = true, A4 = false, P4 = false, L4 = null, M3 = { box: null, offscreen: null, occluded: null }, z4 = { box: null, offscreen: null, occluded: null }, O3 = null, F5 = null, B4 = null, k4 = 0, N4 = 0, U3 = 0;
              _5.textFeatureIndex ? k4 = _5.textFeatureIndex : t5.useRuntimeCollisionCircles && (k4 = t5.featureIndex), _5.verticalTextFeatureIndex && (N4 = _5.verticalTextFeatureIndex);
              const G4 = (e4) => {
                e4.tileID = this.retainedQueryData[s4.bucketInstanceId].tileID;
                const i5 = this.transform.elevation;
                e4.elevation = t5.zOffset + (i5 ? i5.getAtTileOffset(e4.tileID, e4.tileAnchorX, e4.tileAnchorY) : 0);
              }, j5 = _5.textBox;
              if (j5) {
                G4(j5);
                const i5 = (i6) => {
                  let o5 = e3.b9.horizontal;
                  if (s4.allowVerticalPlacement && !i6 && this.prevPlacement) {
                    const e4 = this.prevPlacement.placedOrientations[T6];
                    e4 && (this.placedOrientations[T6] = e4, o5 = e4, this.markUsedOrientation(s4, o5, t5));
                  }
                  return o5;
                }, o4 = (t6, i6) => {
                  if (s4.allowVerticalPlacement && E4 > 0 && _5.verticalTextBox) {
                    for (const o5 of s4.writingModes) if (o5 === e3.b9.vertical ? (M3 = i6(), z4 = M3) : M3 = t6(), M3 && M3.box && M3.box.length) break;
                  } else M3 = t6();
                };
                if (n3.get("text-variable-anchor")) {
                  let l5 = n3.get("text-variable-anchor");
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[T6]) {
                    const e4 = this.prevPlacement.variableOffsets[T6];
                    l5.indexOf(e4.anchor) > 0 && (l5 = l5.filter((t6) => t6 !== e4.anchor), l5.unshift(e4.anchor));
                  }
                  const c5 = (e4, i6, o5) => {
                    const n4 = s4.getSymbolInstanceTextSize(p4, t5, this.transform.zoom, r5), c6 = (e4.x2 - e4.x1) * n4 + 2 * e4.padding, h6 = (e4.y2 - e4.y1) * n4 + 2 * e4.padding, d4 = t5.hasIconTextFit && !y4 ? i6 : null;
                    d4 && G4(d4);
                    let _6 = { box: [], offscreen: false, occluded: false };
                    const g6 = x5 ? 2 * l5.length : l5.length;
                    for (let i7 = 0; i7 < g6; ++i7) {
                      const g7 = this.attemptAnchorPlacement(l5[i7 % l5.length], e4, c6, h6, n4, b4, w5, u5, a4, m4, i7 >= l5.length, t5, r5, s4, o5, d4, p4, f4);
                      if (g7 && (_6 = g7.placedGlyphBoxes, _6 && _6.box && _6.box.length)) {
                        I5 = true, L4 = g7.shift;
                        break;
                      }
                    }
                    return _6;
                  };
                  o4(() => c5(j5, _5.iconBox, e3.b9.horizontal), () => {
                    const t6 = _5.verticalTextBox;
                    return t6 && G4(t6), s4.allowVerticalPlacement && !(M3 && M3.box && M3.box.length) && E4 > 0 && t6 ? c5(t6, _5.verticalIconBox, e3.b9.vertical) : { box: null, offscreen: null, occluded: null };
                  }), M3 && (I5 = M3.box, R2 = M3.offscreen, A4 = M3.occluded);
                  const h5 = i5(!(!M3 || !M3.box));
                  if (!I5 && this.prevPlacement) {
                    const e4 = this.prevPlacement.variableOffsets[T6];
                    e4 && (this.variableOffsets[T6] = e4, this.markUsedJustification(s4, e4.anchor, t5, h5));
                  }
                } else {
                  const n4 = (i6, o5) => {
                    const n5 = s4.getSymbolInstanceTextSize(p4, t5, this.transform.zoom, r5), l5 = this.collisionIndex.placeCollisionBox(s4, n5, i6, new e3.P(0, 0), x5, u5, a4, m4.predicate);
                    return l5 && l5.box && l5.box.length && (this.markUsedOrientation(s4, o5, t5), this.placedOrientations[T6] = o5), l5;
                  };
                  o4(() => n4(j5, e3.b9.horizontal), () => {
                    const t6 = _5.verticalTextBox;
                    return s4.allowVerticalPlacement && E4 > 0 && t6 ? (G4(t6), n4(t6, e3.b9.vertical)) : { box: null, offscreen: null, occluded: null };
                  }), i5(!!(M3 && M3.box && M3.box.length));
                }
              }
              if (O3 = M3, I5 = O3 && O3.box && O3.box.length > 0, R2 = O3 && O3.offscreen, A4 = O3 && O3.occluded, t5.useRuntimeCollisionCircles) {
                const i5 = s4.text.placedSymbolArray.get(t5.centerJustifiedTextSymbolIndex >= 0 ? t5.centerJustifiedTextSymbolIndex : t5.verticalPlacedTextSymbolIndex), r6 = e3.ba(s4.textSizeData, p4, i5), h5 = n3.get("text-padding");
                F5 = this.collisionIndex.placeCollisionCircles(s4, x5, i5, s4.lineVertexArray, s4.glyphOffsetArray, r6, a4, l4, c4, o3, w5, m4.predicate, t5.collisionCircleDiameter * r6 / e3.bf, h5, this.retainedQueryData[s4.bucketInstanceId].tileID), I5 = x5 || F5.circles.length > 0 && !F5.collisionDetected, R2 = R2 && F5.offscreen, A4 = F5.occluded;
              }
              if (_5.iconFeatureIndex && (U3 = _5.iconFeatureIndex), _5.iconBox) {
                const i5 = (i6) => {
                  G4(i6);
                  const o4 = t5.hasIconTextFit && L4 ? Ui(L4.x, L4.y, b4, w5, this.transform.angle) : new e3.P(0, 0), r6 = s4.getSymbolInstanceIconSize(f4, this.transform.zoom, t5.placedIconSymbolIndex);
                  return this.collisionIndex.placeCollisionBox(s4, r6, i6, o4, y4, u5, a4, m4.predicate);
                };
                z4 && z4.box && z4.box.length && _5.verticalIconBox ? (B4 = i5(_5.verticalIconBox), D4 = B4.box.length > 0) : (B4 = i5(_5.iconBox), D4 = B4.box.length > 0), R2 = R2 && B4.offscreen, P4 = B4.occluded;
              }
              const V4 = g5 || 0 === t5.numHorizontalGlyphVertices && 0 === E4, Z3 = v4 || 0 === t5.numIconVertices;
              if (V4 || Z3 ? Z3 ? V4 || (D4 = D4 && I5) : I5 = D4 && I5 : D4 = I5 = D4 && I5, I5 && O3 && O3.box && this.collisionIndex.insertCollisionBox(O3.box, n3.get("text-ignore-placement"), s4.bucketInstanceId, z4 && z4.box && N4 ? N4 : k4, m4.ID), D4 && B4 && this.collisionIndex.insertCollisionBox(B4.box, n3.get("icon-ignore-placement"), s4.bucketInstanceId, U3, m4.ID), F5 && (I5 && this.collisionIndex.insertCollisionCircles(F5.circles, n3.get("text-ignore-placement"), s4.bucketInstanceId, k4, m4.ID), o3)) {
                const e4 = s4.bucketInstanceId;
                let t6 = this.collisionCircleArrays[e4];
                void 0 === t6 && (t6 = this.collisionCircleArrays[e4] = new Fi());
                for (let e5 = 0; e5 < F5.circles.length; e5 += 4) t6.circles.push(F5.circles[e5 + 0]), t6.circles.push(F5.circles[e5 + 1]), t6.circles.push(F5.circles[e5 + 2]), t6.circles.push(F5.collisionDetected ? 1 : 0);
              }
              const W3 = "globe" !== s4.projection.name;
              S3 = S3 && (W3 || !A4), C4 = C4 && (W3 || !P4), this.placements[T6] = new Oi(I5 || S3, D4 || C4, R2 || s4.justReloaded), i4.add(T6);
            };
            if (E3 && this.buildingIndex && (this.buildingIndex.updateZOffset(s4, this.retainedQueryData[s4.bucketInstanceId].tileID), s4.updateZOffset()), T5) {
              const t5 = s4.getSortedSymbolIndexes(this.transform.angle);
              for (let e4 = t5.length - 1; e4 >= 0; --e4) {
                const i5 = t5[e4];
                I4(s4.symbolInstances.get(i5), i5, s4.collisionArrays[i5]);
              }
              s4.hasAnyZOffset && e3.w(`${s4.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
            } else if (s4.hasAnyZOffset) {
              const e4 = s4.getSortedIndexesByZOffset();
              for (let t5 = 0; t5 < e4.length; ++t5) {
                const i5 = e4[t5];
                I4(s4.symbolInstances.get(i5), i5, s4.collisionArrays[i5]);
              }
            } else for (let e4 = t4.symbolInstanceStart; e4 < t4.symbolInstanceEnd; e4++) I4(s4.symbolInstances.get(e4), e4, s4.collisionArrays[e4]);
            if (o3 && s4.bucketInstanceId in this.collisionCircleArrays) {
              const t5 = this.collisionCircleArrays[s4.bucketInstanceId];
              e3.a9.invert(t5.invProjMatrix, a4), t5.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            s4.justReloaded = false;
          }
          markUsedJustification(t4, i4, o3, r4) {
            const { leftJustifiedTextSymbolIndex: s4, centerJustifiedTextSymbolIndex: n3, rightJustifiedTextSymbolIndex: a4, verticalPlacedTextSymbolIndex: l4, crossTileID: c4 } = o3, h4 = e3.bg(i4), u5 = r4 === e3.b9.vertical ? l4 : "left" === h4 ? s4 : "center" === h4 ? n3 : "right" === h4 ? a4 : -1;
            s4 >= 0 && (t4.text.placedSymbolArray.get(s4).crossTileID = u5 >= 0 && s4 !== u5 ? 0 : c4), n3 >= 0 && (t4.text.placedSymbolArray.get(n3).crossTileID = u5 >= 0 && n3 !== u5 ? 0 : c4), a4 >= 0 && (t4.text.placedSymbolArray.get(a4).crossTileID = u5 >= 0 && a4 !== u5 ? 0 : c4), l4 >= 0 && (t4.text.placedSymbolArray.get(l4).crossTileID = u5 >= 0 && l4 !== u5 ? 0 : c4);
          }
          markUsedOrientation(t4, i4, o3) {
            const r4 = i4 === e3.b9.horizontal || i4 === e3.b9.horizontalOnly ? i4 : 0, s4 = i4 === e3.b9.vertical ? i4 : 0, { leftJustifiedTextSymbolIndex: n3, centerJustifiedTextSymbolIndex: a4, rightJustifiedTextSymbolIndex: l4, verticalPlacedTextSymbolIndex: c4 } = o3, h4 = t4.text.placedSymbolArray;
            n3 >= 0 && (h4.get(n3).placedOrientation = r4), a4 >= 0 && (h4.get(a4).placedOrientation = r4), l4 >= 0 && (h4.get(l4).placedOrientation = r4), c4 >= 0 && (h4.get(c4).placedOrientation = s4);
          }
          commit(e4) {
            this.commitTime = e4, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const t4 = this.prevPlacement;
            let i4 = false;
            this.prevZoomAdjustment = t4 ? t4.zoomAdjustment(this.transform.zoom) : 0;
            const o3 = t4 ? t4.symbolFadeChange(e4) : 1, r4 = t4 ? t4.opacities : {}, s4 = t4 ? t4.variableOffsets : {}, n3 = t4 ? t4.placedOrientations : {};
            for (const e5 in this.placements) {
              const t5 = this.placements[e5], s5 = r4[e5];
              s5 ? (this.opacities[e5] = new zi(s5, o3, t5.text, t5.icon, null, t5.clipped), i4 = i4 || t5.text !== s5.text.placed || t5.icon !== s5.icon.placed) : (this.opacities[e5] = new zi(null, o3, t5.text, t5.icon, t5.skipFade, t5.clipped), i4 = i4 || t5.text || t5.icon);
            }
            for (const e5 in r4) {
              const t5 = r4[e5];
              if (!this.opacities[e5]) {
                const r5 = new zi(t5, o3, false, false);
                r5.isHidden() || (this.opacities[e5] = r5, i4 = i4 || t5.text.placed || t5.icon.placed);
              }
            }
            for (const e5 in s4) this.variableOffsets[e5] || !this.opacities[e5] || this.opacities[e5].isHidden() || (this.variableOffsets[e5] = s4[e5]);
            for (const e5 in n3) this.placedOrientations[e5] || !this.opacities[e5] || this.opacities[e5].isHidden() || (this.placedOrientations[e5] = n3[e5]);
            i4 ? this.lastPlacementChangeTime = e4 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t4 ? t4.lastPlacementChangeTime : e4);
          }
          updateLayerOpacities(e4, t4) {
            const i4 = /* @__PURE__ */ new Set();
            for (const o3 of t4) {
              const t5 = o3.getBucket(e4);
              t5 && o3.latestFeatureIndex && e4.fqid === t5.layerIds[0] && (this.updateBucketOpacities(t5, i4, o3.collisionBoxArray), t5.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(t5, o3.tileID), t5.updateZOffset()));
            }
          }
          updateBucketOpacities(t4, i4, o3) {
            t4.hasTextData() && t4.text.opacityVertexArray.clear(), t4.hasIconData() && t4.icon.opacityVertexArray.clear(), t4.hasIconCollisionBoxData() && t4.iconCollisionBox.collisionVertexArray.clear(), t4.hasTextCollisionBoxData() && t4.textCollisionBox.collisionVertexArray.clear();
            const r4 = t4.layers[0].layout, s4 = !!t4.layers[0].dynamicFilter(), n3 = new zi(null, 0, false, false, true), a4 = r4.get("text-allow-overlap"), l4 = r4.get("icon-allow-overlap"), c4 = r4.get("text-variable-anchor"), h4 = "map" === r4.get("text-rotation-alignment"), u5 = "map" === r4.get("text-pitch-alignment"), d3 = new zi(null, 0, a4 && (l4 || !t4.hasIconData() || r4.get("icon-optional")), l4 && (a4 || !t4.hasTextData() || r4.get("text-optional")), true);
            !t4.collisionArrays && o3 && (t4.hasIconCollisionBoxData() || t4.hasTextCollisionBoxData()) && t4.deserializeCollisionBoxes(o3);
            const _4 = (e4, t5, i5) => {
              for (let o4 = 0; o4 < t5 / 4; o4++) e4.opacityVertexArray.emplaceBack(i5);
            };
            let p4 = 0;
            for (let o4 = 0; o4 < t4.symbolInstances.length; o4++) {
              const r5 = t4.symbolInstances.get(o4), { numHorizontalGlyphVertices: a5, numVerticalGlyphVertices: l5, crossTileID: f4, numIconVertices: m4 } = r5, g5 = i4.has(f4);
              let v4 = this.opacities[f4];
              g5 ? v4 = n3 : v4 || (v4 = d3, this.opacities[f4] = v4), i4.add(f4);
              const x5 = a5 > 0 || l5 > 0, y4 = m4 > 0, b4 = this.placedOrientations[f4], w5 = b4 === e3.b9.vertical, T5 = b4 === e3.b9.horizontal || b4 === e3.b9.horizontalOnly;
              if (!x5 && !y4 || v4.isHidden() || p4++, x5) {
                const e4 = Xi(v4.text);
                _4(t4.text, a5, w5 ? Yi : e4), _4(t4.text, l5, T5 ? Yi : e4);
                const i5 = v4.text.isHidden(), { leftJustifiedTextSymbolIndex: o5, centerJustifiedTextSymbolIndex: s5, rightJustifiedTextSymbolIndex: n4, verticalPlacedTextSymbolIndex: c5 } = r5, h5 = t4.text.placedSymbolArray, u6 = i5 || w5 ? 1 : 0;
                o5 >= 0 && (h5.get(o5).hidden = u6), s5 >= 0 && (h5.get(s5).hidden = u6), n4 >= 0 && (h5.get(n4).hidden = u6), c5 >= 0 && (h5.get(c5).hidden = i5 || T5 ? 1 : 0);
                const d4 = this.variableOffsets[f4];
                d4 && this.markUsedJustification(t4, d4.anchor, r5, b4);
                const p5 = this.placedOrientations[f4];
                p5 && (this.markUsedJustification(t4, "left", r5, p5), this.markUsedOrientation(t4, p5, r5));
              }
              if (y4) {
                const e4 = Xi(v4.icon), { placedIconSymbolIndex: i5, verticalPlacedIconSymbolIndex: o5 } = r5, s5 = t4.icon.placedSymbolArray, n4 = v4.icon.isHidden() ? 1 : 0;
                i5 >= 0 && (_4(t4.icon, m4, w5 ? Yi : e4), s5.get(i5).hidden = n4), o5 >= 0 && (_4(t4.icon, r5.numVerticalIconVertices, T5 ? Yi : e4), s5.get(o5).hidden = n4);
              }
              if (t4.hasIconCollisionBoxData() || t4.hasTextCollisionBoxData()) {
                const i5 = t4.collisionArrays[o4];
                if (i5) {
                  let o5 = new e3.P(0, 0), n4 = true;
                  if (i5.textBox || i5.verticalTextBox) {
                    if (c4) {
                      const e4 = this.variableOffsets[f4];
                      e4 ? (o5 = Ni(e4.anchor, e4.width, e4.height, e4.textOffset, e4.textScale), h4 && o5._rotate(u5 ? this.transform.angle : -this.transform.angle)) : n4 = false;
                    }
                    s4 && (n4 = !v4.clipped), i5.textBox && ji(t4.textCollisionBox.collisionVertexArray, v4.text.placed, !n4 || w5, o5.x, o5.y), i5.verticalTextBox && ji(t4.textCollisionBox.collisionVertexArray, v4.text.placed, !n4 || T5, o5.x, o5.y);
                  }
                  const a6 = n4 && Boolean(!T5 && i5.verticalIconBox);
                  i5.iconBox && ji(t4.iconCollisionBox.collisionVertexArray, v4.icon.placed, a6, r5.hasIconTextFit ? o5.x : 0, r5.hasIconTextFit ? o5.y : 0), i5.verticalIconBox && ji(t4.iconCollisionBox.collisionVertexArray, v4.icon.placed, !a6, r5.hasIconTextFit ? o5.x : 0, r5.hasIconTextFit ? o5.y : 0);
                }
              }
            }
            if (t4.fullyClipped = 0 === p4, t4.sortFeatures(this.transform.angle), this.retainedQueryData[t4.bucketInstanceId] && (this.retainedQueryData[t4.bucketInstanceId].featureSortOrder = t4.featureSortOrder), t4.hasTextData() && t4.text.opacityVertexBuffer && t4.text.opacityVertexBuffer.updateData(t4.text.opacityVertexArray), t4.hasIconData() && t4.icon.opacityVertexBuffer && t4.icon.opacityVertexBuffer.updateData(t4.icon.opacityVertexArray), t4.hasIconCollisionBoxData() && t4.iconCollisionBox.collisionVertexBuffer && t4.iconCollisionBox.collisionVertexBuffer.updateData(t4.iconCollisionBox.collisionVertexArray), t4.hasTextCollisionBoxData() && t4.textCollisionBox.collisionVertexBuffer && t4.textCollisionBox.collisionVertexBuffer.updateData(t4.textCollisionBox.collisionVertexArray), t4.bucketInstanceId in this.collisionCircleArrays) {
              const e4 = this.collisionCircleArrays[t4.bucketInstanceId];
              t4.placementInvProjMatrix = e4.invProjMatrix, t4.placementViewportMatrix = e4.viewportMatrix, t4.collisionCircleArray = e4.circles, delete this.collisionCircleArrays[t4.bucketInstanceId];
            }
          }
          symbolFadeChange(e4) {
            return 0 === this.fadeDuration ? 1 : (e4 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e4) {
            return Math.max(0, (this.transform.zoom - e4) / 1.5);
          }
          hasTransitions(e4) {
            return this.stale || e4 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e4, t4) {
            const i4 = this.zoomAtLastRecencyCheck === t4 ? 1 - this.zoomAdjustment(t4) : 1;
            return this.zoomAtLastRecencyCheck = t4, this.commitTime + this.fadeDuration * i4 > e4;
          }
          setStale() {
            this.stale = true;
          }
        }
        function ji(e4, t4, i4, o3, r4) {
          e4.emplaceBack(t4 ? 1 : 0, i4 ? 1 : 0, o3 || 0, r4 || 0), e4.emplaceBack(t4 ? 1 : 0, i4 ? 1 : 0, o3 || 0, r4 || 0), e4.emplaceBack(t4 ? 1 : 0, i4 ? 1 : 0, o3 || 0, r4 || 0), e4.emplaceBack(t4 ? 1 : 0, i4 ? 1 : 0, o3 || 0, r4 || 0);
        }
        const Vi = Math.pow(2, 25), Zi = Math.pow(2, 24), Wi = Math.pow(2, 17), Hi = Math.pow(2, 16), qi = Math.pow(2, 9), Qi = Math.pow(2, 8), $i = Math.pow(2, 1);
        function Xi(e4) {
          if (0 === e4.opacity && !e4.placed) return 0;
          if (1 === e4.opacity && e4.placed) return 4294967295;
          const t4 = e4.placed ? 1 : 0, i4 = Math.floor(127 * e4.opacity);
          return i4 * Vi + t4 * Zi + i4 * Wi + t4 * Hi + i4 * qi + t4 * Qi + i4 * $i + t4;
        }
        const Yi = 0;
        class Ji {
          constructor(e4) {
            this._sortAcrossTiles = "viewport-y" !== e4.layout.get("symbol-z-order") && void 0 !== e4.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
          }
          continuePlacement(e4, t4, i4, o3, r4) {
            const s4 = this._bucketParts;
            for (; this._currentTileIndex < e4.length; ) if (t4.getBucketParts(s4, o3, e4[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r4()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, s4.sort((e5, t5) => e5.sortKey - t5.sortKey)); this._currentPartIndex < s4.length; ) {
              const e5 = s4[this._currentPartIndex];
              if (t4.placeLayerBucketPart(e5, this._seenCrossTileIDs, i4, 0 === e5.symbolInstanceStart), this._currentPartIndex++, r4()) return true;
            }
            return false;
          }
        }
        class Ki {
          constructor(e4, t4, i4, o3, r4, s4, n3, a4, l4) {
            this.placement = new Gi(e4, r4, s4, n3, a4, l4), this._currentPlacementIndex = t4.length - 1, this._forceFullPlacement = i4, this._showCollisionBoxes = o3, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t4, i4, o3, r4) {
            const s4 = e3.f.now(), n3 = () => {
              const t5 = e3.f.now() - s4;
              return !this._forceFullPlacement && t5 > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              const s5 = i4[t4[this._currentPlacementIndex]], a4 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === s5.type && (!s5.minzoom || s5.minzoom <= a4) && (!s5.maxzoom || s5.maxzoom > a4)) {
                const t5 = s5, i5 = t5.layout.get("symbol-z-elevate"), a5 = this._inProgressLayer = this._inProgressLayer || new Ji(t5), l4 = e3.aj(s5.source, s5.scope);
                if (a5.continuePlacement(i5 ? r4[l4] : o3[l4], this.placement, this._showCollisionBoxes, s5, n3)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e4) {
            return this.placement.commit(e4), this.placement;
          }
        }
        const eo = 512 / e3.Y / 2;
        class to {
          constructor(t4, i4, o3) {
            this.tileID = t4, this.bucketInstanceId = o3, this.index = new e3.bj(i4.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
            const r4 = t4.canonical.x * e3.Y, s4 = t4.canonical.y * e3.Y;
            for (let e4 = 0; e4 < i4.length; e4++) {
              const { key: t5, crossTileID: o4, tileAnchorX: n3, tileAnchorY: a4 } = i4.get(e4), l4 = Math.floor((r4 + n3) * eo), c4 = Math.floor((s4 + a4) * eo);
              this.index.add(l4, c4), this.keys.push(t5), this.crossTileIDs.push(o4);
            }
            this.index.finish();
          }
          findMatches(t4, i4, o3) {
            const r4 = this.tileID.canonical.z < i4.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i4.canonical.z), s4 = eo / Math.pow(2, i4.canonical.z - this.tileID.canonical.z), n3 = i4.canonical.x * e3.Y, a4 = i4.canonical.y * e3.Y;
            for (let e4 = 0; e4 < t4.length; e4++) {
              const i5 = t4.get(e4);
              if (i5.crossTileID) continue;
              const { key: l4, tileAnchorX: c4, tileAnchorY: h4 } = i5, u5 = Math.floor((n3 + c4) * s4), d3 = Math.floor((a4 + h4) * s4), _4 = this.index.range(u5 - r4, d3 - r4, u5 + r4, d3 + r4);
              for (const e5 of _4) {
                const t5 = this.crossTileIDs[e5];
                if (this.keys[e5] === l4 && !o3.has(t5)) {
                  o3.add(t5), i5.crossTileID = t5;
                  break;
                }
              }
            }
          }
        }
        class io {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class oo {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e4) {
            const t4 = Math.round((e4 - this.lng) / 360);
            if (0 !== t4) for (const e5 in this.indexes) {
              const i4 = this.indexes[e5], o3 = {};
              for (const e6 in i4) {
                const r4 = i4[e6];
                r4.tileID = r4.tileID.unwrapTo(r4.tileID.wrap + t4), o3[r4.tileID.key] = r4;
              }
              this.indexes[e5] = o3;
            }
            this.lng = e4;
          }
          addBucket(e4, t4, i4) {
            if (this.indexes[e4.overscaledZ] && this.indexes[e4.overscaledZ][e4.key]) {
              if (this.indexes[e4.overscaledZ][e4.key].bucketInstanceId === t4.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(e4.overscaledZ, this.indexes[e4.overscaledZ][e4.key]);
            }
            for (let e5 = 0; e5 < t4.symbolInstances.length; e5++) t4.symbolInstances.get(e5).crossTileID = 0;
            this.usedCrossTileIDs[e4.overscaledZ] || (this.usedCrossTileIDs[e4.overscaledZ] = /* @__PURE__ */ new Set());
            const o3 = this.usedCrossTileIDs[e4.overscaledZ];
            for (const i5 in this.indexes) {
              const r4 = this.indexes[i5];
              if (Number(i5) > e4.overscaledZ) for (const i6 in r4) {
                const s4 = r4[i6];
                s4.tileID.isChildOf(e4) && s4.findMatches(t4.symbolInstances, e4, o3);
              }
              else {
                const s4 = r4[e4.scaledTo(Number(i5)).key];
                s4 && s4.findMatches(t4.symbolInstances, e4, o3);
              }
            }
            for (let e5 = 0; e5 < t4.symbolInstances.length; e5++) {
              const r4 = t4.symbolInstances.get(e5);
              r4.crossTileID || (r4.crossTileID = i4.generate(), o3.add(r4.crossTileID));
            }
            return void 0 === this.indexes[e4.overscaledZ] && (this.indexes[e4.overscaledZ] = {}), this.indexes[e4.overscaledZ][e4.key] = new to(e4, t4.symbolInstances, t4.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e4, t4) {
            for (const i4 of t4.crossTileIDs) this.usedCrossTileIDs[e4].delete(i4);
          }
          removeStaleBuckets(e4) {
            let t4 = false;
            for (const i4 in this.indexes) {
              const o3 = this.indexes[i4];
              for (const r4 in o3) e4[o3[r4].bucketInstanceId] || (this.removeBucketCrossTileIDs(i4, o3[r4]), delete o3[r4], t4 = true);
            }
            return t4;
          }
        }
        class ro {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new io(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e4, t4, i4, o3) {
            let r4 = this.layerIndexes[e4.fqid];
            void 0 === r4 && (r4 = this.layerIndexes[e4.fqid] = new oo());
            let s4 = false;
            const n3 = {};
            "globe" !== o3.name && r4.handleWrapJump(i4);
            for (const i5 of t4) {
              const t5 = i5.getBucket(e4);
              t5 && e4.fqid === t5.layerIds[0] && (t5.bucketInstanceId || (t5.bucketInstanceId = ++this.maxBucketInstanceId), r4.addBucket(i5.tileID, t5, this.crossTileIDs) && (s4 = true), n3[t5.bucketInstanceId] = true);
            }
            return r4.removeStaleBuckets(n3) && (s4 = true), s4;
          }
          pruneUnusedLayers(e4) {
            const t4 = {};
            e4.forEach((e5) => {
              t4[e5] = true;
            });
            for (const e5 in this.layerIndexes) t4[e5] || delete this.layerIndexes[e5];
          }
        }
        class so {
          constructor(e4 = 0, t4 = 0, i4 = 0, o3 = 0) {
            if (isNaN(e4) || e4 < 0 || isNaN(t4) || t4 < 0 || isNaN(i4) || i4 < 0 || isNaN(o3) || o3 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e4, this.bottom = t4, this.left = i4, this.right = o3;
          }
          interpolate(t4, i4, o3) {
            return null != i4.top && null != t4.top && (this.top = e3.X(t4.top, i4.top, o3)), null != i4.bottom && null != t4.bottom && (this.bottom = e3.X(t4.bottom, i4.bottom, o3)), null != i4.left && null != t4.left && (this.left = e3.X(t4.left, i4.left, o3)), null != i4.right && null != t4.right && (this.right = e3.X(t4.right, i4.right, o3)), this;
          }
          getCenter(t4, i4) {
            const o3 = e3.ad((this.left + t4 - this.right) / 2, 0, t4), r4 = e3.ad((this.top + i4 - this.bottom) / 2, 0, i4);
            return new e3.P(o3, r4);
          }
          equals(e4) {
            return this.top === e4.top && this.bottom === e4.bottom && this.left === e4.left && this.right === e4.right;
          }
          clone() {
            return new so(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function no(t4, i4) {
          const o3 = e3.bn(t4, 3);
          e3.a9.fromQuat(t4, i4), e3.bp(t4, 3, o3);
        }
        function ao(t4, i4) {
          const o3 = e3.bl.identity([]);
          return e3.bl.rotateZ(o3, o3, -i4), e3.bl.rotateX(o3, o3, -t4), o3;
        }
        function lo(t4, i4) {
          const o3 = [t4[0], t4[1], 0], r4 = [i4[0], i4[1], 0];
          if (e3.Q.length(o3) >= 1e-15) {
            const t5 = e3.Q.normalize([], o3);
            e3.Q.scale(r4, t5, e3.Q.dot(r4, t5)), i4[0] = r4[0], i4[1] = r4[1];
          }
          const s4 = e3.Q.cross([], i4, t4);
          if (e3.Q.len(s4) < 1e-15) return null;
          const n3 = Math.atan2(-s4[1], s4[0]);
          return ao(Math.atan2(Math.sqrt(t4[0] * t4[0] + t4[1] * t4[1]), -t4[2]), n3);
        }
        class co {
          constructor(e4, t4) {
            this.position = e4, this.orientation = t4;
          }
          get position() {
            return this._position;
          }
          set position(t4) {
            if (t4) {
              const i4 = t4 instanceof e3.O ? t4 : new e3.O(t4[0], t4[1], t4[2]);
              this._renderWorldCopies && (i4.x = e3.bk(i4.x, 0, 1)), this._position = i4;
            } else this._position = null;
          }
          lookAtPoint(t4, i4) {
            if (this.orientation = null, !this.position) return;
            const o3 = this.position, r4 = this._elevation ? this._elevation.getAtPointOrZero(e3.O.fromLngLat(t4)) : 0, s4 = e3.O.fromLngLat(t4, r4), n3 = [s4.x - o3.x, s4.y - o3.y, s4.z - o3.z];
            i4 || (i4 = [0, 0, 1]), i4[2] = Math.abs(i4[2]), this.orientation = lo(n3, i4);
          }
          setPitchBearing(t4, i4) {
            this.orientation = ao(e3.bm(t4), e3.bm(-i4));
          }
        }
        class ho {
          constructor(t4, i4) {
            this._transform = e3.a9.identity([]), this.orientation = i4, this.position = t4;
          }
          get mercatorPosition() {
            const t4 = this.position;
            return new e3.O(t4[0], t4[1], t4[2]);
          }
          get position() {
            const t4 = e3.bn(this._transform, 3);
            return [t4[0], t4[1], t4[2]];
          }
          set position(t4) {
            var i4;
            t4 && e3.bp(this._transform, 3, [(i4 = t4)[0], i4[1], i4[2], 1]);
          }
          get orientation() {
            return this._orientation;
          }
          set orientation(t4) {
            this._orientation = t4 || e3.bl.identity([]), t4 && no(this._transform, this._orientation);
          }
          getPitchBearing() {
            const e4 = this.forward(), t4 = this.right();
            return { bearing: Math.atan2(-t4[1], t4[0]), pitch: Math.atan2(Math.sqrt(e4[0] * e4[0] + e4[1] * e4[1]), -e4[2]) };
          }
          setPitchBearing(e4, t4) {
            this._orientation = ao(e4, t4), no(this._transform, this._orientation);
          }
          forward() {
            const t4 = e3.bn(this._transform, 2);
            return [-t4[0], -t4[1], -t4[2]];
          }
          up() {
            const t4 = e3.bn(this._transform, 1);
            return [-t4[0], -t4[1], -t4[2]];
          }
          right() {
            const t4 = e3.bn(this._transform, 0);
            return [t4[0], t4[1], t4[2]];
          }
          getCameraToWorld(t4, i4) {
            const o3 = new Float64Array(16);
            return e3.a9.invert(o3, this.getWorldToCamera(t4, i4)), o3;
          }
          getCameraToWorldMercator() {
            return this._transform;
          }
          getWorldToCameraPosition(t4, i4, o3) {
            const r4 = this.position;
            e3.Q.scale(r4, r4, -t4);
            const s4 = new Float64Array(16);
            return e3.a9.fromScaling(s4, [o3, o3, o3]), e3.a9.translate(s4, s4, r4), s4[10] *= i4, s4;
          }
          getWorldToCamera(t4, i4) {
            const o3 = new Float64Array(16), r4 = new Float64Array(4), s4 = this.position;
            return e3.bl.conjugate(r4, this._orientation), e3.Q.scale(s4, s4, -t4), e3.a9.fromQuat(o3, r4), e3.a9.translate(o3, o3, s4), o3[1] *= -1, o3[5] *= -1, o3[9] *= -1, o3[13] *= -1, o3[8] *= i4, o3[9] *= i4, o3[10] *= i4, o3[11] *= i4, o3;
          }
          getCameraToClipPerspective(t4, i4, o3, r4) {
            const s4 = new Float64Array(16);
            return e3.a9.perspective(s4, t4, i4, o3, r4), s4;
          }
          getCameraToClipOrthographic(t4, i4, o3, r4, s4, n3) {
            const a4 = new Float64Array(16);
            return e3.a9.ortho(a4, t4, i4, o3, r4, s4, n3), a4;
          }
          getDistanceToElevation(t4, i4 = false) {
            const o3 = 0 === t4 ? 0 : e3.bo(t4, i4 ? e3.ax(this.position[1]) : this.position[1]), r4 = this.forward();
            return (o3 - this.position[2]) / r4[2];
          }
          clone() {
            return new ho([...this.position], [...this.orientation]);
          }
        }
        const uo = (e4, t4, i4) => (1 - i4) * e4 + i4 * t4, _o = (e4) => e4 * e4 * e4 * e4 * e4;
        class po {
          constructor(t4, i4, o3, r4, s4, n3, a4) {
            this.tileSize = 512, this._renderWorldCopies = void 0 === s4 || s4, this._minZoom = t4 || 0, this._maxZoom = i4 || 22, this._minPitch = null == o3 ? 0 : o3, this._maxPitch = null == r4 ? 60 : r4, this.setProjection(n3), this.setMaxBounds(a4), this.width = 0, this.height = 0, this._center = new e3.bq(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new so(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new ho(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = false, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = false;
          }
          clone() {
            const e4 = new po(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
            return e4._elevation = this._elevation, e4._centerAltitude = this._centerAltitude, e4._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e4.tileSize = this.tileSize, e4.mercatorFromTransition = this.mercatorFromTransition, e4.width = this.width, e4.height = this.height, e4.cameraElevationReference = this.cameraElevationReference, e4._center = this._center, e4._setZoom(this.zoom), e4._seaLevelZoom = this._seaLevelZoom, e4.angle = this.angle, e4._fov = this._fov, e4._pitch = this._pitch, e4._nearZ = this._nearZ, e4._farZ = this._farZ, e4._averageElevation = this._averageElevation, e4._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e4._unmodified = this._unmodified, e4._edgeInsets = this._edgeInsets.clone(), e4._camera = this._camera.clone(), e4._calcMatrices(), e4.freezeTileCoverage = this.freezeTileCoverage, e4.frustumCorners = this.frustumCorners, e4;
          }
          get isOrthographic() {
            return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < 15;
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(e4) {
            this._elevation !== e4 && (this._elevation = e4, this._updateCameraOnTerrain(), this._calcMatrices());
          }
          get depthOcclusionForSymbolsAndCircles() {
            return "globe" !== this.projection.name && !this.isOrthographic;
          }
          updateElevation(e4, t4 = false) {
            const i4 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
            (null == this._seaLevelZoom || i4) && this._updateCameraOnTerrain(), (e4 || i4) && this._constrainCamera(t4), this._calcMatrices();
          }
          getProjection() {
            return e3.af(this.projection, ["name", "center", "parallels"]);
          }
          setProjection(i4) {
            this.projectionOptions = i4 || { name: "mercator" };
            const o3 = this.projection ? this.getProjection() : void 0;
            this.projection = e3.br(this.projectionOptions);
            const r4 = !t3(o3, this.getProjection());
            return r4 && this._calcMatrices(), this.mercatorFromTransition = false, r4;
          }
          setOrthographicProjectionAtLowPitch(e4) {
            return this._orthographicProjectionAtLowPitch !== e4 && (this._orthographicProjectionAtLowPitch = e4, this._calcMatrices(), true);
          }
          setMercatorFromTransition() {
            const t4 = this.projection.name;
            this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e3.br({ name: "mercator" });
            const i4 = t4 !== this.projection.name;
            return i4 && this._calcMatrices(), i4;
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(e4) {
            this._minZoom !== e4 && (this._minZoom = e4, this.zoom = Math.max(this.zoom, e4));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(e4) {
            this._maxZoom !== e4 && (this._maxZoom = e4, this.zoom = Math.min(this.zoom, e4));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(e4) {
            this._minPitch !== e4 && (this._minPitch = e4, this.pitch = Math.max(this.pitch, e4));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(e4) {
            this._maxPitch !== e4 && (this._maxPitch = e4, this.pitch = Math.min(this.pitch, e4));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
          }
          set renderWorldCopies(e4) {
            void 0 === e4 ? e4 = true : null === e4 && (e4 = false), this._renderWorldCopies = e4;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get cameraWorldSizeForFog() {
            const e4 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e4));
          }
          get cameraWorldSize() {
            const e4 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e4));
          }
          get pixelsPerMeter() {
            return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
          }
          get cameraPixelsPerMeter() {
            return e3.bo(1, this.center.lat) * this.cameraWorldSizeForFog;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e3.P(this.width, this.height);
          }
          get bearing() {
            return e3.bk(this.rotation, -180, 180);
          }
          set bearing(e4) {
            this.rotation = e4;
          }
          get rotation() {
            return -this.angle / Math.PI * 180;
          }
          set rotation(t4) {
            const i4 = -t4 * Math.PI / 180;
            this.angle !== i4 && (this._unmodified = false, this.angle = i4, this._calcMatrices(), this.rotationMatrix = e3.b7.create(), e3.b7.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t4) {
            const i4 = e3.ad(t4, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i4 && (this._unmodified = false, this._pitch = i4, this._calcMatrices());
          }
          get aspect() {
            return this.width / this.height;
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          get fovX() {
            return this._fov;
          }
          get fovY() {
            const e4 = 1 / Math.tan(0.5 * this.fovX);
            return 2 * Math.atan(1 / this.aspect / e4);
          }
          set fov(t4) {
            t4 = Math.max(0.01, Math.min(60, t4)), this._fov !== t4 && (this._unmodified = false, this._fov = e3.bm(t4), this._calcMatrices());
          }
          get averageElevation() {
            return this._averageElevation;
          }
          set averageElevation(e4) {
            this._averageElevation = e4, this._calcFogMatrices(), this._distanceTileDataCache = {};
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(e4) {
            const t4 = Math.min(Math.max(e4, this.minZoom), this.maxZoom);
            this._zoom !== t4 && (this._unmodified = false, this._setZoom(t4), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
          }
          _setZoom(e4) {
            this._zoom = e4, this.scale = this.zoomScale(e4), this.tileZoom = Math.floor(e4), this.zoomFraction = e4 - this.tileZoom;
          }
          get tileCoverLift() {
            return this._tileCoverLift;
          }
          set tileCoverLift(e4) {
            this._tileCoverLift !== e4 && (this._tileCoverLift = e4);
          }
          _updateCameraOnTerrain() {
            const e4 = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t4 = this.elevation && e4 === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
            if (!this._elevation || e4 === Number.NEGATIVE_INFINITY && (!t4 || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
            const i4 = this._elevation;
            t4 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i4.exaggeration() && this._centerAltitudeValidForExaggeration !== i4.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i4.exaggeration(), this._centerAltitudeValidForExaggeration = i4.exaggeration()) : (this._centerAltitude = e4 || 0, this._centerAltitudeValidForExaggeration = i4.exaggeration()), this._updateSeaLevelZoom();
          }
          _updateSeaLevelZoom() {
            void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
          }
          sampleAverageElevation() {
            if (!this._elevation) return 0;
            const t4 = this._elevation, i4 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o3 = this.horizonLineFromTop();
            let r4 = 0, s4 = 0;
            for (let n3 = 0; n3 < i4.length; n3++) {
              const a4 = new e3.P(i4[n3][0] * this.width, o3 + i4[n3][1] * (this.height - o3)), l4 = t4.pointCoordinate(a4);
              if (!l4) continue;
              const c4 = 1 / Math.hypot(l4[0] - this._camera.position[0], l4[1] - this._camera.position[1]);
              r4 += l4[3] * c4, s4 += c4;
            }
            return 0 === s4 ? NaN : r4 / s4;
          }
          get center() {
            return this._center;
          }
          set center(e4) {
            e4.lat === this._center.lat && e4.lng === this._center.lng || (this._unmodified = false, this._center = e4, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
          }
          _updateZoomFromElevation() {
            if (null == this._seaLevelZoom || !this._elevation) return;
            const e4 = this._seaLevelZoom, t4 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i4 = this.pixelsPerMeter / this.worldSize * t4, o3 = this._mercatorZfromZoom(e4), r4 = this._mercatorZfromZoom(this._maxZoom), s4 = Math.max(o3 - i4, r4);
            this._setZoom(this._zoomFromMercatorZ(s4));
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(e4) {
            this._edgeInsets.equals(e4) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e4, 1), this._calcMatrices());
          }
          computeZoomRelativeTo(t4) {
            const i4 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t4.toAltitude()));
            let o3;
            o3 = t4.z < this._camera.position[2] ? [i4.x, i4.y, i4.z] : [t4.x, t4.y, t4.z];
            const r4 = e3.Q.length(e3.Q.sub([], this._camera.position, o3));
            return e3.ad(this._zoomFromMercatorZ(r4), this._minZoom, this._maxZoom);
          }
          setFreeCameraOptions(t4) {
            if (!this.height) return;
            if (!t4.position && !t4.orientation) return;
            this._updateCameraState();
            let i4 = false;
            if (t4.orientation && !e3.bl.exactEquals(t4.orientation, this._camera.orientation) && (i4 = this._setCameraOrientation(t4.orientation)), t4.position) {
              const o3 = [t4.position.x, t4.position.y, t4.position.z];
              e3.Q.exactEquals(o3, this._camera.position) || (this._setCameraPosition(o3), i4 = true);
            }
            i4 && (this._updateStateFromCamera(), this.recenterOnTerrain());
          }
          getFreeCameraOptions() {
            this._updateCameraState();
            const t4 = this._camera.position, i4 = new co();
            return i4.position = new e3.O(t4[0], t4[1], t4[2]), i4.orientation = this._camera.orientation, i4._elevation = this.elevation, i4._renderWorldCopies = this.renderWorldCopies, i4;
          }
          _setCameraOrientation(t4) {
            if (!e3.bl.length(t4)) return false;
            e3.bl.normalize(t4, t4);
            const i4 = e3.Q.transformQuat([], [0, 0, -1], t4), o3 = e3.Q.transformQuat([], [0, -1, 0], t4);
            if (o3[2] < 0) return false;
            const r4 = lo(i4, o3);
            return !!r4 && (this._camera.orientation = r4, true);
          }
          _setCameraPosition(t4) {
            const i4 = this.zoomScale(this.minZoom) * this.tileSize, o3 = this.zoomScale(this.maxZoom) * this.tileSize, r4 = this.cameraToCenterDistance;
            t4[2] = e3.ad(t4[2], r4 / o3, r4 / i4), this._camera.position = t4;
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          get fovAboveCenter() {
            return this._fov * (0.5 + this.centerOffset.y / this.height);
          }
          isPaddingEqual(e4) {
            return this._edgeInsets.equals(e4);
          }
          interpolatePadding(e4, t4, i4) {
            this._unmodified = false, this._edgeInsets.interpolate(e4, t4, i4), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(e4) {
            const t4 = (e4.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e4.tileSize));
            return Math.max(0, t4);
          }
          getVisibleUnwrappedCoordinates(t4) {
            const i4 = [new e3.bs(0, t4)];
            if (this.renderWorldCopies) {
              const o3 = this.pointCoordinate(new e3.P(0, 0)), r4 = this.pointCoordinate(new e3.P(this.width, 0)), s4 = this.pointCoordinate(new e3.P(this.width, this.height)), n3 = this.pointCoordinate(new e3.P(0, this.height)), a4 = Math.floor(Math.min(o3.x, r4.x, s4.x, n3.x)), l4 = Math.floor(Math.max(o3.x, r4.x, s4.x, n3.x)), c4 = 1;
              for (let o4 = a4 - c4; o4 <= l4 + c4; o4++) 0 !== o4 && i4.push(new e3.bs(o4, t4));
            }
            return i4;
          }
          isLODDisabled(e4) {
            return (!e4 || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
          }
          extendTileCoverForShadows(t4, i4, o3) {
            let r4 = [];
            if (0 === i4[0] && 0 === i4[1]) return r4;
            for (const o4 of t4) {
              const t5 = o4.canonical, s5 = o4.overscaledZ, n3 = o4.wrap, a4 = 1 << t5.z, l4 = t5.x + 1 < a4, c4 = t5.x > 0, h4 = t5.y + 1 < a4, u5 = t5.y > 0, d3 = o4.wrap - (c4 ? 0 : 1), _4 = o4.wrap + (l4 ? 0 : 1), p4 = c4 ? t5.x - 1 : a4 - 1, f4 = l4 ? t5.x + 1 : 0;
              i4[0] < 0 ? (r4.push(new e3.ap(s5, _4, t5.z, f4, t5.y)), i4[1] < 0 && h4 && (r4.push(new e3.ap(s5, n3, t5.z, t5.x, t5.y + 1)), r4.push(new e3.ap(s5, _4, t5.z, f4, t5.y + 1))), i4[1] > 0 && u5 && (r4.push(new e3.ap(s5, n3, t5.z, t5.x, t5.y - 1)), r4.push(new e3.ap(s5, _4, t5.z, f4, t5.y - 1)))) : i4[0] > 0 ? (r4.push(new e3.ap(s5, d3, t5.z, p4, t5.y)), i4[1] < 0 && h4 && (r4.push(new e3.ap(s5, n3, t5.z, t5.x, t5.y + 1)), r4.push(new e3.ap(s5, d3, t5.z, p4, t5.y + 1))), i4[1] > 0 && u5 && (r4.push(new e3.ap(s5, n3, t5.z, t5.x, t5.y - 1)), r4.push(new e3.ap(s5, d3, t5.z, p4, t5.y - 1)))) : i4[1] < 0 && h4 ? r4.push(new e3.ap(s5, n3, t5.z, t5.x, t5.y + 1)) : u5 && r4.push(new e3.ap(s5, n3, t5.z, t5.x, t5.y - 1));
            }
            if (r4.length > 1) {
              r4.sort((e5, t6) => e5.overscaledZ - t6.overscaledZ || e5.wrap - t6.wrap || e5.canonical.z - t6.canonical.z || e5.canonical.x - t6.canonical.x || e5.canonical.y - t6.canonical.y);
              let e4 = 0, t5 = 0;
              for (; t5 < r4.length; ) r4[t5].equals(r4[e4]) ? ++t5 : r4[++e4] = r4[t5++];
              r4.length = e4 + 1;
            }
            const s4 = [];
            for (const e4 of r4) r4.some((t5) => e4.isChildOf(t5)) || s4.push(e4);
            return r4 = s4.filter((e4) => !t4.some((t5) => !!(e4.overscaledZ < o3 && t5.isChildOf(e4)) || e4.equals(t5) || e4.isChildOf(t5))), r4;
          }
          coveringTiles(t4) {
            let i4 = this.coveringZoomLevel(t4);
            const o3 = i4, r4 = this.elevation && this.elevation.exaggeration(), s4 = r4 && !t4.isTerrainDEM, n3 = "mercator" === this.projection.name;
            if (void 0 !== t4.minzoom && i4 < t4.minzoom) return [];
            void 0 !== t4.maxzoom && i4 > t4.maxzoom && (i4 = t4.maxzoom);
            const a4 = this.locationCoordinate(this.center), l4 = this.center.lat, c4 = 1 << i4, h4 = [c4 * a4.x, c4 * a4.y, 0], u5 = "globe" === this.projection.name, d3 = !u5, _4 = e3.bt.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i4, d3), p4 = u5 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f4 = c4 * e3.bo(1, this.center.lat), m4 = this._camera.position[2] / e3.bo(1, this.center.lat), g5 = [c4 * p4.x, c4 * p4.y, m4 * (d3 ? 1 : f4)], v4 = u5 || r4, x5 = this.cameraToCenterDistance / t4.tileSize * (t4.roundZoom ? 1 : 0.502), y4 = this.isLODDisabled(true) ? i4 : 0;
            let b4;
            if (this._elevation && t4.isTerrainDEM) b4 = 1e4 * this._elevation.exaggeration();
            else if (this._elevation) {
              const e4 = this._elevation.getMinMaxForVisibleTiles();
              b4 = e4 ? e4.max : this._centerAltitude;
            } else b4 = this._centerAltitude;
            const w5 = t4.isTerrainDEM ? -b4 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T5 = this.projection.isReprojectedInTileSpace ? e3.bu(this) : 1, E3 = (t5) => {
              const i5 = 1 / 4e4, o4 = new e3.O(t5.x + i5, t5.y, t5.z), r5 = new e3.O(t5.x, t5.y + i5, t5.z), s5 = t5.toLngLat(), n4 = o4.toLngLat(), a5 = r5.toLngLat(), l5 = this.locationCoordinate(s5), c5 = this.locationCoordinate(n4), h5 = this.locationCoordinate(a5), u6 = Math.hypot(c5.x - l5.x, c5.y - l5.y), d4 = Math.hypot(h5.x - l5.x, h5.y - l5.y);
              return Math.sqrt(u6 * d4) * T5 / i5;
            }, S3 = (t5) => {
              const i5 = b4, o4 = w5;
              return { aabb: e3.bx(this, c4, 0, 0, 0, t5, o4, i5, this.projection), zoom: 0, x: 0, y: 0, minZ: o4, maxZ: i5, wrap: t5, fullyVisible: false };
            }, C4 = [];
            let I4 = [];
            const D4 = i4, R2 = t4.reparseOverscaled ? o3 : i4, A4 = (e4) => e4 * e4, P4 = A4((m4 - this._centerAltitude) * f4), L4 = (e4) => {
              if (!this._elevation || !e4.tileID || !n3) return;
              const t5 = this._elevation.getMinMaxForTile(e4.tileID), i5 = e4.aabb;
              t5 ? (i5.min[2] = t5.min, i5.max[2] = t5.max, i5.center[2] = (i5.min[2] + i5.max[2]) / 2) : (e4.shouldSplit = M3(e4), e4.shouldSplit || (i5.min[2] = i5.max[2] = i5.center[2] = this._centerAltitude));
            }, M3 = (t5) => {
              if (t5.zoom < y4) return true;
              if (t5.zoom === D4) return false;
              if (null != t5.shouldSplit) return t5.shouldSplit;
              const i5 = t5.aabb.distanceX(g5), r5 = t5.aabb.distanceY(g5);
              let n4 = P4, a5 = 1;
              if (u5) {
                n4 = A4(t5.aabb.distanceZ(g5));
                const i6 = Math.pow(2, t5.zoom), o4 = e3.ax((t5.y + 1) / i6), r6 = e3.ax(t5.y / i6), s5 = Math.min(Math.max(l4, o4), r6), c6 = e3.bM(s5) / e3.bM(l4);
                if (a5 = s5 === l4 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, c6 / this._mercatorScaleRatio), this.zoom <= e3.bJ && t5.zoom === D4 - 1 && c6 >= 0.9) return true;
              } else if (s4 && (n4 = A4(t5.aabb.distanceZ(g5) * f4)), this.projection.isReprojectedInTileSpace && o3 <= 5) {
                const i6 = Math.pow(2, t5.zoom), o4 = E3(new e3.O((t5.x + 0.5) / i6, (t5.y + 0.5) / i6));
                a5 = o4 > 0.85 ? 1 : o4;
              }
              const c5 = i5 * i5 + r5 * r5 + n4, h5 = A4((1 << D4 - t5.zoom) * x5 * a5 * ((e4, t6) => {
                if (t6 * A4(0.707) < e4) return 1;
                const i6 = Math.sqrt(t6 / e4);
                return i6 / (1.4144271570014144 + (Math.pow(1.1, i6 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
              })(Math.max(n4, P4), c5));
              return c5 < h5;
            };
            if (this.renderWorldCopies) for (let e4 = 1; e4 <= 3; e4++) C4.push(S3(-e4)), C4.push(S3(e4));
            for (C4.push(S3(0)); C4.length > 0; ) {
              const o4 = C4.pop(), r5 = o4.x, a5 = o4.y;
              let l5 = o4.fullyVisible;
              const d4 = () => "globe" === this.projection.name && (0 === o4.y || o4.y === (1 << o4.zoom) - 1);
              if (!l5) {
                let t5 = v4 ? o4.aabb.intersects(_4) : o4.aabb.intersectsFlat(_4);
                if (0 === t5 && d4()) {
                  const i5 = new e3.bv(o4.zoom, r5, a5);
                  t5 = e3.bw(this, c4, i5, true).intersects(_4);
                }
                if (0 === t5) continue;
                l5 = 2 === t5;
              }
              if (o4.zoom !== D4 && M3(o4)) for (let t5 = 0; t5 < 4; t5++) {
                const i5 = (r5 << 1) + t5 % 2, h5 = (a5 << 1) + (t5 >> 1), d5 = { aabb: n3 ? o4.aabb.quadrant(t5) : e3.bx(this, c4, o4.zoom + 1, i5, h5, o4.wrap, o4.minZ, o4.maxZ, this.projection), zoom: o4.zoom + 1, x: i5, y: h5, wrap: o4.wrap, fullyVisible: l5, tileID: void 0, shouldSplit: void 0, minZ: o4.minZ, maxZ: o4.maxZ };
                s4 && !u5 && (d5.tileID = new e3.ap(o4.zoom + 1 === D4 ? R2 : o4.zoom + 1, o4.wrap, o4.zoom + 1, i5, h5), L4(d5)), C4.push(d5);
              }
              else {
                const s5 = o4.zoom === D4 ? R2 : o4.zoom;
                if (t4.minzoom && t4.minzoom > s5) continue;
                if (!l5) {
                  let t5 = v4 ? o4.aabb.intersectsPrecise(_4) : o4.aabb.intersectsPreciseFlat(_4);
                  if (0 === t5 && d4()) {
                    const i5 = new e3.bv(o4.zoom, r5, a5);
                    t5 = e3.bw(this, c4, i5, true).intersectsPrecise(_4);
                  }
                  if (0 === t5) continue;
                }
                const n4 = h4[0] - (0.5 + r5 + (o4.wrap << o4.zoom)) * (1 << i4 - o4.zoom), u6 = h4[1] - 0.5 - a5, p5 = o4.tileID ? o4.tileID : new e3.ap(s5, o4.wrap, o4.zoom, r5, a5);
                I4.push({ tileID: p5, distanceSq: n4 * n4 + u6 * u6 });
              }
            }
            if (this.fogCullDistSq) {
              const i5 = this.fogCullDistSq, o4 = this.horizonLineFromTop();
              I4 = I4.filter((r5) => {
                const s5 = [0, 0, 0, 1], n4 = [e3.Y, e3.Y, 0, 1], a5 = this.calculateFogTileMatrix(r5.tileID.toUnwrapped());
                e3.aa.transformMat4(s5, s5, a5), e3.aa.transformMat4(n4, n4, a5);
                const l5 = e3.aa.min([], s5, n4), c5 = e3.aa.max([], s5, n4), h5 = e3.by(l5, c5);
                if (0 === h5) return true;
                let u6 = false;
                const d4 = this._elevation;
                if (d4 && h5 > i5 && 0 !== o4) {
                  const i6 = this.calculateProjMatrix(r5.tileID.toUnwrapped());
                  let s6;
                  t4.isTerrainDEM || (s6 = d4.getMinMaxForTile(r5.tileID)), s6 || (s6 = { min: w5, max: b4 });
                  const n5 = e3.bK(this.rotation), a6 = [n5[0] * e3.Y, n5[1] * e3.Y, s6.max];
                  e3.Q.transformMat4(a6, a6, i6), u6 = (1 - a6[1]) * this.height * 0.5 < o4;
                }
                return h5 < i5 || u6;
              });
            }
            return I4.sort((e4, t5) => e4.distanceSq - t5.distanceSq).map((e4) => e4.tileID);
          }
          resize(e4, t4) {
            this.width = e4, this.height = t4, this.pixelsToGLUnits = [2 / e4, -2 / t4], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(e4) {
            return Math.pow(2, e4);
          }
          scaleZoom(e4) {
            return Math.log(e4) / Math.LN2;
          }
          project(t4) {
            const i4 = e3.ad(t4.lat, -e3.bz, e3.bz), o3 = this.projection.project(t4.lng, i4);
            return new e3.P(o3.x * this.worldSize, o3.y * this.worldSize);
          }
          unproject(e4) {
            return this.projection.unproject(e4.x / this.worldSize, e4.y / this.worldSize);
          }
          get point() {
            return this.project(this.center);
          }
          get pointMerc() {
            return this.point._div(this.worldSize);
          }
          get pixelsPerMeterRatio() {
            return this.pixelsPerMeter / e3.bo(1, this.center.lat) / this.worldSize;
          }
          setLocationAtPoint(t4, i4) {
            let o3, r4;
            const s4 = this.centerPoint;
            if ("globe" === this.projection.name) {
              const e4 = this.worldSize;
              o3 = (i4.x - s4.x) / e4, r4 = (i4.y - s4.y) / e4;
            } else {
              const e4 = this.pointCoordinate(i4), t5 = this.pointCoordinate(s4);
              o3 = e4.x - t5.x, r4 = e4.y - t5.y;
            }
            const n3 = this.locationCoordinate(t4);
            this.setLocation(new e3.O(n3.x - o3, n3.y - r4));
          }
          setLocation(e4) {
            this.center = this.coordinateLocation(e4), this.projection.wrap && (this.center = this.center.wrap());
          }
          locationPoint(e4) {
            return this.projection.locationPoint(this, e4);
          }
          locationPoint3D(e4) {
            return this.projection.locationPoint(this, e4, true);
          }
          pointLocation(e4) {
            return this.coordinateLocation(this.pointCoordinate(e4));
          }
          pointLocation3D(e4) {
            return this.coordinateLocation(this.pointCoordinate3D(e4));
          }
          locationCoordinate(t4, i4) {
            const o3 = i4 ? e3.bo(i4, t4.lat) : void 0, r4 = this.projection.project(t4.lng, t4.lat);
            return new e3.O(r4.x, r4.y, o3);
          }
          coordinateLocation(e4) {
            return this.projection.unproject(e4.x, e4.y);
          }
          pointRayIntersection(t4, i4) {
            const o3 = null != i4 ? i4 : this._centerAltitude, r4 = [t4.x, t4.y, 0, 1], s4 = [t4.x, t4.y, 1, 1];
            e3.aa.transformMat4(r4, r4, this.pixelMatrixInverse), e3.aa.transformMat4(s4, s4, this.pixelMatrixInverse);
            const n3 = s4[3];
            e3.aa.scale(r4, r4, 1 / r4[3]), e3.aa.scale(s4, s4, 1 / n3);
            const a4 = r4[2], l4 = s4[2];
            return { p0: r4, p1: s4, t: a4 === l4 ? 0 : (o3 - a4) / (l4 - a4) };
          }
          screenPointToMercatorRay(t4) {
            const i4 = [t4.x, t4.y, 0, 1], o3 = [t4.x, t4.y, 1, 1];
            return e3.aa.transformMat4(i4, i4, this.pixelMatrixInverse), e3.aa.transformMat4(o3, o3, this.pixelMatrixInverse), e3.aa.scale(i4, i4, 1 / i4[3]), e3.aa.scale(o3, o3, 1 / o3[3]), i4[2] = e3.bo(i4[2], this._center.lat) * this.worldSize, o3[2] = e3.bo(o3[2], this._center.lat) * this.worldSize, e3.aa.scale(i4, i4, 1 / this.worldSize), e3.aa.scale(o3, o3, 1 / this.worldSize), new e3.a5([i4[0], i4[1], i4[2]], e3.Q.normalize([], e3.Q.sub([], o3, i4)));
          }
          rayIntersectionCoordinate(t4) {
            const { p0: i4, p1: o3, t: r4 } = t4, s4 = e3.bo(i4[2], this._center.lat), n3 = e3.bo(o3[2], this._center.lat);
            return new e3.O(e3.X(i4[0], o3[0], r4) / this.worldSize, e3.X(i4[1], o3[1], r4) / this.worldSize, e3.X(s4, n3, r4));
          }
          pointCoordinate(e4, t4 = this._centerAltitude) {
            return this.projection.pointCoordinate(this, e4.x, e4.y, t4);
          }
          pointCoordinate3D(t4) {
            if (!this.elevation) return this.pointCoordinate(t4);
            let i4 = this.projection.pointCoordinate3D(this, t4.x, t4.y);
            if (i4) return new e3.O(i4[0], i4[1], i4[2]);
            let o3 = 0, r4 = this.horizonLineFromTop();
            if (t4.y > r4) return this.pointCoordinate(t4);
            const s4 = 0.02 * r4, n3 = t4.clone();
            for (let t5 = 0; t5 < 10 && r4 - o3 > s4; t5++) {
              n3.y = e3.X(o3, r4, 0.66);
              const t6 = this.projection.pointCoordinate3D(this, n3.x, n3.y);
              t6 ? (r4 = n3.y, i4 = t6) : o3 = n3.y;
            }
            return i4 ? new e3.O(i4[0], i4[1], i4[2]) : this.pointCoordinate(t4);
          }
          isPointAboveHorizon(e4) {
            return this.projection.isPointAboveHorizon(this, e4);
          }
          isPointOnSurface(t4) {
            if (t4.y < 0 || t4.y > this.height || t4.x < 0 || t4.x > this.width) return false;
            if (this.elevation || this.zoom >= e3.bA) return !this.isPointAboveHorizon(t4);
            const i4 = this.pointCoordinate(t4);
            return i4.y >= 0 && i4.y <= 1;
          }
          _coordinatePoint(t4, i4) {
            const o3 = i4 && this.elevation ? this.elevation.getAtPointOrZero(t4, this._centerAltitude) : this._centerAltitude, r4 = [t4.x * this.worldSize, t4.y * this.worldSize, o3 + t4.toAltitude(), 1];
            return e3.aa.transformMat4(r4, r4, this.pixelMatrix), r4[3] > 0 ? new e3.P(r4[0] / r4[3], r4[1] / r4[3]) : new e3.P(Number.MAX_VALUE, Number.MAX_VALUE);
          }
          _getBoundsNonRectangular() {
            const { top: t4, left: i4 } = this._edgeInsets, o3 = this.height - this._edgeInsets.bottom, r4 = this.width - this._edgeInsets.right, s4 = this.pointLocation3D(new e3.P(i4, t4)), n3 = this.pointLocation3D(new e3.P(r4, t4)), a4 = this.pointLocation3D(new e3.P(r4, o3)), l4 = this.pointLocation3D(new e3.P(i4, o3));
            let c4 = Math.min(s4.lng, n3.lng, a4.lng, l4.lng), h4 = Math.max(s4.lng, n3.lng, a4.lng, l4.lng), u5 = Math.min(s4.lat, n3.lat, a4.lat, l4.lat), d3 = Math.max(s4.lat, n3.lat, a4.lat, l4.lat);
            const _4 = Math.pow(2, -this.zoom) / 16 * 270, p4 = "globe" === this.projection.name ? 1 : 4, f4 = (t5, i5, o4, r5, s5) => {
              const n4 = (t5 + o4) / 2, a5 = (i5 + r5) / 2, l5 = new e3.P(n4, a5), { lng: m4, lat: g5 } = this.pointLocation3D(l5), v4 = Math.max(0, c4 - m4, u5 - g5, m4 - h4, g5 - d3);
              c4 = Math.min(c4, m4), h4 = Math.max(h4, m4), u5 = Math.min(u5, g5), d3 = Math.max(d3, g5), (s5 < p4 || v4 > _4) && (f4(t5, i5, n4, a5, s5 + 1), f4(n4, a5, o4, r5, s5 + 1));
            };
            if (f4(i4, t4, r4, t4, 1), f4(r4, t4, r4, o3, 1), f4(r4, o3, i4, o3, 1), f4(i4, o3, i4, t4, 1), "globe" === this.projection.name) {
              const [t5, i5] = e3.bB(this);
              t5 ? (d3 = 90, h4 = 180, c4 = -180) : i5 && (u5 = -90, h4 = 180, c4 = -180);
            }
            return new e3.ag(new e3.bq(c4, u5), new e3.bq(h4, d3));
          }
          _getBoundsRectangular(t4, i4) {
            const { top: o3, left: r4 } = this._edgeInsets, s4 = this.height - this._edgeInsets.bottom, n3 = this.width - this._edgeInsets.right, a4 = new e3.P(r4, o3), l4 = new e3.P(n3, o3), c4 = new e3.P(n3, s4), h4 = new e3.P(r4, s4);
            let u5 = this.pointCoordinate(a4, t4), d3 = this.pointCoordinate(l4, t4);
            const _4 = this.pointCoordinate(c4, i4), p4 = this.pointCoordinate(h4, i4), f4 = (e4, t5) => (t5.y - e4.y) / (t5.x - e4.x);
            return u5.y > 1 && d3.y >= 0 ? u5 = new e3.O((1 - p4.y) / f4(p4, u5) + p4.x, 1) : u5.y < 0 && d3.y <= 1 && (u5 = new e3.O(-p4.y / f4(p4, u5) + p4.x, 0)), d3.y > 1 && u5.y >= 0 ? d3 = new e3.O((1 - _4.y) / f4(_4, d3) + _4.x, 1) : d3.y < 0 && u5.y <= 1 && (d3 = new e3.O(-_4.y / f4(_4, d3) + _4.x, 0)), new e3.ag().extend(this.coordinateLocation(u5)).extend(this.coordinateLocation(d3)).extend(this.coordinateLocation(p4)).extend(this.coordinateLocation(_4));
          }
          _getBoundsRectangularTerrain() {
            const e4 = this.elevation;
            if (!e4.visibleDemTiles.length || e4.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
            const t4 = e4.visibleDemTiles.reduce((e5, t5) => {
              if (t5.dem) {
                const i4 = t5.dem.tree;
                e5.min = Math.min(e5.min, i4.minimums[0]), e5.max = Math.max(e5.max, i4.maximums[0]);
              }
              return e5;
            }, { min: Number.MAX_VALUE, max: 0 });
            return this._getBoundsRectangular(t4.min * e4.exaggeration(), t4.max * e4.exaggeration());
          }
          getBounds() {
            return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
          }
          horizonLineFromTop(e4 = true) {
            const t4 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, i4 = this.height / 2 - t4 * (1 - this._horizonShift);
            return e4 ? Math.max(0, i4) : i4;
          }
          getMaxBounds() {
            return this.maxBounds;
          }
          setMaxBounds(t4) {
            this.maxBounds = t4, this.minLat = -e3.bz, this.maxLat = e3.bz, this.minLng = -180, this.maxLng = 180, t4 && (this.minLat = t4.getSouth(), this.maxLat = t4.getNorth(), this.minLng = t4.getWest(), this.maxLng = t4.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e3.a8(this.minLng) * this.tileSize, this.worldMaxX = e3.a8(this.maxLng) * this.tileSize, this.worldMinY = e3.ah(this.maxLat) * this.tileSize, this.worldMaxY = e3.ah(this.minLat) * this.tileSize, this._constrain();
          }
          calculatePosMatrix(e4, t4) {
            return this.projection.createTileMatrix(this, t4, e4);
          }
          calculateDistanceTileData(t4) {
            const i4 = t4.key, o3 = this._distanceTileDataCache;
            if (o3[i4]) return o3[i4];
            const r4 = t4.canonical, s4 = 1 / this.height, n3 = this.cameraWorldSize, a4 = n3 / this.zoomScale(r4.z), l4 = (r4.x + Math.pow(2, r4.z) * t4.wrap) * a4, c4 = r4.y * a4, h4 = this.point;
            h4.x *= n3 / this.worldSize, h4.y *= n3 / this.worldSize;
            const u5 = this.angle, d3 = Math.sin(-u5), _4 = -Math.cos(-u5);
            return o3[i4] = { bearing: [d3, _4], center: [(h4.x - l4) * s4, (h4.y - c4) * s4], scale: a4 / e3.Y * s4 }, o3[i4];
          }
          calculateFogTileMatrix(t4) {
            const i4 = t4.key, o3 = this._fogTileMatrixCache;
            if (o3[i4]) return o3[i4];
            const r4 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t4);
            return e3.a9.multiply(r4, this.worldToFogMatrix, r4), o3[i4] = new Float32Array(r4), o3[i4];
          }
          calculateProjMatrix(t4, i4 = false, o3 = false) {
            const r4 = t4.key;
            let s4;
            if (s4 = o3 ? this._expandedProjMatrixCache : i4 ? this._alignedProjMatrixCache : this._projMatrixCache, s4[r4]) return s4[r4];
            const n3 = this.calculatePosMatrix(t4, this.worldSize);
            let a4;
            return a4 = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o3 ? this.expandedFarZProjMatrix : i4 ? this.alignedProjMatrix : this.projMatrix, e3.a9.multiply(n3, a4, n3), s4[r4] = new Float32Array(n3), s4[r4];
          }
          calculatePixelsToTileUnitsMatrix(t4) {
            const i4 = t4.tileID.key, o3 = this._pixelsToTileUnitsCache;
            if (o3[i4]) return o3[i4];
            const r4 = e3.bC(t4, this);
            return o3[i4] = r4, o3[i4];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          globeToMercatorMatrix() {
            if ("globe" === this.projection.name) {
              const t4 = 1 / this.worldSize, i4 = e3.a9.fromScaling([], [t4, t4, t4]);
              return e3.a9.multiply(i4, i4, this.globeMatrix), i4;
            }
          }
          recenterOnTerrain() {
            if (!this._elevation || "globe" === this.projection.name) return;
            const t4 = this._elevation;
            this._updateCameraState();
            const i4 = e3.bo(1, this._center.lat) * this.worldSize, o3 = this._computeCameraPosition(i4), r4 = this._camera.forward(), s4 = e3.bo(1, this._center.lat);
            o3[2] /= s4, r4[2] /= s4, e3.Q.normalize(r4, r4);
            const n3 = t4.raycast(o3, r4, t4.exaggeration());
            if (n3) {
              const t5 = e3.Q.scaleAndAdd([], o3, r4, n3), i5 = new e3.O(t5[0], t5[1], e3.bo(t5[2], e3.ax(t5[1]))), a4 = (i5.z + e3.Q.length([i5.x - o3[0], i5.y - o3[1], i5.z - o3[2] * s4])) * this._pixelsPerMercatorPixel;
              this._seaLevelZoom = this._zoomFromMercatorZ(a4), this._centerAltitude = i5.toAltitude(), this._center = this.coordinateLocation(i5), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
            }
          }
          _constrainCamera(t4 = false) {
            if (!this._elevation) return;
            const i4 = this._elevation, o3 = e3.bo(1, this._center.lat) * this.worldSize, r4 = this._computeCameraPosition(o3), s4 = i4.getAtPointOrZero(new e3.O(...r4)), n3 = this.pixelsPerMeter / this.worldSize * s4, a4 = this._minimumHeightOverTerrain(), l4 = r4[2] - n3;
            if (l4 <= a4) if (l4 < 0 || t4) {
              const t5 = this.locationCoordinate(this._center, this._centerAltitude), i5 = [r4[0], r4[1], t5.z - r4[2]], o4 = e3.Q.length(i5);
              i5[2] -= (a4 - l4) / this._pixelsPerMercatorPixel;
              const s5 = e3.Q.length(i5);
              if (0 === s5) return;
              e3.Q.scale(i5, i5, o4 / s5 * this._pixelsPerMercatorPixel), this._camera.position = [r4[0], r4[1], t5.z * this._pixelsPerMercatorPixel - i5[2]], this._updateStateFromCamera();
            } else this._isCameraConstrained = true;
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining) return;
            this._constraining = true;
            const t4 = "globe" === this.projection.name || this.mercatorFromTransition;
            if (this.projection.isReprojectedInTileSpace || t4) {
              const i5 = this.center;
              return i5.lat = e3.ad(i5.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t4) && (i5.lng = e3.ad(i5.lng, this.minLng, this.maxLng)), this.center = i5, void (this._constraining = false);
            }
            const i4 = this._unmodified, { x: o3, y: r4 } = this.point;
            let s4 = 0, n3 = o3, a4 = r4;
            const l4 = this.width / 2, c4 = this.height / 2, h4 = this.worldMinY * this.scale, u5 = this.worldMaxY * this.scale;
            if (r4 - c4 < h4 && (a4 = h4 + c4), r4 + c4 > u5 && (a4 = u5 - c4), u5 - h4 < this.height && (s4 = Math.max(s4, this.height / (u5 - h4)), a4 = (u5 + h4) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
              const e4 = this.worldMinX * this.scale, t5 = this.worldMaxX * this.scale, i5 = this.worldSize / 2 - (e4 + t5) / 2;
              n3 = (o3 + i5 + this.worldSize) % this.worldSize - i5, n3 - l4 < e4 && (n3 = e4 + l4), n3 + l4 > t5 && (n3 = t5 - l4), t5 - e4 < this.width && (s4 = Math.max(s4, this.width / (t5 - e4)), n3 = (t5 + e4) / 2);
            }
            n3 === o3 && a4 === r4 || (this.center = this.unproject(new e3.P(n3, a4))), s4 && (this.zoom += this.scaleZoom(s4)), this._constrainCamera(), this._unmodified = i4, this._constraining = false;
          }
          _minZoomForBounds() {
            let e4 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
            return this.maxBounds && (e4 = Math.max(e4, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e4;
          }
          _maxCameraBoundsDistance() {
            return this._mercatorZfromZoom(this._minZoomForBounds());
          }
          _calcMatrices() {
            if (!this.height) return;
            const t4 = this.centerOffset, i4 = "globe" === this.projection.name, o3 = this.pixelsPerMeter;
            "globe" === this.projection.name && (this._mercatorScaleRatio = e3.bo(1, this.center.lat) / e3.bo(1, e3.bL));
            const r4 = e3.bD(this.projection, this.zoom, this.width, this.height, 1024);
            this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r4), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
            const s4 = "meters" === this.projection.zAxisUnit ? o3 : 1, n3 = this._camera.getWorldToCamera(this.worldSize, s4);
            let a4;
            const l4 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
            if (l4[8] = 2 * -t4.x / this.width, l4[9] = 2 * t4.y / this.height, this.isOrthographic) {
              let e4 = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), i5 = e4 * this.aspect, o4 = -i5, r5 = -e4;
              i5 -= t4.x, o4 -= t4.x, e4 += t4.y, r5 += t4.y, a4 = this._camera.getCameraToClipOrthographic(o4, i5, r5, e4, this._nearZ, this._farZ), ((e5, t5, i6, o5) => {
                for (let r6 = 0; r6 < 16; r6++) e5[r6] = uo(t5[r6], i6[r6], o5);
              })(a4, a4, l4, _o(this.pitch >= 15 ? 1 : this.pitch / 15));
            } else a4 = l4;
            const c4 = e3.a9.mul([], l4, n3);
            let h4 = e3.a9.mul([], a4, n3);
            if (this.projection.isReprojectedInTileSpace) {
              const t5 = this.locationCoordinate(this.center), i5 = e3.a9.identity([]);
              e3.a9.translate(i5, i5, [t5.x * this.worldSize, t5.y * this.worldSize, 0]), e3.a9.multiply(i5, i5, e3.bE(this)), e3.a9.translate(i5, i5, [-t5.x * this.worldSize, -t5.y * this.worldSize, 0]), e3.a9.multiply(h4, h4, i5), e3.a9.multiply(c4, c4, i5), this.inverseAdjustmentMatrix = e3.bF(this);
            } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
            if (this.mercatorMatrix = e3.a9.scale([], h4, [this.worldSize, this.worldSize, this.worldSize / s4, 1]), this.projMatrix = h4, this.invProjMatrix = e3.a9.invert(new Float64Array(16), this.projMatrix), i4) {
              const i5 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
              i5[8] = 2 * -t4.x / this.width, i5[9] = 2 * t4.y / this.height, this.expandedFarZProjMatrix = e3.a9.mul([], i5, n3);
            } else this.expandedFarZProjMatrix = this.projMatrix;
            const u5 = e3.a9.invert([], a4);
            this.frustumCorners = e3.bG.fromInvProjectionMatrix(u5, this.horizonLineFromTop(), this.height), this.cameraFrustum = e3.bt.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i4);
            const d3 = new Float32Array(16);
            e3.a9.identity(d3), e3.a9.scale(d3, d3, [1, -1, 1]), e3.a9.rotateX(d3, d3, this._pitch), e3.a9.rotateZ(d3, d3, this.angle);
            const _4 = e3.a9.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
            this.starsProjMatrix = e3.a9.clone(_4);
            const p4 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
            _4[8] = 2 * -t4.x / this.width, _4[9] = 2 * (t4.y + p4) / this.height, this.skyboxMatrix = e3.a9.multiply(d3, _4, d3);
            const f4 = this.point, m4 = f4.x, g5 = f4.y, v4 = this.width % 2 / 2, x5 = this.height % 2 / 2, y4 = Math.cos(this.angle), b4 = Math.sin(this.angle), w5 = m4 - Math.round(m4) + y4 * v4 + b4 * x5, T5 = g5 - Math.round(g5) + y4 * x5 + b4 * v4, E3 = new Float64Array(h4);
            if (e3.a9.translate(E3, E3, [w5 > 0.5 ? w5 - 1 : w5, T5 > 0.5 ? T5 - 1 : T5, 0]), this.alignedProjMatrix = E3, h4 = e3.a9.create(), e3.a9.scale(h4, h4, [this.width / 2, -this.height / 2, 1]), e3.a9.translate(h4, h4, [1, -1, 0]), this.labelPlaneMatrix = h4, h4 = e3.a9.create(), e3.a9.scale(h4, h4, [1, -1, 1]), e3.a9.translate(h4, h4, [-1, -1, 0]), e3.a9.scale(h4, h4, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h4, this.pixelMatrix = e3.a9.multiply(new Float64Array(16), this.labelPlaneMatrix, c4), this._calcFogMatrices(), this._distanceTileDataCache = {}, h4 = e3.a9.invert(new Float64Array(16), this.pixelMatrix), !h4) throw new Error("failed to invert matrix");
            if (this.pixelMatrixInverse = h4, "globe" === this.projection.name || this.mercatorFromTransition) {
              this.globeMatrix = e3.bH(this);
              const t5 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
              this.globeCenterInViewSpace = e3.Q.transformMat4(t5, t5, n3), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
            } else this.globeMatrix = h4;
            this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
          }
          _calcFogMatrices() {
            this._fogTileMatrixCache = {};
            const t4 = this.cameraWorldSizeForFog, i4 = this.cameraPixelsPerMeter, o3 = this._camera.position, r4 = 1 / this.height / this._pixelsPerMercatorPixel, s4 = [t4, t4, i4];
            e3.Q.scale(s4, s4, r4), e3.Q.scale(o3, o3, -1), e3.Q.multiply(o3, o3, s4);
            const n3 = e3.a9.create();
            e3.a9.translate(n3, n3, o3), e3.a9.scale(n3, n3, s4), this.mercatorFogMatrix = n3, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t4, i4, r4);
          }
          _computeCameraPosition(e4) {
            const t4 = (e4 = e4 || this.pixelsPerMeter) / this.pixelsPerMeter, i4 = this._camera.forward(), o3 = this.point, r4 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t4 - e4 / this.worldSize * this._centerAltitude;
            return [o3.x / this.worldSize - i4[0] * r4, o3.y / this.worldSize - i4[1] * r4, e4 / this.worldSize * this._centerAltitude - i4[2] * r4];
          }
          _updateCameraState() {
            this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
          }
          _translateCameraConstrained(t4) {
            const i4 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o3 = this._camera.position[2], r4 = t4[2];
            let s4 = 1;
            this.projection.wrap && (this.center = this.center.wrap()), r4 > 0 && (s4 = Math.min((i4 - o3) / r4, 1)), this._camera.position = e3.Q.scaleAndAdd([], this._camera.position, t4, s4), this._updateStateFromCamera();
          }
          _updateStateFromCamera() {
            const t4 = this._camera.position, i4 = this._camera.forward(), { pitch: o3, bearing: r4 } = this._camera.getPitchBearing(), s4 = e3.bo(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, n3 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e3.bm(this._maxPitch)), a4 = Math.max((t4[2] - s4) / Math.cos(o3), n3), l4 = this._zoomFromMercatorZ(a4);
            e3.Q.scaleAndAdd(t4, t4, i4, a4), this._pitch = e3.ad(o3, e3.bm(this.minPitch), e3.bm(this.maxPitch)), this.angle = e3.bk(r4, -Math.PI, Math.PI), this._setZoom(e3.ad(l4, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e3.O(t4[0], t4[1], t4[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
          }
          _worldSizeFromZoom(e4) {
            return Math.pow(2, e4) * this.tileSize;
          }
          _mercatorZfromZoom(e4) {
            return this.cameraToCenterDistance / this._worldSizeFromZoom(e4);
          }
          _minimumHeightOverTerrain() {
            const e4 = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
            return this._mercatorZfromZoom(e4);
          }
          _zoomFromMercatorZ(e4) {
            return this.scaleZoom(this.cameraToCenterDistance / (e4 * this.tileSize));
          }
          zoomFromMercatorZAdjusted(t4) {
            let i4 = 0, o3 = e3.bA, r4 = 0, s4 = 1 / 0;
            for (; o3 - i4 > 1e-6 && o3 > i4; ) {
              const e4 = i4 + 0.5 * (o3 - i4), n3 = this.tileSize * Math.pow(2, e4), a4 = this.getCameraToCenterDistance(this.projection, e4, n3), l4 = this.scaleZoom(a4 / (t4 * this.tileSize)), c4 = Math.abs(e4 - l4);
              c4 < s4 && (s4 = c4, r4 = e4), e4 < l4 ? i4 = e4 : o3 = e4;
            }
            return r4;
          }
          _terrainEnabled() {
            return !(!this._elevation || !this.projection.supportsTerrain && (e3.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
          }
          anyCornerOffEdge(t4, i4) {
            const o3 = Math.min(t4.x, i4.x), r4 = Math.max(t4.x, i4.x), s4 = Math.min(t4.y, i4.y), n3 = Math.max(t4.y, i4.y);
            if (s4 < this.horizonLineFromTop(false)) return true;
            if ("mercator" !== this.projection.name) return false;
            const a4 = [new e3.P(o3, s4), new e3.P(r4, n3), new e3.P(o3, n3), new e3.P(r4, s4)], l4 = this.renderWorldCopies ? -3 : 0, c4 = this.renderWorldCopies ? 4 : 1;
            for (const e4 of a4) {
              const t5 = this.pointRayIntersection(e4);
              if (t5.t < 0) return true;
              const i5 = this.rayIntersectionCoordinate(t5);
              if (i5.x < l4 || i5.y < 0 || i5.x > c4 || i5.y > 1) return true;
            }
            return false;
          }
          isHorizonVisible() {
            return this.pitch + e3.bI(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e3.P(0, 0), new e3.P(this.width, this.height));
          }
          zoomDeltaToMovement(t4, i4) {
            const o3 = e3.Q.length(e3.Q.sub([], this._camera.position, t4)), r4 = this._zoomFromMercatorZ(o3) + i4;
            return o3 - this._mercatorZfromZoom(r4);
          }
          getCameraPoint() {
            if ("globe" === this.projection.name) {
              const t4 = function([t5, i4, o3], r4) {
                const s4 = [t5, i4, o3, 1];
                e3.aa.transformMat4(s4, s4, r4);
                const n3 = s4[3] = Math.max(s4[3], 1e-6);
                return s4[0] /= n3, s4[1] /= n3, s4[2] /= n3, s4;
              }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
              return new e3.P(t4[0], t4[1]);
            }
            {
              const t4 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new e3.P(0, t4));
            }
          }
          getCameraToCenterDistance(t4, i4 = this.zoom, o3 = this.worldSize) {
            const r4 = e3.bD(t4, i4, this.width, this.height, 1024), s4 = t4.pixelSpaceConversion(this.center.lat, o3, r4);
            let n3 = 0.5 / Math.tan(0.5 * this._fov) * this.height * s4;
            return this.isOrthographic && (n3 = uo(1, n3, _o(this.pitch >= 15 ? 1 : this.pitch / 15))), n3;
          }
          getWorldToCameraMatrix() {
            const t4 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
            return "globe" === this.projection.name && e3.a9.multiply(t4, t4, this.globeMatrix), t4;
          }
          getFrustum(t4) {
            return e3.bt.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t4, "meters" === this.projection.zAxisUnit);
          }
        }
        const fo = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, ShadowMap0: 10 }, mo = (t4, i4) => {
          if (i4 > 0 && t4.terrain && e3.w("Cutoff is currently disabled on terrain"), i4 <= 0 || t4.terrain) return { shouldRenderCutoff: false, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
          const o3 = t4.transform, r4 = Math.max(Math.abs(o3._zoom - (t4.minCutoffZoom - 1)), 1), s4 = o3.isLODDisabled(false) ? e3.S(60, 45, o3.pitch) : e3.S(30, 15, o3.pitch), n3 = o3._farZ - o3._nearZ, a4 = i4 * o3.height, l4 = ((1 - (c4 = s4)) * o3.cameraToCenterDistance + c4 * (o3._farZ + a4)) * r4;
          var c4;
          return { shouldRenderCutoff: s4 < 1, uniformValues: { u_cutoff_params: [o3._nearZ, o3._farZ, (l4 - o3._nearZ) / n3, (l4 - a4 - o3._nearZ) / n3] } };
        }, go = { cascadeCount: 2, shadowMapResolution: 2048 };
        class vo {
          constructor(e4, t4) {
            this.aabb = e4, this.lastCascade = t4;
          }
        }
        class xo {
          add(e4, t4) {
            const i4 = this.receivers[e4.key];
            void 0 !== i4 ? (i4.aabb.min[0] = Math.min(i4.aabb.min[0], t4.min[0]), i4.aabb.min[1] = Math.min(i4.aabb.min[1], t4.min[1]), i4.aabb.min[2] = Math.min(i4.aabb.min[2], t4.min[2]), i4.aabb.max[0] = Math.max(i4.aabb.max[0], t4.max[0]), i4.aabb.max[1] = Math.max(i4.aabb.max[1], t4.max[1]), i4.aabb.max[2] = Math.max(i4.aabb.max[2], t4.max[2])) : this.receivers[e4.key] = new vo(t4, null);
          }
          clear() {
            this.receivers = {};
          }
          get(e4) {
            return this.receivers[e4.key];
          }
          computeRequiredCascades(t4, i4, o3) {
            const r4 = e3.bV.fromPoints(t4.points);
            let s4 = 0;
            for (const t5 in this.receivers) {
              const n3 = this.receivers[t5];
              if (!n3) continue;
              if (!r4.intersectsAabb(n3.aabb)) continue;
              n3.aabb.min = r4.closestPoint(n3.aabb.min), n3.aabb.max = r4.closestPoint(n3.aabb.max);
              const a4 = n3.aabb.getCorners();
              for (let t6 = 0; t6 < o3.length; t6++) {
                let r5 = true;
                for (const s5 of a4) {
                  const n4 = [s5[0] * i4, s5[1] * i4, s5[2]];
                  if (e3.Q.transformMat4(n4, n4, o3[t6].matrix), n4[0] < -1 || n4[0] > 1 || n4[1] < -1 || n4[1] > 1) {
                    r5 = false;
                    break;
                  }
                }
                if (n3.lastCascade = t6, s4 = Math.max(s4, t6), r5) break;
              }
            }
            return s4 + 1;
          }
        }
        class yo {
          constructor(e4) {
            this.painter = e4, this._enabled = false, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new xo(), this._depthMode = new Ct(e4.context.gl.LEQUAL, Ct.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = false, this.useNormalOffset = false, e4.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => {
              this.painter.style.map.triggerRepaint();
            }), e4.tp.registerParameter(go, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), e4.tp.registerParameter(go, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), e4.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: true, label: "numCascadesToRender" });
          }
          destroy() {
            for (const e4 of this._cascades) e4.texture.destroy(), e4.framebuffer.destroy();
            this._cascades = [];
          }
          updateShadowParameters(t4, i4) {
            const o3 = this.painter;
            if (this._enabled = false, this._shadowLayerCount = 0, this._receivers.clear(), !i4 || !i4.properties) return;
            const r4 = i4.properties.get("shadow-intensity");
            if (!i4.shadowsEnabled() || r4 <= 0) return;
            if (this._shadowLayerCount = o3.style.order.reduce((e4, i5) => {
              const r5 = o3.style._mergedLayers[i5];
              return e4 + (r5.hasShadowPass() && !r5.isHidden(t4.zoom) ? 1 : 0);
            }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled) return;
            const s4 = o3.context, n3 = go.shadowMapResolution, a4 = go.shadowMapResolution;
            if (0 === this._cascades.length || go.shadowMapResolution !== this._cascades[0].texture.size[0]) {
              this._cascades = [];
              for (let t5 = 0; t5 < go.cascadeCount; ++t5) {
                const t6 = o3._shadowMapDebug, i5 = s4.gl, r5 = s4.createFramebuffer(n3, a4, t6, "texture"), l5 = new e3.T(s4, { width: n3, height: a4, data: null }, i5.DEPTH_COMPONENT);
                if (r5.depthAttachment.set(l5.texture), t6) {
                  const t7 = new e3.T(s4, { width: n3, height: a4, data: null }, i5.RGBA);
                  r5.colorAttachment.set(t7.texture);
                }
                this._cascades.push({ framebuffer: r5, texture: l5, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new e3.bt(), scale: 0 });
              }
            }
            this.shadowDirection = wo(i4);
            let l4 = 0;
            if (t4.elevation) {
              const e4 = t4.elevation, i5 = [1e4, -1e4];
              e4.visibleDemTiles.filter((e5) => e5.dem).forEach((e5) => {
                const t5 = e5.dem.tree;
                i5[0] = Math.min(i5[0], t5.minimums[0]), i5[1] = Math.max(i5[1], t5.maximums[0]);
              }), 1e4 !== i5[0] && (l4 = (i5[1] - i5[0]) * e4.exaggeration());
            }
            const c4 = 1.5 * t4.cameraToCenterDistance, h4 = 3 * c4, u5 = new Float64Array(16);
            for (let i5 = 0; i5 < this._cascades.length; ++i5) {
              const o4 = this._cascades[i5];
              let r5 = t4.height / 50, s5 = 1;
              1 === go.cascadeCount ? s5 = h4 : 0 === i5 ? s5 = c4 : (r5 = c4, s5 = h4);
              const [n4, a5] = Eo(t4, this.shadowDirection, r5, s5, go.shadowMapResolution, l4);
              o4.scale = t4.scale, o4.matrix = n4, o4.boundingSphereRadius = a5, e3.a9.invert(u5, o4.matrix), o4.frustum = e3.bt.fromInvProjectionMatrix(u5, 1, 0, true), o4.far = s5;
            }
            const d3 = this._cascades.length - 1;
            this._uniformValues.u_fade_range = [0.75 * this._cascades[d3].far, this._cascades[d3].far], this._uniformValues.u_shadow_intensity = r4, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / go.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = go.shadowMapResolution, this._uniformValues.u_shadowmap_0 = fo.ShadowMap0, this._uniformValues.u_shadowmap_1 = fo.ShadowMap0 + 1, this._groundShadowTiles = o3.transform.coveringTiles({ tileSize: 512, renderWorldCopies: true });
            const _4 = o3.transform.elevation;
            for (const e4 of this._groundShadowTiles) {
              let t5 = { min: 0, max: 0 };
              if (_4) {
                const i5 = _4.getMinMaxForTile(e4);
                i5 && (t5 = i5);
              }
              this.addShadowReceiver(e4.toUnwrapped(), t5.min, t5.max);
            }
          }
          get enabled() {
            return this._enabled && !this._forceDisable;
          }
          set enabled(e4) {
            this._enabled = e4;
          }
          drawShadowPass(t4, i4) {
            if (!this.enabled) return;
            const o3 = this.painter, r4 = o3.context;
            this._numCascadesToRender = this._receivers.computeRequiredCascades(o3.transform.getFrustum(0), o3.transform.worldSize, this._cascades), r4.viewport.set([0, 0, go.shadowMapResolution, go.shadowMapResolution]);
            for (let s4 = 0; s4 < this._numCascadesToRender; ++s4) {
              o3.currentShadowCascade = s4, r4.bindFramebuffer.set(this._cascades[s4].framebuffer.framebuffer), r4.clear({ color: e3.aA.white, depth: 1 });
              for (const e4 of t4.order) {
                const r5 = t4._mergedLayers[e4];
                if (!r5.hasShadowPass() || r5.isHidden(o3.transform.zoom)) continue;
                const s5 = t4.getLayerSourceCache(r5), n3 = s5 ? i4[s5.id] : void 0;
                ("model" === r5.type || n3 && n3.length) && o3.renderLayer(o3, s5, r5, n3);
              }
            }
            o3.currentShadowCascade = 0;
          }
          drawGroundShadows() {
            if (!this.enabled) return;
            const e4 = this.painter, t4 = e4.style, i4 = e4.context, o3 = t4.directionalLight, r4 = t4.ambientLight;
            if (!o3 || !r4) return;
            const s4 = [], n3 = mo(e4, e4.longestCutoffRange);
            n3.shouldRenderCutoff && s4.push("RENDER_CUTOFF");
            const a4 = To(o3, r4), l4 = new Ct(i4.gl.LEQUAL, Ct.ReadOnly, e4.depthRangeFor3D);
            for (const t5 of this._groundShadowTiles) {
              const o4 = t5.toUnwrapped(), r5 = e4.isTileAffectedByFog(t5), c4 = e4.getOrCreateProgram("groundShadow", { defines: s4, overrideFog: r5 });
              this.setupShadows(o4, c4), e4.uploadCommonUniforms(i4, c4, o4, null, n3);
              const h4 = { u_matrix: e4.transform.calculateProjMatrix(o4), u_ground_shadow_factor: a4 };
              c4.draw(e4, i4.gl.TRIANGLES, l4, Dt.disabled, At.multiply, Mt.disabled, h4, "ground_shadow", e4.tileExtentBuffer, e4.quadTriangleIndexBuffer, e4.tileExtentSegments, {}, e4.transform.zoom, null, null);
            }
          }
          getShadowPassColorMode() {
            return this.painter._shadowMapDebug ? At.unblended : At.disabled;
          }
          getShadowPassDepthMode() {
            return this._depthMode;
          }
          getShadowCastingLayerCount() {
            return this._shadowLayerCount;
          }
          calculateShadowPassMatrixFromTile(t4) {
            const i4 = this.painter.transform, o3 = i4.calculatePosMatrix(t4, i4.worldSize);
            return e3.a9.multiply(o3, this._cascades[this.painter.currentShadowCascade].matrix, o3), Float32Array.from(o3);
          }
          calculateShadowPassMatrixFromMatrix(t4) {
            return e3.a9.multiply(t4, this._cascades[this.painter.currentShadowCascade].matrix, t4), Float32Array.from(t4);
          }
          setupShadows(t4, i4, o3, r4 = 0) {
            if (!this.enabled) return;
            const s4 = this.painter.transform, n3 = this.painter.context, a4 = n3.gl, l4 = this._uniformValues, c4 = new Float64Array(16), h4 = s4.calculatePosMatrix(t4, s4.worldSize);
            for (let t5 = 0; t5 < this._cascades.length; t5++) e3.a9.multiply(c4, this._cascades[t5].matrix, h4), l4[0 === t5 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(c4), n3.activeTexture.set(a4.TEXTURE0 + fo.ShadowMap0 + t5), this._cascades[t5].texture.bind(a4.NEAREST, a4.CLAMP_TO_EDGE);
            if (this.useNormalOffset = !!o3, this.useNormalOffset) {
              const i5 = e3.bU(t4.canonical), n4 = 2 / s4.tileSize * e3.Y / go.shadowMapResolution, a5 = n4 * this._cascades[0].boundingSphereRadius, c5 = n4 * this._cascades[this._cascades.length - 1].boundingSphereRadius, h5 = ("vector-tile" === o3 ? 1 : 3) / Math.pow(2, r4 - t4.canonical.z - (1 - s4.zoom + Math.floor(s4.zoom)));
              l4.u_shadow_normal_offset = [i5, a5 * h5, c5 * h5], l4.u_shadow_bias = [6e-5, 12e-4, 0.012];
            } else l4.u_shadow_bias = [36e-5, 12e-4, 0.012];
            i4.setShadowUniformValues(n3, l4);
          }
          setupShadowsFromMatrix(t4, i4, o3 = false) {
            if (!this.enabled) return;
            const r4 = this.painter.context, s4 = r4.gl, n3 = this._uniformValues, a4 = new Float64Array(16);
            for (let i5 = 0; i5 < go.cascadeCount; i5++) e3.a9.multiply(a4, this._cascades[i5].matrix, t4), n3[0 === i5 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(a4), r4.activeTexture.set(s4.TEXTURE0 + fo.ShadowMap0 + i5), this._cascades[i5].texture.bind(s4.NEAREST, s4.CLAMP_TO_EDGE);
            if (this.useNormalOffset = o3, o3) {
              const e4 = 5;
              n3.u_shadow_normal_offset = [1, e4, e4], n3.u_shadow_bias = [6e-5, 12e-4, 0.012];
            } else n3.u_shadow_bias = [36e-5, 12e-4, 0.012];
            i4.setShadowUniformValues(r4, n3);
          }
          getShadowUniformValues() {
            return this._uniformValues;
          }
          getCurrentCascadeFrustum() {
            return this._cascades[this.painter.currentShadowCascade].frustum;
          }
          computeSimplifiedTileShadowVolume(t4, i4, o3, r4) {
            if (r4[2] >= 0) return {};
            const s4 = function(t5, i5, o4) {
              const r5 = o4 / (1 << t5.canonical.z);
              return new e3.bV([t5.canonical.x * r5 + t5.wrap * o4, t5.canonical.y * r5 + t5.wrap * o4, 0], [(t5.canonical.x + 1) * r5 + t5.wrap * o4, (t5.canonical.y + 1) * r5 + t5.wrap * o4, i5]);
            }(t4, i4, o3).getCorners(), n3 = i4 / -r4[2];
            r4[0] < 0 ? (e3.Q.add(s4[0], s4[0], [r4[0] * n3, 0, 0]), e3.Q.add(s4[3], s4[3], [r4[0] * n3, 0, 0])) : r4[0] > 0 && (e3.Q.add(s4[1], s4[1], [r4[0] * n3, 0, 0]), e3.Q.add(s4[2], s4[2], [r4[0] * n3, 0, 0])), r4[1] < 0 ? (e3.Q.add(s4[0], s4[0], [0, r4[1] * n3, 0]), e3.Q.add(s4[1], s4[1], [0, r4[1] * n3, 0])) : r4[1] > 0 && (e3.Q.add(s4[2], s4[2], [0, r4[1] * n3, 0]), e3.Q.add(s4[3], s4[3], [0, r4[1] * n3, 0]));
            const a4 = {};
            return a4.vertices = s4, a4.planes = [bo(s4[1], s4[0], s4[4]), bo(s4[2], s4[1], s4[5]), bo(s4[3], s4[2], s4[6]), bo(s4[0], s4[3], s4[7])], a4;
          }
          addShadowReceiver(t4, i4, o3) {
            this._receivers.add(t4, e3.bV.fromTileIdAndHeight(t4, i4, o3));
          }
          getMaxCascadeForTile(e4) {
            const t4 = this._receivers.get(e4);
            return t4 && t4.lastCascade ? t4.lastCascade : 0;
          }
        }
        function bo(t4, i4, o3) {
          const r4 = e3.Q.sub([], o3, i4), s4 = e3.Q.sub([], t4, i4), n3 = e3.Q.cross([], r4, s4), a4 = e3.Q.length(n3);
          return 0 === a4 ? [0, 0, 1, 0] : (e3.Q.scale(n3, n3, 1 / a4), [n3[0], n3[1], n3[2], -e3.Q.dot(n3, i4)]);
        }
        function wo(t4) {
          const i4 = t4.properties.get("direction"), o3 = e3.bT(i4.x, i4.y, i4.z);
          o3[2] = e3.ad(o3[2], 0, 75);
          const r4 = e3.bW([o3[0], o3[1], o3[2]]);
          return e3.Q.fromValues(r4.x, r4.y, r4.z);
        }
        function To(t4, i4) {
          const o3 = t4.properties.get("color"), r4 = t4.properties.get("intensity"), s4 = t4.properties.get("direction"), n3 = [s4.x, s4.y, s4.z], a4 = i4.properties.get("color"), l4 = i4.properties.get("intensity"), c4 = Math.max(e3.Q.dot([0, 0, 1], n3), 0), h4 = [0, 0, 0];
          e3.Q.scale(h4, a4.toArray01Linear().slice(0, 3), l4);
          const u5 = [0, 0, 0];
          return e3.Q.scale(u5, o3.toArray01Linear().slice(0, 3), c4 * r4), e3.bX([h4[0] > 0 ? h4[0] / (h4[0] + u5[0]) : 0, h4[1] > 0 ? h4[1] / (h4[1] + u5[1]) : 0, h4[2] > 0 ? h4[2] / (h4[2] + u5[2]) : 0]);
        }
        function Eo(t4, i4, o3, r4, s4, n3) {
          const a4 = t4.zoom, l4 = t4.scale, c4 = t4.worldSize, h4 = 1 / c4, u5 = t4.aspect, d3 = Math.sqrt(1 + u5 * u5) * Math.tan(0.5 * t4.fovX), _4 = d3 * d3, p4 = r4 - o3, f4 = r4 + o3;
          let m4, g5;
          _4 > p4 / f4 ? (m4 = r4, g5 = r4 * d3) : (m4 = 0.5 * f4 * (1 + _4), g5 = 0.5 * Math.sqrt(p4 * p4 + 2 * (r4 * r4 + o3 * o3) * _4 + f4 * f4 * _4 * _4));
          const v4 = t4.projection.pixelsPerMeter(t4.center.lat, c4), x5 = t4._camera.getCameraToWorldMercator(), y4 = [0, 0, -m4 * h4];
          e3.Q.transformMat4(y4, y4, x5);
          let b4 = g5 * h4;
          const w5 = t4._edgeInsets;
          if (!(0 === w5.left && 0 === w5.top && 0 === w5.right && 0 === w5.bottom || w5.left === w5.right && w5.top === w5.bottom)) {
            const i5 = t4._camera.getWorldToCamera(t4.worldSize, "meters" === t4.projection.zAxisUnit ? v4 : 1), s5 = t4._camera.getCameraToClipPerspective(t4._fov, t4.width / t4.height, o3, r4);
            s5[8] = 2 * -t4.centerOffset.x / t4.width, s5[9] = 2 * t4.centerOffset.y / t4.height;
            const n4 = new Float64Array(16);
            e3.a9.mul(n4, s5, i5);
            const h5 = new Float64Array(16);
            e3.a9.invert(h5, n4);
            const u6 = e3.bt.fromInvProjectionMatrix(h5, c4, a4, true);
            for (const i6 of u6.points) {
              const o4 = ((T5 = i6)[0] /= l4, T5[1] /= l4, T5[2] = e3.bo(T5[2], t4._center.lat), T5);
              b4 = Math.max(b4, e3.Q.len(e3.Q.subtract([], y4, o4)));
            }
          }
          var T5;
          b4 *= s4 / (s4 - 1);
          const E3 = Math.acos(i4[2]), S3 = Math.atan2(-i4[0], -i4[1]), C4 = new ho();
          C4.position = y4, C4.setPitchBearing(E3, S3);
          const I4 = C4.getWorldToCamera(c4, v4), D4 = b4 * c4, R2 = Math.min(t4._mercatorZfromZoom(17) * c4 * -2, -2 * D4), A4 = C4.getCameraToClipOrthographic(-D4, D4, -D4, D4, R2, (D4 + n3 * v4) / i4[2]), P4 = new Float64Array(16);
          e3.a9.multiply(P4, A4, I4);
          const L4 = e3.Q.fromValues(Math.floor(1e6 * y4[0]) / 1e6 * c4, Math.floor(1e6 * y4[1]) / 1e6 * c4, 0), M3 = 0.5 * s4, z4 = [0, 0, 0];
          e3.Q.transformMat4(z4, L4, P4), e3.Q.scale(z4, z4, M3);
          const O3 = [Math.floor(z4[0]), Math.floor(z4[1]), Math.floor(z4[2])], F5 = [0, 0, 0];
          e3.Q.sub(F5, z4, O3), e3.Q.scale(F5, F5, -1 / M3);
          const B4 = new Float64Array(16);
          return e3.a9.identity(B4), e3.a9.translate(B4, B4, F5), e3.a9.multiply(P4, B4, P4), [P4, D4];
        }
        const So = (e4, t4) => ne(e4, t4 && t4.filter((e5) => "source.canvas" !== e5.identifier)), Co = e3.af(ti, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection", "setCamera", "addImport", "removeImport", "updateImport"]), Io = e3.af(ti, ["setCenter", "setZoom", "setBearing", "setPitch"]), Do = { version: 8, layers: [], sources: {} }, Ro = { duration: 300, delay: 0 };
        class Ao extends e3.E {
          constructor(t4, i4 = {}) {
            super(), this.map = t4, this.scope = i4.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i4.importDepth || 0, this.importsCache = i4.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = i4.resolvedImports || /* @__PURE__ */ new Set(), this.transition = e3.e({}, Ro), this._buildingIndex = new Jt(this), this.crossTileSymbolIndex = new ro(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this._changes = i4.styleChanges || new v3(), this.dispatcher = i4.dispatcher ? i4.dispatcher : new e3.bZ(e3.b_(), this), i4.imageManager ? this.imageManager = i4.imageManager : (this.imageManager = new w4(), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = i4.glyphManager ? i4.glyphManager : new e3.b$(t4._requestManager, i4.localFontFamily ? e3.c0.all : i4.localIdeographFontFamily ? e3.c0.ideographs : e3.c0.none, i4.localFontFamily || i4.localIdeographFontFamily), i4.modelManager ? this.modelManager = i4.modelManager : (this.modelManager = new x4(t4._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._precompileDone = false, this._shouldPrecompile = false, this._availableImages = [], this._order = [], this._markersNeedUpdate = false, this.options = i4.configOptions ? i4.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = i4.configDependentLayers ? i4.configDependentLayers : /* @__PURE__ */ new Set(), this._config = i4.config, this._initialConfig = i4.initialConfig, this.dispatcher.broadcast("setReferrer", e3.c1());
            const o3 = this;
            this._rtlTextPluginCallback = Ao.registerForPluginStateChange((t5) => {
              o3.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t5.pluginStatus, pluginURL: t5.pluginURL }, (t6, i5) => {
                if (e3.c2(t6), i5 && i5.every((e4) => e4)) for (const e4 in o3._sourceCaches) {
                  const t7 = o3._sourceCaches[e4], i6 = t7.getSource().type;
                  "vector" !== i6 && "geojson" !== i6 || t7.reload();
                }
              });
            }), this.on("data", (e4) => {
              if ("source" !== e4.dataType || "metadata" !== e4.sourceDataType) return;
              const t5 = this.getOwnSource(e4.sourceId);
              if (t5 && t5.vectorLayerIds) for (const e5 in this._layers) {
                const i5 = this._layers[e5];
                i5.source === t5.id && this._validateLayer(i5);
              }
            });
          }
          load(e4) {
            return e4 ? ("string" == typeof e4 ? this.loadURL(e4) : this.loadJSON(e4), this) : this;
          }
          _getGlobalId(t4) {
            if (!t4) return null;
            if ("string" == typeof t4) {
              if (e3.c3(t4)) return t4;
              const i4 = e3.c4(t4);
              if (!i4.startsWith("http")) try {
                return new URL(i4, location.href).toString();
              } catch (e4) {
                return i4;
              }
              return i4;
            }
            return `json://${e3.c5(JSON.stringify(t4))}`;
          }
          _diffStyle(t4, i4, o3) {
            this.globalId = this._getGlobalId(t4);
            const r4 = (e4, t5) => {
              try {
                t5(null, this.setState(e4, o3));
              } catch (e5) {
                t5(e5, false);
              }
            };
            if ("string" == typeof t4) {
              const o4 = this.map._requestManager.normalizeStyleURL(t4), s4 = this.map._requestManager.transformRequest(o4, e3.R.Style);
              e3.g(s4, (t5, o5) => {
                t5 ? this.fire(new e3.a(t5)) : o5 && r4(o5, i4);
              });
            } else "object" == typeof t4 && r4(t4, i4);
          }
          loadURL(t4, i4 = {}) {
            this.fire(new e3.b("dataloading", { dataType: "style" }));
            const o3 = "boolean" == typeof i4.validate ? i4.validate : !e3.c3(t4);
            this.globalId = this._getGlobalId(t4), t4 = this.map._requestManager.normalizeStyleURL(t4, i4.accessToken), this.resolvedImports.add(t4);
            const r4 = this.importsCache.get(t4);
            if (r4) return this._load(r4, o3);
            const s4 = this.map._requestManager.transformRequest(t4, e3.R.Style);
            this._request = e3.g(s4, (i5, r5) => {
              if (this._request = null, i5) this.fire(new e3.a(i5));
              else if (r5) return this.importsCache.set(t4, r5), this._load(r5, o3);
            });
          }
          loadJSON(t4, i4 = {}) {
            this.fire(new e3.b("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t4), this._request = e3.f.frame(() => {
              this._request = null, this._load(t4, false !== i4.validate);
            });
          }
          loadEmpty() {
            this.fire(new e3.b("dataloading", { dataType: "style" })), this._load(Do, false);
          }
          _loadImports(t4, i4, o3) {
            if (this.importDepth >= 4) return e3.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
            const r4 = [];
            for (const e4 of t4) {
              const t5 = this._createFragmentStyle(e4), s4 = new Promise((e5) => {
                t5.once("style.import.load", e5), t5.once("error", e5);
              }).then(() => this.mergeAll());
              if (r4.push(s4), this.resolvedImports.has(e4.url)) {
                t5.loadEmpty();
                continue;
              }
              const n3 = e4.data || this.importsCache.get(e4.url);
              n3 ? (t5.loadJSON(n3, { validate: i4 }), this._isInternalStyle(n3) && (t5.globalId = null)) : e4.url ? t5.loadURL(e4.url, { validate: i4 }) : t5.loadEmpty();
              const a4 = { style: t5, id: e4.id, config: e4.config };
              if (o3) {
                const e5 = this.fragments.findIndex(({ id: e6 }) => e6 === o3);
                this.fragments = this.fragments.slice(0, e5).concat(a4).concat(this.fragments.slice(e5));
              } else this.fragments.push(a4);
            }
            return Promise.allSettled(r4);
          }
          getImportGlobalIds(e4 = this, t4 = /* @__PURE__ */ new Set()) {
            for (const i4 of e4.fragments) i4.style.globalId && t4.add(i4.style.globalId), this.getImportGlobalIds(i4.style, t4);
            return [...t4.values()];
          }
          _createFragmentStyle(t4) {
            const i4 = this.scope ? e3.aj(t4.id, this.scope) : t4.id;
            let o3;
            const r4 = this._initialConfig && this._initialConfig[i4];
            (t4.config || r4) && (o3 = e3.e({}, t4.config, r4));
            const s4 = new Ao(this.map, { scope: i4, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: o3, configOptions: this.options, configDependentLayers: this._configDependentLayers });
            return s4.setEventedParent(this.map, { style: s4 }), s4;
          }
          _reloadImports() {
            this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.isRootStyle();
          }
          _isInternalStyle(e4) {
            return this.isRootStyle() && (e4.fragment || !!e4.schema && false !== e4.fragment);
          }
          _load(t4, i4) {
            const o3 = t4.schema;
            if (this._isInternalStyle(t4)) {
              const o4 = e3.e({}, Do, { imports: [{ id: "basemap", data: t4, url: "" }] });
              return void this._load(o4, i4);
            }
            if (this.updateConfig(this._config, o3), i4 && So(this, Q2(t4))) return;
            this._loaded = true, this.stylesheet = e3.c6(t4);
            for (const e4 in t4.sources) this.addSource(e4, t4.sources[e4], { validate: false, isInitialLoad: true });
            t4.sprite ? this._loadSprite(t4.sprite) : (this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true })), this.glyphManager.setURL(t4.glyphs, this.scope);
            const r4 = ei(this.stylesheet.layers);
            if (this._order = r4.map((e4) => e4.id), this.stylesheet.light && e3.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
              const e4 = this.stylesheet.lights[0];
              this.light = new le(e4.properties, e4.id);
            } else this.setLights(this.stylesheet.lights);
            this.light || (this.light = new le(this.stylesheet.light)), this._layers = {}, this._serializedLayers = {};
            for (const t5 of r4) {
              const i5 = e3.c7(t5, this.scope, this.options);
              i5.isConfigDependent && this._configDependentLayers.add(i5.fqid), i5.setEventedParent(this, { layer: { id: i5.id } }), this._layers[i5.id] = i5, this._serializedLayers[i5.id] = i5.serialize();
              const o4 = this.getOwnLayerSourceCache(i5), r5 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
              o4 && i5.canCastShadows() && r5 && (o4.castsShadows = true);
            }
            this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
            const s4 = this.stylesheet.terrain;
            s4 && (void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e3.f.hasCanvasFingerprintNoise()), this.disableElevatedTerrain ? e3.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode).") : this.terrainSetForDrapingOnly() || this._createTerrain(s4, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e3.b("data", { dataType: "style" }));
            const n3 = this.isRootStyle();
            t4.imports ? this._loadImports(t4.imports, i4).then(() => {
              this._reloadImports(), this.fire(new e3.b(n3 ? "style.load" : "style.import.load"));
            }) : (this._reloadImports(), this.fire(new e3.b(n3 ? "style.load" : "style.import.load")));
          }
          isRootStyle() {
            return 0 === this.importDepth;
          }
          mergeAll() {
            let t4, i4, o3, r4, s4, n3, a4, l4;
            this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((e4) => {
              if (e4.stylesheet) {
                if (null != e4.light && (t4 = e4.light), e4.stylesheet.lights) for (const t5 of e4.stylesheet.lights) "ambient" === t5.type && null != e4.ambientLight && (i4 = e4.ambientLight), "directional" === t5.type && null != e4.directionalLight && (o3 = e4.directionalLight);
                r4 = this._prioritizeTerrain(r4, e4.terrain, e4.stylesheet.terrain), e4.stylesheet.fog && null != e4.fog && (s4 = e4.fog), null != e4.stylesheet.camera && (l4 = e4.stylesheet.camera), null != e4.stylesheet.projection && (n3 = e4.stylesheet.projection), null != e4.stylesheet.transition && (a4 = e4.stylesheet.transition);
              }
            }), this.light = t4, this.ambientLight = i4, this.directionalLight = o3, this.fog = s4, null === r4 ? delete this.terrain : this.terrain = r4, this.camera = l4 || { "camera-projection": "perspective" }, this.projection = n3 || { name: "mercator" }, this.transition = e3.e({}, Ro, a4), this.mergeSources(), this.mergeLayers();
          }
          forEachFragmentStyle(e4) {
            const t4 = (i4) => {
              for (const e5 of i4.fragments) t4(e5.style);
              e4(i4);
            };
            t4(this);
          }
          _prioritizeTerrain(e4, t4, i4) {
            const o3 = e4 && 0 === e4.drapeRenderMode;
            return null === i4 ? t4 && 0 === t4.drapeRenderMode ? t4 : o3 ? e4 : null : null != t4 && (!e4 || o3 || t4 && 1 === t4.drapeRenderMode) ? t4 : e4;
          }
          mergeTerrain() {
            let e4;
            this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t4) => {
              e4 = this._prioritizeTerrain(e4, t4.terrain, t4.stylesheet.terrain);
            }), null === e4 ? delete this.terrain : this.terrain = e4;
          }
          mergeProjection() {
            let e4;
            this.forEachFragmentStyle((t4) => {
              null != t4.stylesheet.projection && (e4 = t4.stylesheet.projection);
            }), this.projection = e4 || { name: "mercator" };
          }
          mergeSources() {
            const t4 = {}, i4 = {}, o3 = {};
            this.forEachFragmentStyle((r4) => {
              for (const i5 in r4._sourceCaches) {
                const o4 = e3.aj(i5, r4.scope);
                t4[o4] = r4._sourceCaches[i5];
              }
              for (const t5 in r4._otherSourceCaches) {
                const o4 = e3.aj(t5, r4.scope);
                i4[o4] = r4._otherSourceCaches[t5];
              }
              for (const t5 in r4._symbolSourceCaches) {
                const i5 = e3.aj(t5, r4.scope);
                o3[i5] = r4._symbolSourceCaches[t5];
              }
            }), this._mergedSourceCaches = t4, this._mergedOtherSourceCaches = i4, this._mergedSymbolSourceCaches = o3;
          }
          mergeLayers() {
            const t4 = {}, i4 = [], o3 = {};
            this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this.forEachFragmentStyle((o4) => {
              for (const r5 of o4._order) {
                const s4 = o4._layers[r5];
                if ("slot" === s4.type) {
                  const i5 = e3.c8(r5);
                  if (t4[i5]) continue;
                  t4[i5] = [];
                }
                s4.slot && t4[s4.slot] ? t4[s4.slot].push(s4) : i4.push(s4);
              }
            }), this._mergedOrder = [];
            const r4 = (i5 = []) => {
              for (const s4 of i5) if ("slot" === s4.type) {
                const i6 = e3.c8(s4.id);
                t4[i6] && r4(t4[i6]);
              } else {
                const t5 = e3.aj(s4.id, s4.scope);
                this._mergedOrder.push(t5), o3[t5] = s4, s4.is3D() && (this._has3DLayers = true), "circle" === s4.type && (this._hasCircleLayers = true), "symbol" === s4.type && (this._hasSymbolLayers = true);
              }
            };
            r4(i4), this._mergedLayers = o3, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
          }
          terrainSetForDrapingOnly() {
            return !!this.terrain && 0 === this.terrain.drapeRenderMode;
          }
          getCamera() {
            return this.stylesheet.camera;
          }
          setCamera(t4) {
            return this.stylesheet.camera = e3.e({}, this.stylesheet.camera, t4), this.camera = this.stylesheet.camera, this;
          }
          setProjection(e4) {
            e4 ? this.stylesheet.projection = e4 : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
          }
          applyProjectionUpdate() {
            this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
          }
          _updateMapProjection() {
            this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
          }
          _loadSprite(t4) {
            this._spriteRequest = function(t5, i4, o3) {
              let r4, s4, n3;
              const a4 = e3.f.devicePixelRatio > 1 ? "@2x" : "";
              let l4 = e3.g(i4.transformRequest(i4.normalizeSpriteURL(t5, a4, ".json"), e3.R.SpriteJSON), (e4, t6) => {
                l4 = null, n3 || (n3 = e4, r4 = t6, h4());
              }), c4 = e3.d(i4.transformRequest(i4.normalizeSpriteURL(t5, a4, ".png"), e3.R.SpriteImage), (e4, t6) => {
                c4 = null, n3 || (n3 = e4, s4 = t6, h4());
              });
              function h4() {
                if (n3) o3(n3);
                else if (r4 && s4) {
                  const t6 = e3.f.getImageData(s4), i5 = {};
                  for (const o4 in r4) {
                    const { width: s5, height: n4, x: a5, y: l5, sdf: c5, pixelRatio: h5, stretchX: u5, stretchY: d3, content: _4 } = r4[o4], p4 = new e3.h({ width: s5, height: n4 });
                    e3.h.copy(t6, p4, { x: a5, y: l5 }, { x: 0, y: 0 }, { width: s5, height: n4 }), i5[o4] = { data: p4, pixelRatio: h5, sdf: c5, stretchX: u5, stretchY: d3, content: _4 };
                  }
                  o3(null, i5);
                }
              }
              return { cancel() {
                l4 && (l4.cancel(), l4 = null), c4 && (c4.cancel(), c4 = null);
              } };
            }(t4, this.map._requestManager, (t5, i4) => {
              if (this._spriteRequest = null, t5) this.fire(new e3.a(t5));
              else if (i4) for (const e4 in i4) this.imageManager.addImage(e4, this.scope, i4[e4]);
              this.imageManager.setLoaded(true, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e3.b("data", { dataType: "style" }));
            });
          }
          _validateLayer(t4) {
            const i4 = this.getOwnSource(t4.source);
            if (!i4) return;
            const o3 = t4.sourceLayer;
            o3 && ("geojson" === i4.type || i4.vectorLayerIds && -1 === i4.vectorLayerIds.indexOf(o3)) && this.fire(new e3.a(new Error(`Source layer "${o3}" does not exist on source "${i4.id}" as specified by style layer "${t4.id}"`)));
          }
          loaded() {
            if (!this._loaded) return false;
            if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return false;
            for (const e4 in this._sourceCaches) if (!this._sourceCaches[e4].loaded()) return false;
            if (!this.imageManager.isLoaded()) return false;
            if (!this.modelManager.isLoaded()) return false;
            for (const { style: e4 } of this.fragments) if (!e4.loaded()) return false;
            return true;
          }
          _serializeImports() {
            if (this.stylesheet.imports) return this.stylesheet.imports.map((e4, t4) => {
              const i4 = this.fragments[t4];
              return i4 && i4.style && (e4.data = i4.style.serialize()), e4;
            });
          }
          _serializeSources() {
            const e4 = {};
            for (const t4 in this._sourceCaches) {
              const i4 = this._sourceCaches[t4].getSource();
              e4[i4.id] || (e4[i4.id] = i4.serialize());
            }
            return e4;
          }
          _serializeLayers(e4) {
            const t4 = [];
            for (const i4 of e4) {
              const e5 = this._layers[i4];
              e5 && "custom" !== e5.type && t4.push(e5.serialize());
            }
            return t4;
          }
          hasLightTransitions() {
            return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
          }
          hasFogTransition() {
            return !!this.fog && this.fog.hasTransition();
          }
          hasTransitions() {
            if (this.hasLightTransitions()) return true;
            if (this.hasFogTransition()) return true;
            for (const e4 in this._sourceCaches) if (this._sourceCaches[e4].hasTransition()) return true;
            for (const e4 in this._layers) if (this._layers[e4].hasTransition()) return true;
            return false;
          }
          get order() {
            return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
          }
          isLayerDraped(e4) {
            return !!this.terrain && e4.isDraped(this.getLayerSourceCache(e4));
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading");
          }
          _checkLayer(t4) {
            const i4 = this.getOwnLayer(t4);
            if (i4) return i4;
            this.fire(new e3.a(new Error(`The layer '${t4}' does not exist in the map's style.`)));
          }
          _checkSource(t4) {
            const i4 = this.getOwnSource(t4);
            if (i4) return i4;
            this.fire(new e3.a(new Error(`The source '${t4}' does not exist in the map's style.`)));
          }
          update(t4) {
            if (!this._loaded) return;
            this.ambientLight && this.ambientLight.recalculate(t4), this.directionalLight && this.directionalLight.recalculate(t4);
            const i4 = this.calculateLightsBrightness();
            t4.brightness = i4 || 0, i4 !== this._brightness && (this._brightness = i4, this.dispatcher.broadcast("setBrightness", i4));
            const o3 = this._changes.isDirty();
            if (this._changes.isDirty()) {
              const e4 = this._changes.getLayerUpdatesByScope();
              for (const t5 in e4) {
                const { updatedIds: i5, removedIds: o4 } = e4[t5];
                (i5 || o4) && this._updateWorkerLayers(t5, i5, o4);
              }
              this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t4), this.light && this.light.updateTransitions(t4), this.ambientLight && this.ambientLight.updateTransitions(t4), this.directionalLight && this.directionalLight.updateTransitions(t4), this.fog && this.fog.updateTransitions(t4), this._changes.reset();
            }
            const r4 = {};
            for (const e4 in this._mergedSourceCaches) {
              const t5 = this._mergedSourceCaches[e4];
              r4[e4] = t5.used, t5.used = false, t5.tileCoverLift = 0;
            }
            for (const e4 of this._mergedOrder) {
              const i5 = this._mergedLayers[e4];
              if (i5.recalculate(t4, this._availableImages), !i5.isHidden(t4.zoom)) {
                const e5 = this.getLayerSourceCache(i5);
                e5 && (e5.used = true, e5.tileCoverLift = Math.max(e5.tileCoverLift, i5.tileCoverLift()));
              }
              if (!this._precompileDone && this._shouldPrecompile) for (let e5 = i5.minzoom || 0; e5 < (i5.maxzoom || 25.5); e5++) {
                const e6 = this.map.painter;
                if (e6) {
                  const o4 = i5.getProgramIds();
                  if (!o4) continue;
                  for (const r5 of o4) {
                    const o5 = i5.getDefaultProgramParams(r5, t4.zoom);
                    o5 && (e6.style = this, this.fog && (e6._fogVisible = true, o5.overrideFog = true, e6.getOrCreateProgram(r5, o5)), e6._fogVisible = false, o5.overrideFog = false, e6.getOrCreateProgram(r5, o5), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o5.overrideRtt = true, e6.getOrCreateProgram(r5, o5)));
                  }
                }
              }
            }
            this._shouldPrecompile && (this._precompileDone = true);
            for (const t5 in r4) {
              const i5 = this._mergedSourceCaches[t5];
              r4[t5] !== i5.used && i5.getSource().fire(new e3.b("data", { sourceDataType: "visibility", dataType: "source", sourceId: i5.getSource().id }));
            }
            this.light && this.light.recalculate(t4), this.terrain && this.terrain.recalculate(t4), this.fog && this.fog.recalculate(t4), this.z = t4.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), o3 && this.fire(new e3.b("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e4 = this._changes.getUpdatedImages();
            if (e4.length) {
              for (const t4 in this._sourceCaches) this._sourceCaches[t4].reloadTilesForDependencies(["icons", "patterns"], e4);
              this._changes.resetUpdatedImages();
            }
          }
          _updateWorkerLayers(e4, t4, i4) {
            const o3 = this.getFragmentStyle(e4);
            o3 && this.dispatcher.broadcast("updateLayers", { layers: t4 ? o3._serializeLayers(t4) : [], scope: e4, removedIds: i4 || [], options: o3.options });
          }
          setState(i4, o3) {
            if (this._checkLoaded(), So(this, Q2(i4))) return false;
            (i4 = e3.c6(i4)).layers = ei(i4.layers);
            const r4 = function(e4, i5) {
              if (!e4) return [{ command: ti.setStyle, args: [i5] }];
              let o4 = [];
              try {
                if (!t3(e4.version, i5.version)) return [{ command: ti.setStyle, args: [i5] }];
                t3(e4.center, i5.center) || o4.push({ command: ti.setCenter, args: [i5.center] }), t3(e4.zoom, i5.zoom) || o4.push({ command: ti.setZoom, args: [i5.zoom] }), t3(e4.bearing, i5.bearing) || o4.push({ command: ti.setBearing, args: [i5.bearing] }), t3(e4.pitch, i5.pitch) || o4.push({ command: ti.setPitch, args: [i5.pitch] }), t3(e4.sprite, i5.sprite) || o4.push({ command: ti.setSprite, args: [i5.sprite] }), t3(e4.glyphs, i5.glyphs) || o4.push({ command: ti.setGlyphs, args: [i5.glyphs] }), t3(e4.imports, i5.imports) || function(e5 = [], i6 = [], o5) {
                  i6 = i6 || [];
                  const r6 = (e5 = e5 || []).map(ai), s6 = i6.map(ai), n5 = e5.reduce(li, {}), a5 = i6.reduce(li, {}), l4 = r6.slice();
                  let c4, h4, u5, d3;
                  for (c4 = 0, h4 = 0; c4 < r6.length; c4++) u5 = r6[c4], a5.hasOwnProperty(u5) ? h4++ : (o5.push({ command: ti.removeImport, args: [u5] }), l4.splice(l4.indexOf(u5, h4), 1));
                  for (c4 = 0, h4 = 0; c4 < s6.length; c4++) u5 = s6[s6.length - 1 - c4], l4[l4.length - 1 - c4] !== u5 && (n5.hasOwnProperty(u5) ? (o5.push({ command: ti.removeImport, args: [u5] }), l4.splice(l4.lastIndexOf(u5, l4.length - h4), 1)) : h4++, d3 = l4[l4.length - c4], o5.push({ command: ti.addImport, args: [a5[u5], d3] }), l4.splice(l4.length - c4, 0, u5));
                  for (const e6 of i6) {
                    const i7 = n5[e6.id];
                    i7 && !t3(i7, e6) && o5.push({ command: ti.updateImport, args: [e6.id, e6] });
                  }
                }(e4.imports, i5.imports, o4), t3(e4.transition, i5.transition) || o4.push({ command: ti.setTransition, args: [i5.transition] }), t3(e4.light, i5.light) || o4.push({ command: ti.setLight, args: [i5.light] }), t3(e4.fog, i5.fog) || o4.push({ command: ti.setFog, args: [i5.fog] }), t3(e4.projection, i5.projection) || o4.push({ command: ti.setProjection, args: [i5.projection] }), t3(e4.lights, i5.lights) || o4.push({ command: ti.setLights, args: [i5.lights] }), t3(e4.camera, i5.camera) || o4.push({ command: ti.setCamera, args: [i5.camera] });
                const r5 = {}, s5 = [];
                !function(e5, i6, o5, r6) {
                  let s6;
                  for (s6 in i6 = i6 || {}, e5 = e5 || {}) e5.hasOwnProperty(s6) && (i6.hasOwnProperty(s6) || oi(s6, o5, r6));
                  for (s6 in i6) {
                    if (!i6.hasOwnProperty(s6)) continue;
                    const n5 = i6[s6];
                    e5.hasOwnProperty(s6) ? t3(e5[s6], n5) || ("geojson" === e5[s6].type && "geojson" === n5.type && si(e5, i6, s6) ? o5.push({ command: ti.setGeoJSONSourceData, args: [s6, n5.data] }) : ri(s6, i6, o5, r6)) : ii(s6, i6, o5);
                  }
                }(e4.sources, i5.sources, s5, r5);
                const n4 = [];
                e4.layers && e4.layers.forEach((e5) => {
                  e5.source && r5[e5.source] ? o4.push({ command: ti.removeLayer, args: [e5.id] }) : n4.push(e5);
                });
                let a4 = e4.terrain;
                a4 && r5[a4.source] && (o4.push({ command: ti.setTerrain, args: [void 0] }), a4 = void 0), o4 = o4.concat(s5), t3(a4, i5.terrain) || o4.push({ command: ti.setTerrain, args: [i5.terrain] }), function(e5, i6, o5) {
                  i6 = i6 || [];
                  const r6 = (e5 = e5 || []).map(ai), s6 = i6.map(ai), n5 = e5.reduce(li, {}), a5 = i6.reduce(li, {}), l4 = r6.slice(), c4 = /* @__PURE__ */ Object.create(null);
                  let h4, u5, d3, _4, p4, f4, m4;
                  for (h4 = 0, u5 = 0; h4 < r6.length; h4++) d3 = r6[h4], a5.hasOwnProperty(d3) ? u5++ : (o5.push({ command: ti.removeLayer, args: [d3] }), l4.splice(l4.indexOf(d3, u5), 1));
                  for (h4 = 0, u5 = 0; h4 < s6.length; h4++) d3 = s6[s6.length - 1 - h4], l4[l4.length - 1 - h4] !== d3 && (n5.hasOwnProperty(d3) ? (o5.push({ command: ti.removeLayer, args: [d3] }), l4.splice(l4.lastIndexOf(d3, l4.length - u5), 1)) : u5++, f4 = l4[l4.length - h4], o5.push({ command: ti.addLayer, args: [a5[d3], f4] }), l4.splice(l4.length - h4, 0, d3), c4[d3] = true);
                  for (h4 = 0; h4 < s6.length; h4++) if (d3 = s6[h4], _4 = n5[d3], p4 = a5[d3], !c4[d3] && !t3(_4, p4)) if (t3(_4.source, p4.source) && t3(_4["source-layer"], p4["source-layer"]) && t3(_4.type, p4.type)) {
                    for (m4 in ni(_4.layout, p4.layout, o5, d3, null, ti.setLayoutProperty), ni(_4.paint, p4.paint, o5, d3, null, ti.setPaintProperty), t3(_4.slot, p4.slot) || o5.push({ command: ti.setSlot, args: [d3, p4.slot] }), t3(_4.filter, p4.filter) || o5.push({ command: ti.setFilter, args: [d3, p4.filter] }), t3(_4.minzoom, p4.minzoom) && t3(_4.maxzoom, p4.maxzoom) || o5.push({ command: ti.setLayerZoomRange, args: [d3, p4.minzoom, p4.maxzoom] }), _4) _4.hasOwnProperty(m4) && "layout" !== m4 && "paint" !== m4 && "filter" !== m4 && "metadata" !== m4 && "minzoom" !== m4 && "maxzoom" !== m4 && "slot" !== m4 && (0 === m4.indexOf("paint.") ? ni(_4[m4], p4[m4], o5, d3, m4.slice(6), ti.setPaintProperty) : t3(_4[m4], p4[m4]) || o5.push({ command: ti.setLayerProperty, args: [d3, m4, p4[m4]] }));
                    for (m4 in p4) p4.hasOwnProperty(m4) && !_4.hasOwnProperty(m4) && "layout" !== m4 && "paint" !== m4 && "filter" !== m4 && "metadata" !== m4 && "minzoom" !== m4 && "maxzoom" !== m4 && "slot" !== m4 && (0 === m4.indexOf("paint.") ? ni(_4[m4], p4[m4], o5, d3, m4.slice(6), ti.setPaintProperty) : t3(_4[m4], p4[m4]) || o5.push({ command: ti.setLayerProperty, args: [d3, m4, p4[m4]] }));
                  } else o5.push({ command: ti.removeLayer, args: [d3] }), f4 = l4[l4.lastIndexOf(d3) + 1], o5.push({ command: ti.addLayer, args: [p4, f4] });
                }(n4, i5.layers, o4);
              } catch (e5) {
                console.warn("Unable to compute style diff:", e5), o4 = [{ command: ti.setStyle, args: [i5] }];
              }
              return o4;
            }(this.serialize(), i4).filter((e4) => !(e4.command in Io));
            if (0 === r4.length) return false;
            const s4 = r4.filter((e4) => !(e4.command in Co));
            if (s4.length > 0) throw new Error(`Unimplemented: ${s4.map((e4) => e4.command).join(", ")}.`);
            const n3 = [];
            return r4.forEach((e4) => {
              n3.push(this[e4.command].apply(this, e4.args));
            }), o3 && Promise.all(n3).then(o3), this.stylesheet = i4, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), true;
          }
          addImage(t4, i4) {
            return this.getImage(t4) ? this.fire(new e3.a(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t4, this.scope, i4), this._afterImageUpdated(t4), this);
          }
          updateImage(e4, t4) {
            this.imageManager.updateImage(e4, this.scope, t4);
          }
          getImage(e4) {
            return this.imageManager.getImage(e4, this.scope);
          }
          removeImage(t4) {
            return this.getImage(t4) ? (this.imageManager.removeImage(t4, this.scope), this._afterImageUpdated(t4), this) : this.fire(new e3.a(new Error("No image with this name exists.")));
          }
          _afterImageUpdated(t4) {
            this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t4), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.fire(new e3.b("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this._availableImages.slice();
          }
          addModel(e4, t4, i4 = {}) {
            return this._checkLoaded(), this._validate(re, `models.${e4}`, t4, null, i4) || (this.modelManager.addModel(e4, t4, this.scope), this._changes.setDirty()), this;
          }
          hasModel(e4) {
            return this.modelManager.hasModel(e4, this.scope);
          }
          removeModel(t4) {
            return this.hasModel(t4) ? (this.modelManager.removeModel(t4, this.scope), this) : this.fire(new e3.a(new Error("No model with this ID exists.")));
          }
          listModels() {
            return this._checkLoaded(), this.modelManager.listModels(this.scope);
          }
          addSource(t4, i4, o3 = {}) {
            if (this._checkLoaded(), void 0 !== this.getOwnSource(t4)) throw new Error(`There is already a source with ID "${t4}".`);
            if (!i4.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i4).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i4.type) >= 0 && this._validate($3, `sources.${t4}`, i4, null, o3)) return;
            this.map && this.map._collectResourceTiming && (i4.collectResourceTiming = true);
            const r4 = Gt(t4, i4, this.dispatcher, this);
            r4.scope = this.scope, r4.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(r4.id), source: r4.serialize(), sourceId: r4.id }));
            const s4 = (t5) => {
              const i5 = (t5 ? "symbol:" : "other:") + r4.id, o4 = e3.aj(i5, this.scope), s5 = this._sourceCaches[i5] = new Qt(o4, r4, t5);
              (t5 ? this._symbolSourceCaches : this._otherSourceCaches)[r4.id] = s5, s5.onAdd(this.map);
            };
            s4(false), "vector" !== i4.type && "geojson" !== i4.type || s4(true), r4.onAdd && r4.onAdd(this.map), o3.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
          }
          removeSource(t4) {
            this._checkLoaded();
            const i4 = this.getOwnSource(t4);
            if (!i4) throw new Error("There is no source with this ID");
            for (const i5 in this._layers) if (this._layers[i5].source === t4) return this.fire(new e3.a(new Error(`Source "${t4}" cannot be removed while layer "${i5}" is using it.`)));
            if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t4) return this.fire(new e3.a(new Error(`Source "${t4}" cannot be removed while terrain is using it.`)));
            const o3 = this.getOwnSourceCaches(t4);
            for (const t5 of o3) {
              const i5 = e3.c8(t5.id);
              delete this._sourceCaches[i5], this._changes.discardSourceCacheUpdate(t5.id), t5.fire(new e3.b("data", { sourceDataType: "metadata", dataType: "source", sourceId: t5.getSource().id })), t5.setEventedParent(null), t5.clearTiles();
            }
            return delete this._otherSourceCaches[t4], delete this._symbolSourceCaches[t4], this.mergeSources(), i4.setEventedParent(null), i4.onRemove && i4.onRemove(this.map), this._changes.setDirty(), this;
          }
          setGeoJSONSourceData(e4, t4) {
            this._checkLoaded(), this.getOwnSource(e4).setData(t4), this._changes.setDirty();
          }
          getOwnSource(e4) {
            const t4 = this.getOwnSourceCache(e4);
            return t4 && t4.getSource();
          }
          getOwnSources() {
            const e4 = [];
            for (const t4 in this._otherSourceCaches) {
              const i4 = this.getOwnSourceCache(t4);
              i4 && e4.push(i4.getSource());
            }
            return e4;
          }
          areTilesLoaded() {
            const e4 = this._mergedSourceCaches;
            for (const t4 in e4) {
              const i4 = e4[t4]._tiles;
              for (const e5 in i4) {
                const t5 = i4[e5];
                if ("loaded" !== t5.state && "errored" !== t5.state) return false;
              }
            }
            return true;
          }
          setLights(t4) {
            if (this._checkLoaded(), !t4) return delete this.ambientLight, void delete this.directionalLight;
            const i4 = this._getTransitionParameters();
            for (const e4 of t4) {
              if (this._validate(Y, "lights", e4)) return;
              switch (e4.type) {
                case "ambient":
                  if (this.ambientLight) {
                    const t5 = this.ambientLight;
                    t5.set(e4), t5.updateTransitions(i4);
                  } else this.ambientLight = new ye(e4, be, this.scope, this.options);
                  break;
                case "directional":
                  if (this.directionalLight) {
                    const t5 = this.directionalLight;
                    t5.set(e4), t5.updateTransitions(i4);
                  } else this.directionalLight = new ye(e4, we, this.scope, this.options);
              }
            }
            const o3 = new e3.N(this.z || 0, i4);
            this.ambientLight && this.ambientLight.recalculate(o3), this.directionalLight && this.directionalLight.recalculate(o3), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
          }
          calculateLightsBrightness() {
            const t4 = this.directionalLight, i4 = this.ambientLight;
            if (!t4 || !i4) return;
            const o3 = (e4) => 0.2126 * (e4[0] <= 0.03928 ? e4[0] / 12.92 : Math.pow((e4[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (e4[1] <= 0.03928 ? e4[1] / 12.92 : Math.pow((e4[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (e4[2] <= 0.03928 ? e4[2] / 12.92 : Math.pow((e4[2] + 0.055) / 1.055, 2.4)), r4 = t4.properties.get("color").toArray01(), s4 = t4.properties.get("intensity"), n3 = t4.properties.get("direction"), a4 = 1 - e3.bT(n3.x, n3.y, n3.z)[2] / 90, l4 = o3(r4) * s4 * a4, c4 = i4.properties.get("color").toArray01(), h4 = i4.properties.get("intensity");
            return (l4 + o3(c4) * h4) / 2;
          }
          getBrightness() {
            return this._brightness;
          }
          getLights() {
            if (!this.enable3dLights()) return null;
            const e4 = [];
            return this.directionalLight && e4.push(this.directionalLight.get()), this.ambientLight && e4.push(this.ambientLight.get()), e4;
          }
          enable3dLights() {
            return !!this.ambientLight && !!this.directionalLight;
          }
          getFragmentStyle(t4) {
            if (!t4) return this;
            if (e3.c9(t4)) {
              const i4 = e3.ca(t4), o3 = this.fragments.find(({ id: e4 }) => e4 === i4);
              if (!o3) throw new Error(`Style import not found: ${t4}`);
              const r4 = e3.c8(t4);
              return o3.style.getFragmentStyle(r4);
            }
            {
              const e4 = this.fragments.find(({ id: e5 }) => e5 === t4);
              if (!e4) throw new Error(`Style import not found: ${t4}`);
              return e4.style;
            }
          }
          getConfigProperty(t4, i4) {
            const o3 = this.getFragmentStyle(t4);
            if (!o3) return null;
            const r4 = e3.aj(i4, o3.scope), s4 = o3.options.get(r4), n3 = s4 ? s4.value || s4.default : null;
            return n3 ? n3.serialize() : null;
          }
          setConfigProperty(t4, i4, o3) {
            const r4 = this.getFragmentStyle(t4);
            if (!r4) return;
            const s4 = r4.stylesheet.schema;
            if (!s4 || !s4[i4]) return;
            const n3 = e3.t(o3);
            if ("success" !== n3.result) return void So(this, n3.value);
            const a4 = n3.value.expression, l4 = e3.aj(i4, r4.scope), c4 = r4.options.get(l4);
            if (!c4) return;
            let h4;
            const { minValue: u5, maxValue: d3, stepValue: _4, type: p4, values: f4 } = s4[i4], m4 = e3.t(s4[i4].default);
            "success" === m4.result && (h4 = m4.value.expression), h4 ? (this.options.set(l4, __spreadProps(__spreadValues({}, c4), { value: a4, default: h4, minValue: u5, maxValue: d3, stepValue: _4, type: p4, values: f4 })), this.updateConfigDependencies()) : this.fire(new e3.a(new Error(`No schema defined for the config option "${i4}" in the "${t4}" fragment.`)));
          }
          getConfig(t4) {
            const i4 = this.getFragmentStyle(t4);
            if (!i4) return null;
            const o3 = i4.stylesheet.schema;
            if (!o3) return null;
            const r4 = {};
            for (const t5 in o3) {
              const o4 = e3.aj(t5, i4.scope), s4 = i4.options.get(o4), n3 = s4 ? s4.value || s4.default : null;
              r4[t5] = n3 ? n3.serialize() : null;
            }
            return r4;
          }
          setConfig(e4, t4) {
            const i4 = this.getFragmentStyle(e4);
            i4 && (i4.updateConfig(t4, i4.stylesheet.schema), this.updateConfigDependencies());
          }
          getSchema(e4) {
            const t4 = this.getFragmentStyle(e4);
            return t4 ? t4.stylesheet.schema : null;
          }
          setSchema(e4, t4) {
            const i4 = this.getFragmentStyle(e4);
            i4 && (i4.stylesheet.schema = t4, i4.updateConfig(i4._config, t4), this.updateConfigDependencies());
          }
          updateConfig(t4, i4) {
            if (this._config = t4, t4 || i4) if (i4) for (const o3 in i4) {
              let r4, s4;
              const n3 = e3.t(i4[o3].default);
              if ("success" === n3.result && (r4 = n3.value.expression), t4 && void 0 !== t4[o3]) {
                const i5 = e3.t(t4[o3]);
                "success" === i5.result && (s4 = i5.value.expression);
              }
              const { minValue: a4, maxValue: l4, stepValue: c4, type: h4, values: u5 } = i4[o3];
              if (r4) {
                const t5 = e3.aj(o3, this.scope);
                this.options.set(t5, { default: r4, value: s4, minValue: a4, maxValue: l4, stepValue: c4, type: h4, values: u5 });
              } else this.fire(new e3.a(new Error(`No schema defined for config option "${o3}".`)));
            }
            else this.fire(new e3.a(new Error("Attempting to set config for a style without schema.")));
          }
          updateConfigDependencies() {
            for (const e4 of this._configDependentLayers) {
              const t4 = this.getLayer(e4);
              t4 && (t4.possiblyEvaluateVisibility(), this._updateLayer(t4));
            }
            this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this._changes.setDirty();
          }
          addLayer(t4, i4, o3 = {}) {
            this._checkLoaded();
            const r4 = t4.id;
            if (this._layers[r4]) return void this.fire(new e3.a(new Error(`Layer with id "${r4}" already exists on this map`)));
            let s4;
            if ("custom" === t4.type) {
              if (So(this, e3.cb(t4))) return;
              s4 = e3.c7(t4, this.scope, this.options);
            } else {
              if ("object" == typeof t4.source && (this.addSource(r4, t4.source), t4 = e3.c6(t4), t4 = e3.e(t4, { source: r4 })), this._validate(ee, `layers.${r4}`, t4, { arrayIndex: -1 }, o3)) return;
              s4 = e3.c7(t4, this.scope, this.options), this._validateLayer(s4), s4.setEventedParent(this, { layer: { id: r4 } }), this._serializedLayers[s4.id] = s4.serialize();
            }
            s4.isConfigDependent && this._configDependentLayers.add(s4.fqid);
            let n3 = this._order.length;
            if (i4) {
              const t5 = this._order.indexOf(i4);
              if (-1 === t5) return void this.fire(new e3.a(new Error(`Layer with id "${i4}" does not exist on this map.`)));
              s4.slot === this._layers[i4].slot ? n3 = t5 : e3.w(`Layer with id "${i4}" has a different slot. Layers can only be rearranged within the same slot.`);
            }
            this._order.splice(n3, 0, r4), this._layerOrderChanged = true, this._layers[r4] = s4;
            const a4 = this.getOwnLayerSourceCache(s4), l4 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
            a4 && s4.canCastShadows() && l4 && (a4.castsShadows = true);
            const c4 = this._changes.getRemovedLayer(s4);
            if (c4 && s4.source && a4 && "custom" !== s4.type) {
              this._changes.discardLayerRemoval(s4);
              const t5 = e3.aj(s4.source, s4.scope);
              c4.type !== s4.type ? this._changes.updateSourceCache(t5, "clear") : (this._changes.updateSourceCache(t5, "reload"), a4.pause());
            }
            this._updateLayer(s4), s4.onAdd && s4.onAdd(this.map), s4.scope = this.scope, this.mergeLayers();
          }
          moveLayer(t4, i4) {
            this._checkLoaded();
            const o3 = this._checkLayer(t4);
            if (!o3) return;
            if (t4 === i4) return;
            const r4 = this._order.indexOf(t4);
            this._order.splice(r4, 1);
            let s4 = this._order.length;
            if (i4) {
              const t5 = this._order.indexOf(i4);
              if (-1 === t5) return void this.fire(new e3.a(new Error(`Layer with id "${i4}" does not exist on this map.`)));
              o3.slot === this._layers[i4].slot ? s4 = t5 : e3.w(`Layer with id "${i4}" has a different slot. Layers can only be rearranged within the same slot.`);
            }
            this._order.splice(s4, 0, t4), this._changes.setDirty(), this._layerOrderChanged = true, this.mergeLayers();
          }
          removeLayer(e4) {
            this._checkLoaded();
            const t4 = this._checkLayer(e4);
            if (!t4) return;
            t4.setEventedParent(null);
            const i4 = this._order.indexOf(e4);
            this._order.splice(i4, 1), delete this._layers[e4], delete this._serializedLayers[e4], this._changes.setDirty(), this._layerOrderChanged = true, this._configDependentLayers.delete(t4.fqid), this._changes.removeLayer(t4);
            const o3 = this.getOwnLayerSourceCache(t4);
            if (o3 && o3.castsShadows) {
              let e5 = false;
              for (const i5 in this._layers) if (this._layers[i5].source === t4.source && this._layers[i5].canCastShadows()) {
                e5 = true;
                break;
              }
              o3.castsShadows = e5;
            }
            t4.onRemove && t4.onRemove(this.map), this.mergeLayers();
          }
          getOwnLayer(e4) {
            return this._layers[e4];
          }
          hasLayer(e4) {
            return e4 in this._mergedLayers;
          }
          hasLayerType(e4) {
            for (const t4 in this._layers) if (this._layers[t4].type === e4) return true;
            return false;
          }
          setLayerZoomRange(e4, t4, i4) {
            this._checkLoaded();
            const o3 = this._checkLayer(e4);
            o3 && (o3.minzoom === t4 && o3.maxzoom === i4 || (null != t4 && (o3.minzoom = t4), null != i4 && (o3.maxzoom = i4), this._updateLayer(o3)));
          }
          setSlot(e4, t4) {
            this._checkLoaded();
            const i4 = this._checkLayer(e4);
            i4 && i4.slot !== t4 && (i4.slot = t4, this._updateLayer(i4));
          }
          setFilter(i4, o3, r4 = {}) {
            this._checkLoaded();
            const s4 = this._checkLayer(i4);
            if (s4 && !t3(s4.filter, o3)) return null == o3 ? (s4.filter = void 0, void this._updateLayer(s4)) : void (this._validate(te, `layers.${s4.id}.filter`, o3, { layerType: s4.type }, r4) || (s4.filter = e3.c6(o3), this._updateLayer(s4)));
          }
          getFilter(t4) {
            const i4 = this._checkLayer(t4);
            if (i4) return e3.c6(i4.filter);
          }
          setLayoutProperty(i4, o3, r4, s4 = {}) {
            this._checkLoaded();
            const n3 = this._checkLayer(i4);
            if (n3 && !t3(n3.getLayoutProperty(o3), r4)) {
              if (null != r4 && (!s4 || false !== s4.validate) && So(n3, oe.call(Q2, { key: `layers.${i4}.layout.${o3}`, layerType: n3.type, objectKey: o3, value: r4, styleSpec: e3.G, style: { glyphs: true, sprite: true } }))) return;
              n3.setLayoutProperty(o3, r4), n3.isConfigDependent && this._configDependentLayers.add(n3.fqid), this._updateLayer(n3);
            }
          }
          getLayoutProperty(e4, t4) {
            const i4 = this._checkLayer(e4);
            if (i4) return i4.getLayoutProperty(t4);
          }
          setPaintProperty(i4, o3, r4, s4 = {}) {
            this._checkLoaded();
            const n3 = this._checkLayer(i4);
            if (!n3) return;
            if (t3(n3.getPaintProperty(o3), r4)) return;
            if (null != r4 && (!s4 || false !== s4.validate) && So(n3, ie.call(Q2, { key: `layers.${i4}.paint.${o3}`, layerType: n3.type, objectKey: o3, value: r4, styleSpec: e3.G }))) return;
            const a4 = n3.setPaintProperty(o3, r4);
            n3.isConfigDependent && this._configDependentLayers.add(n3.fqid), a4 && this._updateLayer(n3), this._changes.updatePaintProperties(n3);
          }
          getPaintProperty(e4, t4) {
            const i4 = this._checkLayer(e4);
            if (i4) return i4.getPaintProperty(t4);
          }
          setFeatureState(t4, i4) {
            this._checkLoaded();
            const o3 = t4.source, r4 = t4.sourceLayer, s4 = this._checkSource(o3);
            if (!s4) return;
            const n3 = s4.type;
            if ("geojson" === n3 && r4) return void this.fire(new e3.a(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
            if ("vector" === n3 && !r4) return void this.fire(new e3.a(new Error("The sourceLayer parameter must be provided for vector source types.")));
            void 0 === t4.id && this.fire(new e3.a(new Error("The feature id parameter must be provided.")));
            const a4 = this.getOwnSourceCaches(o3);
            for (const e4 of a4) e4.setFeatureState(r4, t4.id, i4);
          }
          removeFeatureState(t4, i4) {
            this._checkLoaded();
            const o3 = t4.source, r4 = this._checkSource(o3);
            if (!r4) return;
            const s4 = r4.type, n3 = "vector" === s4 ? t4.sourceLayer : void 0;
            if ("vector" === s4 && !n3) return void this.fire(new e3.a(new Error("The sourceLayer parameter must be provided for vector source types.")));
            if (i4 && "string" != typeof t4.id && "number" != typeof t4.id) return void this.fire(new e3.a(new Error("A feature id is required to remove its specific state property.")));
            const a4 = this.getOwnSourceCaches(o3);
            for (const e4 of a4) e4.removeFeatureState(n3, t4.id, i4);
          }
          getFeatureState(t4) {
            this._checkLoaded();
            const i4 = t4.source, o3 = t4.sourceLayer, r4 = this._checkSource(i4);
            if (r4) {
              if ("vector" !== r4.type || o3) return void 0 === t4.id && this.fire(new e3.a(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i4)[0].getFeatureState(o3, t4.id);
              this.fire(new e3.a(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
          }
          setTransition(t4) {
            return this.stylesheet.transition = e3.e({}, this.stylesheet.transition, t4), this.transition = this.stylesheet.transition, this;
          }
          getTransition() {
            return e3.e({}, this.stylesheet.transition);
          }
          serialize() {
            this._checkLoaded();
            const t4 = this.getTerrain(), i4 = t4 && this.terrain && this.terrain.scope === this.scope ? t4 : this.stylesheet.terrain;
            return e3.cc({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: i4, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (e4) => void 0 !== e4);
          }
          _updateLayer(t4) {
            this._changes.updateLayer(t4);
            const i4 = this.getLayerSourceCache(t4), o3 = e3.aj(t4.source, t4.scope), r4 = this._changes.getUpdatedSourceCaches();
            t4.source && !r4[o3] && i4 && "raster" !== i4.getSource().type && (this._changes.updateSourceCache(o3, "reload"), i4.pause()), t4.invalidateCompiledFilter();
          }
          _flattenAndSortRenderedFeatures(e4) {
            const t4 = (e5) => "fill-extrusion" === this._mergedLayers[e5].type || "model" === this._mergedLayers[e5].type, i4 = this.order, o3 = {}, r4 = [];
            for (let s5 = i4.length - 1; s5 >= 0; s5--) {
              const n3 = i4[s5];
              if (t4(n3)) {
                o3[n3] = s5;
                for (const t5 of e4) {
                  const e5 = t5[n3];
                  if (e5) for (const t6 of e5) r4.push(t6);
                }
              }
            }
            r4.sort((e5, t5) => t5.intersectionZ - e5.intersectionZ);
            const s4 = [];
            for (let n3 = i4.length - 1; n3 >= 0; n3--) {
              const a4 = i4[n3];
              if (t4(a4)) for (let e5 = r4.length - 1; e5 >= 0; e5--) {
                const t5 = r4[e5].feature;
                if (o3[t5.layer.id] < n3) break;
                s4.push(t5), r4.pop();
              }
              else for (const t5 of e4) {
                const e5 = t5[a4];
                if (e5) for (const t6 of e5) s4.push(t6.feature);
              }
            }
            return s4;
          }
          queryRenderedFeatures(t4, i4, o3) {
            i4 && i4.filter && this._validate(te, "queryRenderedFeatures.filter", i4.filter, null, i4), i4.scope = this.scope, i4.availableImages = this._availableImages, i4.serializedLayers = this._serializedLayers;
            const r4 = {};
            if (i4 && i4.layers) {
              if (!Array.isArray(i4.layers)) return this.fire(new e3.a(new Error("parameters.layers must be an Array."))), [];
              for (const t5 of i4.layers) {
                const i5 = this._mergedLayers[t5];
                if (!i5) return this.fire(new e3.a(new Error(`The layer '${t5}' does not exist in the map's style and cannot be queried for features.`))), [];
                r4[i5.source] = true;
              }
            }
            const s4 = [], n3 = i4.serializedLayers || {}, a4 = i4 && i4.layers ? i4.layers.some((e4) => {
              const t5 = this.getLayer(e4);
              return t5 && t5.is3D();
            }) : this.has3DLayers(), l4 = Te.createFromScreenPoints(t4, o3);
            for (const e4 in this._mergedSourceCaches) {
              const t5 = this._mergedSourceCaches[e4].getSource();
              if (!t5 || t5.scope !== i4.scope) continue;
              const c4 = this._mergedSourceCaches[e4].getSource().id;
              i4.layers && !r4[c4] || s4.push(Vt(this._mergedSourceCaches[e4], this._mergedLayers, n3, l4, i4, o3, a4, !!this.map._showQueryGeometry));
            }
            return this.placement && s4.push(function(e4, t5, i5, o4, r5, s5, n4) {
              const a5 = {}, l5 = s5.queryRenderedSymbols(o4), c4 = [];
              for (const e5 of Object.keys(l5).map(Number)) c4.push(n4[e5]);
              c4.sort(Wt);
              for (const i6 of c4) {
                const o5 = i6.featureIndex.lookupSymbolFeatures(l5[i6.bucketInstanceId], t5, i6.bucketIndex, i6.sourceLayerIndex, r5.filter, r5.layers, r5.availableImages, e4);
                for (const e5 in o5) {
                  const t6 = a5[e5] = a5[e5] || [], r6 = o5[e5];
                  r6.sort((e6, t7) => {
                    const o6 = i6.featureSortOrder;
                    if (o6) {
                      const i7 = o6.indexOf(e6.featureIndex);
                      return o6.indexOf(t7.featureIndex) - i7;
                    }
                    return t7.featureIndex - e6.featureIndex;
                  });
                  for (const e6 of r6) t6.push(e6);
                }
              }
              for (const t6 in a5) a5[t6].forEach((o5) => {
                const r6 = o5.feature, s6 = i5(e4[t6]);
                if (!s6) return;
                const n5 = s6.getFeatureState(r6.layer["source-layer"], r6.id);
                r6.source = r6.layer.source, r6.layer["source-layer"] && (r6.sourceLayer = r6.layer["source-layer"]), r6.state = n5;
              });
              return a5;
            }(this._mergedLayers, n3, this.getLayerSourceCache.bind(this), l4.screenGeometry, i4, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(s4);
          }
          querySourceFeatures(e4, t4) {
            t4 && t4.filter && this._validate(te, "querySourceFeatures.filter", t4.filter, null, t4);
            const i4 = this.getOwnSourceCaches(e4);
            let o3 = [];
            for (const e5 of i4) o3 = o3.concat(Zt(e5, t4));
            return o3;
          }
          addSourceType(e4, t4, i4) {
            return Ao.getSourceType(e4) ? i4(new Error(`A source type called "${e4}" already exists.`)) : (Ao.setSourceType(e4, t4), t4.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e4, url: t4.workerSourceURL }, i4) : i4(null, null));
          }
          getFlatLight() {
            return this.light.getLight();
          }
          setFlatLight(e4, i4, o3 = {}) {
            this._checkLoaded();
            const r4 = this.light.getLight();
            let s4 = false;
            for (const i5 in e4) if (!t3(e4[i5], r4[i5])) {
              s4 = true;
              break;
            }
            if (!s4) return;
            const n3 = this._getTransitionParameters();
            this.light.setLight(e4, i4, o3), this.light.updateTransitions(n3);
          }
          getTerrain() {
            return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
          }
          setTerrainForDraping() {
            this.setTerrain({ source: "", exaggeration: 0 }, 0);
          }
          setTerrain(i4, o3 = 1) {
            if (this._checkLoaded(), !i4) return this.terrainSetForDrapingOnly() && 0 !== o3 || delete this.terrain, null === i4 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
            let r4 = i4;
            const s4 = null == i4.source;
            if (1 === o3) {
              if ("object" == typeof r4.source) {
                const t5 = "terrain-dem-src";
                this.addSource(t5, r4.source), r4 = e3.c6(r4), r4 = e3.e(r4, { source: t5 });
              }
              const t4 = e3.e({}, r4), i5 = {};
              if (this.terrain && s4) {
                t4.source = this.terrain.get().source;
                const e4 = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                e4 && (i5.style = e4.serialize());
              }
              if (this._validate(J2, "terrain", t4, i5)) return;
            }
            if (!this.terrain || this.terrain.scope !== this.scope && !s4 || this.terrain && o3 !== this.terrain.drapeRenderMode) {
              if (!r4) return;
              this._createTerrain(r4, o3), this.fire(new e3.b("data", { dataType: "style" }));
            } else {
              const o4 = this.terrain, s5 = o4.get();
              for (const t4 of Object.keys(e3.G.terrain)) !r4.hasOwnProperty(t4) && e3.G.terrain[t4].default && (r4[t4] = e3.G.terrain[t4].default);
              for (const r5 in i4) if (!t3(i4[r5], s5[r5])) {
                o4.set(i4, this.options), this.stylesheet.terrain = i4;
                const t4 = this._getTransitionParameters({ duration: 0 });
                o4.updateTransitions(t4), this.fire(new e3.b("data", { dataType: "style" }));
                break;
              }
            }
            this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = true;
          }
          _createFog(e4) {
            const t4 = this.fog = new xe(e4, this.map.transform, this.scope, this.options);
            this.stylesheet.fog = t4.get();
            const i4 = this._getTransitionParameters({ duration: 0 });
            t4.updateTransitions(i4);
          }
          _updateMarkersOpacity() {
            0 !== this.map._markers.length && this.map._requestDomTask(() => {
              for (const e4 of this.map._markers) e4._evaluateOpacity();
            });
          }
          getFog() {
            return this.fog ? this.fog.get() : null;
          }
          setFog(e4) {
            if (this._checkLoaded(), !e4) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
            if (this.fog) {
              const i4 = this.fog;
              if (!t3(i4.get(), e4)) {
                i4.set(e4, this.options), this.stylesheet.fog = i4.get();
                const t4 = this._getTransitionParameters({ duration: 0 });
                i4.updateTransitions(t4);
              }
            } else this._createFog(e4);
            this._markersNeedUpdate = true;
          }
          _getTransitionParameters(t4) {
            return { now: e3.f.now(), transition: e3.e(this.transition, t4) };
          }
          updateDrapeFirstLayers() {
            if (!this.terrain) return;
            const e4 = [], t4 = [];
            for (const i4 in this._mergedLayers) this.isLayerDraped(this._mergedLayers[i4]) ? e4.push(i4) : t4.push(i4);
            this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e4), this._drapedFirstOrder.push(...t4);
          }
          _createTerrain(e4, t4) {
            const i4 = this.terrain = new he(e4, t4, this.scope, this.options);
            1 === t4 && (this.stylesheet.terrain = e4), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
            const o3 = this._getTransitionParameters({ duration: 0 });
            i4.updateTransitions(o3);
          }
          _force3DLayerUpdate() {
            for (const e4 in this._layers) {
              const t4 = this._layers[e4];
              "fill-extrusion" === t4.type && this._updateLayer(t4);
            }
          }
          _forceSymbolLayerUpdate() {
            for (const e4 in this._layers) {
              const t4 = this._layers[e4];
              "symbol" === t4.type && this._updateLayer(t4);
            }
          }
          _validate(t4, i4, o3, r4, s4 = {}) {
            if (s4 && false === s4.validate) return false;
            const n3 = e3.e({}, this.serialize());
            return So(this, t4.call(Q2, e3.e({ key: i4, style: n3, value: o3, styleSpec: e3.G }, r4)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e3.cd.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const e4 in this._mergedLayers) this._mergedLayers[e4].setEventedParent(null);
            for (const e4 in this._mergedSourceCaches) this._mergedSourceCaches[e4].clearTiles(), this._mergedSourceCaches[e4].setEventedParent(null);
            this.setEventedParent(null), delete this.fog, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
          }
          clearSource(e4) {
            const t4 = this.getSourceCaches(e4);
            for (const e5 of t4) e5.clearTiles();
          }
          clearSources() {
            for (const e4 in this._mergedSourceCaches) this._mergedSourceCaches[e4].clearTiles();
          }
          reloadSource(e4) {
            const t4 = this.getSourceCaches(e4);
            for (const e5 of t4) e5.resume(), e5.reload();
          }
          reloadSources() {
            for (const e4 of this.getSources()) e4.reload && e4.reload();
          }
          updateSources(e4) {
            let t4;
            this.directionalLight && (t4 = wo(this.directionalLight));
            for (const i4 in this._mergedSourceCaches) this._mergedSourceCaches[i4].update(e4, void 0, void 0, t4);
          }
          _generateCollisionBoxes() {
            for (const e4 in this._sourceCaches) {
              const t4 = this._sourceCaches[e4];
              t4.resume(), t4.reload();
            }
          }
          _updatePlacement(t4, i4, o3, r4, s4 = false) {
            let n3 = false, a4 = false;
            const l4 = {}, c4 = {};
            for (const i5 of this._mergedOrder) {
              const o4 = this._mergedLayers[i5];
              if ("symbol" !== o4.type) continue;
              const r5 = e3.aj(o4.source, o4.scope);
              let s5 = l4[r5];
              if (!s5) {
                const e4 = this.getLayerSourceCache(o4);
                if (!e4) continue;
                const t5 = e4.getRenderableIds(true).map((t6) => e4.getTileByID(t6));
                c4[r5] = t5.slice(), s5 = l4[r5] = t5.sort((e5, t6) => t6.tileID.overscaledZ - e5.tileID.overscaledZ || (e5.tileID.isLessThan(t6.tileID) ? -1 : 1));
              }
              const a5 = this.crossTileSymbolIndex.addLayer(o4, s5, t4.center.lng, t4.projection);
              n3 = n3 || a5;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), s4 = s4 || this._layerOrderChanged || 0 === o3, this._layerOrderChanged && this.fire(new e3.b("neworder")), (s4 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e3.f.now(), t4.zoom)) && (this.pauseablePlacement = new Ki(t4, this._mergedOrder, s4, i4, o3, r4, this.placement, this.fog && t4.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, l4, c4), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e3.f.now()), a4 = true), n3 && this.pauseablePlacement.placement.setStale()), a4 || n3) {
              this._buildingIndex.onNewFrame(t4.zoom);
              for (const t5 of this._mergedOrder) {
                const i5 = this._mergedLayers[t5];
                "symbol" === i5.type && this.placement.updateLayerOpacities(i5, l4[e3.aj(i5.source, i5.scope)]);
              }
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e3.f.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e4 in this._sourceCaches) this._sourceCaches[e4].releaseSymbolFadeTiles();
          }
          addImport(t4, i4) {
            this._checkLoaded();
            const o3 = this.stylesheet.imports = this.stylesheet.imports || [];
            if (-1 !== o3.findIndex(({ id: e4 }) => e4 === t4.id)) return void this.fire(new e3.a(new Error(`Import with id '${t4.id}' already exists in the map's style.`)));
            if (!i4) return o3.push(t4), this._loadImports([t4], true);
            const r4 = o3.findIndex(({ id: e4 }) => e4 === i4);
            return -1 === r4 && this.fire(new e3.a(new Error(`Import with id "${i4}" does not exist on this map.`))), this.stylesheet.imports = o3.slice(0, r4).concat(t4).concat(o3.slice(r4)), this._loadImports([t4], true, i4);
          }
          updateImport(e4, i4) {
            this._checkLoaded();
            const o3 = this.stylesheet.imports || [], r4 = this.getImportIndex(e4);
            return -1 === r4 ? this : "string" == typeof i4 ? (this.setImportUrl(e4, i4), this) : (i4.url && i4.url !== o3[r4].url && this.setImportUrl(e4, i4.url), t3(i4.config, o3[r4].config) || this.setImportConfig(e4, i4.config), t3(i4.data, o3[r4].data) || this.setImportData(e4, i4.data), this);
          }
          moveImport(e4, t4) {
            this._checkLoaded();
            let i4 = this.stylesheet.imports || [];
            const o3 = this.getImportIndex(e4);
            if (-1 === o3) return this;
            const r4 = this.getImportIndex(t4);
            if (-1 === r4) return this;
            const s4 = i4[o3], n3 = this.fragments[o3];
            return i4 = i4.filter(({ id: t5 }) => t5 !== e4), this.fragments = this.fragments.filter(({ id: t5 }) => t5 !== e4), this.stylesheet.imports = i4.slice(0, r4).concat(s4).concat(i4.slice(r4)), this.fragments = this.fragments.slice(0, r4).concat(n3).concat(this.fragments.slice(r4)), this.mergeLayers(), this;
          }
          setImportUrl(e4, t4) {
            this._checkLoaded();
            const i4 = this.stylesheet.imports || [], o3 = this.getImportIndex(e4);
            if (-1 === o3) return this;
            i4[o3].url = t4;
            const r4 = this.fragments[o3];
            return r4.style = this._createFragmentStyle(i4[o3]), r4.style.on("style.import.load", () => this.mergeAll()), r4.style.loadURL(t4), this;
          }
          setImportData(e4, t4) {
            this._checkLoaded();
            const i4 = this.getImportIndex(e4), o3 = this.stylesheet.imports || [];
            return -1 === i4 ? this : t4 ? (this.fragments[i4].style.setState(t4), this._reloadImports(), this) : (delete o3[i4].data, this.setImportUrl(e4, o3[i4].url));
          }
          setImportConfig(e4, t4) {
            this._checkLoaded();
            const i4 = this.getImportIndex(e4), o3 = this.stylesheet.imports || [];
            if (-1 === i4) return this;
            t4 ? o3[i4].config = t4 : delete o3[i4].config;
            const r4 = this.fragments[i4], s4 = r4.style.stylesheet && r4.style.stylesheet.schema;
            return r4.config = t4, r4.style.updateConfig(t4, s4), this.updateConfigDependencies(), this;
          }
          removeImport(e4) {
            this._checkLoaded();
            const t4 = this.stylesheet.imports || [], i4 = this.getImportIndex(e4);
            -1 !== i4 && (t4.splice(i4, 1), this.fragments[i4].style._remove(), this.fragments.splice(i4, 1), this._reloadImports());
          }
          getImportIndex(t4) {
            const i4 = (this.stylesheet.imports || []).findIndex((e4) => e4.id === t4);
            return -1 === i4 && this.fire(new e3.a(new Error(`Import '${t4}' does not exist in the map's style and cannot be updated.`))), i4;
          }
          getLayer(e4) {
            return this._mergedLayers[e4];
          }
          getSources() {
            const e4 = [];
            for (const t4 in this._mergedOtherSourceCaches) {
              const i4 = this._mergedOtherSourceCaches[t4];
              i4 && e4.push(i4.getSource());
            }
            return e4;
          }
          getSource(e4, t4) {
            const i4 = this.getSourceCache(e4, t4);
            return i4 && i4.getSource();
          }
          getLayerSource(e4) {
            const t4 = this.getLayerSourceCache(e4);
            return t4 && t4.getSource();
          }
          getSourceCache(t4, i4) {
            const o3 = e3.aj(t4, i4);
            return this._mergedOtherSourceCaches[o3];
          }
          getLayerSourceCache(t4) {
            const i4 = e3.aj(t4.source, t4.scope);
            return "symbol" === t4.type ? this._mergedSymbolSourceCaches[i4] : this._mergedOtherSourceCaches[i4];
          }
          getSourceCaches(e4) {
            if (null == e4) return Object.values(this._mergedSourceCaches);
            const t4 = [];
            return this._mergedOtherSourceCaches[e4] && t4.push(this._mergedOtherSourceCaches[e4]), this._mergedSymbolSourceCaches[e4] && t4.push(this._mergedSymbolSourceCaches[e4]), t4;
          }
          updateSourceCaches() {
            const e4 = this._changes.getUpdatedSourceCaches();
            for (const t4 in e4) {
              const i4 = e4[t4];
              "reload" === i4 ? this.reloadSource(t4) : "clear" === i4 && this.clearSource(t4);
            }
          }
          updateLayers(e4) {
            const t4 = this._changes.getUpdatedPaintProperties();
            for (const i4 of t4) {
              const t5 = this.getLayer(i4);
              t5 && t5.updateTransitions(e4);
            }
          }
          getImages(e4, t4, i4) {
            this.imageManager.getImages(t4.icons, t4.scope, i4), this._updateTilesForChangedImages();
            const o3 = (e5) => {
              e5 && e5.setDependencies(t4.tileID.key, t4.type, t4.icons);
            };
            o3(this._otherSourceCaches[t4.source]), o3(this._symbolSourceCaches[t4.source]);
          }
          getGlyphs(e4, t4, i4) {
            this.glyphManager.getGlyphs(t4.stacks, t4.scope, i4);
          }
          getResource(t4, i4, o3) {
            return e3.ce(i4, o3);
          }
          getOwnSourceCache(e4) {
            return this._otherSourceCaches[e4];
          }
          getOwnLayerSourceCache(e4) {
            return "symbol" === e4.type ? this._symbolSourceCaches[e4.source] : this._otherSourceCaches[e4.source];
          }
          getOwnSourceCaches(e4) {
            const t4 = [];
            return this._otherSourceCaches[e4] && t4.push(this._otherSourceCaches[e4]), this._symbolSourceCaches[e4] && t4.push(this._symbolSourceCaches[e4]), t4;
          }
          _isSourceCacheLoaded(t4) {
            const i4 = this.getOwnSourceCaches(t4);
            return 0 === i4.length ? (this.fire(new e3.a(new Error(`There is no source with ID '${t4}'`))), false) : i4.every((e4) => e4.loaded());
          }
          has3DLayers() {
            return this._has3DLayers;
          }
          hasSymbolLayers() {
            return this._hasSymbolLayers;
          }
          hasCircleLayers() {
            return this._hasCircleLayers;
          }
          _clearWorkerCaches() {
            this.dispatcher.broadcast("clearCaches");
          }
          destroy() {
            this._clearWorkerCaches(), this.fragments.forEach((e4) => {
              e4.style._remove();
            }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
          }
        }
        Ao.getSourceType = function(e4) {
          return Ut[e4];
        }, Ao.setSourceType = function(e4, t4) {
          Ut[e4] = t4;
        }, Ao.registerForPluginStateChange = e3.bY;
        var Po = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", Lo = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color) {\n#ifdef INDICATOR_CUTOUT\nfloat holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,vec2 pos,vec2 lod_coord) {vec2 size=vec2(textureSize(image,0));vec2 dx=dFdx(lod_coord.xy*size);vec2 dy=dFdy(lod_coord.xy*size);float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}", Mo = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}", zo = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", Oo = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture(u_depth,uv-df.xz)),unpack_depth(texture(u_depth,uv+df.xz)),unpack_depth(texture(u_depth,uv-df.zy)),unpack_depth(texture(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", Fo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", Bo = "highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", ko = "#ifdef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", No = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec4 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=vec2(u_data_offset+dot(t.rg,u_data_scale.yx),-(u_data_offset+dot(t.ba,u_data_scale.yx)));velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", Uo = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", Go = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef NATIVE\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
        const jo = [];
        Qo(Po, jo), Qo(Mo, jo), Qo(Lo, jo);
        const Vo = { "_prelude_fog.vertex.glsl": Fo, "_prelude_terrain.vertex.glsl": Oo, "_prelude_shadow.vertex.glsl": Uo, "_prelude_fog.fragment.glsl": Bo, "_prelude_shadow.fragment.glsl": Go, "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE", "_prelude_raster_array.glsl": ko, "_prelude_raster_particle.glsl": No }, Zo = {};
        $o("", Oo), $o(Bo, Fo), $o(Go, Uo), $o(ko, ""), $o(No, "");
        const Wo = $o(Lo, Mo), Ho = Po;
        var qo = { background: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), backgroundPattern: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), circle: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'), clippingMask: $o("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: $o('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), heatmapTexture: $o("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: $o("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in float a_size_scale;in vec2 a_padding;in float a_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(a_z_offset+elevation(a_anchor_pos)),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'), collisionCircle: $o("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: $o("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'), fill: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutline: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutlinePattern: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;in highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillPattern: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;in vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillExtrusion: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nuniform float u_emissive_strength;in float v_height;void main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,u_emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=max(0.01,cutoff_opacity(u_cutoff_params,ground.z));if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff < 0.01 && centroid_pos.x !=0.0));gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);v_flat=vec4(linearProduct(color.rgb,vec3(calculate_NdotL(normal))),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), fillExtrusionDepth: $o("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_vertical_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'), fillExtrusionPattern: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nout vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'), groundShadow: $o('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'), fillExtrusionGroundEffect: $o("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(1.0,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), hillshadePrepare: $o("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), line: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {    \nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trimmed,out_color.rgb,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), linePattern: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform mediump float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 v_uv;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float pattern_x=v_linesofar/pattern_size.x*aspect;float x=mod(pattern_x,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {color=vec4(0,0,0,0);}}\n#endif\n#ifdef LINE_JOIN_NONE\nfloat pattern_len=pattern_size.x/aspect;float segment_phase=pattern_len-mod((v_linesofar-v_pattern_data.x),pattern_len);float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_ground(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 a_packed;\n#endif\nin float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin vec2 a_pattern_data;out vec2 v_pattern_data;\n#endif\nuniform mat4 u_matrix;uniform mediump float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec4 v_uv;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nfloat a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef LINE_JOIN_NONE\nv_width+=ANTIALIASING;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5/u_tile_units_to_pixels;v_linesofar+=line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), raster: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'), rasterParticle: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'), rasterParticleDraw: $o("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-vec2(1.0),0.0,1.0);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'), rasterParticleTexture: $o("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: $o('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp float speed=velocity==INVALID_VELOCITY ? 0.0 : length(velocity);highp float reset_rate_bump=speed*u_reset_rate;highp vec2 particle_pos_min=-u_particle_pos_offset;highp vec2 particle_pos_max=vec2(1.0)+u_particle_pos_offset;highp vec2 pos_drop_rate=vec2(1.0)-step(particle_pos_min,pos)+step(particle_pos_max,pos);highp float drop_rate=max(u_reset_rate+reset_rate_bump,length(pos_drop_rate));highp float drop=step(1.0-drop_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbolIcon: $o('#include "_prelude_lighting.glsl"\nuniform sampler2D u_texture;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\nin float v_fade_opacity;in vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nlowp float alpha=opacity*v_fade_opacity;vec4 out_color;\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\nout_color*=alpha;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nv_tex_a=a_tex/u_texsize;\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\nv_fade_opacity=out_fade_opacity;}'), symbolSDF: $o('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\nuniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;in float v_draw_halo;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,out_fade_opacity);}'), symbolTextAndIcon: $o('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_halo;in float v_draw_halo;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nfloat out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,out_fade_opacity,is_sdf);}'), terrainRaster: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'), terrainDepth: $o("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'), skybox: $o('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', zo), skyboxGradient: $o('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', zo), skyboxCapture: $o("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'), globeAtmosphere: $o('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\nglFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"), model: $o('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform sampler2D u_depthTexture;uniform vec2 u_inv_depth_size;bool isOccluded() {vec2 coord=gl_FragCoord.xy*u_inv_depth_size;highp float depth=unpack_depth(texture(u_depthTexture,coord));return v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nreturn vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);color=mix(color,v_color_mix.rgb,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=u_matrix*pos;pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normalize(normal_3f));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'), modelDepth: $o("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=u_matrix*pos;\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"), stars: $o("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}") };
        function Qo(e4, t4) {
          const i4 = e4.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
          for (let e5 of i4) if (e5 = e5.trim(), "#" === e5[0] && e5.includes("if") && !e5.includes("endif")) {
            e5 = e5.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const i5 = e5.split(" ");
            for (const e6 of i5) t4.includes(e6) || t4.push(e6);
          }
        }
        function $o(e4, t4) {
          const i4 = /#include\s+"([^"]+)"/g, o3 = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
          let r4 = t4.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
          r4 && (r4 = r4.map((e5) => {
            const t5 = e5.split(" ");
            return t5[t5.length - 1];
          }), r4 = [...new Set(r4)]);
          const s4 = {}, n3 = [], a4 = [];
          if (e4 = e4.replace(i4, (e5, t5) => (a4.push(t5), "")), (t4 = t4.replace(i4, (e5, t5) => (n3.push(t5), ""))).includes("flat out")) return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
          let l4 = [...jo];
          Qo(e4, l4), Qo(t4, l4);
          for (const e5 of [...n3, ...a4]) Vo[e5] || console.error(`Undefined include: ${e5}`), Zo[e5] || (Zo[e5] = [], Qo(Vo[e5], Zo[e5])), l4 = [...l4, ...Zo[e5]];
          return { fragmentSource: e4 = e4.replace(o3, (e5, t5, i5, o4, r5) => (s4[r5] = true, "define" === t5 ? `
#ifndef HAS_UNIFORM_u_${r5}
in ${i5} ${o4} ${r5};
#else
uniform ${i5} ${o4} u_${r5};
#endif
` : "initialize" === t5 ? `
#ifdef HAS_UNIFORM_u_${r5}
    ${i5} ${o4} ${r5} = u_${r5};
#endif
` : "define-attribute" === t5 ? `
#ifdef HAS_ATTRIBUTE_a_${r5}
    in ${i5} ${o4} ${r5};
#endif
` : "initialize-attribute" === t5 ? "" : void 0)), vertexSource: t4 = t4.replace(o3, (e5, t5, i5, o4, r5) => {
            const n4 = "float" === o4 ? "vec2" : o4, a5 = r5.match(/color/) ? "color" : n4;
            return "define-attribute-vertex-shader-only" === t5 ? `
#ifdef HAS_ATTRIBUTE_a_${r5}
in ${i5} ${o4} a_${r5};
#endif
` : s4[r5] ? "define" === t5 ? `
#ifndef HAS_UNIFORM_u_${r5}
uniform lowp float u_${r5}_t;
in ${i5} ${n4} a_${r5};
out ${i5} ${o4} ${r5};
#else
uniform ${i5} ${o4} u_${r5};
#endif
` : "initialize" === t5 ? "vec4" === a5 ? `
#ifndef HAS_UNIFORM_u_${r5}
    ${r5} = a_${r5};
#else
    ${i5} ${o4} ${r5} = u_${r5};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r5}
    ${r5} = unpack_mix_${a5}(a_${r5}, u_${r5}_t);
#else
    ${i5} ${o4} ${r5} = u_${r5};
#endif
` : "define-attribute" === t5 ? `
#ifdef HAS_ATTRIBUTE_a_${r5}
    in ${i5} ${o4} a_${r5};
    out ${i5} ${o4} ${r5};
#endif
` : "initialize-attribute" === t5 ? `
#ifdef HAS_ATTRIBUTE_a_${r5}
    ${r5} = a_${r5};
#endif
` : void 0 : "define" === t5 ? `
#ifndef HAS_UNIFORM_u_${r5}
uniform lowp float u_${r5}_t;
in ${i5} ${n4} a_${r5};
#else
uniform ${i5} ${o4} u_${r5};
#endif
` : "define-instanced" === t5 ? "mat4" === a5 ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${r5}0;
in vec4 a_${r5}1;
in vec4 a_${r5}2;
in vec4 a_${r5}3;
#else
uniform ${i5} ${o4} u_${r5};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${i5} ${n4} a_${r5};
#else
uniform ${i5} ${o4} u_${r5};
#endif
` : "initialize-attribute-custom" === t5 ? `
#ifdef HAS_ATTRIBUTE_a_${r5}
    ${i5} ${o4} ${r5} = a_${r5};
#endif
` : "vec4" === a5 ? `
#ifndef HAS_UNIFORM_u_${r5}
    ${i5} ${o4} ${r5} = a_${r5};
#else
    ${i5} ${o4} ${r5} = u_${r5};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r5}
    ${i5} ${o4} ${r5} = unpack_mix_${a5}(a_${r5}, u_${r5}_t);
#else
    ${i5} ${o4} ${r5} = u_${r5};
#endif
`;
          }), staticAttributes: r4, usedDefines: l4, vertexIncludes: n3, fragmentIncludes: a4 };
        }
        class Xo {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
          }
          bind(e4, t4, i4, o3, r4, s4, n3, a4) {
            this.context = e4;
            let l4 = this.boundPaintVertexBuffers.length !== o3.length;
            for (let e5 = 0; !l4 && e5 < o3.length; e5++) this.boundPaintVertexBuffers[e5] !== o3[e5] && (l4 = true);
            let c4 = this.boundDynamicVertexBuffers.length !== n3.length;
            for (let e5 = 0; !c4 && e5 < n3.length; e5++) this.boundDynamicVertexBuffers[e5] !== n3[e5] && (c4 = true);
            if (!this.vao || this.boundProgram !== t4 || this.boundLayoutVertexBuffer !== i4 || l4 || c4 || this.boundIndexBuffer !== r4 || this.boundVertexOffset !== s4) this.freshBind(t4, i4, o3, r4, s4, n3, a4);
            else {
              e4.bindVertexArrayOES.set(this.vao);
              for (const i5 of n3) i5 && (i5.bind(), a4 && i5.instanceCount && i5.setVertexAttribDivisor(e4.gl, t4, a4));
              r4 && r4.dynamicDraw && r4.bind();
            }
          }
          freshBind(e4, t4, i4, o3, r4, s4, n3) {
            const a4 = e4.numAttributes, l4 = this.context, c4 = l4.gl;
            this.vao && this.destroy(), this.vao = l4.gl.createVertexArray(), l4.bindVertexArrayOES.set(this.vao), this.boundProgram = e4, this.boundLayoutVertexBuffer = t4, this.boundPaintVertexBuffers = i4, this.boundIndexBuffer = o3, this.boundVertexOffset = r4, this.boundDynamicVertexBuffers = s4, t4.enableAttributes(c4, e4), t4.bind(), t4.setVertexAttribPointers(c4, e4, r4);
            for (const t5 of i4) t5.enableAttributes(c4, e4), t5.bind(), t5.setVertexAttribPointers(c4, e4, r4);
            for (const t5 of s4) t5 && (t5.enableAttributes(c4, e4), t5.bind(), t5.setVertexAttribPointers(c4, e4, r4), n3 && t5.instanceCount && t5.setVertexAttribDivisor(c4, e4, n3));
            o3 && o3.bind(), l4.currentNumAttributes = a4;
          }
          destroy() {
            this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        function Yo(t4, i4) {
          const o3 = Math.pow(2, i4.canonical.z), r4 = i4.canonical.y;
          return [new e3.O(0, r4 / o3).toLngLat().lat, new e3.O(0, (r4 + 1) / o3).toLngLat().lat];
        }
        function Jo(t4, i4, o3, r4, s4, n3, a4) {
          const l4 = t4.context, c4 = l4.gl, h4 = o3.hillshadeFBO;
          if (!h4) return;
          t4.prepareDrawTile();
          const u5 = t4.isTileAffectedByFog(i4), d3 = t4.getOrCreateProgram("hillshade", { overrideFog: u5 });
          l4.activeTexture.set(c4.TEXTURE0), c4.bindTexture(c4.TEXTURE_2D, h4.colorAttachment.get());
          const _4 = ((t5, i5, o4, r5) => {
            const s5 = o4.paint.get("hillshade-shadow-color"), n4 = o4.paint.get("hillshade-highlight-color"), a5 = o4.paint.get("hillshade-accent-color"), l5 = o4.paint.get("hillshade-emissive-strength");
            let c5 = e3.bm(o4.paint.get("hillshade-illumination-direction"));
            if ("viewport" === o4.paint.get("hillshade-illumination-anchor")) c5 -= t5.transform.angle;
            else if (t5.style && t5.style.enable3dLights() && t5.style.directionalLight) {
              const i6 = t5.style.directionalLight.properties.get("direction"), o5 = e3.bT(i6.x, i6.y, i6.z);
              c5 = e3.bm(o5[1]);
            }
            const h5 = !t5.options.moving;
            return { u_matrix: r5 || t5.transform.calculateProjMatrix(i5.tileID.toUnwrapped(), h5), u_image: 0, u_latrange: Yo(0, i5.tileID), u_light: [o4.paint.get("hillshade-exaggeration"), c5], u_shadow: s5, u_highlight: n4, u_emissive_strength: l5, u_accent: a5 };
          })(t4, o3, r4, t4.terrain ? i4.projMatrix : null);
          t4.uploadCommonUniforms(l4, d3, i4.toUnwrapped());
          const { tileBoundsBuffer: p4, tileBoundsIndexBuffer: f4, tileBoundsSegments: m4 } = t4.getTileBoundsBuffers(o3);
          d3.draw(t4, c4.TRIANGLES, s4, n3, a4, Mt.disabled, _4, r4.id, p4, f4, m4);
        }
        function Ko(t4, i4, o3) {
          if (!i4.needsDEMTextureUpload) return;
          const r4 = t4.context, s4 = r4.gl;
          r4.pixelStoreUnpackPremultiplyAlpha.set(false), i4.demTexture = i4.demTexture || t4.getTileTexture(o3.stride);
          const n3 = o3.getPixels();
          i4.demTexture ? i4.demTexture.update(n3, { premultiply: false }) : i4.demTexture = new e3.T(r4, n3, s4.R32F, { premultiply: false }), i4.needsDEMTextureUpload = false;
        }
        function er(t4, i4, o3) {
          const r4 = t4.context, s4 = r4.gl;
          if (!i4.dem) return;
          const n3 = i4.dem;
          if (r4.activeTexture.set(s4.TEXTURE1), Ko(t4, i4, n3), !i4.demTexture) return;
          i4.demTexture.bind(s4.NEAREST, s4.CLAMP_TO_EDGE);
          const a4 = n3.dim;
          r4.activeTexture.set(s4.TEXTURE0);
          let l4 = i4.hillshadeFBO;
          if (!l4) {
            const t5 = new e3.T(r4, { width: a4, height: a4, data: null }, s4.RGBA);
            t5.bind(s4.LINEAR, s4.CLAMP_TO_EDGE), l4 = i4.hillshadeFBO = r4.createFramebuffer(a4, a4, true, "renderbuffer"), l4.colorAttachment.set(t5.texture);
          }
          r4.bindFramebuffer.set(l4.framebuffer), r4.viewport.set([0, 0, a4, a4]);
          const { tileBoundsBuffer: c4, tileBoundsIndexBuffer: h4, tileBoundsSegments: u5 } = t4.getMercatorTileBoundsBuffers(), d3 = [];
          t4.linearFloatFilteringSupported() && d3.push("TERRAIN_DEM_FLOAT_FORMAT"), t4.getOrCreateProgram("hillshadePrepare", { defines: d3 }).draw(t4, s4.TRIANGLES, Ct.disabled, Dt.disabled, At.unblended, Mt.disabled, ((t5, i5) => {
            const o4 = i5.stride, r5 = e3.a9.create();
            return e3.a9.ortho(r5, 0, e3.Y, -e3.Y, 0, 0, 1), e3.a9.translate(r5, r5, [0, -e3.Y, 0]), { u_matrix: r5, u_image: 1, u_dimension: [o4, o4], u_zoom: t5.overscaledZ };
          })(i4.tileID, n3), o3.id, c4, h4, u5), i4.needsHillshadePrepare = false;
        }
        const tr = (t4) => ({ u_matrix: new e3.bN(t4), u_image0: new e3.bR(t4), u_skirt_height: new e3.bQ(t4), u_ground_shadow_factor: new e3.bP(t4) }), ir = (e4, t4, i4) => ({ u_matrix: e4, u_image0: 0, u_skirt_height: t4, u_ground_shadow_factor: i4 }), or = (e4, t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4) => ({ u_proj_matrix: Float32Array.from(e4), u_globe_matrix: t4, u_normalize_matrix: Float32Array.from(o3), u_merc_matrix: i4, u_zoom_transition: r4, u_merc_center: s4, u_image0: 0, u_frustum_tl: n3, u_frustum_tr: a4, u_frustum_br: l4, u_frustum_bl: c4, u_globe_pos: h4, u_globe_radius: u5, u_viewport: d3, u_grid_matrix: f4 ? Float32Array.from(f4) : new Float32Array(9), u_skirt_height: _4, u_far_z_cutoff: p4 });
        function rr(e4, t4) {
          return null != e4 && null != t4 && !(!e4.hasData() || !t4.hasData()) && null != e4.demTexture && null != t4.demTexture && e4.tileID.key !== t4.tileID.key;
        }
        const sr = new class {
          constructor() {
            this.operations = {};
          }
          newMorphing(e4, t4, i4, o3, r4) {
            if (e4 in this.operations) {
              const t5 = this.operations[e4];
              t5.to.tileID.key !== i4.tileID.key && (t5.queued = i4);
            } else this.operations[e4] = { startTime: o3, phase: 0, duration: r4, from: t4, to: i4, queued: null };
          }
          getMorphValuesForProxy(e4) {
            if (!(e4 in this.operations)) return null;
            const t4 = this.operations[e4];
            return { from: t4.from, to: t4.to, phase: t4.phase };
          }
          update(e4) {
            for (const t4 in this.operations) {
              const i4 = this.operations[t4];
              for (i4.phase = (e4 - i4.startTime) / i4.duration; i4.phase >= 1 || !this._validOp(i4); ) if (!this._nextOp(i4, e4)) {
                delete this.operations[t4];
                break;
              }
            }
          }
          _nextOp(e4, t4) {
            return !!e4.queued && (e4.from = e4.to, e4.to = e4.queued, e4.queued = null, e4.phase = 0, e4.startTime = t4, true);
          }
          _validOp(e4) {
            return e4.from.hasData() && e4.to.hasData();
          }
        }(), nr = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
        function ar(e4, t4, i4) {
          if (0 === t4) return 0;
          const o3 = t4 < 1 && 514 === i4 ? 0.25 / t4 : 1;
          return 6 * Math.pow(1.5, 22 - e4) * Math.max(t4, 1) * o3;
        }
        function lr(e4, t4) {
          const i4 = 1 << e4.z;
          return !t4 && (0 === e4.x || e4.x === i4 - 1) || 0 === e4.y || e4.y === i4 - 1;
        }
        const cr = (e4) => ({ u_matrix: e4 });
        function hr(t4, i4, o3, r4, s4) {
          if (s4 > 0) {
            const n3 = e3.f.now(), a4 = (n3 - t4.timeAdded) / s4, l4 = i4 ? (n3 - i4.timeAdded) / s4 : -1, c4 = o3.getSource(), h4 = r4.coveringZoomLevel({ tileSize: c4.tileSize, roundZoom: c4.roundZoom }), u5 = !i4 || Math.abs(i4.tileID.overscaledZ - h4) > Math.abs(t4.tileID.overscaledZ - h4), d3 = u5 && t4.refreshedUponExpiration ? 1 : e3.ad(u5 ? a4 : 1 - l4, 0, 1);
            return t4.refreshedUponExpiration && a4 >= 1 && (t4.refreshedUponExpiration = false), i4 ? { opacity: 1, mix: 1 - d3 } : { opacity: d3, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        class ur extends Qt {
          constructor(t4) {
            const i4 = { type: "raster-dem", maxzoom: t4.transform.maxZoom }, o3 = new e3.bZ(e3.b_(), null), r4 = Gt("mock-dem", i4, o3, t4.style);
            super("mock-dem", r4, false), r4.setEventedParent(this), this._sourceLoaded = true;
          }
          _loadTile(e4, t4) {
            e4.state = "loaded", t4(null);
          }
        }
        class dr extends Qt {
          constructor(t4) {
            const i4 = Gt("proxy", { type: "geojson", maxzoom: t4.transform.maxZoom }, new e3.bZ(e3.b_(), null), t4.style);
            super("proxy", i4, false), i4.setEventedParent(this), this.map = this.getSource().map = t4, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
          update(e4, t4, i4) {
            if (e4.freezeTileCoverage) return;
            this.transform = e4;
            const o3 = e4.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((t5, i5) => {
              if (t5[i5.key] = "", !this._tiles[i5.key]) {
                const t6 = new Nt(i5, this._source.tileSize * i5.overscaleFactor(), e4.tileZoom);
                t6.state = "loaded", this._tiles[i5.key] = t6;
              }
              return t5;
            }, {});
            for (const e5 in this._tiles) e5 in o3 || (this.freeFBO(e5), this._tiles[e5].unloadVectorData(), delete this._tiles[e5]);
          }
          freeFBO(e4) {
            const t4 = this.proxyCachedFBO[e4];
            if (void 0 !== t4) {
              const i4 = Object.values(t4);
              this.renderCachePool.push(...i4), delete this.proxyCachedFBO[e4];
            }
          }
          deallocRenderCache() {
            this.renderCache.forEach((e4) => e4.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
        }
        class _r extends e3.ap {
          constructor(e4, t4, i4) {
            super(e4.overscaledZ, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y), this.proxyTileKey = t4, this.projMatrix = i4;
          }
        }
        class pr extends e3.cp {
          constructor(t4, i4) {
            super(), this._debugParams = { sortTilesHiZFirst: true, disableRenderCache: false }, t4.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
              this._style.map.triggerRepaint();
            }), t4.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
              this._style.map.triggerRepaint();
            }), t4.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
              this.invalidateRenderCache = true, this._style.map.triggerRepaint();
            }), this.painter = t4, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
            const [o3, r4, s4] = function(t5) {
              const i5 = new e3.aQ(), o4 = new e3.az(), r5 = 131;
              i5.reserve(17161), o4.reserve(33800);
              const s5 = e3.Y / 128, n4 = e3.Y + s5 / 2, a5 = n4 + s5;
              for (let t6 = -s5; t6 < a5; t6 += s5) for (let o5 = -s5; o5 < a5; o5 += s5) {
                const r6 = o5 < 0 || o5 > n4 || t6 < 0 || t6 > n4 ? 24575 : 0, s6 = e3.ad(Math.round(o5), 0, e3.Y), a6 = e3.ad(Math.round(t6), 0, e3.Y);
                i5.emplaceBack(s6 + r6, a6);
              }
              const l4 = (e4, t6) => {
                const i6 = t6 * r5 + e4;
                o4.emplaceBack(i6 + 1, i6, i6 + r5), o4.emplaceBack(i6 + r5, i6 + r5 + 1, i6 + 1);
              };
              for (let e4 = 1; e4 < 129; e4++) for (let t6 = 1; t6 < 129; t6++) l4(t6, e4);
              return [0, 129].forEach((e4) => {
                for (let t6 = 0; t6 < 130; t6++) l4(t6, e4), l4(e4, t6);
              }), [i5, o4, 32768];
            }(), n3 = t4.context;
            this.gridBuffer = n3.createVertexBuffer(o3, e3.aS.members), this.gridIndexBuffer = n3.createIndexBuffer(r4), this.gridSegments = e3.aE.simpleSegment(0, 0, o3.length, r4.length), this.gridNoSkirtSegments = e3.aE.simpleSegment(0, 0, o3.length, s4), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new dr(i4.map), this.orthoMatrix = e3.a9.create(), e3.a9.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e3.Y, 0, e3.Y, 0, 1);
            const a4 = n3.gl;
            this._overlapStencilMode = new Dt({ func: a4.GEQUAL, mask: 255 }, 0, 255, a4.KEEP, a4.KEEP, a4.REPLACE), this._previousZoom = t4.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i4, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new ur(i4.map), this._pendingGroundEffectLayers = [];
          }
          set style(e4) {
            e4.on("data", this._onStyleDataEvent.bind(this)), this._style = e4, this._style.map.on("moveend", () => {
              this._clearLineLayersFromRenderCache();
            });
          }
          update(t4, i4, o3) {
            if (t4 && t4.terrain) {
              this._style !== t4 && (this.style = t4, this._evaluationZoom = void 0);
              const r4 = t4.terrain.properties, s4 = 0 === t4.terrain.drapeRenderMode, n3 = t4.terrain.isZoomDependent();
              this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e3.f.now();
              const a4 = t4.terrain && t4.terrain.scope, l4 = r4.get("source"), c4 = s4 ? this._mockSourceCache : t4.getSourceCache(l4, a4);
              if (!c4) return void e3.w(`Couldn't find terrain source "${l4}".`);
              if (this.sourceCache = c4, this._exaggeration = n3 ? this.calculateExaggeration(i4) : r4.get("exaggeration"), !i4.projection.requiresDraping && n3 && 0 === this._exaggeration) return void this._disable();
              this.enabled = true;
              const h4 = () => {
                this.sourceCache.used && e3.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                const t5 = this.getScaledDemTileSize();
                this.sourceCache.update(i4, t5, true), this.resetTileLookupCache(this.sourceCache.id);
              };
              this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, h4(), this._initializing = true), h4(), i4.updateElevation(true, o3), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i4), this._emptyDEMTextureDirty = true, this._previousZoom = i4.zoom;
            } else this._disable();
          }
          calculateExaggeration(t4) {
            const i4 = this._previousCameraAltitude, o3 = t4.getFreeCameraOptions().position.z / t4.pixelsPerMeter * t4.worldSize;
            this._previousCameraAltitude = o3;
            const r4 = null != i4 ? o3 - i4 : Number.MAX_VALUE;
            if (Math.abs(r4) < 2) return this._exaggeration;
            const s4 = t4.zoom, n3 = this._style.terrain;
            if (!this._previousUpdateTimestamp) return n3.getExaggeration(s4);
            let a4 = s4 - this._previousZoom;
            const l4 = this._previousUpdateTimestamp;
            let c4 = s4;
            null != this._evaluationZoom && (c4 = this._evaluationZoom, Math.abs(s4 - c4) > 0.5 && (a4 = 0.5 * (s4 - c4 + a4)), a4 * r4 < 0 && (c4 += a4)), this._evaluationZoom = c4;
            const h4 = n3.getExaggeration(c4), u5 = h4 === n3.getExaggeration(Math.max(0, c4 - 0.1));
            if (u5 && Math.abs(h4 - this._exaggeration) < 0.01) return h4;
            let d3 = Math.min(0.1, 375e-5 * (this._updateTimestamp - l4));
            return (u5 || h4 < 0.1 || Math.abs(a4) < 1e-4) && (d3 = Math.min(0.2, 4 * d3)), e3.X(this._exaggeration, h4, d3);
          }
          resetTileLookupCache(e4) {
            this._findCoveringTileCache[e4] = {};
          }
          getScaledDemTileSize() {
            return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
          }
          _onStyleDataEvent(e4) {
            e4.coord && "source" === e4.dataType ? this._clearRenderCacheForTile(e4.sourceCacheId, e4.coord) : "style" === e4.dataType && (this.invalidateRenderCache = true, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
          }
          _disable() {
            if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e4 in this._style._mergedSourceCaches) this._style._mergedSourceCaches[e4].usedForTerrain = false;
          }
          destroy() {
            this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e4) => e4.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
          }
          _source() {
            return this.enabled ? this.sourceCache : null;
          }
          isUsingMockSource() {
            return this.sourceCache === this._mockSourceCache;
          }
          exaggeration() {
            return this._exaggeration;
          }
          get visibleDemTiles() {
            return this._visibleDemTiles;
          }
          get drapeBufferSize() {
            const e4 = 2 * this.proxySourceCache.getSource().tileSize;
            return [e4, e4];
          }
          set useVertexMorphing(e4) {
            this._useVertexMorphing = e4;
          }
          updateTileBinding(t4) {
            if (!this.enabled) return;
            this.prevTerrainTileForTile = this.terrainTileForTile;
            const i4 = this.proxySourceCache, o3 = this.painter.transform;
            this._initializing && (this._initializing = 0 === o3._centerAltitude && -1 === this.getAtPointOrZero(e3.O.fromLngLat(o3.center), -1), this._emptyDEMTextureDirty = !this._initializing);
            const r4 = this.proxyCoords = i4.getIds().map((e4) => {
              const t5 = i4.getTileByID(e4).tileID;
              return t5.projMatrix = o3.calculateProjMatrix(t5.toUnwrapped()), t5;
            });
            !function(t5, i5) {
              const o4 = i5.transform.pointCoordinate(i5.transform.getCameraPoint()), r5 = new e3.P(o4.x, o4.y);
              t5.sort((t6, i6) => {
                if (i6.overscaledZ - t6.overscaledZ) return i6.overscaledZ - t6.overscaledZ;
                const o5 = new e3.P(t6.canonical.x + (1 << t6.canonical.z) * t6.wrap, t6.canonical.y), s5 = new e3.P(i6.canonical.x + (1 << i6.canonical.z) * i6.wrap, i6.canonical.y), n4 = r5.mult(1 << t6.canonical.z);
                return n4.x -= 0.5, n4.y -= 0.5, n4.distSqr(o5) - n4.distSqr(s5);
              });
            }(r4, this.painter);
            const s4 = this.proxyToSource || {};
            this.proxyToSource = {}, r4.forEach((e4) => {
              this.proxyToSource[e4.key] = {};
            }), this.terrainTileForTile = {};
            const n3 = this._style._mergedSourceCaches;
            for (const e4 in n3) {
              const i5 = n3[e4];
              if (!i5.used) continue;
              if (i5 !== this.sourceCache && this.resetTileLookupCache(i5.id), this._setupProxiedCoordsForOrtho(i5, t4[e4], s4), i5.usedForTerrain) continue;
              const o4 = t4[e4];
              i5.getSource().reparseOverscaled && this._assignTerrainTiles(o4);
            }
            this.proxiedCoords[i4.id] = r4.map((e4) => new _r(e4, e4.key, this.orthoMatrix)), this._assignTerrainTiles(r4), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(s4), this.renderingToTexture = false;
            const a4 = {};
            this._visibleDemTiles = [];
            for (const e4 of this.proxyCoords) {
              const t5 = this.terrainTileForTile[e4.key];
              if (!t5) continue;
              const i5 = t5.tileID.key;
              i5 in a4 || (this._visibleDemTiles.push(t5), a4[i5] = i5);
            }
          }
          _assignTerrainTiles(e4) {
            this._initializing || e4.forEach((e5) => {
              if (this.terrainTileForTile[e5.key]) return;
              const t4 = this._findTileCoveringTileID(e5, this.sourceCache);
              t4 && (this.terrainTileForTile[e5.key] = t4);
            });
          }
          _prepareDEMTextures() {
            const e4 = this.painter.context, t4 = e4.gl;
            for (const i4 in this.terrainTileForTile) {
              const o3 = this.terrainTileForTile[i4], r4 = o3.dem;
              !r4 || o3.demTexture && !o3.needsDEMTextureUpload || (e4.activeTexture.set(t4.TEXTURE1), Ko(this.painter, o3, r4));
            }
          }
          _prepareDemTileUniforms(e4, t4, i4, o3) {
            if (!t4 || null == t4.demTexture) return false;
            const r4 = e4.tileID.canonical, s4 = Math.pow(2, t4.tileID.canonical.z - r4.z), n3 = o3 || "";
            return i4[`u_dem_tl${n3}`] = [r4.x * s4 % 1, r4.y * s4 % 1], i4[`u_dem_scale${n3}`] = s4, true;
          }
          get emptyDEMTexture() {
            return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
          }
          get emptyDepthBufferTexture() {
            const t4 = this.painter.context, i4 = t4.gl;
            if (!this._emptyDepthBufferTexture) {
              const o3 = new e3.h({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
              this._emptyDepthBufferTexture = new e3.T(t4, o3, i4.RGBA, { premultiply: false });
            }
            return this._emptyDepthBufferTexture;
          }
          _getLoadedAreaMinimum() {
            let e4 = 0;
            const t4 = this._visibleDemTiles.reduce((t5, i4) => {
              if (!i4.dem) return t5;
              const o3 = i4.dem.tree.minimums[0];
              return o3 > 0 && e4++, t5 + o3;
            }, 0);
            return e4 ? t4 / e4 : 0;
          }
          _updateEmptyDEMTexture() {
            const t4 = this.painter.context, i4 = t4.gl;
            t4.activeTexture.set(i4.TEXTURE2);
            const o3 = this._getLoadedAreaMinimum(), [r4, s4] = (() => {
              const t5 = new e3.cr({ width: 1, height: 1 }, new Float32Array([o3]));
              return [i4.R32F, t5];
            })();
            this._emptyDEMTextureDirty = false;
            let n3 = this._emptyDEMTexture;
            return n3 ? n3.update(s4, { premultiply: false }) : n3 = this._emptyDEMTexture = new e3.T(t4, s4, r4, { premultiply: false }), n3;
          }
          setupElevationDraw(t4, i4, o3) {
            const r4 = this.painter.context, s4 = r4.gl, n3 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 };
            n3.u_exaggeration = this.exaggeration();
            let a4 = null, l4 = null, c4 = 1;
            if (o3 && o3.morphing && this._useVertexMorphing) {
              const e4 = o3.morphing.srcDemTile, i5 = o3.morphing.dstDemTile;
              c4 = o3.morphing.phase, e4 && i5 && (this._prepareDemTileUniforms(t4, e4, n3, "_prev") && (l4 = e4), this._prepareDemTileUniforms(t4, i5, n3) && (a4 = i5));
            }
            const h4 = (e4) => e4 && e4.demTexture && this.painter.linearFloatFilteringSupported() ? s4.LINEAR : s4.NEAREST, u5 = (e4) => {
              n3.u_dem_size = 1 === e4.size[0] ? 1 : e4.size[0] - 2;
            };
            if (l4 && a4) r4.activeTexture.set(s4.TEXTURE2), a4.demTexture.bind(h4(a4), s4.CLAMP_TO_EDGE), r4.activeTexture.set(s4.TEXTURE4), l4.demTexture.bind(h4(l4), s4.CLAMP_TO_EDGE), a4.demTexture && u5(a4.demTexture), n3.u_dem_lerp = c4;
            else {
              a4 = this.terrainTileForTile[t4.tileID.key], r4.activeTexture.set(s4.TEXTURE2);
              const e4 = this._prepareDemTileUniforms(t4, a4, n3) ? a4.demTexture : this.emptyDEMTexture;
              e4.bind(h4(a4), s4.CLAMP_TO_EDGE), u5(e4);
            }
            if (r4.activeTexture.set(s4.TEXTURE3), o3 && o3.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(s4.NEAREST, s4.CLAMP_TO_EDGE), this._depthFBO && (n3.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(s4.NEAREST, s4.CLAMP_TO_EDGE), n3.u_depth_size_inv = [1, 1]), o3 && o3.useMeterToDem && a4) {
              const t5 = (1 << a4.tileID.canonical.z) * e3.bo(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
              n3.u_meter_to_dem = t5;
            }
            if (o3 && o3.labelPlaneMatrixInv && (n3.u_label_plane_matrix_inv = o3.labelPlaneMatrixInv), i4.setTerrainUniformValues(r4, n3), "globe" === this.painter.transform.projection.name) {
              const e4 = this.globeUniformValues(this.painter.transform, t4.tileID.canonical, o3 && o3.useDenormalizedUpVectorScale);
              i4.setGlobeUniformValues(r4, e4);
            }
          }
          globeUniformValues(t4, i4, o3) {
            const r4 = t4.projection;
            return { u_tile_tl_up: r4.upVector(i4, 0, 0), u_tile_tr_up: r4.upVector(i4, e3.Y, 0), u_tile_br_up: r4.upVector(i4, e3.Y, e3.Y), u_tile_bl_up: r4.upVector(i4, 0, e3.Y), u_tile_up_scale: o3 ? e3.cq(1) : r4.upVectorScale(i4, t4.center.lat, t4.worldSize).metersToTile };
          }
          renderToBackBuffer(t4) {
            const i4 = this.painter, o3 = this.painter.context;
            0 !== t4.length && (o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, i4.width, i4.height]), i4.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t5, i5, o4, r4, s4) {
              if ("globe" === t5.transform.projection.name) !function(t6, i6, o5, r5, s5) {
                const n3 = t6.context, a4 = n3.gl;
                let l4, c4;
                const h4 = t6.transform, u5 = e3.ci(t6, n3, h4), d3 = (e4, i7) => {
                  if (c4 === i7) return;
                  const o6 = [nr[i7], "PROJECTION_GLOBE_VIEW"];
                  u5 && o6.push("CUSTOM_ANTIALIASING");
                  const r6 = t6.isTileAffectedByFog(e4);
                  l4 = t6.getOrCreateProgram("globeRaster", { defines: o6, overrideFog: r6 }), c4 = i7;
                }, _4 = t6.colorModeForRenderPass(), p4 = new Ct(a4.LEQUAL, Ct.ReadWrite, t6.depthRangeFor3D);
                sr.update(s5);
                const f4 = e3.cj(h4), m4 = [e3.a8(h4.center.lng), e3.ah(h4.center.lat)], g5 = t6.globeSharedBuffers, v4 = [h4.width * e3.f.devicePixelRatio, h4.height * e3.f.devicePixelRatio], x5 = Float32Array.from(h4.globeMatrix), y4 = { useDenormalizedUpVectorScale: true };
                {
                  const h5 = t6.transform, u6 = ar(h5.zoom, i6.exaggeration(), i6.sourceCache._source.tileSize);
                  c4 = -1;
                  const b4 = a4.TRIANGLES;
                  for (const c5 of r5) {
                    const r6 = o5.getTile(c5), w5 = Dt.disabled, T5 = i6.prevTerrainTileForTile[c5.key], E3 = i6.terrainTileForTile[c5.key];
                    rr(T5, E3) && sr.newMorphing(c5.key, T5, E3, s5, 250), n3.activeTexture.set(a4.TEXTURE0), r6.texture && r6.texture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE);
                    const S3 = sr.getMorphValuesForProxy(c5.key), C4 = S3 ? 1 : 0;
                    S3 && e3.k(y4, { morphing: { srcDemTile: S3.from, dstDemTile: S3.to, phase: e3.ch(S3.phase) } });
                    const I4 = e3.ck(c5.canonical), D4 = e3.cl(I4.getCenter().lat), R2 = e3.cm(c5.canonical, I4, D4, h5.worldSize / h5._pixelsPerMercatorPixel), A4 = e3.aW(e3.cn(c5.canonical)), P4 = or(h5.expandedFarZProjMatrix, x5, f4, A4, e3.W(h5.zoom), m4, h5.frustumCorners.TL, h5.frustumCorners.TR, h5.frustumCorners.BR, h5.frustumCorners.BL, h5.globeCenterInViewSpace, h5.globeRadius, v4, u6, h5._farZ, R2);
                    if (d3(c5, C4), l4 && (i6.setupElevationDraw(r6, l4, y4), t6.uploadCommonUniforms(n3, l4, c5.toUnwrapped()), g5)) {
                      const [e4, i7, o6] = g5.getGridBuffers(D4, 0 !== u6);
                      l4.draw(t6, b4, p4, w5, _4, Mt.backCCW, P4, "globe_raster", e4, i7, o6);
                    }
                  }
                }
                if (g5 && (t6.renderDefaultNorthPole || t6.renderDefaultSouthPole)) {
                  const s6 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  u5 && s6.push("CUSTOM_ANTIALIASING"), l4 = t6.getOrCreateProgram("globeRaster", { defines: s6 });
                  for (const s7 of r5) {
                    const { x: r6, y: c5, z: u6 } = s7.canonical, d4 = 0 === c5, f5 = c5 === (1 << u6) - 1, [x6, b4, w5, T5] = g5.getPoleBuffers(u6, false);
                    if (T5 && (d4 || f5)) {
                      const c6 = o5.getTile(s7);
                      n3.activeTexture.set(a4.TEXTURE0), c6.texture && c6.texture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE);
                      let g6 = e3.co(u6, r6, h4);
                      const E3 = e3.aW(e3.cn(s7.canonical)), S3 = (e4, i7) => e4.draw(t6, a4.TRIANGLES, p4, Dt.disabled, _4, Mt.disabled, or(h4.expandedFarZProjMatrix, g6, g6, E3, 0, m4, h4.frustumCorners.TL, h4.frustumCorners.TR, h4.frustumCorners.BR, h4.frustumCorners.BL, h4.globeCenterInViewSpace, h4.globeRadius, v4, 0, h4._farZ), "globe_pole_raster", i7, w5, T5);
                      i6.setupElevationDraw(c6, l4, y4), t6.uploadCommonUniforms(n3, l4, s7.toUnwrapped()), d4 && t6.renderDefaultNorthPole && S3(l4, x6), f5 && t6.renderDefaultSouthPole && (g6 = e3.a9.scale(e3.a9.create(), g6, [1, -1, 1]), S3(l4, b4));
                    }
                  }
                }
              }(t5, i5, o4, r4, s4);
              else {
                const n3 = t5.context, a4 = n3.gl;
                let l4, c4;
                const h4 = t5.shadowRenderer, u5 = mo(t5, t5.longestCutoffRange), d3 = (e4) => {
                  if (c4 === e4) return;
                  const i6 = [];
                  i6.push(nr[e4]), u5.shouldRenderCutoff && i6.push("RENDER_CUTOFF"), l4 = t5.getOrCreateProgram("terrainRaster", { defines: i6 }), c4 = e4;
                }, _4 = t5.colorModeForRenderPass(), p4 = new Ct(a4.LEQUAL, Ct.ReadWrite, t5.depthRangeFor3D);
                sr.update(s4);
                const f4 = t5.transform, m4 = ar(f4.zoom, i5.exaggeration(), i5.sourceCache._source.tileSize);
                let g5 = [0, 0, 0];
                if (h4) {
                  const e4 = t5.style.directionalLight, i6 = t5.style.ambientLight;
                  e4 && i6 && (g5 = To(e4, i6));
                }
                {
                  c4 = -1;
                  const v4 = a4.TRIANGLES, [x5, y4] = [i5.gridIndexBuffer, i5.gridSegments];
                  for (const c5 of r4) {
                    const r5 = o4.getTile(c5), b4 = Dt.disabled, w5 = i5.prevTerrainTileForTile[c5.key], T5 = i5.terrainTileForTile[c5.key];
                    rr(w5, T5) && sr.newMorphing(c5.key, w5, T5, s4, 250), n3.activeTexture.set(a4.TEXTURE0), r5.texture && r5.texture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE);
                    const E3 = sr.getMorphValuesForProxy(c5.key), S3 = E3 ? 1 : 0;
                    let C4;
                    E3 && (C4 = { morphing: { srcDemTile: E3.from, dstDemTile: E3.to, phase: e3.ch(E3.phase) } });
                    const I4 = ir(c5.projMatrix, lr(c5.canonical, f4.renderWorldCopies) ? m4 / 10 : m4, g5);
                    if (d3(S3), !l4) continue;
                    i5.setupElevationDraw(r5, l4, C4);
                    const D4 = c5.toUnwrapped();
                    h4 && h4.setupShadows(D4, l4), t5.uploadCommonUniforms(n3, l4, D4, null, u5), l4.draw(t5, v4, p4, b4, _4, Mt.backCCW, I4, "terrain_raster", i5.gridBuffer, x5, y4);
                  }
                }
              }
            }(i4, this, this.proxySourceCache, t4, this._updateTimestamp), this.renderingToTexture = true, i4.gpuTimingDeferredRenderEnd(), t4.splice(0, t4.length));
          }
          renderBatch(t4) {
            if (0 === this._drapedRenderBatches.length) return t4 + 1;
            this.renderingToTexture = true;
            const i4 = this.painter, o3 = this.painter.context, r4 = this.proxySourceCache, s4 = this.proxiedCoords[r4.id], n3 = this._drapedRenderBatches.shift(), a4 = i4.style.order, l4 = [];
            let c4 = 0;
            for (const h4 of s4) {
              const s5 = r4.getTileByID(h4.proxyTileKey), u5 = r4.proxyCachedFBO[h4.key] ? r4.proxyCachedFBO[h4.key][t4] : void 0, d3 = void 0 !== u5 ? r4.renderCache[u5] : this.pool[c4++], _4 = void 0 !== u5;
              if (s5.texture = d3.tex, _4 && !d3.dirty) {
                l4.push(s5.tileID);
                continue;
              }
              let p4;
              o3.bindFramebuffer.set(d3.fb.framebuffer), this.renderedToTile = false, d3.dirty && (o3.clear({ color: e3.aA.transparent, stencil: 0 }), d3.dirty = false);
              for (let e4 = n3.start; e4 <= n3.end; ++e4) {
                const t5 = i4.style._mergedLayers[a4[e4]];
                if (t5.isHidden(i4.transform.zoom)) continue;
                const r5 = i4.style.getLayerSourceCache(t5), s6 = r5 ? this.proxyToSource[h4.key][r5.id] : [h4];
                if (!s6) continue;
                const n4 = s6;
                o3.viewport.set([0, 0, d3.fb.width, d3.fb.height]), p4 !== (r5 ? r5.id : null) && (this._setupStencil(d3, s6, t5, r5), p4 = r5 ? r5.id : null), i4.renderLayer(i4, r5, t5, n4);
              }
              if (0 === this._drapedRenderBatches.length) for (const e4 of this._pendingGroundEffectLayers) {
                const t5 = i4.style._mergedLayers[a4[e4]];
                if (t5.isHidden(i4.transform.zoom)) continue;
                const r5 = i4.style.getLayerSourceCache(t5), s6 = r5 ? this.proxyToSource[h4.key][r5.id] : [h4];
                if (!s6) continue;
                const n4 = s6;
                o3.viewport.set([0, 0, d3.fb.width, d3.fb.height]), p4 !== (r5 ? r5.id : null) && (this._setupStencil(d3, s6, t5, r5), p4 = r5 ? r5.id : null), i4.renderLayer(i4, r5, t5, n4);
              }
              this.renderedToTile ? (d3.dirty = true, l4.push(s5.tileID)) : _4 || --c4, 5 === c4 && (c4 = 0, this.renderToBackBuffer(l4));
            }
            return this.renderToBackBuffer(l4), this.renderingToTexture = false, o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, i4.width, i4.height]), n3.end + 1;
          }
          postRender() {
          }
          isLayerOrderingCorrect(e4) {
            const t4 = e4.order.length;
            let i4 = -1, o3 = t4;
            for (let r4 = 0; r4 < t4; ++r4) this._style.isLayerDraped(e4._mergedLayers[e4.order[r4]]) ? i4 = Math.max(i4, r4) : o3 = Math.min(o3, r4);
            return o3 > i4;
          }
          getMinElevationBelowMSL() {
            let e4 = 0;
            return this._visibleDemTiles.filter((e5) => e5.dem).forEach((t4) => {
              e4 = Math.min(e4, t4.dem.tree.minimums[0]);
            }), 0 === e4 ? e4 : (e4 - 30) * this._exaggeration;
          }
          raycast(e4, t4, i4) {
            if (!this._visibleDemTiles) return null;
            const o3 = this._visibleDemTiles.filter((e5) => e5.dem).map((o4) => {
              const r4 = o4.tileID, s4 = 1 << r4.overscaledZ, { x: n3, y: a4 } = r4.canonical, l4 = n3 / s4, c4 = (n3 + 1) / s4, h4 = a4 / s4, u5 = (a4 + 1) / s4;
              return { minx: l4, miny: h4, maxx: c4, maxy: u5, t: o4.dem.tree.raycastRoot(l4, h4, c4, u5, e4, t4, i4), tile: o4 };
            });
            o3.sort((e5, t5) => (null !== e5.t ? e5.t : Number.MAX_VALUE) - (null !== t5.t ? t5.t : Number.MAX_VALUE));
            for (const r4 of o3) {
              if (null == r4.t) return null;
              const o4 = r4.tile.dem.tree.raycast(r4.minx, r4.miny, r4.maxx, r4.maxy, e4, t4, i4);
              if (null != o4) return o4;
            }
            return null;
          }
          _createFBO() {
            const t4 = this.painter.context, i4 = t4.gl, o3 = this.drapeBufferSize;
            t4.activeTexture.set(i4.TEXTURE0);
            const r4 = new e3.T(t4, { width: o3[0], height: o3[1], data: null }, i4.RGBA);
            r4.bind(i4.LINEAR, i4.CLAMP_TO_EDGE);
            const s4 = t4.createFramebuffer(o3[0], o3[1], true, null);
            return s4.colorAttachment.set(r4.texture), s4.depthAttachment = new Et(t4, s4.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t4.createRenderbuffer(t4.gl.DEPTH_STENCIL, o3[0], o3[1]), this._stencilRef = 0, s4.depthAttachment.set(this._sharedDepthStencil), t4.clear({ stencil: 0 })) : s4.depthAttachment.set(this._sharedDepthStencil), t4.extTextureFilterAnisotropic && i4.texParameterf(i4.TEXTURE_2D, t4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t4.extTextureFilterAnisotropicMax), { fb: s4, tex: r4, dirty: false };
          }
          _initFBOPool() {
            for (; this.pool.length < Math.min(5, this.proxyCoords.length); ) this.pool.push(this._createFBO());
          }
          _shouldDisableRenderCache() {
            if (this._debugParams.disableRenderCache) return true;
            if (this._style.hasLightTransitions()) return true;
            for (const e4 in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[e4].hasTransition()) return true;
            return this._style.order.some((e4) => {
              const t4 = this._style._mergedLayers[e4], i4 = t4.isHidden(this.painter.transform.zoom);
              return "custom" === t4.type ? !i4 && t4.shouldRedrape() : !i4 && t4.hasTransition();
            });
          }
          _clearLineLayersFromRenderCache() {
            let t4 = false;
            for (const e4 of this._style.getSources()) if (e4 instanceof Re) {
              t4 = true;
              break;
            }
            if (!t4) return;
            const i4 = {};
            for (let t5 = 0; t5 < this._style.order.length; ++t5) {
              const o3 = this._style._mergedLayers[this._style.order[t5]], r4 = this._style.getLayerSourceCache(o3);
              if (r4 && !i4[r4.id] && !o3.isHidden(this.painter.transform.zoom) && "line" === o3.type && o3.widthExpression() instanceof e3.Z) {
                i4[r4.id] = true;
                for (const e4 of this.proxyCoords) {
                  const t6 = this.proxyToSource[e4.key][r4.id];
                  if (t6) for (const e5 of t6) this._clearRenderCacheForTile(r4.id, e5);
                }
              }
            }
          }
          _clearRasterLayersFromRenderCache() {
            let e4 = false;
            for (const t5 in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t5]._source instanceof Ae) {
              e4 = true;
              break;
            }
            if (!e4) return;
            const t4 = {};
            for (let e5 = 0; e5 < this._style.order.length; ++e5) {
              const i4 = this._style._mergedLayers[this._style.order[e5]], o3 = this._style.getLayerSourceCache(i4);
              if (!o3 || t4[o3.id]) continue;
              if (i4.isHidden(this.painter.transform.zoom) || "raster" !== i4.type) continue;
              const r4 = i4.paint.get("raster-fade-duration");
              for (const e6 of this.proxyCoords) {
                const t5 = this.proxyToSource[e6.key][o3.id];
                if (t5) for (const e7 of t5) {
                  const t6 = hr(o3.getTile(e7), o3.findLoadedParent(e7, 0), o3, this.painter.transform, r4);
                  (1 !== t6.opacity || 0 !== t6.mix) && this._clearRenderCacheForTile(o3.id, e7);
                }
              }
            }
          }
          _setupDrapedRenderBatches() {
            const t4 = this._style.order, i4 = t4.length;
            if (0 === i4) return;
            const o3 = [];
            this._pendingGroundEffectLayers = [];
            let r4, s4 = 0, n3 = this._style._mergedLayers[t4[s4]];
            for (; !this._style.isLayerDraped(n3) && n3.isHidden(this.painter.transform.zoom) && ++s4 < i4; ) n3 = this._style._mergedLayers[t4[s4]];
            for (; s4 < i4; ++s4) {
              const e4 = this._style._mergedLayers[t4[s4]];
              e4.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e4) ? void 0 === r4 && (r4 = s4) : ("fill-extrusion" === e4.type && this._pendingGroundEffectLayers.push(s4), void 0 !== r4 && (o3.push({ start: r4, end: s4 - 1 }), r4 = void 0)));
            }
            if (void 0 !== r4 && o3.push({ start: r4, end: s4 - 1 }), 0 !== o3.length) {
              const t5 = o3[o3.length - 1];
              this._pendingGroundEffectLayers.every((e4) => e4 > t5.end) || e3.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
            }
            this._drapedRenderBatches = o3;
          }
          _setupRenderCache(e4) {
            const t4 = this.proxySourceCache;
            if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
              if (this.invalidateRenderCache = false, t4.renderCache.length > t4.renderCachePool.length) {
                const e5 = Object.values(t4.proxyCachedFBO);
                t4.proxyCachedFBO = {};
                for (let i5 = 0; i5 < e5.length; ++i5) {
                  const o4 = Object.values(e5[i5]);
                  t4.renderCachePool.push(...o4);
                }
              }
              return;
            }
            this._clearRasterLayersFromRenderCache();
            const i4 = this.proxyCoords, o3 = this._tilesDirty;
            for (let r5 = i4.length - 1; r5 >= 0; r5--) {
              const s4 = i4[r5];
              if (t4.getTileByID(s4.key), void 0 !== t4.proxyCachedFBO[s4.key]) {
                const i5 = e4[s4.key], r6 = this.proxyToSource[s4.key];
                let n3 = 0;
                for (const e5 in r6) {
                  const t5 = r6[e5], s5 = i5[e5];
                  if (!s5 || s5.length !== t5.length || t5.some((t6, i6) => t6 !== s5[i6] || o3[e5] && o3[e5].hasOwnProperty(t6.key))) {
                    n3 = -1;
                    break;
                  }
                  ++n3;
                }
                for (const e5 in t4.proxyCachedFBO[s4.key]) t4.renderCache[t4.proxyCachedFBO[s4.key][e5]].dirty = n3 < 0 || n3 !== Object.values(i5).length;
              }
            }
            const r4 = [...this._drapedRenderBatches];
            r4.sort((e5, t5) => t5.end - t5.start - (e5.end - e5.start));
            for (const e5 of r4) for (const o4 of i4) {
              if (t4.proxyCachedFBO[o4.key]) continue;
              let i5 = t4.renderCachePool.pop();
              void 0 === i5 && t4.renderCache.length < 50 && (i5 = t4.renderCache.length, t4.renderCache.push(this._createFBO())), void 0 !== i5 && (t4.proxyCachedFBO[o4.key] = {}, t4.proxyCachedFBO[o4.key][e5.start] = i5, t4.renderCache[i5].dirty = true);
            }
            this._tilesDirty = {};
          }
          _setupStencil(e4, t4, i4, o3) {
            if (!o3 || !this._sourceTilesOverlap[o3.id]) return void (this._overlapStencilType && (this._overlapStencilType = false));
            const r4 = this.painter.context, s4 = r4.gl;
            if (t4.length <= 1) return void (this._overlapStencilType = false);
            let n3;
            if (i4.isTileClipped()) n3 = t4.length, this._overlapStencilMode.test = { func: s4.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
            else {
              if (!(t4[0].overscaledZ > t4[t4.length - 1].overscaledZ)) return void (this._overlapStencilType = false);
              n3 = 1, this._overlapStencilMode.test = { func: s4.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
            }
            this._stencilRef + n3 > 255 && (r4.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += n3, this._overlapStencilMode.ref = this._stencilRef, i4.isTileClipped() && this._renderTileClippingMasks(t4, this._overlapStencilMode.ref);
          }
          clipOrMaskOverlapStencilType() {
            return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
          }
          stencilModeForRTTOverlap(e4) {
            return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e4.key]), this._overlapStencilMode) : Dt.disabled;
          }
          _renderTileClippingMasks(e4, t4) {
            const i4 = this.painter, o3 = this.painter.context, r4 = o3.gl;
            i4._tileClippingMaskIDs = {}, o3.setColorMode(At.disabled), o3.setDepthMode(Ct.disabled);
            const s4 = i4.getOrCreateProgram("clippingMask");
            for (const o4 of e4) {
              const e5 = i4._tileClippingMaskIDs[o4.key] = --t4;
              s4.draw(i4, r4.TRIANGLES, Ct.disabled, new Dt({ func: r4.ALWAYS, mask: 0 }, e5, 255, r4.KEEP, r4.KEEP, r4.REPLACE), At.disabled, Mt.disabled, cr(o4.projMatrix), "$clipping", i4.tileExtentBuffer, i4.quadTriangleIndexBuffer, i4.tileExtentSegments);
            }
          }
          pointCoordinate(t4) {
            const i4 = this.painter.transform;
            if (t4.x < 0 || t4.x > i4.width || t4.y < 0 || t4.y > i4.height) return null;
            const o3 = [t4.x, t4.y, 1, 1];
            e3.aa.transformMat4(o3, o3, i4.pixelMatrixInverse), e3.aa.scale(o3, o3, 1 / o3[3]), o3[0] /= i4.worldSize, o3[1] /= i4.worldSize;
            const r4 = i4._camera.position, s4 = e3.bo(1, i4.center.lat), n3 = [r4[0], r4[1], r4[2] / s4, 0], a4 = e3.Q.subtract([], o3.slice(0, 3), n3);
            e3.Q.normalize(a4, a4);
            const l4 = this.raycast(n3, a4, this._exaggeration);
            return null !== l4 && l4 ? (e3.Q.scaleAndAdd(n3, n3, a4, l4), n3[3] = n3[2], n3[2] *= s4, n3) : null;
          }
          drawDepth() {
            const t4 = this.painter, i4 = t4.context, o3 = this.proxySourceCache, r4 = Math.ceil(t4.width), s4 = Math.ceil(t4.height);
            if (!this._depthFBO || this._depthFBO.width === r4 && this._depthFBO.height === s4 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
              const t5 = i4.gl, o4 = i4.createFramebuffer(r4, s4, true, "renderbuffer");
              i4.activeTexture.set(t5.TEXTURE0);
              const n3 = new e3.T(i4, { width: r4, height: s4, data: null }, t5.RGBA);
              n3.bind(t5.NEAREST, t5.CLAMP_TO_EDGE), o4.colorAttachment.set(n3.texture);
              const a4 = i4.createRenderbuffer(i4.gl.DEPTH_COMPONENT16, r4, s4);
              o4.depthAttachment.set(a4), this._depthFBO = o4, this._depthTexture = n3;
            }
            i4.bindFramebuffer.set(this._depthFBO.framebuffer), i4.viewport.set([0, 0, r4, s4]), function(e4, t5, i5, o4) {
              if ("globe" === e4.transform.projection.name) return;
              const r5 = e4.context, s5 = r5.gl;
              r5.clear({ depth: 1 });
              const n3 = e4.getOrCreateProgram("terrainDepth"), a4 = new Ct(s5.LESS, Ct.ReadWrite, e4.depthRangeFor3D);
              for (const r6 of o4) {
                const o5 = i5.getTile(r6), l4 = ir(r6.projMatrix, 0, [0, 0, 0]);
                t5.setupElevationDraw(o5, n3), n3.draw(e4, s5.TRIANGLES, a4, Dt.disabled, At.unblended, Mt.backCCW, l4, "terrain_depth", t5.gridBuffer, t5.gridIndexBuffer, t5.gridNoSkirtSegments);
              }
            }(t4, this, o3, this.proxyCoords);
          }
          _setupProxiedCoordsForOrtho(t4, i4, o3) {
            if (t4.getSource() instanceof e3.as) return this._setupProxiedCoordsForImageSource(t4, i4, o3);
            this._findCoveringTileCache[t4.id] = this._findCoveringTileCache[t4.id] || {};
            const r4 = this.proxiedCoords[t4.id] = [], s4 = this.proxyCoords;
            for (let e4 = 0; e4 < s4.length; e4++) {
              const i5 = s4[e4], n4 = this._findTileCoveringTileID(i5, t4);
              if (n4) {
                const e5 = this._createProxiedId(i5, n4, o3[i5.key] && o3[i5.key][t4.id]);
                r4.push(e5), this.proxyToSource[i5.key][t4.id] = [e5];
              }
            }
            let n3 = false;
            const a4 = /* @__PURE__ */ new Set();
            for (let e4 = 0; e4 < i4.length; e4++) {
              const s5 = t4.getTile(i4[e4]);
              if (!s5 || !s5.hasData()) continue;
              const l4 = this._findTileCoveringTileID(s5.tileID, this.proxySourceCache);
              if (l4 && l4.tileID.canonical.z !== s5.tileID.canonical.z) {
                const e5 = this.proxyToSource[l4.tileID.key][t4.id], i5 = this._createProxiedId(l4.tileID, s5, o3[l4.tileID.key] && o3[l4.tileID.key][t4.id]);
                e5 ? e5.splice(e5.length - 1, 0, i5) : this.proxyToSource[l4.tileID.key][t4.id] = [i5];
                const c4 = this.proxyToSource[l4.tileID.key][t4.id];
                a4.has(c4) || a4.add(c4), r4.push(i5), n3 = true;
              }
            }
            if (this._sourceTilesOverlap[t4.id] = n3, n3 && this._debugParams.sortTilesHiZFirst) for (const e4 of a4) e4.sort((e5, t5) => t5.overscaledZ - e5.overscaledZ);
          }
          _setupProxiedCoordsForImageSource(t4, i4, o3) {
            if (!t4.getSource().loaded()) return;
            const r4 = this.proxiedCoords[t4.id] = [], s4 = this.proxyCoords, n3 = t4.getSource(), a4 = n3.tileID;
            if (!a4) return;
            const l4 = new e3.P(a4.x, a4.y)._div(1 << a4.z), c4 = n3.coordinates.map(e3.O.fromLngLat).reduce((e4, t5) => (e4.min.x = Math.min(e4.min.x, t5.x - l4.x), e4.min.y = Math.min(e4.min.y, t5.y - l4.y), e4.max.x = Math.max(e4.max.x, t5.x - l4.x), e4.max.y = Math.max(e4.max.y, t5.y - l4.y), e4), { min: new e3.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new e3.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), h4 = (t5, i5) => {
              const o4 = t5.wrap + t5.canonical.x / (1 << t5.canonical.z), r5 = t5.canonical.y / (1 << t5.canonical.z), s5 = e3.Y / (1 << t5.canonical.z), n4 = i5.wrap + i5.canonical.x / (1 << i5.canonical.z), a5 = i5.canonical.y / (1 << i5.canonical.z);
              return o4 + s5 < n4 + c4.min.x || o4 > n4 + c4.max.x || r5 + s5 < a5 + c4.min.y || r5 > a5 + c4.max.y;
            };
            for (let e4 = 0; e4 < s4.length; e4++) {
              const n4 = s4[e4];
              for (let e5 = 0; e5 < i4.length; e5++) {
                const s5 = t4.getTile(i4[e5]);
                if (!s5 || !s5.hasData()) continue;
                if (h4(n4, s5.tileID)) continue;
                const a5 = this._createProxiedId(n4, s5, o3[n4.key] && o3[n4.key][t4.id]), l5 = this.proxyToSource[n4.key][t4.id];
                l5 ? l5.push(a5) : this.proxyToSource[n4.key][t4.id] = [a5], r4.push(a5);
              }
            }
          }
          _createProxiedId(t4, i4, o3) {
            let r4 = this.orthoMatrix;
            if (o3) {
              const e4 = o3.find((e5) => e5.key === i4.tileID.key);
              if (e4) return e4;
            }
            if (i4.tileID.key !== t4.key) {
              const o4 = t4.canonical.z - i4.tileID.canonical.z;
              let s4, n3, a4;
              r4 = e3.a9.create();
              const l4 = i4.tileID.wrap - t4.wrap << t4.overscaledZ;
              o4 > 0 ? (s4 = e3.Y >> o4, n3 = s4 * ((i4.tileID.canonical.x << o4) - t4.canonical.x + l4), a4 = s4 * ((i4.tileID.canonical.y << o4) - t4.canonical.y)) : (s4 = e3.Y << -o4, n3 = e3.Y * (i4.tileID.canonical.x - (t4.canonical.x + l4 << -o4)), a4 = e3.Y * (i4.tileID.canonical.y - (t4.canonical.y << -o4))), e3.a9.ortho(r4, 0, s4, 0, s4, 0, 1), e3.a9.translate(r4, r4, [n3, a4, 0]);
            }
            return new _r(i4.tileID, t4.key, r4);
          }
          _findTileCoveringTileID(t4, i4) {
            let o3 = i4.getTile(t4);
            if (o3 && o3.hasData()) return o3;
            const r4 = this._findCoveringTileCache[i4.id], s4 = r4[t4.key];
            if (o3 = s4 ? i4.getTileByID(s4) : null, o3 && o3.hasData() || null === s4) return o3;
            let n3 = o3 ? o3.tileID : t4, a4 = n3.overscaledZ;
            const l4 = i4.getSource().minzoom, c4 = [];
            if (!s4) {
              const r5 = i4.getSource().maxzoom;
              if (t4.canonical.z >= r5) {
                const o4 = t4.canonical.z - r5;
                i4.getSource().reparseOverscaled ? (a4 = Math.max(t4.canonical.z + 2, i4.transform.tileZoom), n3 = new e3.ap(a4, t4.wrap, r5, t4.canonical.x >> o4, t4.canonical.y >> o4)) : 0 !== o4 && (a4 = r5, n3 = new e3.ap(a4, t4.wrap, r5, t4.canonical.x >> o4, t4.canonical.y >> o4));
              }
              n3.key !== t4.key && (c4.push(n3.key), o3 = i4.getTile(n3));
            }
            const h4 = (e4) => {
              c4.forEach((t5) => {
                r4[t5] = e4;
              }), c4.length = 0;
            };
            for (a4 -= 1; a4 >= l4 && (!o3 || !o3.hasData()); a4--) {
              o3 && h4(o3.tileID.key);
              const e4 = n3.calculateScaledKey(a4);
              if (o3 = i4.getTileByID(e4), o3 && o3.hasData()) break;
              const t5 = r4[e4];
              if (null === t5) break;
              void 0 === t5 ? c4.push(e4) : o3 = i4.getTileByID(t5);
            }
            return h4(o3 ? o3.tileID.key : null), o3 && o3.hasData() ? o3 : null;
          }
          findDEMTileFor(e4) {
            return this.enabled ? this._findTileCoveringTileID(e4, this.sourceCache) : null;
          }
          prepareDrawTile() {
            this.renderedToTile = true;
          }
          _clearRenderCacheForTile(e4, t4) {
            let i4 = this._tilesDirty[e4];
            i4 || (i4 = this._tilesDirty[e4] = {}), i4[t4.key] = true;
          }
        }
        function fr(t4, i4, o3) {
          const r4 = function(t5, i5, o4) {
            const r5 = e3.Q.dot(i5, t5), s5 = e3.Q.dot(o4, [0.2126, 0.7152, 0.0722]), n4 = (e4, t6, i6) => (1 - i6) * e4 + i6 * t6, a5 = n4(1 - 0.3 * Math.min(s5, 1), 1, Math.min(r5 + 1, 1));
            return n4(0.92, 1, Math.asin(e3.ad(i5[2], -1, 1)) / Math.PI + 0.5) * a5;
          }(t4, [0, 0, 1], i4), s4 = [0, 0, 0];
          e3.Q.scale(s4, o3.slice(0, 3), r4);
          const n3 = [0, 0, 0];
          e3.Q.scale(n3, i4.slice(0, 3), t4[2]);
          const a4 = [0, 0, 0];
          return e3.Q.add(a4, s4, n3), e3.bX(a4);
        }
        const mr = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], gr = ["stars", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbolSDF", "symbolIcon", "symbolTextAndIcon"];
        class vr {
          static cacheKey(e4, t4, i4, o3) {
            let r4 = `${t4}${o3 ? o3.cacheKey : ""}`;
            for (const t5 of i4) e4.usedDefines.includes(t5) && (r4 += `/${t5}`);
            return r4;
          }
          constructor(t4, i4, o3, r4, s4, n3) {
            const a4 = t4.gl;
            this.program = a4.createProgram(), this.configuration = r4, this.name = i4, this.fixedDefines = [...n3];
            const l4 = r4 ? r4.getBinderAttributes() : [], c4 = (o3.staticAttributes || []).concat(l4);
            let h4 = r4 ? r4.defines() : [];
            h4 = h4.concat(n3.map((e4) => `#define ${e4}`));
            const u5 = "#version 300 es\n";
            let d3 = u5 + h4.concat("precision mediump float;", Ho, Wo.fragmentSource).join("\n");
            for (const e4 of o3.fragmentIncludes) d3 += `
${Vo[e4]}`;
            d3 += `
${o3.fragmentSource}`;
            let _4 = u5 + h4.concat("precision highp float;", Ho, Wo.vertexSource).join("\n");
            for (const e4 of o3.vertexIncludes) _4 += `
${Vo[e4]}`;
            _4 += `
${o3.vertexSource}`;
            const p4 = a4.createShader(a4.FRAGMENT_SHADER);
            if (a4.isContextLost()) return void (this.failedToCreate = true);
            a4.shaderSource(p4, d3), a4.compileShader(p4), a4.attachShader(this.program, p4);
            const f4 = a4.createShader(a4.VERTEX_SHADER);
            if (a4.isContextLost()) this.failedToCreate = true;
            else {
              a4.shaderSource(f4, _4), a4.compileShader(f4), a4.attachShader(this.program, f4), this.attributes = {}, this.numAttributes = c4.length;
              for (let e4 = 0; e4 < this.numAttributes; e4++) if (c4[e4]) {
                const t5 = c4[e4].startsWith("a_") ? c4[e4] : `a_${c4[e4]}`;
                a4.bindAttribLocation(this.program, e4, t5), this.attributes[t5] = e4;
              }
              a4.linkProgram(this.program), a4.deleteShader(f4), a4.deleteShader(p4), this.fixedUniforms = s4(t4), this.binderUniforms = r4 ? r4.getUniforms(t4) : [], n3.includes("TERRAIN") && (this.terrainUniforms = ((t5) => ({ u_dem: new e3.bR(t5), u_dem_prev: new e3.bR(t5), u_dem_tl: new e3.bO(t5), u_dem_scale: new e3.bQ(t5), u_dem_tl_prev: new e3.bO(t5), u_dem_scale_prev: new e3.bQ(t5), u_dem_size: new e3.bQ(t5), u_dem_lerp: new e3.bQ(t5), u_exaggeration: new e3.bQ(t5), u_depth: new e3.bR(t5), u_depth_size_inv: new e3.bO(t5), u_meter_to_dem: new e3.bQ(t5), u_label_plane_matrix_inv: new e3.bN(t5) }))(t4)), n3.includes("GLOBE") && (this.globeUniforms = ((t5) => ({ u_tile_tl_up: new e3.bP(t5), u_tile_tr_up: new e3.bP(t5), u_tile_br_up: new e3.bP(t5), u_tile_bl_up: new e3.bP(t5), u_tile_up_scale: new e3.bQ(t5) }))(t4)), n3.includes("FOG") && (this.fogUniforms = ((t5) => ({ u_fog_matrix: new e3.bN(t5), u_fog_range: new e3.bO(t5), u_fog_color: new e3.bS(t5), u_fog_horizon_blend: new e3.bQ(t5), u_fog_vertical_limit: new e3.bO(t5), u_fog_temporal_offset: new e3.bQ(t5), u_frustum_tl: new e3.bP(t5), u_frustum_tr: new e3.bP(t5), u_frustum_br: new e3.bP(t5), u_frustum_bl: new e3.bP(t5), u_globe_pos: new e3.bP(t5), u_globe_radius: new e3.bQ(t5), u_globe_transition: new e3.bQ(t5), u_is_globe: new e3.bR(t5), u_viewport: new e3.bO(t5) }))(t4)), n3.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t5) => ({ u_cutoff_params: new e3.bS(t5) }))(t4)), n3.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t5) => ({ u_lighting_ambient_color: new e3.bP(t5), u_lighting_directional_dir: new e3.bP(t5), u_lighting_directional_color: new e3.bP(t5), u_ground_radiance: new e3.bP(t5) }))(t4)), n3.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t5) => ({ u_light_matrix_0: new e3.bN(t5), u_light_matrix_1: new e3.bN(t5), u_fade_range: new e3.bO(t5), u_shadow_normal_offset: new e3.bP(t5), u_shadow_intensity: new e3.bQ(t5), u_shadow_texel_size: new e3.bQ(t5), u_shadow_map_resolution: new e3.bQ(t5), u_shadow_direction: new e3.bP(t5), u_shadow_bias: new e3.bP(t5), u_shadowmap_0: new e3.bR(t5), u_shadowmap_1: new e3.bR(t5) }))(t4));
            }
          }
          setTerrainUniformValues(e4, t4) {
            if (!this.terrainUniforms) return;
            const i4 = this.terrainUniforms;
            if (!this.failedToCreate) {
              e4.program.set(this.program);
              for (const e5 in t4) i4[e5] && i4[e5].set(this.program, e5, t4[e5]);
            }
          }
          setGlobeUniformValues(e4, t4) {
            if (!this.globeUniforms) return;
            const i4 = this.globeUniforms;
            if (!this.failedToCreate) {
              e4.program.set(this.program);
              for (const e5 in t4) i4[e5] && i4[e5].set(this.program, e5, t4[e5]);
            }
          }
          setFogUniformValues(e4, t4) {
            if (!this.fogUniforms) return;
            const i4 = this.fogUniforms;
            if (!this.failedToCreate) {
              e4.program.set(this.program);
              for (const e5 in t4) i4[e5].set(this.program, e5, t4[e5]);
            }
          }
          setCutoffUniformValues(e4, t4) {
            if (!this.cutoffUniforms) return;
            const i4 = this.cutoffUniforms;
            if (!this.failedToCreate) {
              e4.program.set(this.program);
              for (const e5 in t4) i4[e5].set(this.program, e5, t4[e5]);
            }
          }
          setLightsUniformValues(e4, t4) {
            if (!this.lightsUniforms) return;
            const i4 = this.lightsUniforms;
            if (!this.failedToCreate) {
              e4.program.set(this.program);
              for (const e5 in t4) i4[e5].set(this.program, e5, t4[e5]);
            }
          }
          setShadowUniformValues(e4, t4) {
            if (this.failedToCreate || !this.shadowUniforms) return;
            const i4 = this.shadowUniforms;
            e4.program.set(this.program);
            for (const e5 in t4) i4[e5].set(this.program, e5, t4[e5]);
          }
          _drawDebugWireframe(t4, i4, o3, r4, s4, n3, a4, l4, c4, h4) {
            const u5 = t4.options.wireframe;
            if (false === u5.terrain && false === u5.layers2D && false === u5.layers3D) return;
            const d3 = t4.context;
            if (!(() => !(!u5.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!u5.layers2D || t4._terrain && t4._terrain.renderingToTexture || !mr.includes(this.name)) || !(!u5.layers3D || !gr.includes(this.name)))()) return;
            const _4 = d3.gl, p4 = t4.wireframeDebugCache.getLinesFromTrianglesBuffer(t4.frameCounter, s4, d3);
            if (!p4) return;
            const f4 = [...this.fixedDefines];
            f4.push("DEBUG_WIREFRAME");
            const m4 = t4.getOrCreateProgram(this.name, { config: this.configuration, defines: f4 });
            d3.program.set(m4.program);
            const g5 = (e4, t5, i5) => {
              if (t5[e4] && i5[e4]) for (const o4 in t5[e4]) i5[e4][o4] && i5[e4][o4].set(i5.program, o4, t5[e4][o4].current);
            };
            c4 && c4.setUniforms(m4.program, d3, m4.binderUniforms, a4, { zoom: l4 }), g5("fixedUniforms", this, m4), g5("terrainUniforms", this, m4), g5("globeUniforms", this, m4), g5("fogUniforms", this, m4), g5("lightsUniforms", this, m4), g5("shadowUniforms", this, m4), p4.bind(), d3.setColorMode(new At([_4.ONE, _4.ONE_MINUS_SRC_ALPHA, _4.ZERO, _4.ONE], e3.aA.transparent, [true, true, true, false])), d3.setDepthMode(new Ct(i4.func === _4.LESS ? _4.LEQUAL : i4.func, Ct.ReadOnly, i4.range)), d3.setStencilMode(Dt.disabled);
            const v4 = 3 * n3.primitiveLength * 2, x5 = 3 * n3.primitiveOffset * 2 * 2;
            h4 && h4 > 1 ? _4.drawElementsInstanced(_4.LINES, v4, _4.UNSIGNED_SHORT, x5, h4) : _4.drawElements(_4.LINES, v4, _4.UNSIGNED_SHORT, x5), s4.bind(), d3.program.set(this.program), d3.setDepthMode(i4), d3.setStencilMode(o3), d3.setColorMode(r4);
          }
          draw(e4, t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4) {
            const m4 = e4.context, g5 = m4.gl;
            if (this.failedToCreate) return;
            m4.program.set(this.program), m4.setDepthMode(i4), m4.setStencilMode(o3), m4.setColorMode(r4), m4.setCullFace(s4);
            for (const e5 of Object.keys(this.fixedUniforms)) this.fixedUniforms[e5].set(this.program, e5, n3[e5]);
            _4 && _4.setUniforms(this.program, m4, this.binderUniforms, u5, { zoom: d3 });
            const v4 = { [g5.POINTS]: 1, [g5.LINES]: 2, [g5.TRIANGLES]: 3, [g5.LINE_STRIP]: 1 }[t4], x5 = f4 && f4 > 0 ? 1 : void 0;
            for (const s5 of h4.get()) {
              const n4 = s5.vaos || (s5.vaos = {});
              (n4[a4] || (n4[a4] = new Xo())).bind(m4, this, l4, _4 ? _4.getPaintVertexBuffers() : [], c4, s5.vertexOffset, p4 || [], x5), f4 && f4 > 1 ? g5.drawElementsInstanced(t4, s5.primitiveLength * v4, g5.UNSIGNED_SHORT, s5.primitiveOffset * v4 * 2, f4) : c4 ? g5.drawElements(t4, s5.primitiveLength * v4, g5.UNSIGNED_SHORT, s5.primitiveOffset * v4 * 2) : g5.drawArrays(t4, s5.vertexOffset, s5.vertexLength), t4 === g5.TRIANGLES && c4 && this._drawDebugWireframe(e4, i4, o3, r4, c4, s5, u5, d3, _4, f4);
            }
          }
        }
        function xr(t4, i4) {
          const o3 = Math.pow(2, i4.tileID.overscaledZ), r4 = i4.tileSize * Math.pow(2, t4.transform.tileZoom) / o3, s4 = r4 * (i4.tileID.canonical.x + i4.tileID.wrap * o3), n3 = r4 * i4.tileID.canonical.y;
          return { u_image: 0, u_texsize: i4.imageAtlasTexture ? i4.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / e3.a6(i4, 1, t4.transform.tileZoom), u_pixel_coord_upper: [s4 >> 16, n3 >> 16], u_pixel_coord_lower: [65535 & s4, 65535 & n3] };
        }
        const yr = e3.a9.create(), br = (t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4, m4) => {
          const g5 = i4.style.light, v4 = g5.properties.get("position"), x5 = [v4.x, v4.y, v4.z], y4 = e3.ct.create();
          "viewport" === g5.properties.get("anchor") && (e3.ct.fromRotation(y4, -i4.transform.angle), e3.Q.transformMat3(x5, x5, y4));
          const b4 = g5.properties.get("color"), w5 = i4.transform, T5 = { u_matrix: t4, u_lightpos: x5, u_lightintensity: g5.properties.get("intensity"), u_lightcolor: [b4.r, b4.g, b4.b], u_vertical_gradient: +o3, u_opacity: r4, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: yr, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: s4, u_edge_radius: n3, u_flood_light_color: d3, u_vertical_scale: _4, u_flood_light_intensity: p4, u_ground_shadow_factor: f4, u_emissive_strength: m4 };
          return "globe" === w5.projection.name && (T5.u_tile_id = [a4.canonical.x, a4.canonical.y, 1 << a4.canonical.z], T5.u_zoom_transition = c4, T5.u_inv_rot_matrix = u5, T5.u_merc_center = h4, T5.u_up_dir = w5.projection.upVector(new e3.bv(0, 0, 0), h4[0] * e3.Y, h4[1] * e3.Y), T5.u_height_lift = l4), T5;
        }, wr = (e4, t4, i4) => ({ u_matrix: e4, u_edge_radius: t4, u_vertical_scale: i4 }), Tr = (t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4) => {
          const f4 = br(t4, i4, o3, r4, s4, n3, a4, c4, h4, u5, d3, _4, p4, 1, [0, 0, 0], 0), m4 = { u_height_factor: -Math.pow(2, a4.overscaledZ) / l4.tileSize / 8 };
          return e3.e(f4, xr(i4, l4), m4);
        }, Er = (e4, t4) => ({ u_matrix: e4, u_emissive_strength: t4 }), Sr = (t4, i4, o3, r4) => e3.e(Er(t4, i4), xr(o3, r4)), Cr = (e4, t4, i4) => ({ u_matrix: e4, u_world: i4, u_emissive_strength: t4 }), Ir = (t4, i4, o3, r4, s4) => e3.e(Sr(t4, i4, o3, r4), { u_world: s4 }), Dr = (t4, i4, o3, r4) => {
          const s4 = e3.Y / o3.tileSize;
          return { u_matrix: t4, u_camera_to_center_distance: i4.getCameraToCenterDistance(r4), u_extrude_scale: [i4.pixelsToGLUnits[0] / s4, i4.pixelsToGLUnits[1] / s4] };
        }, Rr = (e4, t4, i4 = 1) => ({ u_matrix: e4, u_color: t4, u_overlay: 0, u_overlay_scale: i4 }), Ar = e3.a9.create(), Pr = (t4, i4, o3, r4, s4, n3, a4) => {
          const l4 = t4.transform, c4 = "globe" === l4.projection.name, h4 = c4 ? e3.cu(l4.zoom, i4.canonical) * l4._pixelsPerMercatorPixel : e3.a6(o3, 1, n3), u5 = { u_matrix: i4.projMatrix, u_extrude_scale: h4, u_intensity: a4, u_inv_rot_matrix: Ar, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (c4) {
            u5.u_inv_rot_matrix = r4, u5.u_merc_center = s4, u5.u_tile_id = [i4.canonical.x, i4.canonical.y, 1 << i4.canonical.z], u5.u_zoom_transition = e3.W(l4.zoom);
            const t5 = s4[0] * e3.Y, o4 = s4[1] * e3.Y;
            u5.u_up_dir = l4.projection.upVector(new e3.bv(0, 0, 0), t5, o4);
          }
          return u5;
        };
        function Lr(e4, [t4, i4, o3, r4], [s4, n3]) {
          if (s4 === n3) return [0, 0, 0, 0];
          const a4 = 255 * (e4 - 1) / (e4 * (n3 - s4));
          return [t4 * a4, i4 * a4, o3 * a4, r4 * a4];
        }
        function Mr(e4, t4, [i4, o3]) {
          return i4 === o3 ? 0 : 0.5 / e4 + (t4 - i4) * (e4 - 1) / (e4 * (o3 - i4));
        }
        const zr = (t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4, m4, g5, v4, x5, y4, b4) => ({ u_matrix: t4, u_normalize_matrix: i4, u_globe_matrix: o3, u_merc_matrix: r4, u_grid_matrix: s4, u_tl_parent: n3, u_scale_parent: h4, u_fade_t: u5.mix, u_opacity: u5.opacity * d3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: d3.paint.get("raster-brightness-min"), u_brightness_high: d3.paint.get("raster-brightness-max"), u_saturation_factor: e3.cv(d3.paint.get("raster-saturation")), u_contrast_factor: e3.cw(d3.paint.get("raster-contrast")), u_spin_weights: Or(d3.paint.get("raster-hue-rotate")), u_perspective_transform: _4, u_raster_elevation: p4, u_zoom_transition: a4, u_merc_center: l4, u_cutoff_params: c4, u_colorization_mix: Lr(e3.cx, m4, v4), u_colorization_offset: Mr(e3.cx, g5, v4), u_color_ramp: f4, u_texture_offset: [y4 / (x5 + 2 * y4), x5 / (x5 + 2 * y4)], u_texture_res: [x5 + 2 * y4, x5 + 2 * y4], u_emissive_strength: b4 });
        function Or(e4) {
          e4 *= Math.PI / 180;
          const t4 = Math.sin(e4), i4 = Math.cos(e4);
          return [(2 * i4 + 1) / 3, (-Math.sqrt(3) * t4 - i4 + 1) / 3, (Math.sqrt(3) * t4 - i4 + 1) / 3];
        }
        const Fr = (e4, t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5) => ({ u_matrix: e4, u_normalize_matrix: t4, u_globe_matrix: i4, u_merc_matrix: o3, u_grid_matrix: r4, u_tl_parent: s4, u_scale_parent: c4, u_fade_t: h4.mix, u_opacity: h4.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: u5, u_zoom_transition: n3, u_merc_center: a4, u_cutoff_params: l4 }), Br = (e4, t4, i4, o3, r4, s4, n3, a4, l4, c4) => ({ u_particle_texture: e4, u_particle_texture_side_len: t4, u_tile_offset: i4, u_velocity: o3, u_color_ramp: s4, u_velocity_res: r4, u_max_speed: n3, u_uv_offset: a4, u_data_scale: l4, u_data_offset: c4, u_particle_pos_scale: 1.3, u_particle_pos_offset: [Ft, Ft] }), kr = (e4, t4, i4, o3, r4, s4, n3, a4, l4, c4) => ({ u_particle_texture: e4, u_particle_texture_side_len: t4, u_velocity: i4, u_velocity_res: o3, u_max_speed: r4, u_speed_factor: s4, u_reset_rate: n3, u_rand_seed: Math.random(), u_uv_offset: a4, u_data_scale: l4, u_data_offset: c4, u_particle_pos_scale: 1.3, u_particle_pos_offset: [Ft, Ft] }), Nr = e3.a9.create(), Ur = (t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4, m4, g5, v4) => {
          const x5 = s4.transform, y4 = { u_is_size_zoom_constant: +("constant" === t4 || "source" === t4), u_is_size_feature_constant: +("constant" === t4 || "camera" === t4), u_size_t: i4 ? i4.uSizeT : 0, u_size: i4 ? i4.uSize : 0, u_camera_to_center_distance: x5.getCameraToCenterDistance(m4), u_rotate_symbol: +o3, u_aspect_ratio: x5.width / x5.height, u_fade_change: s4.options.fadeDuration ? s4.symbolFadeChange : 1, u_matrix: n3, u_label_plane_matrix: a4, u_coord_matrix: l4, u_is_text: +c4, u_pitch_with_map: +r4, u_texsize: h4, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Nr, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: Nr, u_up_vector: [0, -1, 0], u_color_adj_mat: g5, u_icon_transition: v4 || 0 };
          return "globe" === m4.name && (y4.u_tile_id = [u5.canonical.x, u5.canonical.y, 1 << u5.canonical.z], y4.u_zoom_transition = d3, y4.u_inv_rot_matrix = p4, y4.u_merc_center = _4, y4.u_camera_forward = x5._camera.forward(), y4.u_ecef_origin = e3.cy(x5.globeMatrix, u5.toUnwrapped()), y4.u_tile_matrix = Float32Array.from(x5.globeMatrix), y4.u_up_vector = f4), y4;
        }, Gr = (t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4, m4, g5) => e3.e(Ur(t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, d3, _4, p4, f4, m4, g5), { u_gamma_scale: r4 ? s4.transform.getCameraToCenterDistance(g5) * Math.cos(s4.terrain ? 0 : s4.transform._pitch) : 1, u_device_pixel_ratio: e3.f.devicePixelRatio, u_is_halo: +u5, undefined: void 0 }), jr = (t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4, m4) => e3.e(Gr(t4, i4, o3, r4, s4, n3, a4, l4, true, c4, true, u5, d3, _4, p4, f4, m4), { u_texsize_icon: h4, u_texture_icon: 1 }), Vr = (e4, t4, i4, o3) => ({ u_matrix: e4, u_emissive_strength: t4, u_opacity: i4, u_color: o3 }), Zr = (t4, i4, o3, r4, s4, n3, a4) => e3.e(function(t5, i5, o4, r5) {
          const s5 = o4.imageManager.getPattern(t5.toString(), i5), { width: n4, height: a5 } = o4.imageManager.getPixelSize(i5), l4 = Math.pow(2, r5.tileID.overscaledZ), c4 = r5.tileSize * Math.pow(2, o4.transform.tileZoom) / l4, h4 = c4 * (r5.tileID.canonical.x + r5.tileID.wrap * l4), u5 = c4 * r5.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl: s5.tl, u_pattern_br: s5.br, u_texsize: [n4, a5], u_pattern_size: s5.displaySize, u_tile_units_to_pixels: 1 / e3.a6(r5, 1, o4.transform.tileZoom), u_pixel_coord_upper: [h4 >> 16, u5 >> 16], u_pixel_coord_lower: [65535 & h4, 65535 & u5] };
        }(s4, n3, r4, a4), { u_matrix: t4, u_emissive_strength: i4, u_opacity: o3 }), Wr = new Float32Array(e3.a9.identity([])), Hr = (t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4 = [0, 0, 0], f4) => {
          const m4 = s4.style.light, g5 = m4.properties.get("position"), v4 = [-g5.x, -g5.y, g5.z], x5 = e3.ct.create();
          "viewport" === m4.properties.get("anchor") && (e3.ct.fromRotation(x5, -s4.transform.angle), e3.Q.transformMat3(v4, v4, x5));
          const y4 = "MASK" === u5.alphaMode, b4 = m4.properties.get("color"), w5 = _4.paint.get("model-ambient-occlusion-intensity"), T5 = _4.paint.get("model-color").constantOr(e3.aA.white), E3 = _4.paint.get("model-color-mix-intensity").constantOr(0);
          return { u_matrix: t4, u_lighting_matrix: i4, u_normal_matrix: o3, u_node_matrix: r4 || Wr, u_lightpos: v4, u_lightintensity: m4.properties.get("intensity"), u_lightcolor: [b4.r, b4.g, b4.b], u_camera_pos: p4, u_opacity: n3, u_baseTextureIsAlpha: 0, u_alphaMask: +y4, u_alphaCutoff: u5.alphaCutoff, u_baseColorFactor: [a4.r, a4.g, a4.b, a4.a], u_emissiveFactor: [l4[0], l4[1], l4[2], 1], u_metallicFactor: c4, u_roughnessFactor: h4, u_baseColorTexture: fo.BaseColor, u_metallicRoughnessTexture: fo.MetallicRoughness, u_normalTexture: fo.Normal, u_occlusionTexture: fo.Occlusion, u_emissionTexture: fo.Emission, u_color_mix: [T5.r, T5.g, T5.b, E3], u_aoIntensity: w5, u_emissive_strength: d3, u_occlusionTextureTransform: f4 || [0, 0, 0, 0] };
        }, qr = (e4, t4 = Wr, i4 = Wr) => ({ u_matrix: e4, u_instance: t4, u_node_matrix: i4 }), Qr = { fillExtrusion: (t4) => ({ u_matrix: new e3.bN(t4), u_lightpos: new e3.bP(t4), u_lightintensity: new e3.bQ(t4), u_lightcolor: new e3.bP(t4), u_vertical_gradient: new e3.bQ(t4), u_opacity: new e3.bQ(t4), u_edge_radius: new e3.bQ(t4), u_ao: new e3.bO(t4), u_tile_id: new e3.bP(t4), u_zoom_transition: new e3.bQ(t4), u_inv_rot_matrix: new e3.bN(t4), u_merc_center: new e3.bO(t4), u_up_dir: new e3.bP(t4), u_height_lift: new e3.bQ(t4), u_flood_light_color: new e3.bP(t4), u_vertical_scale: new e3.bQ(t4), u_flood_light_intensity: new e3.bQ(t4), u_ground_shadow_factor: new e3.bP(t4), u_emissive_strength: new e3.bQ(t4) }), fillExtrusionDepth: (t4) => ({ u_matrix: new e3.bN(t4), u_edge_radius: new e3.bQ(t4), u_vertical_scale: new e3.bQ(t4) }), fillExtrusionPattern: (t4) => ({ u_matrix: new e3.bN(t4), u_lightpos: new e3.bP(t4), u_lightintensity: new e3.bQ(t4), u_lightcolor: new e3.bP(t4), u_vertical_gradient: new e3.bQ(t4), u_height_factor: new e3.bQ(t4), u_edge_radius: new e3.bQ(t4), u_ao: new e3.bO(t4), u_tile_id: new e3.bP(t4), u_zoom_transition: new e3.bQ(t4), u_inv_rot_matrix: new e3.bN(t4), u_merc_center: new e3.bO(t4), u_up_dir: new e3.bP(t4), u_height_lift: new e3.bQ(t4), u_image: new e3.bR(t4), u_texsize: new e3.bO(t4), u_pixel_coord_upper: new e3.bO(t4), u_pixel_coord_lower: new e3.bO(t4), u_tile_units_to_pixels: new e3.bQ(t4), u_opacity: new e3.bQ(t4) }), fillExtrusionGroundEffect: (t4) => ({ u_matrix: new e3.bN(t4), u_opacity: new e3.bQ(t4), u_ao_pass: new e3.bQ(t4), u_meter_to_tile: new e3.bQ(t4), u_ao: new e3.bO(t4), u_flood_light_intensity: new e3.bQ(t4), u_flood_light_color: new e3.bP(t4), u_attenuation: new e3.bQ(t4), u_edge_radius: new e3.bQ(t4), u_fb: new e3.bR(t4), u_fb_size: new e3.bQ(t4) }), fill: (t4) => ({ u_matrix: new e3.bN(t4), u_emissive_strength: new e3.bQ(t4) }), fillPattern: (t4) => ({ u_matrix: new e3.bN(t4), u_emissive_strength: new e3.bQ(t4), u_image: new e3.bR(t4), u_texsize: new e3.bO(t4), u_pixel_coord_upper: new e3.bO(t4), u_pixel_coord_lower: new e3.bO(t4), u_tile_units_to_pixels: new e3.bQ(t4) }), fillOutline: (t4) => ({ u_matrix: new e3.bN(t4), u_emissive_strength: new e3.bQ(t4), u_world: new e3.bO(t4) }), fillOutlinePattern: (t4) => ({ u_matrix: new e3.bN(t4), u_emissive_strength: new e3.bQ(t4), u_world: new e3.bO(t4), u_image: new e3.bR(t4), u_texsize: new e3.bO(t4), u_pixel_coord_upper: new e3.bO(t4), u_pixel_coord_lower: new e3.bO(t4), u_tile_units_to_pixels: new e3.bQ(t4) }), circle: e3.cz, collisionBox: (t4) => ({ u_matrix: new e3.bN(t4), u_camera_to_center_distance: new e3.bQ(t4), u_extrude_scale: new e3.bO(t4) }), collisionCircle: (t4) => ({ u_matrix: new e3.bN(t4), u_inv_matrix: new e3.bN(t4), u_camera_to_center_distance: new e3.bQ(t4), u_viewport_size: new e3.bO(t4) }), debug: (t4) => ({ u_color: new e3.cf(t4), u_matrix: new e3.bN(t4), u_overlay: new e3.bR(t4), u_overlay_scale: new e3.bQ(t4) }), clippingMask: (t4) => ({ u_matrix: new e3.bN(t4) }), heatmap: (t4) => ({ u_extrude_scale: new e3.bQ(t4), u_intensity: new e3.bQ(t4), u_matrix: new e3.bN(t4), u_inv_rot_matrix: new e3.bN(t4), u_merc_center: new e3.bO(t4), u_tile_id: new e3.bP(t4), u_zoom_transition: new e3.bQ(t4), u_up_dir: new e3.bP(t4) }), heatmapTexture: (t4) => ({ u_image: new e3.bR(t4), u_color_ramp: new e3.bR(t4), u_opacity: new e3.bQ(t4) }), hillshade: (t4) => ({ u_matrix: new e3.bN(t4), u_image: new e3.bR(t4), u_latrange: new e3.bO(t4), u_light: new e3.bO(t4), u_shadow: new e3.cf(t4), u_highlight: new e3.cf(t4), u_emissive_strength: new e3.bQ(t4), u_accent: new e3.cf(t4) }), hillshadePrepare: (t4) => ({ u_matrix: new e3.bN(t4), u_image: new e3.bR(t4), u_dimension: new e3.bO(t4), u_zoom: new e3.bQ(t4) }), line: e3.cA, linePattern: e3.cB, raster: (t4) => ({ u_matrix: new e3.bN(t4), u_normalize_matrix: new e3.bN(t4), u_globe_matrix: new e3.bN(t4), u_merc_matrix: new e3.bN(t4), u_grid_matrix: new e3.cg(t4), u_tl_parent: new e3.bO(t4), u_scale_parent: new e3.bQ(t4), u_fade_t: new e3.bQ(t4), u_opacity: new e3.bQ(t4), u_image0: new e3.bR(t4), u_image1: new e3.bR(t4), u_brightness_low: new e3.bQ(t4), u_brightness_high: new e3.bQ(t4), u_saturation_factor: new e3.bQ(t4), u_contrast_factor: new e3.bQ(t4), u_spin_weights: new e3.bP(t4), u_perspective_transform: new e3.bO(t4), u_raster_elevation: new e3.bQ(t4), u_zoom_transition: new e3.bQ(t4), u_merc_center: new e3.bO(t4), u_cutoff_params: new e3.bS(t4), u_colorization_mix: new e3.bS(t4), u_colorization_offset: new e3.bQ(t4), u_color_ramp: new e3.bR(t4), u_texture_offset: new e3.bO(t4), u_texture_res: new e3.bO(t4), u_emissive_strength: new e3.bQ(t4) }), rasterParticle: (t4) => ({ u_matrix: new e3.bN(t4), u_normalize_matrix: new e3.bN(t4), u_globe_matrix: new e3.bN(t4), u_merc_matrix: new e3.bN(t4), u_grid_matrix: new e3.cg(t4), u_tl_parent: new e3.bO(t4), u_scale_parent: new e3.bQ(t4), u_fade_t: new e3.bQ(t4), u_opacity: new e3.bQ(t4), u_image0: new e3.bR(t4), u_image1: new e3.bR(t4), u_raster_elevation: new e3.bQ(t4), u_zoom_transition: new e3.bQ(t4), u_merc_center: new e3.bO(t4), u_cutoff_params: new e3.bS(t4) }), rasterParticleTexture: (t4) => ({ u_texture: new e3.bR(t4), u_opacity: new e3.bQ(t4) }), rasterParticleDraw: (t4) => ({ u_particle_texture: new e3.bR(t4), u_particle_texture_side_len: new e3.bQ(t4), u_tile_offset: new e3.bO(t4), u_velocity: new e3.bR(t4), u_color_ramp: new e3.bR(t4), u_velocity_res: new e3.bO(t4), u_max_speed: new e3.bQ(t4), u_uv_offset: new e3.bO(t4), u_data_scale: new e3.bS(t4), u_data_offset: new e3.bQ(t4), u_particle_pos_scale: new e3.bQ(t4), u_particle_pos_offset: new e3.bO(t4) }), rasterParticleUpdate: (t4) => ({ u_particle_texture: new e3.bR(t4), u_particle_texture_side_len: new e3.bQ(t4), u_velocity: new e3.bR(t4), u_velocity_res: new e3.bO(t4), u_max_speed: new e3.bQ(t4), u_speed_factor: new e3.bQ(t4), u_reset_rate: new e3.bQ(t4), u_rand_seed: new e3.bQ(t4), u_uv_offset: new e3.bO(t4), u_data_scale: new e3.bS(t4), u_data_offset: new e3.bQ(t4), u_particle_pos_scale: new e3.bQ(t4), u_particle_pos_offset: new e3.bO(t4) }), symbolIcon: (t4) => ({ u_is_size_zoom_constant: new e3.bR(t4), u_is_size_feature_constant: new e3.bR(t4), u_size_t: new e3.bQ(t4), u_size: new e3.bQ(t4), u_camera_to_center_distance: new e3.bQ(t4), u_rotate_symbol: new e3.bR(t4), u_aspect_ratio: new e3.bQ(t4), u_fade_change: new e3.bQ(t4), u_matrix: new e3.bN(t4), u_label_plane_matrix: new e3.bN(t4), u_coord_matrix: new e3.bN(t4), u_is_text: new e3.bR(t4), u_pitch_with_map: new e3.bR(t4), u_texsize: new e3.bO(t4), u_tile_id: new e3.bP(t4), u_zoom_transition: new e3.bQ(t4), u_inv_rot_matrix: new e3.bN(t4), u_merc_center: new e3.bO(t4), u_camera_forward: new e3.bP(t4), u_tile_matrix: new e3.bN(t4), u_up_vector: new e3.bP(t4), u_ecef_origin: new e3.bP(t4), u_texture: new e3.bR(t4), u_icon_transition: new e3.bQ(t4), u_color_adj_mat: new e3.bN(t4) }), symbolSDF: (t4) => ({ u_is_size_zoom_constant: new e3.bR(t4), u_is_size_feature_constant: new e3.bR(t4), u_size_t: new e3.bQ(t4), u_size: new e3.bQ(t4), u_camera_to_center_distance: new e3.bQ(t4), u_rotate_symbol: new e3.bR(t4), u_aspect_ratio: new e3.bQ(t4), u_fade_change: new e3.bQ(t4), u_matrix: new e3.bN(t4), u_label_plane_matrix: new e3.bN(t4), u_coord_matrix: new e3.bN(t4), u_is_text: new e3.bR(t4), u_pitch_with_map: new e3.bR(t4), u_texsize: new e3.bO(t4), u_texture: new e3.bR(t4), u_gamma_scale: new e3.bQ(t4), u_device_pixel_ratio: new e3.bQ(t4), u_tile_id: new e3.bP(t4), u_zoom_transition: new e3.bQ(t4), u_inv_rot_matrix: new e3.bN(t4), u_merc_center: new e3.bO(t4), u_camera_forward: new e3.bP(t4), u_tile_matrix: new e3.bN(t4), u_up_vector: new e3.bP(t4), u_ecef_origin: new e3.bP(t4), u_is_halo: new e3.bR(t4) }), symbolTextAndIcon: (t4) => ({ u_is_size_zoom_constant: new e3.bR(t4), u_is_size_feature_constant: new e3.bR(t4), u_size_t: new e3.bQ(t4), u_size: new e3.bQ(t4), u_camera_to_center_distance: new e3.bQ(t4), u_rotate_symbol: new e3.bR(t4), u_aspect_ratio: new e3.bQ(t4), u_fade_change: new e3.bQ(t4), u_matrix: new e3.bN(t4), u_label_plane_matrix: new e3.bN(t4), u_coord_matrix: new e3.bN(t4), u_is_text: new e3.bR(t4), u_pitch_with_map: new e3.bR(t4), u_texsize: new e3.bO(t4), u_texsize_icon: new e3.bO(t4), u_texture: new e3.bR(t4), u_texture_icon: new e3.bR(t4), u_gamma_scale: new e3.bQ(t4), u_device_pixel_ratio: new e3.bQ(t4), u_is_halo: new e3.bR(t4) }), background: (t4) => ({ u_matrix: new e3.bN(t4), u_emissive_strength: new e3.bQ(t4), u_opacity: new e3.bQ(t4), u_color: new e3.cf(t4) }), backgroundPattern: (t4) => ({ u_matrix: new e3.bN(t4), u_emissive_strength: new e3.bQ(t4), u_opacity: new e3.bQ(t4), u_image: new e3.bR(t4), u_pattern_tl: new e3.bO(t4), u_pattern_br: new e3.bO(t4), u_texsize: new e3.bO(t4), u_pattern_size: new e3.bO(t4), u_pixel_coord_upper: new e3.bO(t4), u_pixel_coord_lower: new e3.bO(t4), u_tile_units_to_pixels: new e3.bQ(t4) }), terrainRaster: tr, terrainDepth: tr, skybox: (t4) => ({ u_matrix: new e3.bN(t4), u_sun_direction: new e3.bP(t4), u_cubemap: new e3.bR(t4), u_opacity: new e3.bQ(t4), u_temporal_offset: new e3.bQ(t4) }), skyboxGradient: (t4) => ({ u_matrix: new e3.bN(t4), u_color_ramp: new e3.bR(t4), u_center_direction: new e3.bP(t4), u_radius: new e3.bQ(t4), u_opacity: new e3.bQ(t4), u_temporal_offset: new e3.bQ(t4) }), skyboxCapture: (t4) => ({ u_matrix_3f: new e3.cg(t4), u_sun_direction: new e3.bP(t4), u_sun_intensity: new e3.bQ(t4), u_color_tint_r: new e3.bS(t4), u_color_tint_m: new e3.bS(t4), u_luminance: new e3.bQ(t4) }), globeRaster: (t4) => ({ u_proj_matrix: new e3.bN(t4), u_globe_matrix: new e3.bN(t4), u_normalize_matrix: new e3.bN(t4), u_merc_matrix: new e3.bN(t4), u_zoom_transition: new e3.bQ(t4), u_merc_center: new e3.bO(t4), u_image0: new e3.bR(t4), u_grid_matrix: new e3.cg(t4), u_skirt_height: new e3.bQ(t4), u_far_z_cutoff: new e3.bQ(t4), u_frustum_tl: new e3.bP(t4), u_frustum_tr: new e3.bP(t4), u_frustum_br: new e3.bP(t4), u_frustum_bl: new e3.bP(t4), u_globe_pos: new e3.bP(t4), u_globe_radius: new e3.bQ(t4), u_viewport: new e3.bO(t4) }), globeAtmosphere: (t4) => ({ u_frustum_tl: new e3.bP(t4), u_frustum_tr: new e3.bP(t4), u_frustum_br: new e3.bP(t4), u_frustum_bl: new e3.bP(t4), u_horizon: new e3.bQ(t4), u_transition: new e3.bQ(t4), u_fadeout_range: new e3.bQ(t4), u_color: new e3.bS(t4), u_high_color: new e3.bS(t4), u_space_color: new e3.bS(t4), u_temporal_offset: new e3.bQ(t4), u_horizon_angle: new e3.bQ(t4) }), model: (t4) => ({ u_matrix: new e3.bN(t4), u_lighting_matrix: new e3.bN(t4), u_normal_matrix: new e3.bN(t4), u_node_matrix: new e3.bN(t4), u_lightpos: new e3.bP(t4), u_lightintensity: new e3.bQ(t4), u_lightcolor: new e3.bP(t4), u_camera_pos: new e3.bP(t4), u_opacity: new e3.bQ(t4), u_baseColorFactor: new e3.bS(t4), u_emissiveFactor: new e3.bS(t4), u_metallicFactor: new e3.bQ(t4), u_roughnessFactor: new e3.bQ(t4), u_baseTextureIsAlpha: new e3.bR(t4), u_alphaMask: new e3.bR(t4), u_alphaCutoff: new e3.bQ(t4), u_baseColorTexture: new e3.bR(t4), u_metallicRoughnessTexture: new e3.bR(t4), u_normalTexture: new e3.bR(t4), u_occlusionTexture: new e3.bR(t4), u_emissionTexture: new e3.bR(t4), u_color_mix: new e3.bS(t4), u_aoIntensity: new e3.bQ(t4), u_emissive_strength: new e3.bQ(t4), u_occlusionTextureTransform: new e3.bS(t4) }), modelDepth: (t4) => ({ u_matrix: new e3.bN(t4), u_instance: new e3.bN(t4), u_node_matrix: new e3.bN(t4) }), groundShadow: (t4) => ({ u_matrix: new e3.bN(t4), u_ground_shadow_factor: new e3.bP(t4) }), stars: (t4) => ({ u_matrix: new e3.bN(t4), u_up: new e3.bP(t4), u_right: new e3.bP(t4), u_intensity_multiplier: new e3.bQ(t4) }) };
        let $r;
        function Xr(t4, i4, o3, r4, s4, n3, a4) {
          const l4 = t4.context, c4 = l4.gl, h4 = t4.transform, u5 = t4.getOrCreateProgram("collisionBox"), d3 = [];
          let _4 = 0, p4 = 0;
          for (let l5 = 0; l5 < r4.length; l5++) {
            const f5 = r4[l5], m5 = i4.getTile(f5), g6 = m5.getBucket(o3);
            if (!g6) continue;
            const v5 = Pi(f5, g6, h4);
            let x6 = v5;
            0 === s4[0] && 0 === s4[1] || (x6 = t4.translatePosMatrix(v5, m5, s4, n3));
            const y5 = a4 ? g6.textCollisionBox : g6.iconCollisionBox, b4 = g6.collisionCircleArray;
            if (b4.length > 0) {
              const t5 = e3.a9.create(), i5 = x6;
              e3.a9.mul(t5, g6.placementInvProjMatrix, h4.glCoordMatrix), e3.a9.mul(t5, t5, g6.placementViewportMatrix), d3.push({ circleArray: b4, circleOffset: p4, transform: i5, invTransform: t5, projection: g6.getProjection() }), _4 += b4.length / 4, p4 = _4;
            }
            y5 && (t4.terrain && t4.terrain.setupElevationDraw(m5, u5), u5.draw(t4, c4.LINES, Ct.disabled, Dt.disabled, t4.colorModeForRenderPass(), Mt.disabled, Dr(x6, h4, m5, g6.getProjection()), o3.id, y5.layoutVertexBuffer, y5.indexBuffer, y5.segments, null, h4.zoom, null, [y5.collisionVertexBuffer, y5.collisionVertexBufferExt]));
          }
          if (!a4 || !d3.length) return;
          const f4 = t4.getOrCreateProgram("collisionCircle"), m4 = new e3.cC();
          m4.resize(4 * _4), m4._trim();
          let g5 = 0;
          for (const e4 of d3) for (let t5 = 0; t5 < e4.circleArray.length / 4; t5++) {
            const i5 = 4 * t5, o4 = e4.circleArray[i5 + 0], r5 = e4.circleArray[i5 + 1], s5 = e4.circleArray[i5 + 2], n4 = e4.circleArray[i5 + 3];
            m4.emplace(g5++, o4, r5, s5, n4, 0), m4.emplace(g5++, o4, r5, s5, n4, 1), m4.emplace(g5++, o4, r5, s5, n4, 2), m4.emplace(g5++, o4, r5, s5, n4, 3);
          }
          (!$r || $r.length < 2 * _4) && ($r = function(t5) {
            const i5 = 2 * t5, o4 = new e3.az();
            o4.resize(i5), o4._trim();
            for (let e4 = 0; e4 < i5; e4++) {
              const t6 = 6 * e4;
              o4.uint16[t6 + 0] = 4 * e4 + 0, o4.uint16[t6 + 1] = 4 * e4 + 1, o4.uint16[t6 + 2] = 4 * e4 + 2, o4.uint16[t6 + 3] = 4 * e4 + 2, o4.uint16[t6 + 4] = 4 * e4 + 3, o4.uint16[t6 + 5] = 4 * e4 + 0;
            }
            return o4;
          }(_4));
          const v4 = l4.createIndexBuffer($r, true), x5 = l4.createVertexBuffer(m4, e3.cD.members, true);
          for (const i5 of d3) {
            const r5 = { u_matrix: i5.transform, u_inv_matrix: i5.invTransform, u_camera_to_center_distance: (y4 = h4).getCameraToCenterDistance(i5.projection), u_viewport_size: [y4.width, y4.height] };
            f4.draw(t4, c4.TRIANGLES, Ct.disabled, Dt.disabled, t4.colorModeForRenderPass(), Mt.disabled, r5, o3.id, x5, v4, e3.aE.simpleSegment(0, 2 * i5.circleOffset, i5.circleArray.length, i5.circleArray.length / 2), null, h4.zoom);
          }
          var y4;
          x5.destroy(), v4.destroy();
        }
        const Yr = e3.a9.create();
        function Jr(t4) {
          const i4 = t4._camera.getWorldToCamera(t4.worldSize, 1), o3 = e3.a9.multiply([], i4, t4.globeMatrix);
          e3.a9.invert(o3, o3);
          const r4 = [0, 0, 0], s4 = [0, 1, 0, 0];
          return e3.aa.transformMat4(s4, s4, o3), r4[0] = s4[0], r4[1] = s4[1], r4[2] = s4[2], e3.Q.normalize(r4, r4), r4;
        }
        function Kr({ width: t4, height: i4, anchor: o3, textOffset: r4, textScale: s4 }, n3) {
          const { horizontalAlign: a4, verticalAlign: l4 } = e3.bi(o3), c4 = -(a4 - 0.5) * t4, h4 = -(l4 - 0.5) * i4, u5 = e3.bh(o3, r4);
          return new e3.P((c4 / s4 + u5[0]) * n3, (h4 / s4 + u5[1]) * n3);
        }
        function es(t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5) {
          const d3 = t4.text.placedSymbolArray, _4 = t4.text.dynamicLayoutVertexArray, p4 = t4.icon.dynamicLayoutVertexArray, f4 = {}, m4 = t4.getProjection(), g5 = Li(l4, m4, n3), v4 = n3.elevation, x5 = m4.upVectorScale(l4.canonical, n3.center.lat, n3.worldSize).metersToTile;
          _4.clear();
          for (let p5 = 0; p5 < d3.length; p5++) {
            const y4 = d3.get(p5), { tileAnchorX: b4, tileAnchorY: w5, numGlyphs: T5 } = y4, E3 = y4.hidden || !y4.crossTileID || t4.allowVerticalPlacement && !y4.placedOrientation ? null : r4[y4.crossTileID];
            if (E3) {
              let r5 = 0, d4 = 0, p6 = 0;
              if (v4) {
                const e4 = v4 ? v4.getAtTileOffset(l4, b4, w5) : 0, [t5, i5, o4] = m4.upVector(l4.canonical, b4, w5);
                r5 = e4 * t5 * x5, d4 = e4 * i5 * x5, p6 = e4 * o4 * x5;
              }
              let [S3, C4, I4, D4] = mi(y4.projectedAnchorX + r5, y4.projectedAnchorY + d4, y4.projectedAnchorZ + p6, o3 ? g5 : a4);
              const R2 = gi(n3.getCameraToCenterDistance(m4), D4);
              let A4 = s4.evaluateSizeForFeature(t4.textSizeData, h4, y4) * R2 / e3.bf;
              o3 && (A4 *= t4.tilePixelRatio / c4);
              const P4 = Kr(E3, A4);
              o3 ? ({ x: S3, y: C4, z: I4 } = m4.projectTilePoint(b4 + P4.x, w5 + P4.y, l4.canonical), [S3, C4, I4] = mi(S3 + r5, C4 + d4, I4 + p6, a4)) : (i4 && P4._rotate(-n3.angle), S3 += P4.x, C4 += P4.y, I4 = 0);
              const L4 = t4.allowVerticalPlacement && y4.placedOrientation === e3.b9.vertical ? Math.PI / 2 : 0;
              for (let t5 = 0; t5 < T5; t5++) e3.bc(_4, S3, C4, I4, L4);
              u5 && y4.associatedIconIndex >= 0 && (f4[y4.associatedIconIndex] = { x: S3, y: C4, z: I4, angle: L4 });
            } else Ci(T5, _4);
          }
          if (u5) {
            p4.clear();
            const i5 = t4.icon.placedSymbolArray;
            for (let t5 = 0; t5 < i5.length; t5++) {
              const o4 = i5.get(t5), { numGlyphs: r5 } = o4, s5 = f4[t5];
              if (o4.hidden || !s5) Ci(r5, p4);
              else {
                const { x: t6, y: i6, z: o5, angle: n4 } = s5;
                for (let s6 = 0; s6 < r5; s6++) e3.bc(p4, t6, i6, o5, n4);
              }
            }
            t4.icon.dynamicLayoutVertexBuffer.updateData(p4);
          }
          t4.text.dynamicLayoutVertexBuffer.updateData(_4);
        }
        function ts(t4, i4, o3, r4, s4, n3, a4 = {}) {
          const l4 = o3.paint.get("icon-translate"), c4 = o3.paint.get("text-translate"), h4 = o3.paint.get("icon-translate-anchor"), u5 = o3.paint.get("text-translate-anchor"), d3 = o3.layout.get("icon-rotation-alignment"), _4 = o3.layout.get("text-rotation-alignment"), p4 = o3.layout.get("icon-pitch-alignment"), f4 = o3.layout.get("text-pitch-alignment"), m4 = o3.layout.get("icon-keep-upright"), g5 = o3.layout.get("text-keep-upright"), v4 = o3.paint.get("icon-color-saturation"), x5 = o3.paint.get("icon-color-contrast"), y4 = o3.paint.get("icon-color-brightness-min"), b4 = o3.paint.get("icon-color-brightness-max"), w5 = t4.context, T5 = w5.gl, E3 = t4.transform, S3 = "map" === d3, C4 = "map" === _4, I4 = "map" === p4, D4 = "map" === f4, R2 = void 0 !== o3.layout.get("symbol-sort-key").constantOr(1);
          let A4 = false;
          const P4 = t4.depthModeForSublayer(0, Ct.ReadOnly), L4 = [e3.a8(E3.center.lng), e3.ah(E3.center.lat)], M3 = o3.layout.get("text-variable-anchor"), z4 = "globe" === E3.projection.name, O3 = [], F5 = [0, -1, 0];
          for (const s5 of r4) {
            const r5 = i4.getTile(s5), n4 = r5.getBucket(o3);
            if (!n4) continue;
            if ("mercator" === n4.projection.name && z4) continue;
            if (n4.fullyClipped) continue;
            const d4 = "globe" === n4.projection.name, _5 = d4 ? e3.W(E3.zoom) : 0, p5 = Li(s5, n4.getProjection(), E3), f5 = E3.calculatePixelsToTileUnitsMatrix(r5), w6 = M3 && n4.hasTextData(), P5 = n4.hasIconTextFit() && w6 && n4.hasIconData(), B4 = n4.getProjection().createInversionMatrix(E3, s5.canonical), k4 = () => {
              const i5 = S3 && "point" !== o3.layout.get("symbol-placement"), a5 = [], c5 = i5 || P5, u6 = o3.paint.get("icon-image-cross-fade").constantOr(0);
              t4.terrainRenderModeElevated() && I4 && a5.push("PITCH_WITH_MAP_TERRAIN"), d4 && (a5.push("PROJECTION_GLOBE_VIEW"), c5 && a5.push("PROJECTED_POS_ON_VIEWPORT")), u6 > 0 && a5.push("ICON_TRANSITION"), n4.icon.zOffsetVertexBuffer && a5.push("Z_OFFSET"), 0 === v4 && 0 === x5 && 0 === y4 && 1 === b4 || a5.push("COLOR_ADJUSTMENT");
              const g6 = n4.icon.programConfigurations.get(o3.id), w7 = t4.getOrCreateProgram(n4.sdfIcons ? "symbolSDF" : "symbolIcon", { config: g6, defines: a5 });
              let C5;
              const D5 = r5.imageAtlasTexture ? r5.imageAtlasTexture.size : [0, 0], R3 = n4.iconSizeData, A5 = e3.b8(R3, E3.zoom), M4 = I4 || 0 !== E3.pitch, O4 = _i(p5, r5.tileID.canonical, I4, S3, E3, n4.getProjection(), f5), k5 = fi(p5, r5.tileID.canonical, I4, S3, E3, n4.getProjection(), f5), N5 = t4.translatePosMatrix(k5, r5, l4, h4, true), U4 = t4.translatePosMatrix(p5, r5, l4, h4), G5 = c5 ? Yr : O4, j6 = S3 && !I4 && !i5;
              let V5 = F5;
              !z4 && !E3.mercatorFromTransition || S3 || (V5 = Jr(E3));
              const Z4 = d4 ? V5 : F5;
              if (n4.sdfIcons && !n4.iconsInText) C5 = Gr(R3.kind, A5, j6, I4, t4, U4, G5, N5, false, D5, true, s5, _5, L4, B4, Z4, n4.getProjection());
              else {
                const e4 = o3.getColorAdjustmentMatrix(v4, x5, y4, b4);
                C5 = Ur(R3.kind, A5, j6, I4, t4, U4, G5, N5, false, D5, s5, _5, L4, B4, Z4, n4.getProjection(), e4, u6);
              }
              const W4 = r5.imageAtlasTexture ? r5.imageAtlasTexture : null, H4 = 1 !== o3.layout.get("icon-size").constantOr(0) || n4.iconsNeedLinear, q4 = n4.sdfIcons || t4.options.rotating || t4.options.zooming || H4 || M4 ? T5.LINEAR : T5.NEAREST, Q3 = n4.sdfIcons && 0 !== o3.paint.get("icon-halo-width").constantOr(1), $4 = t4.terrain && I4 && i5 ? e3.a9.invert(e3.a9.create(), O4) : Yr;
              if (i5 && n4.icon) {
                const e4 = E3.elevation, i6 = e4 ? e4.getAtTileOffsetFunc(s5, E3.center.lat, E3.worldSize, n4.getProjection()) : null, o4 = pi(p5, r5.tileID.canonical, I4, S3, E3, n4.getProjection(), f5);
                xi(n4, p5, t4, false, o4, k5, I4, m4, i6, s5);
              }
              return { program: w7, buffers: n4.icon, uniformValues: C5, atlasTexture: W4, atlasTextureIcon: null, atlasInterpolation: q4, atlasInterpolationIcon: null, isSDF: n4.sdfIcons, hasHalo: Q3, tile: r5, labelPlaneMatrixInv: $4 };
            }, N4 = () => {
              const i5 = C4 && "point" !== o3.layout.get("symbol-placement"), a5 = [], l5 = i5 || M3 || P5;
              t4.terrainRenderModeElevated() && D4 && a5.push("PITCH_WITH_MAP_TERRAIN"), d4 && (a5.push("PROJECTION_GLOBE_VIEW"), l5 && a5.push("PROJECTED_POS_ON_VIEWPORT")), n4.text.zOffsetVertexBuffer && a5.push("Z_OFFSET");
              const h5 = n4.text.programConfigurations.get(o3.id), m5 = t4.getOrCreateProgram(n4.iconsInText ? "symbolTextAndIcon" : "symbolSDF", { config: h5, defines: a5 });
              let v5, x6 = [0, 0], y5 = null;
              const b5 = n4.textSizeData;
              n4.iconsInText && (x6 = r5.imageAtlasTexture ? r5.imageAtlasTexture.size : [0, 0], y5 = r5.imageAtlasTexture ? r5.imageAtlasTexture : null, v5 = D4 || 0 !== E3.pitch || t4.options.rotating || t4.options.zooming || "composite" === b5.kind || "camera" === b5.kind ? T5.LINEAR : T5.NEAREST);
              const w7 = r5.glyphAtlasTexture ? r5.glyphAtlasTexture.size : [0, 0], S4 = e3.b8(b5, E3.zoom), I5 = _i(p5, r5.tileID.canonical, D4, C4, E3, n4.getProjection(), f5), R3 = fi(p5, r5.tileID.canonical, D4, C4, E3, n4.getProjection(), f5), A5 = t4.translatePosMatrix(R3, r5, c4, u5, true), O4 = t4.translatePosMatrix(p5, r5, c4, u5), k5 = l5 ? Yr : I5, N5 = C4 && !D4 && !i5;
              let U4 = F5;
              !z4 && !E3.mercatorFromTransition || C4 || (U4 = Jr(E3));
              const G5 = d4 ? U4 : F5;
              let j6;
              j6 = n4.iconsInText ? jr(b5.kind, S4, N5, D4, t4, O4, k5, A5, w7, x6, s5, _5, L4, B4, G5, n4.getProjection()) : Gr(b5.kind, S4, N5, D4, t4, O4, k5, A5, true, w7, true, s5, _5, L4, B4, G5, n4.getProjection());
              const V5 = r5.glyphAtlasTexture ? r5.glyphAtlasTexture : null, Z4 = T5.LINEAR, W4 = 0 !== o3.paint.get("text-halo-width").constantOr(1), H4 = t4.terrain && D4 && i5 ? e3.a9.invert(e3.a9.create(), I5) : Yr;
              if (i5 && n4.text) {
                const e4 = E3.elevation, i6 = e4 ? e4.getAtTileOffsetFunc(s5, E3.center.lat, E3.worldSize, n4.getProjection()) : null, o4 = pi(p5, r5.tileID.canonical, D4, C4, E3, n4.getProjection(), f5);
                xi(n4, p5, t4, true, o4, R3, D4, g5, i6, s5);
              }
              return { program: m5, buffers: n4.text, uniformValues: j6, atlasTexture: V5, atlasTextureIcon: y5, atlasInterpolation: Z4, atlasInterpolationIcon: v5, isSDF: true, hasHalo: W4, tile: r5, labelPlaneMatrixInv: H4 };
            }, U3 = n4.icon.segments.get().length, G4 = n4.text.segments.get().length, j5 = U3 && !a4.onlyText ? k4() : null, V4 = G4 && !a4.onlyIcons ? N4() : null, Z3 = o3.paint.get("icon-opacity").constantOr(1), W3 = o3.paint.get("text-opacity").constantOr(1);
            if (R2 && n4.canOverlap) {
              A4 = true;
              const t5 = Z3 && !a4.onlyText ? n4.icon.segments.get() : [], i5 = W3 && !a4.onlyIcons ? n4.text.segments.get() : [];
              for (const i6 of t5) O3.push({ segments: new e3.aE([i6]), sortKey: i6.sortKey, state: j5 });
              for (const t6 of i5) O3.push({ segments: new e3.aE([t6]), sortKey: t6.sortKey, state: V4 });
            } else a4.onlyText || O3.push({ segments: Z3 ? n4.icon.segments : new e3.aE([]), sortKey: 0, state: j5 }), a4.onlyIcons || O3.push({ segments: W3 ? n4.text.segments : new e3.aE([]), sortKey: 0, state: V4 });
          }
          A4 && O3.sort((e4, t5) => e4.sortKey - t5.sortKey);
          for (const e4 of O3) {
            const i5 = e4.state;
            if (i5) if (t4.terrain && t4.terrain.setupElevationDraw(i5.tile, i5.program, { useDepthForOcclusion: E3.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: i5.labelPlaneMatrixInv }), w5.activeTexture.set(T5.TEXTURE0), i5.atlasTexture && i5.atlasTexture.bind(i5.atlasInterpolation, T5.CLAMP_TO_EDGE, true), i5.atlasTextureIcon && (w5.activeTexture.set(T5.TEXTURE1), i5.atlasTextureIcon && i5.atlasTextureIcon.bind(i5.atlasInterpolationIcon, T5.CLAMP_TO_EDGE, true)), t4.uploadCommonLightUniforms(t4.context, i5.program), i5.hasHalo) {
              const r5 = i5.uniformValues;
              r5.u_is_halo = 1, is(i5.buffers, e4.segments, o3, t4, i5.program, P4, s4, n3, r5, 2), r5.u_is_halo = 0;
            } else {
              if (i5.isSDF) {
                const r5 = i5.uniformValues;
                i5.hasHalo && (r5.u_is_halo = 1, is(i5.buffers, e4.segments, o3, t4, i5.program, P4, s4, n3, r5, 1)), r5.u_is_halo = 0;
              }
              is(i5.buffers, e4.segments, o3, t4, i5.program, P4, s4, n3, i5.uniformValues, 1);
            }
          }
        }
        function is(e4, t4, i4, o3, r4, s4, n3, a4, l4, c4) {
          const h4 = [e4.dynamicLayoutVertexBuffer, e4.opacityVertexBuffer, e4.iconTransitioningVertexBuffer, e4.globeExtVertexBuffer, e4.zOffsetVertexBuffer];
          r4.draw(o3, o3.context.gl.TRIANGLES, s4, n3, a4, Mt.disabled, l4, i4.id, e4.layoutVertexBuffer, e4.indexBuffer, t4, i4.paint, o3.transform.zoom, e4.programConfigurations.get(i4.id), h4, c4);
        }
        function os(e4, t4, i4, o3, r4, s4, n3) {
          const a4 = e4.context.gl, l4 = i4.paint.get("fill-pattern"), c4 = l4 && l4.constantOr(1);
          let h4, u5, d3, _4, p4;
          n3 ? (u5 = c4 && !i4.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", h4 = a4.LINES) : (u5 = c4 ? "fillPattern" : "fill", h4 = a4.TRIANGLES);
          for (const f4 of o3) {
            const o4 = t4.getTile(f4);
            if (c4 && !o4.patternsLoaded()) continue;
            const m4 = o4.getBucket(i4);
            if (!m4) continue;
            e4.prepareDrawTile();
            const g5 = m4.programConfigurations.get(i4.id), v4 = e4.isTileAffectedByFog(f4), x5 = e4.getOrCreateProgram(u5, { config: g5, overrideFog: v4 });
            c4 && (e4.context.activeTexture.set(a4.TEXTURE0), o4.imageAtlasTexture && o4.imageAtlasTexture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE), g5.updatePaintBuffers());
            const y4 = l4.constantOr(null);
            if (y4 && o4.imageAtlas) {
              const e5 = o4.imageAtlas.patternPositions[y4.toString()];
              e5 && g5.setConstantPatternPositions(e5);
            }
            const b4 = e4.translatePosMatrix(f4.projMatrix, o4, i4.paint.get("fill-translate"), i4.paint.get("fill-translate-anchor")), w5 = i4.paint.get("fill-emissive-strength");
            if (n3) {
              _4 = m4.indexBuffer2, p4 = m4.segments2;
              const t5 = e4.terrain && e4.terrain.renderingToTexture ? e4.terrain.drapeBufferSize : [a4.drawingBufferWidth, a4.drawingBufferHeight];
              d3 = "fillOutlinePattern" === u5 && c4 ? Ir(b4, w5, e4, o4, t5) : Cr(b4, w5, t5);
            } else _4 = m4.indexBuffer, p4 = m4.segments, d3 = c4 ? Sr(b4, w5, e4, o4) : Er(b4, w5);
            e4.uploadCommonUniforms(e4.context, x5, f4.toUnwrapped()), x5.draw(e4, h4, r4, e4.stencilModeForClipping(f4), s4, Mt.disabled, d3, i4.id, m4.layoutVertexBuffer, _4, p4, i4.paint, e4.transform.zoom, g5, void 0);
          }
        }
        function rs(t4, i4, o3, r4, s4, n3, a4, l4) {
          o3.resetLayerRenderingStats(t4);
          const c4 = t4.context, h4 = c4.gl, u5 = t4.transform, d3 = o3.paint.get("fill-extrusion-pattern"), _4 = d3.constantOr(1), p4 = o3.paint.get("fill-extrusion-opacity"), f4 = t4.style.enable3dLights(), m4 = o3.paint.get(f4 && !_4 ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), g5 = [o3.paint.get("fill-extrusion-ambient-occlusion-intensity"), m4], v4 = o3.layout.get("fill-extrusion-edge-radius"), x5 = v4 > 0 && !o3.paint.get("fill-extrusion-rounded-roof"), y4 = x5 ? 0 : v4, b4 = "globe" === u5.projection.name ? e3.cM() : 0, w5 = "globe" === u5.projection.name, T5 = w5 ? e3.W(u5.zoom) : 0, E3 = [e3.a8(u5.center.lng), e3.ah(u5.center.lat)], S3 = o3.paint.get("fill-extrusion-flood-light-color").toArray01().slice(0, 3), C4 = o3.paint.get("fill-extrusion-flood-light-intensity"), I4 = o3.paint.get("fill-extrusion-vertical-scale"), D4 = mo(t4, o3.paint.get("fill-extrusion-cutoff-fade-range")), R2 = o3.paint.get("fill-extrusion-emissive-strength"), A4 = [];
          let P4;
          w5 && A4.push("PROJECTION_GLOBE_VIEW"), g5[0] > 0 && A4.push("FAUX_AO"), x5 && A4.push("ZERO_ROOF_RADIUS"), l4 && A4.push("HAS_CENTROID"), C4 > 0 && A4.push("FLOOD_LIGHT"), D4.shouldRenderCutoff && A4.push("RENDER_CUTOFF");
          const L4 = "shadow" === t4.renderPass, M3 = t4.shadowRenderer, z4 = L4 && !!M3;
          t4.shadowRenderer && (t4.shadowRenderer.useNormalOffset = true);
          let O3 = [0, 0, 0];
          if (M3) {
            const e4 = t4.style.directionalLight, i5 = t4.style.ambientLight;
            e4 && i5 && (O3 = To(e4, i5)), P4 = A4.concat(["SHADOWS_SINGLE_CASCADE"]);
          }
          const F5 = z4 ? "fillExtrusionDepth" : _4 ? "fillExtrusionPattern" : "fillExtrusion", B4 = o3.getLayerRenderingStats();
          for (const e4 of r4) {
            const r5 = i4.getTile(e4), f5 = r5.getBucket(o3);
            if (!f5 || f5.projection.name !== u5.projection.name) continue;
            let m5 = false;
            M3 && (m5 = 0 === M3.getMaxCascadeForTile(e4.toUnwrapped()));
            const v5 = t4.isTileAffectedByFog(e4), x6 = f5.programConfigurations.get(o3.id), z5 = t4.getOrCreateProgram(F5, { config: x6, defines: m5 ? P4 : A4, overrideFog: v5 });
            if (t4.terrain && t4.terrain.setupElevationDraw(r5, z5, { useMeterToDem: true }), !f5.centroidVertexBuffer) {
              const e5 = z5.attributes.a_centroid_pos;
              void 0 !== e5 && h4.vertexAttrib2f(e5, 0, 0);
            }
            !L4 && M3 && M3.setupShadows(r5.tileID.toUnwrapped(), z5, "vector-tile", r5.tileID.overscaledZ), _4 && (t4.context.activeTexture.set(h4.TEXTURE0), r5.imageAtlasTexture && r5.imageAtlasTexture.bind(h4.LINEAR, h4.CLAMP_TO_EDGE), x6.updatePaintBuffers());
            const k4 = d3.constantOr(null);
            if (k4 && r5.imageAtlas) {
              const e5 = r5.imageAtlas.patternPositions[k4.toString()];
              e5 && x6.setConstantPatternPositions(e5);
            }
            const N4 = o3.paint.get("fill-extrusion-vertical-gradient");
            let U3;
            if (L4 && M3) {
              if (hs(r5.tileID, f5, t4)) continue;
              const e5 = M3.calculateShadowPassMatrixFromTile(r5.tileID.toUnwrapped());
              U3 = wr(e5, y4, I4);
            } else {
              const i5 = t4.translatePosMatrix(e4.expandedProjMatrix, r5, o3.paint.get("fill-extrusion-translate"), o3.paint.get("fill-extrusion-translate-anchor")), s5 = u5.projection.createInversionMatrix(u5, e4.canonical);
              U3 = _4 ? Tr(i5, t4, N4, p4, g5, y4, e4, r5, b4, T5, E3, s5, S3, I4) : br(i5, t4, N4, p4, g5, y4, e4, b4, T5, E3, s5, S3, I4, C4, O3, R2);
            }
            t4.uploadCommonUniforms(c4, z5, e4.toUnwrapped(), null, D4);
            let G4 = f5.segments;
            if ("mercator" === u5.projection.name && !L4 && (G4 = f5.getVisibleSegments(r5.tileID, t4.terrain, t4.transform.getFrustum(0)), !G4.get().length)) continue;
            if (B4) if (L4) for (const e5 of G4.get()) B4.numRenderedVerticesInShadowPass += e5.primitiveLength;
            else for (const e5 of G4.get()) B4.numRenderedVerticesInTransparentPass += e5.primitiveLength;
            const j5 = [];
            (t4.terrain || l4) && j5.push(f5.centroidVertexBuffer), w5 && j5.push(f5.layoutVertexExtBuffer), z5.draw(t4, c4.gl.TRIANGLES, s4, n3, a4, Mt.backCCW, U3, o3.id, f5.layoutVertexBuffer, f5.indexBuffer, G4, o3.paint, t4.transform.zoom, x6, j5);
          }
          t4.shadowRenderer && (t4.shadowRenderer.useNormalOffset = false);
        }
        function ss(t4, i4, o3, r4, s4, n3, a4, l4, c4, h4, u5, d3, _4, p4, f4, m4, g5, v4, x5) {
          const y4 = t4.context, b4 = y4.gl, w5 = t4.transform, T5 = t4.transform.zoom, E3 = [], S3 = mo(t4, o3.paint.get("fill-extrusion-cutoff-fade-range"));
          "clear" === h4 ? (E3.push("CLEAR_SUBPASS"), x5 && (E3.push("CLEAR_FROM_TEXTURE"), y4.activeTexture.set(b4.TEXTURE0), x5.bind(b4.LINEAR, b4.CLAMP_TO_EDGE))) : "sdf" === h4 && E3.push("SDF_SUBPASS"), g5 && E3.push("HAS_CENTROID"), S3.shouldRenderCutoff && E3.push("RENDER_CUTOFF");
          const C4 = o3.layout.get("fill-extrusion-edge-radius"), I4 = (e4, i5, r5, h5, v5) => {
            const b5 = i5.programConfigurations.get(o3.id), w6 = t4.isTileAffectedByFog(e4), I5 = t4.getOrCreateProgram("fillExtrusionGroundEffect", { config: b5, defines: E3, overrideFog: w6 }), D4 = /* @__PURE__ */ ((e5, t5, i6, o4, r6, s5, n4, a5, l5, c5, h6) => ({ u_matrix: t5, u_opacity: i6, u_ao_pass: o4 ? 1 : 0, u_meter_to_tile: r6, u_ao: s5, u_flood_light_intensity: n4, u_flood_light_color: a5, u_attenuation: l5, u_edge_radius: c5, u_fb: 0, u_fb_size: h6 }))(0, h5, u5, c4, v5, [d3, _4 * v5], p4, f4, m4, T5 >= 17 ? 0 : C4 * v5, x5 ? x5.size[0] : 0), R2 = [];
            g5 && R2.push(i5.hiddenByLandmarkVertexBuffer), t4.uploadCommonUniforms(y4, I5, e4.toUnwrapped(), null, S3), I5.draw(t4, y4.gl.TRIANGLES, s4, n3, a4, l4, D4, o3.id, i5.vertexBuffer, i5.indexBuffer, r5, o3.paint, T5, b5, R2);
          };
          for (const s5 of r4) {
            const r5 = i4.getTile(s5), n4 = r5.getBucket(o3);
            if (!n4 || n4.projection.name !== w5.projection.name || !n4.groundEffect || n4.groundEffect && !n4.groundEffect.hasData()) continue;
            const a5 = n4.groundEffect, l5 = 1 / n4.tileToMeter;
            {
              const e4 = t4.translatePosMatrix(s5.projMatrix, r5, o3.paint.get("fill-extrusion-translate"), o3.paint.get("fill-extrusion-translate-anchor")), i5 = a5.getDefaultSegment();
              I4(s5, a5, i5, e4, l5);
            }
            if (v4) for (let n5 = 0; n5 < 4; n5++) {
              const a6 = e3.cN[n5](s5), c5 = i4.getTile(a6);
              if (!c5) continue;
              const h5 = c5.getBucket(o3);
              if (!h5 || h5.projection.name !== w5.projection.name || !h5.groundEffect || h5.groundEffect && !h5.groundEffect.hasData()) continue;
              const u6 = h5.groundEffect;
              let d4, _5;
              0 === n5 ? (d4 = [-e3.Y, 0, 0], _5 = 1) : 1 === n5 ? (d4 = [e3.Y, 0, 0], _5 = 0) : 2 === n5 ? (d4 = [0, -e3.Y, 0], _5 = 3) : (d4 = [0, e3.Y, 0], _5 = 2);
              const p5 = u6.regionSegments[_5];
              if (!p5) continue;
              const f5 = new Float32Array(16);
              e3.a9.translate(f5, s5.projMatrix, d4), I4(s5, u6, p5, t4.translatePosMatrix(f5, r5, o3.paint.get("fill-extrusion-translate"), o3.paint.get("fill-extrusion-translate-anchor")), l5);
            }
          }
        }
        function ns(t4, i4, o3, r4, s4, n3, a4) {
          0 === r4.centroidVertexArray.length && r4.createCentroidsBuffer();
          const l4 = n3 ? n3.findDEMTileFor(o3) : null;
          if (!(l4 && l4.dem || a4)) return;
          const c4 = (t5) => new e3.P(Math.ceil((t5 + e3.cQ) * e3.cR), 0), h4 = (e4) => {
            const t5 = i4.getSource().minzoom, o4 = (e5) => {
              const t6 = i4.getTileByID(e5);
              if (t6 && t6.hasData()) return t6.getBucket(s4);
            }, r5 = [0, -1, 1];
            for (const i5 of r5) {
              if (e4.overscaledZ + i5 < t5) continue;
              const r6 = o4(e4.calculateScaledKey(e4.overscaledZ + i5));
              if (r6) return r6;
            }
          }, u5 = [0, 0, 0], d3 = (t5, i5) => (u5[0] = Math.min(t5.min.y, i5.min.y), u5[1] = Math.max(t5.max.y, i5.max.y), u5[2] = e3.Y - i5.min.x > t5.max.x ? i5.min.x - e3.Y : t5.max.x, u5), _4 = (t5, i5) => (u5[0] = Math.min(t5.min.x, i5.min.x), u5[1] = Math.max(t5.max.x, i5.max.x), u5[2] = e3.Y - i5.min.y > t5.max.y ? i5.min.y - e3.Y : t5.max.y, u5), p4 = [(e4, t5) => d3(e4, t5), (e4, t5) => d3(t5, e4), (e4, t5) => _4(e4, t5), (e4, t5) => _4(t5, e4)], f4 = (t5, i5, r5, s5, a5, c5, h5) => {
            if (!n3) return 0;
            const u6 = [[c5 ? r5 : t5, c5 ? t5 : r5, 0], [c5 ? r5 : i5, c5 ? i5 : r5, 0]], d4 = h5 < 0 ? e3.Y + h5 : h5, _5 = [c5 ? d4 : (t5 + i5) / 2, c5 ? (t5 + i5) / 2 : d4, 0];
            return 0 === r5 && h5 < 0 || 0 !== r5 && h5 > 0 ? n3.getForTilePoints(a5, [_5], true, s5) : u6.push(_5), n3.getForTilePoints(o3, u6, true, l4), Math.max(u6[0][2], u6[1][2], _5[2]) / n3.exaggeration();
          };
          for (let t5 = 0; t5 < 4; t5++) {
            const i5 = r4.borderFeatureIndices[t5];
            if (0 === i5.length) continue;
            const s5 = e3.cN[t5](o3), l5 = h4(s5);
            if (!(l5 && l5 instanceof e3.cO)) continue;
            if (r4.borderDoneWithNeighborZ[t5] === l5.canonical.z) continue;
            0 === l5.centroidVertexArray.length && l5.createCentroidsBuffer();
            const u6 = n3 ? n3.findDEMTileFor(s5) : null;
            if (!(u6 && u6.dem || a4)) continue;
            const d4 = (t5 < 2 ? 1 : 5) - t5, _5 = l5.borderDoneWithNeighborZ[d4] !== r4.canonical.z, v4 = l5.borderFeatureIndices[d4];
            let x5 = 0;
            if (r4.canonical.z !== l5.canonical.z) {
              for (const e4 of i5) r4.showCentroid(r4.featuresOnBorder[e4]);
              if (_5) for (const e4 of v4) l5.showCentroid(l5.featuresOnBorder[e4]);
              r4.borderDoneWithNeighborZ[t5] = l5.canonical.z, l5.borderDoneWithNeighborZ[d4] = r4.canonical.z;
            }
            for (const o4 of i5) {
              const i6 = r4.featuresOnBorder[o4], n4 = r4.centroidData[i6.centroidDataIndex], h5 = i6.borders[t5];
              let _6;
              for (; x5 < v4.length; ) {
                _6 = l5.featuresOnBorder[v4[x5]];
                const e4 = _6.borders[d4];
                if (e4[1] > h5[0] + 3 || e4[0] > h5[0] - 3) break;
                l5.showCentroid(_6), x5++;
              }
              if (_6 && x5 < v4.length) {
                const o5 = x5;
                let y4 = 0;
                for (; !(_6.borders[d4][0] > h5[1] - 3) && (y4++, ++x5 !== v4.length); ) _6 = l5.featuresOnBorder[v4[x5]];
                if (_6 = l5.featuresOnBorder[v4[o5]], y4 > 1) {
                  const e4 = _6.borders[d4];
                  Math.abs(h5[0] - e4[0]) < 3 && Math.abs(h5[1] - e4[1]) < 3 && (y4 = 1, x5 = o5 + 1);
                } else if (0 === y4) {
                  r4.showCentroid(i6);
                  continue;
                }
                const b4 = l5.centroidData[_6.centroidDataIndex];
                a4 && 1 === y4 && (((m4 = n4).flags | (g5 = b4).flags) & e3.cP ? (m4.flags |= e3.cP, g5.flags |= e3.cP) : (m4.flags &= ~e3.cP, g5.flags &= ~e3.cP));
                const w5 = i6.intersectsCount() > 1 || _6.intersectsCount() > 1;
                if (y4 > 1) x5 = o5, n4.centroidXY = b4.centroidXY = new e3.P(0, 0);
                else if (u6 && u6.dem && !w5) {
                  const i7 = p4[t5](n4, b4), o6 = t5 % 2 ? e3.Y - 1 : 0, r5 = f4(i7[0], Math.min(e3.Y - 1, i7[1]), o6, u6, s5, t5 < 2, i7[2]);
                  n4.centroidXY = b4.centroidXY = c4(r5);
                } else w5 ? n4.centroidXY = b4.centroidXY = new e3.P(0, 0) : (n4.centroidXY = r4.encodeBorderCentroid(i6), b4.centroidXY = l5.encodeBorderCentroid(_6));
                r4.writeCentroidToBuffer(n4), l5.writeCentroidToBuffer(b4);
              } else r4.showCentroid(i6);
            }
            r4.borderDoneWithNeighborZ[t5] = l5.canonical.z, l5.borderDoneWithNeighborZ[d4] = r4.canonical.z;
          }
          var m4, g5;
          (r4.needsCentroidUpdate || !r4.centroidVertexBuffer && 0 !== r4.centroidVertexArray.length) && r4.uploadCentroid(t4);
        }
        const as = [1, 0, 0], ls = [0, 1, 0], cs = [0, 0, 1];
        function hs(t4, i4, o3) {
          const r4 = o3.transform, s4 = o3.shadowRenderer;
          if (!s4) return true;
          const n3 = t4.toUnwrapped(), a4 = r4.tileSize * s4._cascades[o3.currentShadowCascade].scale;
          let l4 = i4.maxHeight;
          if (r4.elevation) {
            const e4 = r4.elevation.getMinMaxForTile(t4);
            e4 && (l4 += e4.max);
          }
          const c4 = [...s4.shadowDirection];
          c4[2] = -c4[2];
          const h4 = s4.computeSimplifiedTileShadowVolume(n3, l4, a4, c4);
          if (!h4) return false;
          const u5 = [as, ls, cs, c4, [c4[0], 0, c4[2]], [0, c4[1], c4[2]]], d3 = "globe" === r4.projection.name, _4 = r4.scaleZoom(a4), p4 = e3.bt.fromInvProjectionMatrix(r4.invProjMatrix, r4.worldSize, _4, !d3), f4 = s4.getCurrentCascadeFrustum();
          return 0 === p4.intersectsPrecise(h4.vertices, h4.planes, u5) || 0 === f4.intersectsPrecise(h4.vertices, h4.planes, u5);
        }
        function us(t4) {
          return [t4[0] * e3.cS, t4[1] * e3.cS, t4[2] * e3.cS, 0];
        }
        function ds(t4, i4, o3, r4, s4, n3, a4, l4, c4) {
          const h4 = r4.getSource(), u5 = o3.globeSharedBuffers;
          if (!u5) return;
          let d3, _4, p4;
          if (i4 && (d3 = r4.getTile(i4)), h4 instanceof e3.as ? (_4 = h4.texture, p4 = e3.co(0, 0, o3.transform)) : d3 && i4 && (_4 = d3.texture, p4 = e3.co(i4.canonical.z, i4.canonical.x, o3.transform)), !_4 || !p4) return;
          t4 || (p4 = e3.a9.scale(e3.a9.create(), p4, [1, -1, 1]));
          const f4 = o3.context, m4 = f4.gl, g5 = "nearest" === s4.paint.get("raster-resampling") ? m4.NEAREST : m4.LINEAR, v4 = o3.colorModeForDrapableLayerRenderPass(n3), x5 = a4.defines;
          x5.push("GLOBE_POLES");
          const y4 = new Ct(m4.LEQUAL, Ct.ReadWrite, o3.depthRangeFor3D), b4 = Float32Array.from(o3.transform.expandedFarZProjMatrix), w5 = Float32Array.from(e3.aW(e3.cn(new e3.bv(0, 0, 0))));
          o3.terrain && o3.terrain.prepareDrawTile(), f4.activeTexture.set(m4.TEXTURE0), _4.bind(g5, m4.CLAMP_TO_EDGE), f4.activeTexture.set(m4.TEXTURE1), _4.bind(g5, m4.CLAMP_TO_EDGE), _4.useMipmap && f4.extTextureFilterAnisotropic && o3.transform.pitch > 20 && m4.texParameterf(m4.TEXTURE_2D, f4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f4.extTextureFilterAnisotropicMax);
          const [T5, E3, S3, C4] = i4 ? u5.getPoleBuffers(i4.canonical.z, false) : u5.getPoleBuffers(0, true), I4 = s4.paint.get("raster-elevation");
          let D4;
          t4 ? (D4 = T5, o3.renderDefaultNorthPole = 0 !== I4) : (D4 = E3, o3.renderDefaultSouthPole = 0 !== I4);
          const R2 = us(a4.mix), A4 = ((e4, t5, i5, o4, r5, s5, n4, a5, l5, c5, h5, u6, d4) => zr(e4, t5, i5, new Float32Array(16), new Float32Array(9), [0, 0], o4, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, s5, [0, 0], a5, 2, c5, h5, u6, 1, 0, d4))(b4, w5, p4, e3.W(o3.transform.zoom), 0, s4, 0, I4, 0, R2, a4.offset, a4.range, n3), P4 = o3.getOrCreateProgram("raster", { defines: x5 });
          o3.uploadCommonUniforms(f4, P4, null), P4.draw(o3, m4.TRIANGLES, y4, c4, v4, l4, A4, s4.id, D4, S3, C4);
        }
        function _s(e4) {
          const t4 = e4._nearZ, i4 = e4.projection.farthestPixelDistance(e4), o3 = i4 - t4, r4 = 0.2 * e4.height, s4 = t4 + r4;
          return [t4, i4, (s4 - r4 - t4) / o3, (s4 - t4) / o3];
        }
        function ps(e4, t4, i4, o3) {
          if (e4) return t4 instanceof Pe && e4 instanceof Ht ? t4.getTextureDescriptor(e4, i4, true) : { texture: e4.texture, mix: us(o3.mix), offset: o3.offset, buffer: 0, tileSize: 1 };
        }
        function fs(t4, i4, o3) {
          if (!t4) return null;
          const r4 = i4.getTextureDescriptor(t4, o3, true);
          if (!r4) return null;
          let { texture: s4, mix: n3, offset: a4, tileSize: l4, buffer: c4, format: h4 } = r4;
          if (!s4 || !h4) return null;
          let u5 = false;
          return "uint32" === h4 && (u5 = true, n3[3] = 0, n3 = Lr(e3.cT, n3, [0, o3.paint.get("raster-particle-max-speed")]), a4 = Mr(e3.cT, a4, [0, o3.paint.get("raster-particle-max-speed")])), { texture: s4, textureOffset: [c4 / (l4 + 2 * c4), l4 / (l4 + 2 * c4)], tileSize: l4, scalarData: u5, scale: n3, offset: a4, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[h4]] };
        }
        function ms(e4) {
          const t4 = e4._nearZ, i4 = e4.projection.farthestPixelDistance(e4), o3 = i4 - t4, r4 = 0.2 * e4.height, s4 = t4 + r4;
          return [t4, i4, (s4 - r4 - t4) / o3, (s4 - t4) / o3];
        }
        const gs = new e3.aA(1, 0, 0, 1), vs = new e3.aA(0, 1, 0, 1), xs = new e3.aA(0, 0, 1, 1), ys = new e3.aA(1, 0, 1, 1), bs = new e3.aA(0, 1, 1, 1);
        function ws(t4, i4, o3, r4, s4, n3, a4) {
          const l4 = t4.context, c4 = t4.transform, h4 = l4.gl, u5 = "globe" === c4.projection.name, d3 = u5 ? ["PROJECTION_GLOBE_VIEW"] : [];
          let _4 = e3.a9.clone(o3.projMatrix);
          if (u5 && e3.W(c4.zoom) > 0) {
            const t5 = e3.aV(o3.canonical, c4), i5 = e3.cU(t5);
            _4 = e3.a9.multiply(new Float32Array(16), c4.globeMatrix, i5), e3.a9.multiply(_4, c4.projMatrix, _4);
          }
          const p4 = e3.a9.create();
          p4[12] += 2 * s4 / (e3.f.devicePixelRatio * c4.width), p4[13] += 2 * n3 / (e3.f.devicePixelRatio * c4.height), e3.a9.multiply(_4, p4, _4);
          const f4 = t4.getOrCreateProgram("debug", { defines: d3 }), m4 = i4.getTileByID(o3.key);
          t4.terrain && t4.terrain.setupElevationDraw(m4, f4);
          const g5 = Ct.disabled, v4 = Dt.disabled, x5 = t4.colorModeForRenderPass(), y4 = "$debug";
          l4.activeTexture.set(h4.TEXTURE0), t4.emptyTexture.bind(h4.LINEAR, h4.CLAMP_TO_EDGE), u5 ? m4._makeGlobeTileDebugBuffers(t4.context, c4) : m4._makeDebugTileBoundsBuffers(t4.context, c4.projection);
          const b4 = m4._tileDebugBuffer || t4.debugBuffer, w5 = m4._tileDebugIndexBuffer || t4.debugIndexBuffer, T5 = m4._tileDebugSegments || t4.debugSegments;
          if (f4.draw(t4, h4.LINE_STRIP, g5, v4, x5, Mt.disabled, Rr(_4, r4), y4, b4, w5, T5, null, null, null, [m4._globeTileDebugBorderBuffer]), a4) {
            const e4 = m4.latestRawTileData, i5 = Math.floor((e4 && e4.byteLength || 0) / 1024);
            let r5 = o3.canonical.toString();
            o3.overscaledZ !== o3.canonical.z && (r5 += ` => ${o3.overscaledZ}`), r5 += ` ${m4.state}`, r5 += ` ${i5}kb`, function(e5, t5) {
              e5.initDebugOverlayCanvas();
              const i6 = e5.debugOverlayCanvas, o4 = e5.context.gl, r6 = e5.debugOverlayCanvas.getContext("2d");
              r6.clearRect(0, 0, i6.width, i6.height), r6.shadowColor = "white", r6.shadowBlur = 2, r6.lineWidth = 1.5, r6.strokeStyle = "white", r6.textBaseline = "top", r6.font = "bold 36px Open Sans, sans-serif", r6.fillText(t5, 5, 5), r6.strokeText(t5, 5, 5), e5.debugOverlayTexture.update(i6), e5.debugOverlayTexture.bind(o4.LINEAR, o4.CLAMP_TO_EDGE);
            }(t4, r5);
          }
          const E3 = i4.getTile(o3).tileSize, S3 = 512 / Math.min(E3, 512) * (o3.overscaledZ / c4.zoom) * 0.5, C4 = m4._tileDebugTextBuffer || t4.debugBuffer, I4 = m4._tileDebugTextIndexBuffer || t4.quadTriangleIndexBuffer, D4 = m4._tileDebugTextSegments || t4.debugSegments;
          f4.draw(t4, h4.TRIANGLES, g5, v4, At.alphaBlended, Mt.disabled, Rr(_4, e3.aA.transparent, S3), y4, C4, I4, D4, null, null, null, [m4._globeTileDebugTextBuffer]);
        }
        function Ts(e4, t4, i4, o3) {
          Ss(e4, 0, t4 + i4 / 2, e4.transform.width, i4, o3);
        }
        function Es(e4, t4, i4, o3) {
          Ss(e4, t4 - i4 / 2, 0, i4, e4.transform.height, o3);
        }
        function Ss(t4, i4, o3, r4, s4, n3) {
          const a4 = t4.context, l4 = a4.gl;
          l4.enable(l4.SCISSOR_TEST), l4.scissor(i4 * e3.f.devicePixelRatio, o3 * e3.f.devicePixelRatio, r4 * e3.f.devicePixelRatio, s4 * e3.f.devicePixelRatio), a4.clear({ color: n3 }), l4.disable(l4.SCISSOR_TEST);
        }
        const Cs = e3.aB([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Is } = Cs;
        function Ds(e4, t4, i4, o3) {
          e4.emplaceBack(t4, i4, o3);
        }
        class Rs {
          constructor(t4) {
            this.vertexArray = new e3.cV(), this.indices = new e3.az(), Ds(this.vertexArray, -1, -1, 1), Ds(this.vertexArray, 1, -1, 1), Ds(this.vertexArray, -1, 1, 1), Ds(this.vertexArray, 1, 1, 1), Ds(this.vertexArray, -1, -1, -1), Ds(this.vertexArray, 1, -1, -1), Ds(this.vertexArray, -1, 1, -1), Ds(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t4.createVertexBuffer(this.vertexArray, Is), this.indexBuffer = t4.createIndexBuffer(this.indices), this.segment = e3.aE.simpleSegment(0, 0, 36, 12);
          }
        }
        function As(t4, i4, o3, r4, s4, n3) {
          const a4 = t4.context.gl, l4 = i4.paint.get("sky-atmosphere-color"), c4 = i4.paint.get("sky-atmosphere-halo-color"), h4 = i4.paint.get("sky-atmosphere-sun-intensity"), u5 = ((e4, t5, i5, o4, r5) => ({ u_matrix_3f: e4, u_sun_direction: t5, u_sun_intensity: i5, u_color_tint_r: [o4.r, o4.g, o4.b, o4.a], u_color_tint_m: [r5.r, r5.g, r5.b, r5.a], u_luminance: 5e-5 }))(e3.ct.fromMat4(e3.ct.create(), r4), s4, h4, l4, c4);
          a4.framebufferTexture2D(a4.FRAMEBUFFER, a4.COLOR_ATTACHMENT0, a4.TEXTURE_CUBE_MAP_POSITIVE_X + n3, i4.skyboxTexture, 0), o3.draw(t4, a4.TRIANGLES, Ct.disabled, Dt.disabled, At.unblended, Mt.frontCW, u5, "skyboxCapture", i4.skyboxGeometry.vertexBuffer, i4.skyboxGeometry.indexBuffer, i4.skyboxGeometry.segment);
        }
        const Ps = e3.aB([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
        class Ls {
          constructor(t4) {
            const i4 = new e3.cW();
            i4.emplaceBack(-1, 1, 1, 0, 0), i4.emplaceBack(1, 1, 1, 1, 0), i4.emplaceBack(1, -1, 1, 1, 1), i4.emplaceBack(-1, -1, 1, 0, 1);
            const o3 = new e3.az();
            o3.emplaceBack(0, 1, 2), o3.emplaceBack(2, 3, 0), this.vertexBuffer = t4.createVertexBuffer(i4, Ps.members), this.indexBuffer = t4.createIndexBuffer(o3), this.segments = e3.aE.simpleSegment(0, 0, 4, 2);
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
          }
        }
        const Ms = e3.aB([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
        class zs {
          constructor() {
            this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
          }
        }
        class Os {
          constructor(t4) {
            this.colorModeAlphaBlendedWriteRGB = new At([1, Rt, 1, Rt], e3.aA.transparent, [true, true, true, false]), this.colorModeWriteAlpha = new At([1, 0, 1, 0], e3.aA.transparent, [false, false, false, true]), this.params = new zs(), this.updateNeeded = true, t4.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => {
              this.updateNeeded = true;
            }), t4.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 }), t4.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => {
              this.updateNeeded = true;
            }), t4.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => {
              this.updateNeeded = true;
            });
          }
          update(t4) {
            const i4 = t4.context;
            if (!this.atmosphereBuffer || this.updateNeeded) {
              this.updateNeeded = false, this.atmosphereBuffer = new Ls(i4);
              const t5 = this.params.sizeRange, o3 = this.params.intensityRange, r4 = function(t6) {
                const i5 = e3.aC(30), o4 = [];
                for (let r5 = 0; r5 < t6; ++r5) {
                  const t7 = 2 * Math.PI * i5(), r6 = Math.acos(1 - 2 * i5()) - 0.5 * Math.PI;
                  o4.push(e3.Q.fromValues(Math.cos(r6) * Math.cos(t7), Math.cos(r6) * Math.sin(t7), Math.sin(r6)));
                }
                return o4;
              }(this.params.starsCount), s4 = e3.aC(300), n3 = new e3.cX(), a4 = new e3.az();
              let l4 = 0;
              for (let i5 = 0; i5 < r4.length; ++i5) {
                const c4 = e3.Q.scale([], r4[i5], 200), h4 = Math.max(0, 1 + 0.01 * t5 * (1 * s4() - 0.5)), u5 = Math.max(0, 1 + 0.01 * o3 * (1 * s4() - 0.5));
                n3.emplaceBack(c4[0], c4[1], c4[2], -1, -1, h4, u5), n3.emplaceBack(c4[0], c4[1], c4[2], 1, -1, h4, u5), n3.emplaceBack(c4[0], c4[1], c4[2], 1, 1, h4, u5), n3.emplaceBack(c4[0], c4[1], c4[2], -1, 1, h4, u5), a4.emplaceBack(l4 + 0, l4 + 1, l4 + 2), a4.emplaceBack(l4 + 0, l4 + 2, l4 + 3), l4 += 4;
              }
              this.starsVx = i4.createVertexBuffer(n3, Ms.members), this.starsIdx = i4.createIndexBuffer(a4), this.starsSegments = e3.aE.simpleSegment(0, 0, n3.length, a4.length);
            }
          }
          destroy() {
            this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
          }
          drawAtmosphereGlow(t4, i4) {
            const o3 = t4.context, r4 = o3.gl, s4 = t4.transform, n3 = new Ct(r4.LEQUAL, Ct.ReadOnly, [0, 1]), a4 = e3.W(s4.zoom), l4 = i4.properties.get("color").toArray01(), c4 = i4.properties.get("high-color").toArray01(), h4 = i4.properties.get("space-color").toArray01PremultipliedAlpha(), u5 = 5e-4, d3 = e3.cY(i4.properties.get("horizon-blend"), 0, 1, u5, 0.25), _4 = e3.ci(t4, o3, s4) && d3 === u5 ? s4.worldSize / (2 * Math.PI * 1.025) - 1 : s4.globeRadius, p4 = t4.frameCounter / 1e3 % 1, f4 = e3.Q.length(s4.globeCenterInViewSpace), m4 = Math.sqrt(Math.pow(f4, 2) - Math.pow(_4, 2)), g5 = Math.acos(m4 / f4), v4 = (e4) => {
              const i5 = "globe" === s4.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
              e4 && i5.push("ALPHA_PASS");
              const u6 = t4.getOrCreateProgram("globeAtmosphere", { defines: i5 }), _5 = /* @__PURE__ */ ((e5, t5, i6, o4, r5, s5, n4, a5, l5, c5, h5, u7) => ({ u_frustum_tl: e5, u_frustum_tr: t5, u_frustum_br: i6, u_frustum_bl: o4, u_horizon: r5, u_transition: s5, u_fadeout_range: n4, u_color: a5, u_high_color: l5, u_space_color: c5, u_temporal_offset: h5, u_horizon_angle: u7 }))(s4.frustumCorners.TL, s4.frustumCorners.TR, s4.frustumCorners.BR, s4.frustumCorners.BL, s4.frustumCorners.horizon, a4, d3, l4, c4, h4, p4, g5);
              t4.uploadCommonUniforms(o3, u6);
              const f5 = this.atmosphereBuffer;
              f5 && u6.draw(t4, r4.TRIANGLES, n3, Dt.disabled, e4 ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Mt.backCW, _5, e4 ? "atmosphere_glow_alpha" : "atmosphere_glow", f5.vertexBuffer, f5.indexBuffer, f5.segments);
            };
            v4(false), v4(true);
          }
          drawStars(t4, i4) {
            const o3 = e3.ad(i4.properties.get("star-intensity"), 0, 1);
            if (0 === o3) return;
            const r4 = t4.context, s4 = r4.gl, n3 = t4.transform, a4 = t4.getOrCreateProgram("stars"), l4 = e3.bl.identity([]);
            e3.bl.rotateX(l4, l4, -n3._pitch), e3.bl.rotateZ(l4, l4, -n3.angle), e3.bl.rotateX(l4, l4, e3.bm(n3._center.lat)), e3.bl.rotateY(l4, l4, -e3.bm(n3._center.lng));
            const c4 = e3.a9.fromQuat(new Float32Array(16), l4), h4 = e3.a9.multiply([], n3.starsProjMatrix, c4), u5 = e3.ct.fromMat4([], c4), d3 = e3.ct.invert([], u5), _4 = [0, 1, 0];
            e3.Q.transformMat3(_4, _4, d3), e3.Q.scale(_4, _4, this.params.sizeMultiplier);
            const p4 = [1, 0, 0];
            e3.Q.transformMat3(p4, p4, d3), e3.Q.scale(p4, p4, this.params.sizeMultiplier);
            const f4 = (m4 = _4, g5 = p4, v4 = o3, { u_matrix: Float32Array.from(h4), u_up: m4, u_right: g5, u_intensity_multiplier: v4 });
            var m4, g5, v4;
            t4.uploadCommonUniforms(r4, a4), this.starsVx && this.starsIdx && a4.draw(t4, s4.TRIANGLES, Ct.disabled, Dt.disabled, this.colorModeAlphaBlendedWriteRGB, Mt.disabled, f4, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
          }
        }
        function Fs(t4, i4) {
          const o3 = [...t4], r4 = i4.cameraWorldSizeForFog / i4.worldSize, s4 = e3.a9.identity([]);
          return e3.a9.scale(s4, s4, [r4, r4, 1]), e3.a9.multiply(o3, s4, o3), e3.a9.multiply(o3, i4.worldToFogMatrix, o3), o3;
        }
        function Bs(e4, t4, i4, o3) {
          const r4 = i4.material, s4 = o3.context, { baseColorTexture: n3, metallicRoughnessTexture: a4 } = r4.pbrMetallicRoughness, { normalTexture: l4, occlusionTexture: c4, emissionTexture: h4 } = r4;
          function u5(t5, i5, o4) {
            if (t5 && (e4.push(i5), s4.activeTexture.set(s4.gl.TEXTURE0 + o4), t5.gfxTexture)) {
              const { minFilter: e5, magFilter: i6, wrapS: o5, wrapT: r5 } = t5.sampler;
              t5.gfxTexture.bindExtraParam(e5, i6, o5, r5);
            }
          }
          u5(n3, "HAS_TEXTURE_u_baseColorTexture", fo.BaseColor), u5(a4, "HAS_TEXTURE_u_metallicRoughnessTexture", fo.MetallicRoughness), u5(l4, "HAS_TEXTURE_u_normalTexture", fo.Normal), u5(c4, "HAS_TEXTURE_u_occlusionTexture", fo.Occlusion), u5(h4, "HAS_TEXTURE_u_emissionTexture", fo.Emission), i4.texcoordBuffer && (e4.push("HAS_ATTRIBUTE_a_uv_2f"), t4.push(i4.texcoordBuffer)), i4.colorBuffer && (e4.push(12 === i4.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), t4.push(i4.colorBuffer)), i4.normalBuffer && (e4.push("HAS_ATTRIBUTE_a_normal_3f"), t4.push(i4.normalBuffer)), i4.pbrBuffer && (e4.push("HAS_ATTRIBUTE_a_pbr"), e4.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), t4.push(i4.pbrBuffer)), "OPAQUE" !== r4.alphaMode && "MASK" !== r4.alphaMode || e4.push("UNPREMULT_TEXTURE_IN_SHADER"), r4.defined || e4.push("DIFFUSE_SHADED"), e4.push("USE_STANDARD_DERIVATIVES");
        }
        function ks(t4, i4, o3, r4, s4, n3) {
          const a4 = o3.paint.get("model-opacity"), l4 = i4.context, c4 = new Ct(i4.context.gl.LEQUAL, Ct.ReadWrite, i4.depthRangeFor3D), h4 = i4.transform, u5 = t4.mesh, d3 = u5.material, _4 = d3.pbrMetallicRoughness, p4 = i4.style.fog;
          let f4;
          f4 = "pixels" === i4.transform.projection.zAxisUnit ? [...t4.nodeModelMatrix] : e3.a9.multiply([], r4.zScaleMatrix, t4.nodeModelMatrix), e3.a9.multiply(f4, r4.negCameraPosMatrix, f4);
          const m4 = e3.a9.invert([], f4);
          e3.a9.transpose(m4, m4);
          const g5 = o3.paint.get("model-emissive-strength").constantOr(0), v4 = Hr(new Float32Array(t4.worldViewProjection), new Float32Array(f4), new Float32Array(m4), null, i4, a4, _4.baseColorFactor, d3.emissiveFactor, _4.metallicFactor, _4.roughnessFactor, d3, g5, o3), x5 = { defines: [] }, y4 = [];
          Bs(x5.defines, y4, u5, i4);
          const b4 = i4.shadowRenderer;
          b4 && (b4.useNormalOffset = false);
          let w5 = null;
          if (p4) {
            const e4 = Fs(t4.nodeModelMatrix, i4.transform);
            if (w5 = new Float32Array(e4), "globe" !== h4.projection.name) {
              const t5 = u5.aabb.min, i5 = u5.aabb.max, [o4, r5] = p4.getOpacityForBounds(e4, t5[0], t5[1], i5[0], i5[1]);
              x5.overrideFog = o4 >= _e || r5 >= _e;
            }
          }
          const T5 = mo(i4, o3.paint.get("model-cutoff-fade-range"));
          T5.shouldRenderCutoff && x5.defines.push("RENDER_CUTOFF");
          const E3 = i4.getOrCreateProgram("model", x5);
          i4.uploadCommonUniforms(l4, E3, null, w5, T5), "shadow" !== i4.renderPass && b4 && b4.setupShadowsFromMatrix(t4.nodeModelMatrix, E3), E3.draw(i4, l4.gl.TRIANGLES, c4, s4, n3, u5.material.doubleSided ? Mt.disabled : Mt.backCCW, v4, o3.id, u5.vertexBuffer, u5.indexBuffer, u5.segments, o3.paint, i4.transform.zoom, void 0, y4);
        }
        function Ns(t4, i4, o3, r4, s4, n3, a4) {
          let l4;
          l4 = "globe" === t4.projection.name ? e3.c_(o3, t4) : [...o3], e3.a9.multiply(l4, l4, i4.matrix);
          const c4 = e3.a9.multiply([], r4, l4);
          if (i4.meshes) for (const t5 of i4.meshes) {
            if ("BLEND" !== t5.material.alphaMode) {
              a4.push({ mesh: t5, depth: 0, modelIndex: s4, worldViewProjection: c4, nodeModelMatrix: l4 });
              continue;
            }
            const i5 = e3.Q.transformMat4([], t5.centroid, c4);
            i5[2] > 0 && n3.push({ mesh: t5, depth: i5[2], modelIndex: s4, worldViewProjection: c4, nodeModelMatrix: l4 });
          }
          if (i4.children) for (const e4 of i4.children) Ns(t4, e4, o3, r4, s4, n3, a4);
        }
        function Us(e4, t4, i4, o3) {
          const r4 = i4.shadowRenderer;
          if (!r4) return;
          const s4 = r4.getShadowPassDepthMode(), n3 = r4.getShadowPassColorMode(), a4 = r4.calculateShadowPassMatrixFromMatrix(t4), l4 = qr(a4);
          i4.getOrCreateProgram("modelDepth", { defines: i4._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(i4, i4.context.gl.TRIANGLES, s4, Dt.disabled, n3, Mt.backCCW, l4, o3.id, e4.vertexBuffer, e4.indexBuffer, e4.segments, o3.paint, i4.transform.zoom, void 0, void 0);
        }
        function Gs(t4, i4, o3) {
          const r4 = i4.updateZoomBasedPaintProperties(), s4 = function(t5, i5, o4) {
            let r5, s5, n3, a4 = t5.terrain ? t5.terrain.exaggeration() : 0;
            if (t5.terrain && a4 > 0) {
              const i6 = t5.terrain, s6 = i6.findDEMTileFor(o4);
              s6 && s6.dem ? r5 = e3.d0.create(i6, o4, s6) : a4 = 0;
            }
            if (0 === a4 && (i5.terrainElevationMin = 0, i5.terrainElevationMax = 0), a4 === i5.validForExaggeration && (0 === a4 || r5 && r5._demTile && r5._demTile.tileID === i5.validForDEMTile.id && r5._dem._timestamp === i5.validForDEMTile.timestamp)) return false;
            for (const e4 in i5.instancesPerModel) {
              const t6 = i5.instancesPerModel[e4];
              for (let e5 = 0; e5 < t6.instancedDataArray.length; ++e5) {
                const o5 = (r5 ? a4 * r5.getElevationAt(0 | t6.instancedDataArray.float32[16 * e5], 0 | t6.instancedDataArray.float32[16 * e5 + 1], true, true) : 0) + t6.instancesEvaluatedElevation[e5];
                t6.instancedDataArray.float32[16 * e5 + 6] = o5, s5 = s5 ? Math.min(i5.terrainElevationMin, o5) : o5, n3 = n3 ? Math.max(i5.terrainElevationMax, o5) : o5;
              }
            }
            return i5.terrainElevationMin = s5 || 0, i5.terrainElevationMax = n3 || 0, i5.validForExaggeration = a4, i5.validForDEMTile = r5 && r5._demTile ? { id: r5._demTile.tileID, timestamp: r5._dem._timestamp } : { id: void 0, timestamp: 0 }, true;
          }(t4, i4, o3);
          (r4 || s4) && (i4.uploaded = false, i4.upload(t4.context));
        }
        const js = { shadowUniformsInitialized: false, useSingleShadowCascade: false, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new e3.bV([0, 0, 0], [e3.Y, e3.Y, 0]) };
        function Vs(t4, i4) {
          const o3 = 1 << t4.canonical.z, r4 = i4.getFreeCameraOptions().position, s4 = i4.elevation, n3 = t4.canonical.x / o3, a4 = (t4.canonical.x + 1) / o3, l4 = t4.canonical.y / o3, c4 = (t4.canonical.y + 1) / o3;
          let h4 = i4._centerAltitude;
          if (s4) {
            const e4 = s4.getMinMaxForTile(t4);
            e4 && e4.max > h4 && (h4 = e4.max);
          }
          const u5 = e3.ad(r4.x, n3, a4) - r4.x, d3 = e3.ad(r4.y, l4, c4) - r4.y, _4 = e3.bo(h4, i4.center.lat) - r4.z;
          return i4._zoomFromMercatorZ(Math.sqrt(u5 * u5 + d3 * d3 + _4 * _4));
        }
        function Zs(e4, t4, i4, o3, r4, s4, n3) {
          const a4 = e4.context, l4 = "shadow" === e4.renderPass, c4 = e4.shadowRenderer, h4 = l4 && c4 ? c4.getShadowPassDepthMode() : new Ct(a4.gl.LEQUAL, Ct.ReadWrite, e4.depthRangeFor3D), u5 = e4.isTileAffectedByFog(s4);
          if (i4.meshes) for (const d3 of i4.meshes) {
            const _4 = ["MODEL_POSITION_ON_GPU"], p4 = [];
            let f4, m4, g5;
            o3.instancedDataArray.length > 20 && _4.push("INSTANCED_ARRAYS");
            const v4 = mo(e4, t4.paint.get("model-cutoff-fade-range"));
            if (v4.shouldRenderCutoff && _4.push("RENDER_CUTOFF"), l4 && c4) f4 = e4.getOrCreateProgram("modelDepth", { defines: _4 }), m4 = qr(n3.shadowTileMatrix, n3.shadowTileMatrix, Float32Array.from(i4.matrix)), g5 = c4.getShadowPassColorMode();
            else {
              Bs(_4, p4, d3, e4), f4 = e4.getOrCreateProgram("model", { defines: _4, overrideFog: u5 });
              const o4 = d3.material, l5 = o4.pbrMetallicRoughness, h5 = t4.paint.get("model-opacity"), x6 = t4.paint.get("model-emissive-strength").constantOr(0);
              m4 = Hr(s4.expandedProjMatrix, Float32Array.from(i4.matrix), new Float32Array(16), null, e4, h5, l5.baseColorFactor, o4.emissiveFactor, l5.metallicFactor, l5.roughnessFactor, o4, x6, t4, r4), c4 && (n3.shadowUniformsInitialized ? f4.setShadowUniformValues(a4, c4.getShadowUniformValues()) : (c4.setupShadows(s4.toUnwrapped(), f4, "model-tile", s4.overscaledZ), n3.shadowUniformsInitialized = true)), g5 = v4.shouldRenderCutoff || h5 < 1 || "OPAQUE" !== o4.alphaMode ? At.alphaBlended : At.unblended;
            }
            e4.uploadCommonUniforms(a4, f4, s4.toUnwrapped(), null, v4);
            const x5 = d3.material.doubleSided ? Mt.disabled : Mt.backCCW;
            if (o3.instancedDataArray.length > 20) p4.push(o3.instancedDataBuffer), f4.draw(e4, a4.gl.TRIANGLES, h4, Dt.disabled, g5, x5, m4, t4.id, d3.vertexBuffer, d3.indexBuffer, d3.segments, t4.paint, e4.transform.zoom, void 0, p4, o3.instancedDataArray.length);
            else {
              const i5 = l4 ? "u_instance" : "u_normal_matrix";
              for (let r5 = 0; r5 < o3.instancedDataArray.length; ++r5) m4[i5] = new Float32Array(o3.instancedDataArray.arrayBuffer, 64 * r5, 16), f4.draw(e4, a4.gl.TRIANGLES, h4, Dt.disabled, g5, x5, m4, t4.id, d3.vertexBuffer, d3.indexBuffer, d3.segments, t4.paint, e4.transform.zoom, void 0, p4);
            }
          }
          if (i4.children) for (const a5 of i4.children) Zs(e4, t4, a5, o3, r4, s4, n3);
        }
        const Ws = [1, -1, 1];
        function Hs(t4, i4, o3, r4) {
          if (!o3.modelManager) return true;
          const s4 = o3.modelManager;
          if (!o3.shadowRenderer) return true;
          const n3 = o3.shadowRenderer, a4 = i4.aabb;
          let l4 = true, c4 = t4.maxHeight;
          if (0 === c4) {
            let e4 = 0;
            for (const i5 in t4.instancesPerModel) {
              const t5 = s4.getModel(i5, r4);
              t5 ? e4 = Math.max(e4, Math.max(Math.max(t5.aabb.max[0], t5.aabb.max[1]), t5.aabb.max[2])) : l4 = false;
            }
            c4 = t4.maxScale * e4 * 1.41 + t4.maxVerticalOffset, l4 && (t4.maxHeight = c4);
          }
          a4.max[2] = c4, a4.min[2] += t4.terrainElevationMin, a4.max[2] += t4.terrainElevationMax, e3.Q.transformMat4(a4.min, a4.min, i4.tileMatrix), e3.Q.transformMat4(a4.max, a4.max, i4.tileMatrix);
          const h4 = a4.intersects(n3.getCurrentCascadeFrustum());
          return 0 === o3.currentShadowCascade && (t4.isInsideFirstShadowMapFrustum = 2 === h4), 0 === h4;
        }
        class qs {
        }
        class Qs {
          constructor() {
            this._storage = /* @__PURE__ */ new Map();
          }
          getLinesFromTrianglesBuffer(t4, i4, o3) {
            {
              const e4 = this._storage.get(i4.id);
              if (e4) return e4.lastUsedFrameIdx = t4, e4.buf;
            }
            const r4 = o3.gl, s4 = r4.getBufferParameter(r4.ELEMENT_ARRAY_BUFFER, r4.BUFFER_SIZE), n3 = new ArrayBuffer(s4), a4 = new Int16Array(n3);
            r4.getBufferSubData(r4.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n3));
            const l4 = new e3.d2();
            for (let e4 = 0; e4 < s4 / 2; e4 += 3) {
              const t5 = a4[e4], i5 = a4[e4 + 1], o4 = a4[e4 + 2];
              l4.emplaceBack(t5, i5), l4.emplaceBack(i5, o4), l4.emplaceBack(o4, t5);
            }
            const c4 = o3.bindVertexArrayOES.current, h4 = new qs();
            return h4.buf = new Ne(o3, l4), h4.lastUsedFrameIdx = t4, this._storage.set(i4.id, h4), o3.bindVertexArrayOES.set(c4), h4.buf;
          }
          update(e4) {
            for (const [t4, i4] of this._storage) e4 - i4.lastUsedFrameIdx > 30 && (i4.buf.destroy(), this._storage.delete(t4));
          }
          destroy() {
            for (const [e4, t4] of this._storage) t4.buf.destroy(), this._storage.delete(e4);
          }
        }
        const $s = { symbol: function(t4, i4, o3, r4, s4) {
          if ("translucent" !== t4.renderPass) return;
          const n3 = Dt.disabled, a4 = t4.colorModeForRenderPass();
          o3.layout.get("text-variable-anchor") && function(t5, i5, o4, r5, s5, n4, a5) {
            const l5 = i5.transform, c5 = "map" === s5, h4 = "map" === n4;
            for (const i6 of t5) {
              const t6 = r5.getTile(i6), s6 = t6.getBucket(o4);
              if (!s6 || !s6.text || !s6.text.segments.get().length) continue;
              const n5 = e3.b8(s6.textSizeData, l5.zoom), u5 = Li(i6, s6.getProjection(), l5), d3 = l5.calculatePixelsToTileUnitsMatrix(t6), _4 = _i(u5, t6.tileID.canonical, h4, c5, l5, s6.getProjection(), d3), p4 = s6.hasIconTextFit() && s6.hasIconData();
              if (n5) {
                const o5 = Math.pow(2, l5.zoom - t6.tileID.overscaledZ);
                es(s6, c5, h4, a5, e3.cE, l5, _4, i6, o5, n5, p4);
              }
            }
          }(r4, t4, o3, i4, o3.layout.get("text-rotation-alignment"), o3.layout.get("text-pitch-alignment"), s4);
          const l4 = 0 !== o3.paint.get("icon-opacity").constantOr(1), c4 = 0 !== o3.paint.get("text-opacity").constantOr(1);
          void 0 !== o3.layout.get("symbol-sort-key").constantOr(1) && (l4 || c4) ? ts(t4, i4, o3, r4, n3, a4) : (l4 && ts(t4, i4, o3, r4, n3, a4, { onlyIcons: true }), c4 && ts(t4, i4, o3, r4, n3, a4, { onlyText: true })), i4.map.showCollisionBoxes && (Xr(t4, i4, o3, r4, o3.paint.get("text-translate"), o3.paint.get("text-translate-anchor"), true), Xr(t4, i4, o3, r4, o3.paint.get("icon-translate"), o3.paint.get("icon-translate-anchor"), false));
        }, circle: function(t4, i4, o3, r4) {
          if ("translucent" !== t4.renderPass) return;
          const s4 = o3.paint.get("circle-opacity"), n3 = o3.paint.get("circle-stroke-width"), a4 = o3.paint.get("circle-stroke-opacity"), l4 = void 0 !== o3.layout.get("circle-sort-key").constantOr(1), c4 = o3.paint.get("circle-emissive-strength");
          if (0 === s4.constantOr(1) && (0 === n3.constantOr(1) || 0 === a4.constantOr(1))) return;
          const h4 = t4.context, u5 = h4.gl, d3 = t4.transform, _4 = t4.depthModeForSublayer(0, Ct.ReadOnly), p4 = Dt.disabled, f4 = t4.colorModeForDrapableLayerRenderPass(c4), m4 = "globe" === d3.projection.name, g5 = [e3.a8(d3.center.lng), e3.ah(d3.center.lat)], v4 = [];
          for (let s5 = 0; s5 < r4.length; s5++) {
            const n4 = r4[s5], a5 = i4.getTile(n4), c5 = a5.getBucket(o3);
            if (!c5 || c5.projection.name !== d3.projection.name) continue;
            const h5 = c5.programConfigurations.get(o3.id), u6 = e3.cF(o3), _5 = t4.isTileAffectedByFog(n4);
            m4 && u6.push("PROJECTION_GLOBE_VIEW");
            const p5 = t4.getOrCreateProgram("circle", { config: h5, defines: u6, overrideFog: _5 }), f5 = c5.layoutVertexBuffer, x6 = c5.globeExtVertexBuffer, y4 = c5.indexBuffer, b4 = d3.projection.createInversionMatrix(d3, n4.canonical), w5 = { programConfiguration: h5, program: p5, layoutVertexBuffer: f5, globeExtVertexBuffer: x6, indexBuffer: y4, uniformValues: e3.cG(t4, n4, a5, b4, g5, o3), tile: a5 };
            if (l4) {
              const t5 = c5.segments.get();
              for (const i5 of t5) v4.push({ segments: new e3.aE([i5]), sortKey: i5.sortKey, state: w5 });
            } else v4.push({ segments: c5.segments, sortKey: 0, state: w5 });
          }
          l4 && v4.sort((e4, t5) => e4.sortKey - t5.sortKey);
          const x5 = { useDepthForOcclusion: d3.depthOcclusionForSymbolsAndCircles };
          for (const e4 of v4) {
            const { programConfiguration: i5, program: r5, layoutVertexBuffer: s5, globeExtVertexBuffer: n4, indexBuffer: a5, uniformValues: l5, tile: c5 } = e4.state, m5 = e4.segments;
            t4.terrain && t4.terrain.setupElevationDraw(c5, r5, x5), t4.uploadCommonUniforms(h4, r5, c5.tileID.toUnwrapped()), r5.draw(t4, u5.TRIANGLES, _4, p4, f4, Mt.disabled, l5, o3.id, s5, a5, m5, o3.paint, d3.zoom, i5, [n4]);
          }
        }, heatmap: function(t4, i4, o3, r4) {
          if (0 !== o3.paint.get("heatmap-opacity")) if ("offscreen" === t4.renderPass) {
            const s4 = t4.context, n3 = s4.gl, a4 = Dt.disabled, l4 = new At([n3.ONE, n3.ONE, n3.ONE, n3.ONE], e3.aA.transparent, [true, true, true, true]);
            !function(e4, t5, i5, o4) {
              const r5 = e4.gl, s5 = t5.width * o4, n4 = t5.height * o4;
              e4.activeTexture.set(r5.TEXTURE1), e4.viewport.set([0, 0, s5, n4]);
              let a5 = i5.heatmapFbo;
              if (!a5 || a5 && (a5.width !== s5 || a5.height !== n4)) {
                a5 && a5.destroy();
                const t6 = r5.createTexture();
                r5.bindTexture(r5.TEXTURE_2D, t6), r5.texParameteri(r5.TEXTURE_2D, r5.TEXTURE_WRAP_S, r5.CLAMP_TO_EDGE), r5.texParameteri(r5.TEXTURE_2D, r5.TEXTURE_WRAP_T, r5.CLAMP_TO_EDGE), r5.texParameteri(r5.TEXTURE_2D, r5.TEXTURE_MIN_FILTER, r5.LINEAR), r5.texParameteri(r5.TEXTURE_2D, r5.TEXTURE_MAG_FILTER, r5.LINEAR), a5 = i5.heatmapFbo = e4.createFramebuffer(s5, n4, true, null), function(e5, t7, i6, o5, r6, s6) {
                  const n5 = e5.gl;
                  n5.texImage2D(n5.TEXTURE_2D, 0, e5.extRenderToTextureHalfFloat ? n5.RGBA16F : n5.RGBA, r6, s6, 0, n5.RGBA, e5.extRenderToTextureHalfFloat ? n5.HALF_FLOAT : n5.UNSIGNED_BYTE, null), o5.colorAttachment.set(i6);
                }(e4, 0, t6, a5, s5, n4);
              } else r5.bindTexture(r5.TEXTURE_2D, a5.colorAttachment.get()), e4.bindFramebuffer.set(a5.framebuffer);
            }(s4, t4, o3, "globe" === t4.transform.projection.name ? 0.5 : 0.25), s4.clear({ color: e3.aA.transparent });
            const c4 = t4.transform, h4 = "globe" === c4.projection.name, u5 = h4 ? ["PROJECTION_GLOBE_VIEW"] : [], d3 = h4 ? Mt.frontCCW : Mt.disabled, _4 = [e3.a8(c4.center.lng), e3.ah(c4.center.lat)];
            for (let e4 = 0; e4 < r4.length; e4++) {
              const p4 = r4[e4];
              if (i4.hasRenderableParent(p4)) continue;
              const f4 = i4.getTile(p4), m4 = f4.getBucket(o3);
              if (!m4 || m4.projection.name !== c4.projection.name) continue;
              const g5 = t4.isTileAffectedByFog(p4), v4 = m4.programConfigurations.get(o3.id), x5 = t4.getOrCreateProgram("heatmap", { config: v4, defines: u5, overrideFog: g5 }), { zoom: y4 } = t4.transform;
              t4.terrain && t4.terrain.setupElevationDraw(f4, x5), t4.uploadCommonUniforms(s4, x5, p4.toUnwrapped());
              const b4 = c4.projection.createInversionMatrix(c4, p4.canonical);
              x5.draw(t4, n3.TRIANGLES, Ct.disabled, a4, l4, d3, Pr(t4, p4, f4, b4, _4, y4, o3.paint.get("heatmap-intensity")), o3.id, m4.layoutVertexBuffer, m4.indexBuffer, m4.segments, o3.paint, t4.transform.zoom, v4, h4 ? [m4.globeExtVertexBuffer] : null);
            }
            s4.viewport.set([0, 0, t4.width, t4.height]);
          } else "translucent" === t4.renderPass && (t4.context.setColorMode(t4.colorModeForRenderPass()), function(t5, i5) {
            const o4 = t5.context, r5 = o4.gl, s4 = i5.heatmapFbo;
            if (!s4) return;
            o4.activeTexture.set(r5.TEXTURE0), r5.bindTexture(r5.TEXTURE_2D, s4.colorAttachment.get()), o4.activeTexture.set(r5.TEXTURE1);
            let n3 = i5.colorRampTexture;
            n3 || (n3 = i5.colorRampTexture = new e3.T(o4, i5.colorRamp, r5.RGBA)), n3.bind(r5.LINEAR, r5.CLAMP_TO_EDGE), t5.getOrCreateProgram("heatmapTexture").draw(t5, r5.TRIANGLES, Ct.disabled, Dt.disabled, t5.colorModeForRenderPass(), Mt.disabled, ((e4, t6, i6, o5) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t6.paint.get("heatmap-opacity") }))(0, i5), i5.id, t5.viewportBuffer, t5.quadTriangleIndexBuffer, t5.viewportSegments, i5.paint, t5.transform.zoom);
          }(t4, o3));
        }, line: function(t4, i4, o3, r4) {
          if ("translucent" !== t4.renderPass) return;
          const s4 = o3.paint.get("line-opacity"), n3 = o3.paint.get("line-width");
          if (0 === s4.constantOr(1) || 0 === n3.constantOr(1)) return;
          const a4 = o3.paint.get("line-emissive-strength"), l4 = t4.depthModeForSublayer(0, Ct.ReadOnly), c4 = t4.colorModeForDrapableLayerRenderPass(a4), h4 = t4.terrain && t4.terrain.renderingToTexture ? 1 : e3.f.devicePixelRatio, u5 = o3.paint.get("line-dasharray"), d3 = u5.constantOr(1), _4 = o3.layout.get("line-cap"), p4 = o3.paint.get("line-pattern"), f4 = p4.constantOr(1), m4 = 1 !== o3.paint.get("line-opacity").constantOr(1);
          let g5 = !f4 && m4;
          const v4 = o3.paint.get("line-gradient"), x5 = f4 ? "linePattern" : "line", y4 = t4.context, b4 = y4.gl, w5 = e3.cH(o3);
          t4.terrain && t4.terrain.clipOrMaskOverlapStencilType() && (g5 = false);
          for (const s5 of r4) {
            const r5 = i4.getTile(s5);
            if (f4 && !r5.patternsLoaded()) continue;
            const n4 = r5.getBucket(o3);
            if (!n4) continue;
            t4.prepareDrawTile();
            const a5 = n4.programConfigurations.get(o3.id), m5 = t4.isTileAffectedByFog(s5), T5 = t4.getOrCreateProgram(x5, { config: a5, defines: w5, overrideFog: m5 }), E3 = p4.constantOr(null);
            if (E3 && r5.imageAtlas) {
              const e4 = r5.imageAtlas.patternPositions[E3.toString()];
              e4 && a5.setConstantPatternPositions(e4);
            }
            const S3 = u5.constantOr(null), C4 = _4.constantOr(null);
            if (!f4 && S3 && C4 && r5.lineAtlas) {
              const e4 = r5.lineAtlas.getDash(S3, C4);
              e4 && a5.setConstantPatternPositions(e4);
            }
            let [I4, D4] = o3.paint.get("line-trim-offset");
            if ("round" === C4 || "square" === C4) {
              const e4 = 1;
              I4 !== D4 && (0 === I4 && (I4 -= e4), 1 === D4 && (D4 += e4));
            }
            const R2 = t4.terrain ? s5.projMatrix : null, A4 = f4 ? e3.cI(t4, r5, o3, R2, h4, [I4, D4]) : e3.cJ(t4, r5, o3, R2, n4.lineClipsArray.length, h4, [I4, D4]);
            if (v4) {
              const r6 = n4.gradients[o3.id];
              let a6 = r6.texture;
              if (o3.gradientVersion !== r6.version) {
                let l5 = 256;
                if (o3.stepInterpolant) {
                  const o4 = i4.getSource().maxzoom, r7 = s5.canonical.z === o4 ? Math.ceil(1 << t4.transform.maxZoom - s5.canonical.z) : 1;
                  l5 = e3.ad(e3.cK(n4.maxLineLength / e3.Y * 1024 * r7), 256, y4.maxTextureSize);
                }
                r6.gradient = e3.cL({ expression: o3.gradientExpression(), evaluationKey: "lineProgress", resolution: l5, image: r6.gradient || void 0, clips: n4.lineClipsArray }), r6.texture ? r6.texture.update(r6.gradient) : r6.texture = new e3.T(y4, r6.gradient, b4.RGBA), r6.version = o3.gradientVersion, a6 = r6.texture;
              }
              y4.activeTexture.set(b4.TEXTURE1), a6.bind(o3.stepInterpolant ? b4.NEAREST : b4.LINEAR, b4.CLAMP_TO_EDGE);
            }
            d3 && (y4.activeTexture.set(b4.TEXTURE0), r5.lineAtlasTexture && r5.lineAtlasTexture.bind(b4.LINEAR, b4.REPEAT), a5.updatePaintBuffers()), f4 && (y4.activeTexture.set(b4.TEXTURE0), r5.imageAtlasTexture && r5.imageAtlasTexture.bind(b4.LINEAR, b4.CLAMP_TO_EDGE), a5.updatePaintBuffers()), t4.uploadCommonUniforms(y4, T5, s5.toUnwrapped());
            const P4 = (e4) => {
              T5.draw(t4, b4.TRIANGLES, l4, e4, c4, Mt.disabled, A4, o3.id, n4.layoutVertexBuffer, n4.indexBuffer, n4.segments, o3.paint, t4.transform.zoom, a5, [n4.layoutVertexBuffer2, n4.patternVertexBuffer]);
            };
            if (g5) {
              const e4 = t4.stencilModeForClipping(s5).ref;
              0 === e4 && t4.terrain && y4.clear({ stencil: 0 });
              const i5 = { func: b4.EQUAL, mask: 255 };
              A4.u_alpha_discard_threshold = 0.8, P4(new Dt(i5, e4, 255, b4.KEEP, b4.KEEP, b4.INVERT)), A4.u_alpha_discard_threshold = 0, P4(new Dt(i5, e4, 255, b4.KEEP, b4.KEEP, b4.KEEP));
            } else P4(t4.stencilModeForClipping(s5));
          }
          g5 && (t4.resetStencilClippingMasks(), t4.terrain && y4.clear({ stencil: 0 }));
        }, fill: function(t4, i4, o3, r4) {
          const s4 = o3.paint.get("fill-color"), n3 = o3.paint.get("fill-opacity");
          if (0 === n3.constantOr(1)) return;
          const a4 = o3.paint.get("fill-emissive-strength"), l4 = t4.colorModeForDrapableLayerRenderPass(a4), c4 = o3.paint.get("fill-pattern"), h4 = t4.opaquePassEnabledForLayer() && !c4.constantOr(1) && 1 === s4.constantOr(e3.aA.transparent).a && 1 === n3.constantOr(0) ? "opaque" : "translucent";
          if (t4.renderPass === h4) {
            const e4 = t4.depthModeForSublayer(1, "opaque" === t4.renderPass ? Ct.ReadWrite : Ct.ReadOnly);
            os(t4, i4, o3, r4, e4, l4, false);
          }
          if ("translucent" === t4.renderPass && o3.paint.get("fill-antialias")) {
            const e4 = t4.depthModeForSublayer(o3.getPaintProperty("fill-outline-color") ? 2 : 0, Ct.ReadOnly);
            os(t4, i4, o3, r4, e4, l4, true);
          }
        }, "fill-extrusion": function(t4, i4, o3, r4) {
          const s4 = o3.paint.get("fill-extrusion-opacity"), n3 = t4.context, a4 = n3.gl, l4 = t4.terrain, c4 = l4 && l4.renderingToTexture;
          if (0 === s4) return;
          const h4 = t4.conflationActive && t4.layerUsedInConflation(o3, i4.getSource());
          if (h4 && function(e4, t5, i5, o4) {
            for (const r5 of o4) {
              const o5 = t5.getTile(r5).getBucket(i5);
              o5 && (o5.updateReplacement(r5, e4.replacementSource), o5.uploadCentroid(e4.context));
            }
          }(t4, i4, o3, r4), l4 || h4) for (const e4 of r4) {
            const r5 = i4.getTile(e4).getBucket(o3);
            r5 && ns(t4.context, i4, e4, r5, o3, l4, h4);
          }
          if ("shadow" === t4.renderPass && t4.shadowRenderer) {
            const n4 = t4.shadowRenderer;
            if (l4 && s4 < 0.65 && o3._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e3.Z) return;
            const a5 = n4.getShadowPassDepthMode(), c5 = n4.getShadowPassColorMode();
            rs(t4, i4, o3, r4, a5, Dt.disabled, c5, h4);
          } else if ("translucent" === t4.renderPass) {
            const u5 = !o3.paint.get("fill-extrusion-pattern").constantOr(1), d3 = o3.paint.get("fill-extrusion-color").constantOr(e3.aA.white);
            if (!c4 && 0 !== d3.a) {
              const e4 = new Ct(t4.context.gl.LEQUAL, Ct.ReadWrite, t4.depthRangeFor3D);
              1 === s4 && u5 ? rs(t4, i4, o3, r4, e4, Dt.disabled, At.unblended, h4) : (rs(t4, i4, o3, r4, e4, Dt.disabled, At.disabled, h4), rs(t4, i4, o3, r4, e4, t4.stencilModeFor3D(), t4.colorModeForRenderPass(), h4), t4.resetStencilClippingMasks());
            }
            if (t4.style.enable3dLights() && u5 && (!l4 && "globe" !== t4.transform.projection.name || c4)) {
              const s5 = o3.paint.get("fill-extrusion-opacity"), u6 = o3.paint.get("fill-extrusion-ambient-occlusion-intensity"), d4 = o3.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), _4 = o3.paint.get("fill-extrusion-flood-light-intensity"), p4 = o3.paint.get("fill-extrusion-flood-light-color").toArray01().slice(0, 3), f4 = u6 > 0 && d4 > 0, m4 = _4 > 0, g5 = (e4, t5, i5) => (1 - i5) * e4 + i5 * t5, v4 = (n4) => {
                const l5 = t4.depthModeForSublayer(1, Ct.ReadOnly, a4.LEQUAL, true), c5 = o3.paint.get(n4 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), f5 = g5(0.1, 3, c5), m5 = t4._showOverdrawInspector;
                if (!m5) {
                  const c6 = new Dt({ func: a4.ALWAYS, mask: 255 }, 255, 255, a4.KEEP, a4.KEEP, a4.REPLACE), m6 = new At([a4.ONE, a4.ONE, a4.ONE, a4.ONE], e3.aA.transparent, [false, false, false, true], a4.MIN);
                  ss(t4, i4, o3, r4, l5, c6, m6, Mt.disabled, n4, "sdf", s5, u6, d4, _4, p4, f5, h4, false);
                }
                {
                  const c6 = m5 ? Dt.disabled : new Dt({ func: a4.EQUAL, mask: 255 }, 255, 255, a4.KEEP, a4.DECR, a4.DECR), g6 = m5 ? t4.colorModeForRenderPass() : new At([a4.ONE_MINUS_DST_ALPHA, a4.DST_ALPHA, a4.ONE, a4.ONE], e3.aA.transparent, [true, true, true, true]);
                  ss(t4, i4, o3, r4, l5, c6, g6, Mt.disabled, n4, "color", s5, u6, d4, _4, p4, f5, h4, false);
                }
              };
              if (c4) {
                const c5 = (n4, l5, c6) => {
                  const f5 = t4.depthModeForSublayer(1, Ct.ReadOnly, a4.LEQUAL, false), m5 = o3.paint.get(n4 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), v5 = g5(0.1, 3, m5);
                  {
                    const c7 = new At([a4.ONE, a4.ONE, a4.ONE, a4.ONE], e3.aA.transparent, [false, false, false, true]);
                    ss(t4, i4, o3, r4, f5, Dt.disabled, c7, Mt.disabled, n4, "clear", s5, u6, d4, _4, p4, v5, h4, l5);
                  }
                  {
                    const c7 = new Dt({ func: a4.ALWAYS, mask: 255 }, 255, 255, a4.KEEP, a4.KEEP, a4.REPLACE), m6 = new At([a4.ONE, a4.ONE, a4.ONE, a4.ONE], e3.aA.transparent, [false, false, false, true], a4.MIN);
                    ss(t4, i4, o3, r4, f5, c7, m6, Mt.disabled, n4, "sdf", s5, u6, d4, _4, p4, v5, h4, l5);
                  }
                  {
                    const c7 = n4 ? a4.ZERO : a4.ONE_MINUS_DST_ALPHA, m6 = new Dt({ func: a4.EQUAL, mask: 255 }, 255, 255, a4.KEEP, a4.DECR, a4.DECR), g6 = new At([c7, a4.DST_ALPHA, a4.ONE_MINUS_DST_ALPHA, a4.ZERO], e3.aA.transparent, [true, true, true, true]);
                    ss(t4, i4, o3, r4, f5, m6, g6, Mt.disabled, n4, "color", s5, u6, d4, _4, p4, v5, h4, l5);
                  }
                  {
                    const m6 = new At([a4.ONE, a4.ONE, a4.ONE, n4 ? a4.ZERO : a4.ONE], e3.aA.transparent, [false, false, false, true], n4 ? a4.FUNC_ADD : a4.MAX);
                    ss(t4, i4, o3, r4, f5, Dt.disabled, m6, Mt.disabled, n4, "clear", s5, u6, d4, _4, p4, v5, h4, l5, c6);
                  }
                };
                if (f4 || m4) {
                  let i5;
                  if (t4.prepareDrawTile(), l4) {
                    const t5 = l4.drapeBufferSize[0], o4 = l4.drapeBufferSize[1];
                    i5 = l4.framebufferCopyTexture, i5 && (!i5 || i5.size[0] === t5 && i5.size[1] === o4) || (i5 && i5.destroy(), i5 = l4.framebufferCopyTexture = new e3.T(n3, new e3.h({ width: t5, height: o4 }), a4.RGBA)), i5.bind(a4.LINEAR, a4.CLAMP_TO_EDGE), a4.copyTexImage2D(a4.TEXTURE_2D, 0, a4.RGBA, 0, 0, t5, o4, 0);
                  }
                  f4 && c5(true, false, i5), m4 && c5(false, true, i5);
                }
              } else f4 && v4(true), m4 && v4(false);
            }
          }
        }, hillshade: function(e4, t4, i4, o3) {
          if ("offscreen" !== e4.renderPass && "translucent" !== e4.renderPass) return;
          if (e4.style.disableElevatedTerrain) return;
          const r4 = e4.context, s4 = e4.terrain && e4.terrain.renderingToTexture, [n3, a4] = "translucent" !== e4.renderPass || s4 ? [{}, o3] : e4.stencilConfigForOverlap(o3);
          for (const o4 of a4) {
            const r5 = t4.getTile(o4);
            if (r5.needsHillshadePrepare && "offscreen" === e4.renderPass) er(e4, r5, i4);
            else if ("translucent" === e4.renderPass) {
              const t5 = e4.depthModeForSublayer(0, Ct.ReadOnly), a5 = i4.paint.get("hillshade-emissive-strength"), l4 = e4.colorModeForDrapableLayerRenderPass(a5), c4 = s4 && e4.terrain ? e4.terrain.stencilModeForRTTOverlap(o4) : n3[o4.overscaledZ];
              Jo(e4, o4, r5, i4, t5, c4, l4);
            }
          }
          r4.viewport.set([0, 0, e4.width, e4.height]), e4.resetStencilClippingMasks();
        }, raster: function(t4, i4, o3, r4, s4, n3) {
          if ("translucent" !== t4.renderPass) return;
          if (0 === o3.paint.get("raster-opacity")) return;
          const a4 = "globe" === t4.transform.projection.name, l4 = 0 !== o3.paint.get("raster-elevation"), c4 = l4 && a4;
          if (t4.renderElevatedRasterBackface && !c4) return;
          const h4 = t4.context, u5 = h4.gl, d3 = i4.getSource(), _4 = function(t5, i5, o4, r5) {
            const s5 = i5.paint.get("raster-color"), n4 = "raster-array" === t5.type, a5 = [], l5 = i5.paint.get("raster-resampling"), c5 = i5.paint.get("raster-color-mix");
            let h5 = i5.paint.get("raster-color-range");
            const u6 = [c5[0], c5[1], c5[2], 0], d4 = c5[3];
            let _5 = "nearest" === l5 ? r5.NEAREST : r5.LINEAR;
            if (n4 && (a5.push("RASTER_ARRAY"), s5 || a5.push("RASTER_COLOR"), "linear" === l5 && a5.push("RASTER_ARRAY_LINEAR"), _5 = r5.NEAREST, !h5 && t5.rasterLayers)) {
              const e4 = t5.rasterLayers.find(({ id: e5 }) => e5 === i5.sourceLayer);
              e4 && e4.fields && e4.fields.range && (h5 = e4.fields.range);
            }
            if (h5 = h5 || [0, 1], s5) {
              a5.push("RASTER_COLOR"), o4.activeTexture.set(r5.TEXTURE2), i5.updateColorRamp(h5);
              let t6 = i5.colorRampTexture;
              t6 || (t6 = i5.colorRampTexture = new e3.T(o4, i5.colorRamp, r5.RGBA)), t6.bind(r5.LINEAR, r5.CLAMP_TO_EDGE);
            }
            return { mix: u6, range: h5, offset: d4, defines: a5, resampling: _5 };
          }(d3, o3, h4, u5);
          if (d3 instanceof e3.as && !r4.length && !a4) return;
          const p4 = o3.paint.get("raster-emissive-strength"), f4 = t4.colorModeForDrapableLayerRenderPass(p4), m4 = t4.terrain && t4.terrain.renderingToTexture, g5 = !t4.options.moving, v4 = "nearest" === o3.paint.get("raster-resampling") ? u5.NEAREST : u5.LINEAR;
          if (d3 instanceof e3.as && !r4.length && (d3.onNorthPole || d3.onSouthPole)) {
            const e4 = l4 ? t4.stencilModeFor3D() : Dt.disabled;
            return void ds(!!d3.onNorthPole, null, t4, i4, o3, p4, _4, Mt.disabled, e4);
          }
          if (!r4.length) return;
          const [x5, y4] = d3 instanceof e3.as || m4 ? [{}, r4] : t4.stencilConfigForOverlap(r4), b4 = y4[y4.length - 1].overscaledZ;
          c4 && _4.defines.push("PROJECTION_GLOBE_VIEW"), l4 && _4.defines.push("RENDER_CUTOFF");
          const w5 = (r5, s5, y5) => {
            for (const w6 of r5) {
              const r6 = w6.toUnwrapped(), T5 = i4.getTile(w6);
              if (m4 && (!T5 || !T5.hasData())) continue;
              h4.activeTexture.set(u5.TEXTURE0);
              const E3 = ps(T5, d3, o3, _4);
              if (!E3 || !E3.texture) continue;
              const { texture: S3, mix: C4, offset: I4, tileSize: D4, buffer: R2 } = E3;
              let A4, P4;
              m4 ? (A4 = Ct.disabled, P4 = w6.projMatrix) : l4 ? (A4 = new Ct(u5.LEQUAL, Ct.ReadWrite, t4.depthRangeFor3D), P4 = a4 ? Float32Array.from(t4.transform.expandedFarZProjMatrix) : t4.transform.calculateProjMatrix(r6, g5)) : (A4 = t4.depthModeForSublayer(w6.overscaledZ - b4, 1 === o3.paint.get("raster-opacity") ? Ct.ReadWrite : Ct.ReadOnly, u5.LESS), P4 = t4.transform.calculateProjMatrix(r6, g5));
              const L4 = t4.terrain && m4 ? t4.terrain.stencilModeForRTTOverlap(w6) : x5[w6.overscaledZ], M3 = n3 ? 0 : o3.paint.get("raster-fade-duration");
              T5.registerFadeDuration(M3);
              const z4 = i4.findLoadedParent(w6, 0), O3 = hr(T5, z4, i4, t4.transform, M3);
              let F5, B4;
              t4.terrain && t4.terrain.prepareDrawTile(), h4.activeTexture.set(u5.TEXTURE0), S3.bind(v4, u5.CLAMP_TO_EDGE), h4.activeTexture.set(u5.TEXTURE1), z4 ? (z4.texture && z4.texture.bind(v4, u5.CLAMP_TO_EDGE), F5 = Math.pow(2, z4.tileID.overscaledZ - T5.tileID.overscaledZ), B4 = [T5.tileID.canonical.x * F5 % 1, T5.tileID.canonical.y * F5 % 1]) : S3.bind(v4, u5.CLAMP_TO_EDGE), S3.useMipmap && h4.extTextureFilterAnisotropic && t4.transform.pitch > 20 && u5.texParameterf(u5.TEXTURE_2D, h4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h4.extTextureFilterAnisotropicMax);
              const k4 = t4.transform;
              let N4;
              const U3 = l4 ? _s(k4) : [0, 0, 0, 0];
              let G4, j5, V4, Z3, W3, H4 = 0;
              if (c4 && d3 instanceof e3.as && d3.coordinates.length > 3) G4 = Float32Array.from(e3.aW(e3.cn(new e3.bv(0, 0, 0)))), j5 = Float32Array.from(k4.globeMatrix), V4 = Float32Array.from(e3.cj(k4)), Z3 = [e3.a8(k4.center.lng), e3.ah(k4.center.lat)], N4 = d3.elevatedGlobePerspectiveTransform, W3 = d3.elevatedGlobeGridMatrix || new Float32Array(9);
              else if (c4) {
                const t5 = e3.ck(w6.canonical);
                H4 = e3.cl(t5.getCenter().lat), G4 = Float32Array.from(e3.aW(e3.cn(w6.canonical))), j5 = Float32Array.from(k4.globeMatrix), V4 = Float32Array.from(e3.cj(k4)), Z3 = [e3.a8(k4.center.lng), e3.ah(k4.center.lat)], N4 = [0, 0], W3 = Float32Array.from(e3.cm(w6.canonical, t5, H4, k4.worldSize / k4._pixelsPerMercatorPixel));
              } else N4 = d3 instanceof e3.as ? d3.perspectiveTransform : [0, 0], G4 = new Float32Array(16), j5 = new Float32Array(9), V4 = new Float32Array(16), Z3 = [0, 0], W3 = new Float32Array(9);
              const q4 = zr(P4, G4, j5, V4, W3, B4 || [0, 0], e3.W(t4.transform.zoom), Z3, U3, F5 || 1, O3, o3, N4, l4 ? o3.paint.get("raster-elevation") : 0, 2, C4, I4, _4.range, D4, R2, p4), Q3 = t4.isTileAffectedByFog(w6), $4 = t4.getOrCreateProgram("raster", { defines: _4.defines, overrideFog: Q3 });
              if (t4.uploadCommonUniforms(h4, $4, r6), d3 instanceof e3.as) {
                const i5 = d3.elevatedGlobeVertexBuffer, r7 = d3.elevatedGlobeIndexBuffer;
                if (m4 || !a4) d3.boundsBuffer && d3.boundsSegments && $4.draw(t4, u5.TRIANGLES, A4, Dt.disabled, f4, Mt.disabled, q4, o3.id, d3.boundsBuffer, t4.quadTriangleIndexBuffer, d3.boundsSegments);
                else if (i5 && r7) {
                  const n4 = k4.zoom <= e3.bJ ? d3.elevatedGlobeSegments : d3.getSegmentsForLongitude(k4.center.lng);
                  n4 && $4.draw(t4, u5.TRIANGLES, A4, Dt.disabled, f4, s5, q4, o3.id, i5, r7, n4);
                }
              } else if (c4) {
                A4 = new Ct(u5.LEQUAL, Ct.ReadOnly, t4.depthRangeFor3D);
                const e4 = t4.globeSharedBuffers;
                if (e4) {
                  const [i5, r7, n4] = e4.getGridBuffers(H4, false);
                  $4.draw(t4, u5.TRIANGLES, A4, y5 || L4, t4.colorModeForRenderPass(), s5, q4, o3.id, i5, r7, n4);
                }
              } else {
                const { tileBoundsBuffer: e4, tileBoundsIndexBuffer: i5, tileBoundsSegments: r7 } = t4.getTileBoundsBuffers(T5);
                $4.draw(t4, u5.TRIANGLES, A4, L4, f4, Mt.disabled, q4, o3.id, e4, i5, r7);
              }
            }
            if (!(d3 instanceof e3.as) && c4) for (const e4 of r5) {
              const r6 = e4.canonical.y === (1 << e4.canonical.z) - 1;
              0 === e4.canonical.y && ds(true, e4, t4, i4, o3, p4, _4, s5, y5 || Dt.disabled), r6 && ds(false, e4, t4, i4, o3, p4, _4, s5 === Mt.frontCW ? Mt.backCW : Mt.frontCW, y5 || Dt.disabled);
            }
          };
          c4 ? w5(y4, t4.renderElevatedRasterBackface ? Mt.backCW : Mt.frontCW, t4.stencilModeFor3D()) : w5(y4, Mt.disabled, void 0), t4.resetStencilClippingMasks();
        }, "raster-particle": function(t4, i4, o3, r4, s4, n3) {
          "offscreen" === t4.renderPass && function(t5, i5, o4, r5) {
            if (!r5.length) return;
            const s5 = t5.context, n4 = s5.gl, a4 = i5.getSource();
            if (!(a4 instanceof Pe)) return;
            const l4 = Math.ceil(Math.sqrt(o4.paint.get("raster-particle-count")));
            let c4 = o4.particleFramebuffer;
            c4 ? c4.width !== l4 && (c4.destroy(), c4 = o4.particleFramebuffer = s5.createFramebuffer(l4, l4, true, null)) : c4 = o4.particleFramebuffer = s5.createFramebuffer(l4, l4, true, null);
            const h4 = [];
            for (const e4 of r5) {
              const t6 = i5.getTile(e4);
              if (!(t6 instanceof Ht)) continue;
              const r6 = fs(t6, a4, o4);
              if (!r6) continue;
              const n5 = [t6.tileSize, t6.tileSize];
              let c5 = o4.tileFramebuffer;
              c5 || (c5 = o4.tileFramebuffer = s5.createFramebuffer(n5[0], n5[1], true, null));
              let u6 = t6.rasterParticleState;
              u6 || (u6 = t6.rasterParticleState = new Bt(s5, e4, n5, l4));
              const d4 = u6.update(o4.lastInvalidatedAt);
              u6.particleTextureDimension !== l4 && u6.setParticleTextureDimension(e4, l4);
              const _4 = u6.targetColorTexture;
              u6.targetColorTexture = u6.backgroundColorTexture, u6.backgroundColorTexture = _4;
              const p4 = u6.particleTexture0;
              u6.particleTexture0 = u6.particleTexture1, u6.particleTexture1 = p4, h4.push([e4, r6, u6, d4]);
            }
            if (0 === h4.length) return;
            const u5 = e3.f.now(), d3 = o4.previousDrawTimestamp ? 1e-3 * (u5 - o4.previousDrawTimestamp) : 0.0167;
            if (o4.previousDrawTimestamp = u5, o4.hasColorMap()) {
              s5.activeTexture.set(n4.TEXTURE0 + 2);
              let t6 = o4.colorRampTexture;
              t6 || (t6 = o4.colorRampTexture = new e3.T(s5, o4.colorRamp, n4.RGBA)), t6.bind(n4.LINEAR, n4.CLAMP_TO_EDGE);
            }
            s5.bindFramebuffer.set(o4.tileFramebuffer.framebuffer), function(t6, i6, o5) {
              const r6 = t6.context, s6 = r6.gl, n5 = i6.tileFramebuffer;
              r6.activeTexture.set(s6.TEXTURE0);
              const a5 = { u_texture: 0, u_opacity: 1.05 * (c5 = i6.paint.get("raster-particle-fade-opacity-factor")) / (c5 + 0.05) }, l5 = t6.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: false });
              var c5;
              for (const c6 of o5) {
                const [, , o6, h5] = c6;
                n5.colorAttachment.set(o6.targetColorTexture.texture), r6.viewport.set([0, 0, n5.width, n5.height]), r6.clear({ color: e3.aA.transparent }), h5 && (o6.backgroundColorTexture.bind(s6.NEAREST, s6.CLAMP_TO_EDGE), l5.draw(t6, s6.TRIANGLES, Ct.disabled, Dt.disabled, At.alphaBlended, Mt.disabled, a5, i6.id, t6.viewportBuffer, t6.quadTriangleIndexBuffer, t6.viewportSegments));
              }
            }(t5, o4, h4), function(t6, i6, o5, r6) {
              const s6 = t6.context, n5 = s6.gl, a5 = o5.tileFramebuffer, l5 = "globe" === t6.transform.projection.name, c5 = o5.paint.get("raster-particle-max-speed");
              for (const h5 of r6) {
                const [r7, u6, d4] = h5;
                s6.activeTexture.set(n5.TEXTURE0 + 0), u6.texture.bind(n5.LINEAR, n5.CLAMP_TO_EDGE), a5.colorAttachment.set(d4.targetColorTexture.texture);
                const _4 = t6.getOrCreateProgram("rasterParticleDraw", { defines: u6.defines, overrideFog: false });
                s6.activeTexture.set(n5.TEXTURE0 + 1);
                const p4 = u6.scalarData ? [] : [0, 1, 2, 3].map((t7) => e3.cN[t7](r7));
                p4.push(r7);
                const f4 = r7.canonical.x, m4 = r7.canonical.y;
                for (const e4 of p4) {
                  const s7 = i6.getTile(l5 ? e4.wrapped() : e4);
                  if (!s7) continue;
                  const a6 = s7.rasterParticleState;
                  if (!a6) continue;
                  const h6 = e4.canonical.x + (1 << e4.canonical.z) * (e4.wrap - r7.wrap), d5 = e4.canonical.y;
                  a6.particleTexture0.bind(n5.NEAREST, n5.CLAMP_TO_EDGE);
                  const p5 = Br(1, a6.particleTexture0.size[0], [h6 - f4, d5 - m4], 0, u6.texture.size, 2, c5, u6.textureOffset, u6.scale, u6.offset);
                  _4.draw(t6, n5.POINTS, Ct.disabled, Dt.disabled, At.alphaBlended, Mt.disabled, p5, o5.id, a6.particleIndexBuffer, void 0, a6.particleSegment);
                }
              }
            }(t5, i5, o4, h4), s5.bindFramebuffer.set(o4.particleFramebuffer.framebuffer), function(t6, i6, o5, r6) {
              const s6 = t6.context, n5 = s6.gl, a5 = i6.paint.get("raster-particle-max-speed"), l5 = r6 * i6.paint.get("raster-particle-speed-factor") * 0.3, c5 = function(e4) {
                return Math.pow(e4, 6);
              }(0.01 + 1 * i6.paint.get("raster-particle-reset-rate-factor")), h5 = i6.particleFramebuffer;
              s6.viewport.set([0, 0, h5.width, h5.height]);
              for (const r7 of o5) {
                const [, o6, u6] = r7;
                s6.activeTexture.set(n5.TEXTURE0 + 0), o6.texture.bind(n5.LINEAR, n5.CLAMP_TO_EDGE), s6.activeTexture.set(n5.TEXTURE0 + 1);
                const d4 = u6.particleTexture0;
                d4.bind(n5.NEAREST, n5.CLAMP_TO_EDGE);
                const _4 = kr(1, d4.size[0], 0, o6.texture.size, a5, l5, c5, o6.textureOffset, o6.scale, o6.offset);
                h5.colorAttachment.set(u6.particleTexture1.texture), s6.clear({ color: e3.aA.transparent }), t6.getOrCreateProgram("rasterParticleUpdate", { defines: o6.defines }).draw(t6, n5.TRIANGLES, Ct.disabled, Dt.disabled, At.unblended, Mt.disabled, _4, i6.id, t6.viewportBuffer, t6.quadTriangleIndexBuffer, t6.viewportSegments);
              }
            }(t5, o4, h4, d3);
          }(t4, i4, o3, r4), "translucent" === t4.renderPass && (function(t5, i5, o4, r5, s5) {
            const n4 = t5.context, a4 = n4.gl, l4 = !t5.options.moving, c4 = "globe" === t5.transform.projection.name;
            if (!r5.length) return;
            const [h4, u5] = t5.stencilConfigForOverlap(r5), d3 = [];
            c4 && d3.push("PROJECTION_GLOBE_VIEW");
            const _4 = t5.stencilModeFor3D();
            for (const r6 of u5) {
              const s6 = r6.toUnwrapped(), u6 = i5.getTile(r6);
              if (!u6.rasterParticleState) continue;
              const p4 = u6.rasterParticleState, f4 = 100;
              u6.registerFadeDuration(f4);
              const m4 = i5.findLoadedParent(r6, 0), g5 = hr(u6, m4, i5, t5.transform, f4);
              let v4, x5;
              t5.terrain && t5.terrain.prepareDrawTile(), n4.activeTexture.set(a4.TEXTURE0), p4.targetColorTexture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE), n4.activeTexture.set(a4.TEXTURE1), m4 && m4.rasterParticleState ? (m4.rasterParticleState.targetColorTexture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE), v4 = Math.pow(2, m4.tileID.overscaledZ - u6.tileID.overscaledZ), x5 = [u6.tileID.canonical.x * v4 % 1, u6.tileID.canonical.y * v4 % 1]) : p4.targetColorTexture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE);
              const y4 = c4 ? Float32Array.from(t5.transform.expandedFarZProjMatrix) : t5.transform.calculateProjMatrix(s6, l4), b4 = t5.transform, w5 = ms(b4), T5 = e3.ck(r6.canonical), E3 = e3.cl(T5.getCenter().lat);
              let S3, C4, I4, D4, R2;
              c4 ? (S3 = Float32Array.from(e3.aW(e3.cn(r6.canonical))), C4 = Float32Array.from(b4.globeMatrix), I4 = Float32Array.from(e3.cj(b4)), D4 = [e3.a8(b4.center.lng), e3.ah(b4.center.lat)], R2 = Float32Array.from(e3.cm(r6.canonical, T5, E3, b4.worldSize / b4._pixelsPerMercatorPixel))) : (S3 = new Float32Array(16), C4 = new Float32Array(9), I4 = new Float32Array(16), D4 = [0, 0], R2 = new Float32Array(9));
              const A4 = Fr(y4, S3, C4, I4, R2, x5 || [0, 0], e3.W(t5.transform.zoom), D4, w5, v4 || 1, g5, 250), P4 = t5.isTileAffectedByFog(r6), L4 = t5.getOrCreateProgram("rasterParticle", { defines: d3, overrideFog: P4 });
              if (t5.uploadCommonUniforms(n4, L4, s6), c4) {
                const e4 = new Ct(a4.LEQUAL, Ct.ReadWrite, t5.depthRangeFor3D), i6 = 0, r7 = t5.globeSharedBuffers;
                if (r7) {
                  const [s7, n5, l5] = r7.getGridBuffers(E3, 0 !== i6);
                  L4.draw(t5, a4.TRIANGLES, e4, _4, At.alphaBlended, Mt.backCCW, A4, o4.id, s7, n5, l5);
                }
              } else {
                const e4 = t5.depthModeForSublayer(0, Ct.ReadOnly), i6 = h4[r6.overscaledZ], { tileBoundsBuffer: s7, tileBoundsIndexBuffer: n5, tileBoundsSegments: l5 } = t5.getTileBoundsBuffers(u6);
                L4.draw(t5, a4.TRIANGLES, e4, i6, At.alphaBlended, Mt.disabled, A4, o4.id, s7, n5, l5);
              }
            }
            t5.resetStencilClippingMasks();
          }(t4, i4, o3, r4), t4.style.map.triggerRepaint());
        }, background: function(e4, t4, i4, o3) {
          const r4 = i4.paint.get("background-color"), s4 = i4.paint.get("background-opacity"), n3 = i4.paint.get("background-emissive-strength");
          if (0 === s4) return;
          const a4 = e4.context, l4 = a4.gl, c4 = e4.transform, h4 = c4.tileSize, u5 = i4.paint.get("background-pattern");
          if (e4.isPatternMissing(u5, i4.scope)) return;
          const d3 = !u5 && 1 === r4.a && 1 === s4 && e4.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (e4.renderPass !== d3) return;
          const _4 = Dt.disabled, p4 = e4.depthModeForSublayer(0, "opaque" === d3 ? Ct.ReadWrite : Ct.ReadOnly), f4 = e4.colorModeForDrapableLayerRenderPass(n3), m4 = u5 ? "backgroundPattern" : "background";
          let g5, v4 = o3;
          v4 || (g5 = e4.getBackgroundTiles(), v4 = Object.values(g5).map((e5) => e5.tileID)), u5 && (a4.activeTexture.set(l4.TEXTURE0), e4.imageManager.bind(e4.context, i4.scope));
          for (const d4 of v4) {
            const v5 = e4.isTileAffectedByFog(d4), x5 = e4.getOrCreateProgram(m4, { overrideFog: v5 }), y4 = d4.toUnwrapped(), b4 = o3 ? d4.projMatrix : e4.transform.calculateProjMatrix(y4);
            e4.prepareDrawTile();
            const w5 = t4 ? t4.getTile(d4) : g5 ? g5[d4.key] : new Nt(d4, h4, c4.zoom, e4), T5 = u5 ? Zr(b4, n3, s4, e4, u5, i4.scope, { tileID: d4, tileSize: h4 }) : Vr(b4, n3, s4, r4);
            e4.uploadCommonUniforms(a4, x5, y4);
            const { tileBoundsBuffer: E3, tileBoundsIndexBuffer: S3, tileBoundsSegments: C4 } = e4.getTileBoundsBuffers(w5);
            x5.draw(e4, l4.TRIANGLES, p4, _4, f4, Mt.disabled, T5, i4.id, E3, S3, C4);
          }
        }, sky: function(t4, i4, o3) {
          const r4 = t4._atmosphere ? e3.W(t4.transform.zoom) : 1, s4 = o3.paint.get("sky-opacity") * r4;
          if (0 === s4) return;
          const n3 = t4.context, a4 = o3.paint.get("sky-type"), l4 = new Ct(n3.gl.LEQUAL, Ct.ReadOnly, [0, 1]), c4 = t4.frameCounter / 1e3 % 1;
          "atmosphere" === a4 ? "offscreen" === t4.renderPass ? o3.needsSkyboxCapture(t4) && (function(t5, i5, o4, r5) {
            const s5 = t5.context, n4 = s5.gl;
            let a5 = i5.skyboxFbo;
            if (!a5) {
              a5 = i5.skyboxFbo = s5.createFramebuffer(32, 32, true, null), i5.skyboxGeometry = new Rs(s5), i5.skyboxTexture = s5.gl.createTexture(), n4.bindTexture(n4.TEXTURE_CUBE_MAP, i5.skyboxTexture), n4.texParameteri(n4.TEXTURE_CUBE_MAP, n4.TEXTURE_WRAP_S, n4.CLAMP_TO_EDGE), n4.texParameteri(n4.TEXTURE_CUBE_MAP, n4.TEXTURE_WRAP_T, n4.CLAMP_TO_EDGE), n4.texParameteri(n4.TEXTURE_CUBE_MAP, n4.TEXTURE_MIN_FILTER, n4.LINEAR), n4.texParameteri(n4.TEXTURE_CUBE_MAP, n4.TEXTURE_MAG_FILTER, n4.LINEAR);
              for (let e4 = 0; e4 < 6; ++e4) n4.texImage2D(n4.TEXTURE_CUBE_MAP_POSITIVE_X + e4, 0, n4.RGBA, 32, 32, 0, n4.RGBA, n4.UNSIGNED_BYTE, null);
            }
            s5.bindFramebuffer.set(a5.framebuffer), s5.viewport.set([0, 0, 32, 32]);
            const l5 = i5.getCenter(t5, true), c5 = t5.getOrCreateProgram("skyboxCapture"), h4 = new Float64Array(16);
            e3.a9.identity(h4), e3.a9.rotateY(h4, h4, 0.5 * -Math.PI), As(t5, i5, c5, h4, l5, 0), e3.a9.identity(h4), e3.a9.rotateY(h4, h4, 0.5 * Math.PI), As(t5, i5, c5, h4, l5, 1), e3.a9.identity(h4), e3.a9.rotateX(h4, h4, 0.5 * -Math.PI), As(t5, i5, c5, h4, l5, 2), e3.a9.identity(h4), e3.a9.rotateX(h4, h4, 0.5 * Math.PI), As(t5, i5, c5, h4, l5, 3), e3.a9.identity(h4), As(t5, i5, c5, h4, l5, 4), e3.a9.identity(h4), e3.a9.rotateY(h4, h4, Math.PI), As(t5, i5, c5, h4, l5, 5), s5.viewport.set([0, 0, t5.width, t5.height]);
          }(t4, o3), o3.markSkyboxValid(t4)) : "sky" === t4.renderPass && function(e4, t5, i5, o4, r5) {
            const s5 = e4.context, n4 = s5.gl, a5 = e4.transform, l5 = e4.getOrCreateProgram("skybox");
            s5.activeTexture.set(n4.TEXTURE0), n4.bindTexture(n4.TEXTURE_CUBE_MAP, t5.skyboxTexture);
            const c5 = /* @__PURE__ */ ((e5, t6, i6, o5, r6) => ({ u_matrix: e5, u_sun_direction: t6, u_cubemap: 0, u_opacity: o5, u_temporal_offset: r6 }))(a5.skyboxMatrix, t5.getCenter(e4, false), 0, o4, r5);
            e4.uploadCommonUniforms(s5, l5), l5.draw(e4, n4.TRIANGLES, i5, Dt.disabled, e4.colorModeForRenderPass(), Mt.backCW, c5, "skybox", t5.skyboxGeometry.vertexBuffer, t5.skyboxGeometry.indexBuffer, t5.skyboxGeometry.segment);
          }(t4, o3, l4, s4, c4) : "gradient" === a4 && "sky" === t4.renderPass && function(t5, i5, o4, r5, s5) {
            const n4 = t5.context, a5 = n4.gl, l5 = t5.transform, c5 = t5.getOrCreateProgram("skyboxGradient");
            i5.skyboxGeometry || (i5.skyboxGeometry = new Rs(n4)), n4.activeTexture.set(a5.TEXTURE0);
            let h4 = i5.colorRampTexture;
            h4 || (h4 = i5.colorRampTexture = new e3.T(n4, i5.colorRamp, a5.RGBA)), h4.bind(a5.LINEAR, a5.CLAMP_TO_EDGE);
            const u5 = ((t6, i6, o5, r6, s6) => ({ u_matrix: t6, u_color_ramp: 0, u_center_direction: i6, u_radius: e3.bm(o5), u_opacity: r6, u_temporal_offset: s6 }))(l5.skyboxMatrix, i5.getCenter(t5, false), i5.paint.get("sky-gradient-radius"), r5, s5);
            t5.uploadCommonUniforms(n4, c5), c5.draw(t5, a5.TRIANGLES, o4, Dt.disabled, t5.colorModeForRenderPass(), Mt.backCW, u5, "skyboxGradient", i5.skyboxGeometry.vertexBuffer, i5.skyboxGeometry.indexBuffer, i5.skyboxGeometry.segment);
          }(t4, o3, l4, s4, c4);
        }, debug: function(t4, i4, o3, r4, s4, n3) {
          for (let a4 = 0; a4 < o3.length; a4++) if (s4) {
            const s5 = 1, l4 = 0.8, c4 = new e3.aA(r4.r * l4, r4.g * l4, r4.b * l4, 1);
            ws(t4, i4, o3[a4], r4, -s5, -s5, n3), ws(t4, i4, o3[a4], r4, -s5, s5, n3), ws(t4, i4, o3[a4], r4, s5, s5, n3), ws(t4, i4, o3[a4], r4, s5, -s5, n3), ws(t4, i4, o3[a4], c4, 0, 0, n3);
          } else ws(t4, i4, o3[a4], r4, 0, 0, n3);
        }, custom: function(t4, i4, o3, r4) {
          const s4 = t4.context, n3 = o3.implementation;
          if (!t4.transform.projection.unsupportedLayers || !t4.transform.projection.unsupportedLayers.includes("custom") || t4.terrain && (t4.terrain.renderingToTexture || "offscreen" === t4.renderPass) && o3.isDraped(i4)) {
            if ("offscreen" === t4.renderPass) {
              const i5 = n3.prerender;
              if (i5) {
                if (t4.setCustomLayerDefaults(), s4.setColorMode(t4.colorModeForRenderPass()), "globe" === t4.transform.projection.name) {
                  const o4 = t4.transform.pointMerc;
                  i5.call(n3, s4.gl, t4.transform.customLayerMatrix(), t4.transform.getProjection(), t4.transform.globeToMercatorMatrix(), e3.W(t4.transform.zoom), [o4.x, o4.y], t4.transform.pixelsPerMeterRatio);
                } else i5.call(n3, s4.gl, t4.transform.customLayerMatrix());
                s4.setDirty(), t4.setBaseState();
              }
            } else if ("translucent" === t4.renderPass) {
              if (t4.terrain && t4.terrain.renderingToTexture) {
                const i6 = n3.renderToTile;
                if (i6) {
                  const o4 = r4[0].canonical, a4 = new e3.O(o4.x + r4[0].wrap * (1 << o4.z), o4.y, o4.z);
                  s4.setDepthMode(Ct.disabled), s4.setStencilMode(Dt.disabled), s4.setColorMode(t4.colorModeForRenderPass()), t4.setCustomLayerDefaults(), i6.call(n3, s4.gl, a4), s4.setDirty(), t4.setBaseState();
                }
                return;
              }
              t4.setCustomLayerDefaults(), s4.setColorMode(t4.colorModeForRenderPass()), s4.setStencilMode(Dt.disabled);
              const i5 = "3d" === n3.renderingMode ? new Ct(t4.context.gl.LEQUAL, Ct.ReadWrite, t4.depthRangeFor3D) : t4.depthModeForSublayer(0, Ct.ReadOnly);
              if (s4.setDepthMode(i5), "globe" === t4.transform.projection.name) {
                const i6 = t4.transform.pointMerc;
                n3.render(s4.gl, t4.transform.customLayerMatrix(), t4.transform.getProjection(), t4.transform.globeToMercatorMatrix(), e3.W(t4.transform.zoom), [i6.x, i6.y], t4.transform.pixelsPerMeterRatio);
              } else n3.render(s4.gl, t4.transform.customLayerMatrix());
              s4.setDirty(), t4.setBaseState(), s4.bindFramebuffer.set(null);
            }
          } else e3.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
        }, model: function(t4, i4, o3, r4) {
          if ("opaque" === t4.renderPass) return;
          const s4 = o3.paint.get("model-opacity");
          if (0 === s4) return;
          const n3 = o3.paint.get("model-cast-shadows");
          if ("shadow" === t4.renderPass) {
            if (!n3) return;
            if (t4.terrain && s4 < 0.65 && o3._transitionablePaint._values["model-opacity"].value.expression instanceof e3.Z) return;
          }
          const a4 = t4.shadowRenderer, l4 = o3.paint.get("model-receive-shadows");
          a4 && (a4.useNormalOffset = true, l4 || (a4.enabled = false));
          const c4 = () => {
            a4 && (a4.useNormalOffset = true, l4 || (a4.enabled = true));
          }, h4 = i4.getSource();
          if ("light-beam" === t4.renderPass && "batched-model" !== h4.type) return;
          if ("vector" === h4.type || "geojson" === h4.type) return function(t5, i5, o4, r5, s5) {
            const n4 = t5.transform;
            if ("mercator" !== n4.projection.name) return void e3.w(`Drawing 3D models for ${n4.projection.name} projection is not yet implemented`);
            const a5 = n4.getFreeCameraOptions().position;
            if (!t5.modelManager) return;
            const l5 = t5.modelManager;
            o4.modelManager = l5;
            const c5 = t5.shadowRenderer;
            if (!o4._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
            const h5 = o4._unevaluatedLayout._values["model-id"], u6 = __spreadValues({}, o4.layout.get("model-id").parameters);
            for (const d4 of r5) {
              const r6 = i5.getTile(d4).getBucket(o4);
              if (!r6 || r6.projection.name !== n4.projection.name) continue;
              const _5 = r6.getModelUris();
              _5 && !r6.modelsRequested && (l5.addModelsFromBucket(_5, s5), r6.modelsRequested = true);
              const p5 = Vs(d4, n4);
              u6.zoom = p5;
              const f5 = h5.possiblyEvaluate(u6);
              if (Gs(t5, r6, d4), js.shadowUniformsInitialized = false, js.useSingleShadowCascade = !!c5 && 0 === c5.getMaxCascadeForTile(d4.toUnwrapped()), "shadow" === t5.renderPass && c5) {
                if (1 === t5.currentShadowCascade && r6.isInsideFirstShadowMapFrustum) continue;
                const i6 = n4.calculatePosMatrix(d4.toUnwrapped(), n4.worldSize);
                if (js.tileMatrix.set(i6), js.shadowTileMatrix = Float32Array.from(c5.calculateShadowPassMatrixFromMatrix(i6)), js.aabb.min.fill(0), js.aabb.max[0] = js.aabb.max[1] = e3.Y, js.aabb.max[2] = 0, Hs(r6, js, t5, o4.scope)) continue;
              }
              const m5 = 1 << d4.canonical.z, g6 = [((a5.x - d4.wrap) * m5 - d4.canonical.x) * e3.Y, (a5.y * m5 - d4.canonical.y) * e3.Y, a5.z * m5 * e3.Y];
              for (let e4 in r6.instancesPerModel) {
                const i6 = r6.instancesPerModel[e4];
                i6.features.length > 0 && (e4 = f5.evaluate(i6.features[0].feature, {}));
                const n5 = l5.getModel(e4, s5);
                if (n5 && n5.uploaded) for (const e5 of n5.nodes) Zs(t5, o4, e5, i6, g6, d4, js);
              }
            }
          }(t4, i4, o3, r4, "vector" === h4.type ? o3.scope : ""), void c4();
          if (!h4.loaded()) return;
          if ("batched-model" === h4.type) return function(t5, i5, o4, r5) {
            o4.resetLayerRenderingStats(t5);
            const s5 = t5.context, n4 = t5.transform, a5 = t5.style.fog, l5 = t5.shadowRenderer;
            if ("mercator" !== n4.projection.name) return void e3.w(`Drawing 3D landmark models for ${n4.projection.name} projection is not yet implemented`);
            const c5 = t5.transform.getFreeCameraOptions().position, h5 = e3.Q.scale([], [c5.x, c5.y, c5.z], t5.transform.worldSize);
            e3.Q.negate(h5, h5);
            const u6 = e3.a9.identity([]), d4 = e3.cZ(n4.center.lat, n4.zoom), _5 = e3.a9.fromScaling([], [1, 1, 1 / d4]);
            e3.a9.translate(u6, u6, h5);
            const p5 = o4.paint.get("model-opacity"), f5 = new Ct(s5.gl.LEQUAL, Ct.ReadWrite, t5.depthRangeFor3D), m5 = new Ct(s5.gl.LEQUAL, Ct.ReadOnly, t5.depthRangeFor3D), g6 = new e3.bV([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), v4 = "shadow" === t5.renderPass, x5 = v4 && l5 ? l5.getCurrentCascadeFrustum() : n4.getFrustum(n4.scaleZoom(n4.worldSize)), y4 = o4.getLayerRenderingStats(), b4 = function(c6, h6) {
              for (const d5 of r5) {
                const r6 = i5.getTile(d5).getBucket(o4);
                if (!r6 || !r6.uploaded) continue;
                let b5 = false;
                l5 && (b5 = 0 === l5.getMaxCascadeForTile(d5.toUnwrapped()));
                const w5 = n4.calculatePosMatrix(d5.toUnwrapped(), n4.worldSize), T5 = r6.modelTraits;
                for (const i6 of r6.getNodesInfo()) {
                  if (i6.hiddenByReplacement) continue;
                  if (!i6.node.meshes) continue;
                  const r7 = i6.evaluatedScale, d6 = i6.node;
                  let E3 = 0;
                  if (t5.terrain && d6.elevation && (E3 = d6.elevation * t5.terrain.exaggeration()), r7[0] <= 1 && r7[1] <= 1 && r7[2] <= 1 && 0 === (() => {
                    const t6 = i6.getLocalBounds();
                    return g6.min = [...t6.min], g6.max = [...t6.max], g6.min[2] += E3, g6.max[2] += E3, e3.Q.transformMat4(g6.min, g6.min, w5), e3.Q.transformMat4(g6.max, g6.max, w5), g6;
                  })().intersects(x5)) continue;
                  const S3 = [...w5];
                  e3.a9.translate(S3, S3, [(d6.anchor ? d6.anchor[0] : 0) * (r7[0] - 1), (d6.anchor ? d6.anchor[1] : 0) * (r7[1] - 1), E3]), e3.Q.exactEquals(r7, e3.c$) || e3.a9.scale(S3, S3, r7);
                  const C4 = e3.a9.multiply([], S3, d6.matrix);
                  let I4 = e3.a9.multiply([], _5, S3);
                  e3.a9.multiply(I4, u6, I4);
                  const D4 = e3.a9.invert([], I4);
                  e3.a9.transpose(D4, D4), e3.a9.scale(D4, D4, Ws), I4 = e3.a9.multiply(I4, I4, d6.matrix);
                  const R2 = "light-beam" === t5.renderPass, A4 = e3.a9.multiply([], n4.expandedFarZProjMatrix, C4), P4 = e3.a9.multiply([], n4.expandedFarZProjMatrix, S3), L4 = T5 & e3.d1.HasMapboxMeshFeatures, M3 = L4 ? 0 : i6.evaluatedRMEA[0][2];
                  for (let e4 = 0; e4 < d6.meshes.length; ++e4) {
                    const r8 = d6.meshes[e4], u7 = e4 === d6.lightMeshIndex;
                    let _6 = A4;
                    if (u7) {
                      if (!R2 && !t5.terrain && t5.shadowRenderer) {
                        t5.currentLayer < t5.firstLightBeamLayer && (t5.firstLightBeamLayer = t5.currentLayer);
                        continue;
                      }
                      _6 = P4;
                    } else if (R2) continue;
                    const g7 = { defines: [] }, x6 = [];
                    if (Bs(g7.defines, x6, r8, t5), L4 || g7.defines.push("DIFFUSE_SHADED"), b5 && g7.defines.push("SHADOWS_SINGLE_CASCADE"), y4 && (v4 ? y4.numRenderedVerticesInShadowPass += r8.vertexArray.length : y4.numRenderedVerticesInTransparentPass += r8.vertexArray.length), v4) {
                      Us(r8, C4, t5, o4);
                      continue;
                    }
                    let w6 = null;
                    if (a5) {
                      const e5 = Fs(C4, t5.transform);
                      if (w6 = new Float32Array(e5), "globe" !== n4.projection.name) {
                        const t6 = r8.aabb.min, i7 = r8.aabb.max, [o5, s6] = a5.getOpacityForBounds(e5, t6[0], t6[1], i7[0], i7[1]);
                        g7.overrideFog = o5 >= _e || s6 >= _e;
                      }
                    }
                    const T6 = r8.material;
                    let E4;
                    T6.occlusionTexture && T6.occlusionTexture.offsetScale && (E4 = T6.occlusionTexture.offsetScale, g7.defines.push("OCCLUSION_TEXTURE_TRANSFORM")), !v4 && l5 && (l5.useNormalOffset = !!r8.normalBuffer);
                    const z4 = t5.getOrCreateProgram("model", g7);
                    !v4 && l5 && l5.setupShadowsFromMatrix(S3, z4, l5.useNormalOffset), t5.uploadCommonUniforms(s5, z4, null, w6);
                    const O3 = T6.pbrMetallicRoughness;
                    O3.metallicFactor = 0.9, O3.roughnessFactor = 0.5;
                    const F5 = Hr(new Float32Array(_6), new Float32Array(I4), new Float32Array(D4), new Float32Array(d6.matrix), t5, p5, O3.baseColorFactor, T6.emissiveFactor, O3.metallicFactor, O3.roughnessFactor, T6, M3, o4, [0, 0, 0], E4);
                    z4.draw(t5, s5.gl.TRIANGLES, h6 && !u7 ? f5 : m5, Dt.disabled, c6 ? u7 || p5 < 1 || i6.hasTranslucentParts ? At.alphaBlended : At.unblended : At.disabled, Mt.backCCW, F5, o4.id, r8.vertexBuffer, r8.indexBuffer, r8.segments, o4.paint, t5.transform.zoom, void 0, x6);
                  }
                }
              }
            };
            (function(e4, t6, i6, o5) {
              const r6 = e4.terrain ? e4.terrain.exaggeration() : 0, s6 = e4.transform.zoom;
              for (const n5 of o5) {
                const o6 = t6.getTile(n5).getBucket(i6);
                o6 && (e4.conflationActive && o6.updateReplacement(n5, e4.replacementSource), o6.evaluateScale(e4, i6), e4.terrain && r6 > 0 && o6.elevationUpdate(e4.terrain, r6, n5, i6.source), o6.needsReEvaluation(e4, s6, i6) && o6.evaluate(i6));
              }
            })(t5, i5, o4, r5), 1 === p5 ? b4(true, true) : (b4(false, true), b4(true, false));
          }(t4, i4, o3, r4), void c4();
          const u5 = h4.getModels(), d3 = [], _4 = t4.transform.getFreeCameraOptions().position, p4 = e3.Q.scale([], [_4.x, _4.y, _4.z], t4.transform.worldSize);
          e3.Q.negate(p4, p4);
          const f4 = [], m4 = [];
          let g5 = 0;
          for (const i5 of u5) {
            const r5 = o3.paint.get("model-rotation").constantOr(null), s5 = o3.paint.get("model-scale").constantOr(null), n4 = o3.paint.get("model-translation").constantOr(null);
            i5.computeModelMatrix(t4, r5, s5, n4, true, true, false);
            const a5 = e3.a9.identity([]), l5 = e3.cZ(i5.position.lat, t4.transform.zoom), c5 = e3.a9.fromScaling([], [1, 1, 1 / l5]);
            e3.a9.translate(a5, a5, p4), d3.push({ zScaleMatrix: c5, negCameraPosMatrix: a5 });
            for (const e4 of i5.nodes) Ns(t4.transform, e4, i5.matrix, t4.transform.expandedFarZProjMatrix, g5, f4, m4);
            g5++;
          }
          if (f4.sort((e4, t5) => t5.depth - e4.depth), "shadow" !== t4.renderPass) {
            if (1 === s4) for (const e4 of m4) ks(e4, t4, o3, d3[e4.modelIndex], Dt.disabled, t4.colorModeForRenderPass());
            else {
              for (const e4 of m4) ks(e4, t4, o3, d3[e4.modelIndex], Dt.disabled, At.disabled);
              for (const e4 of m4) ks(e4, t4, o3, d3[e4.modelIndex], t4.stencilModeFor3D(), t4.colorModeForRenderPass());
              t4.resetStencilClippingMasks();
            }
            for (const e4 of f4) ks(e4, t4, o3, d3[e4.modelIndex], Dt.disabled, t4.colorModeForRenderPass());
            c4();
          } else {
            for (const e4 of m4) Us(e4.mesh, e4.nodeModelMatrix, t4, o3);
            for (const e4 of f4) Us(e4.mesh, e4.nodeModelMatrix, t4, o3);
            c4();
          }
        } }, Xs = { model: function(e4, t4, i4) {
          const o3 = t4.getSource();
          if (!o3.loaded()) return;
          if ("vector" === o3.type || "geojson" === o3.type) return void (i4.modelManager && i4.modelManager.upload(i4, "vector" === o3.type ? e4.scope : ""));
          if ("batched-model" === o3.type) return;
          const r4 = o3.getModels();
          for (const e5 of r4) e5.upload(i4.context);
        }, raster: function(e4, t4, i4) {
          const o3 = t4.getSource();
          if (!(o3 instanceof Pe && o3.loaded())) return;
          const r4 = e4.sourceLayer || o3.rasterLayerIds && o3.rasterLayerIds[0];
          if (!r4) return;
          const s4 = e4.paint.get("raster-array-band") || o3.getInitialBand(r4);
          if (null == s4) return;
          const n3 = t4.getIds().map((e5) => t4.getTileByID(e5));
          for (const e5 of n3) e5.updateNeeded(r4, s4) && o3.prepareTile(e5, r4, s4);
        }, "raster-particle": function(e4, t4, i4) {
          const o3 = t4.getSource();
          if (!(o3 instanceof Pe && o3.loaded())) return;
          const r4 = e4.sourceLayer || o3.rasterLayerIds && o3.rasterLayerIds[0];
          if (!r4) return;
          const s4 = e4.paint.get("raster-particle-array-band") || o3.getInitialBand(r4);
          if (null == s4) return;
          const n3 = t4.getIds().map((e5) => t4.getTileByID(e5));
          for (const e5 of n3) e5.updateNeeded(r4, s4) && o3.prepareTile(e5, r4, s4);
        } };
        class Ys {
          constructor(t4, i4, o3, r4) {
            this.context = new zt(t4, i4), this.transform = o3, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r4, this._timeStamp = (/* @__PURE__ */ new Date()).getTime(), this._averageFPS = 0, this._fpsHistory = [], this._debugParams = { showTerrainProxyTiles: false, fpsWindow: 30, continousRedraw: false, enabledLayers: {} };
            const s4 = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
            for (const e4 of s4) this._debugParams.enabledLayers[e4] = true;
            r4.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
              this.style.map.triggerRepaint();
            }), r4.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), r4.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: true, label: "continuous redraw" }), r4.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "value" }), r4.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "graph", view: "graph", min: 0, max: 200 });
            for (const e4 of s4) r4.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], e4);
            this.setup(), this.numSublayers = Qt.maxUnderzooming + Qt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = false, this.replacementSource = new e3.d3(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = false, this._cachedTileFogOpacities = {}, this._shadowRenderer = new yo(this), this._wireframeDebugCache = new Qs(), this.renderDefaultNorthPole = true, this.renderDefaultSouthPole = true;
          }
          updateTerrain(e4, t4) {
            const i4 = !!e4 && !!e4.terrain && this.transform.projection.supportsTerrain;
            if (!(i4 || this._terrain && this._terrain.enabled)) return;
            this._terrain || (this._terrain = new pr(this, e4));
            const o3 = this._terrain;
            this.transform.elevation = i4 ? o3 : null, o3.update(e4, this.transform, t4), this.transform.elevation && !o3.enabled && (this.transform.elevation = null);
          }
          _updateFog(e4) {
            const t4 = e4.fog;
            if (!t4 || "globe" === this.transform.projection.name || t4.getOpacity(this.transform.pitch) < 1 || t4.properties.get("horizon-blend") < 0.03) return void (this.transform.fogCullDistSq = null);
            const [i4, o3] = t4.getFovAdjustedRange(this.transform._fov);
            if (i4 > o3) return void (this.transform.fogCullDistSq = null);
            const r4 = i4 + 0.78 * (o3 - i4);
            this.transform.fogCullDistSq = r4 * r4;
          }
          get terrain() {
            return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
          }
          get shadowRenderer() {
            return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
          }
          get wireframeDebugCache() {
            return this._wireframeDebugCache;
          }
          resize(t4, i4) {
            if (this.width = t4 * e3.f.devicePixelRatio, this.height = i4 * e3.f.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e4 of this.style.order) this.style._mergedLayers[e4].resize();
          }
          setup() {
            const t4 = this.context, i4 = new e3.aQ();
            i4.emplaceBack(0, 0), i4.emplaceBack(e3.Y, 0), i4.emplaceBack(0, e3.Y), i4.emplaceBack(e3.Y, e3.Y), this.tileExtentBuffer = t4.createVertexBuffer(i4, e3.aS.members), this.tileExtentSegments = e3.aE.simpleSegment(0, 0, 4, 2);
            const o3 = new e3.aQ();
            o3.emplaceBack(0, 0), o3.emplaceBack(e3.Y, 0), o3.emplaceBack(0, e3.Y), o3.emplaceBack(e3.Y, e3.Y), this.debugBuffer = t4.createVertexBuffer(o3, e3.aS.members), this.debugSegments = e3.aE.simpleSegment(0, 0, 4, 5);
            const r4 = new e3.aQ();
            r4.emplaceBack(-1, -1), r4.emplaceBack(1, -1), r4.emplaceBack(-1, 1), r4.emplaceBack(1, 1), this.viewportBuffer = t4.createVertexBuffer(r4, e3.aS.members), this.viewportSegments = e3.aE.simpleSegment(0, 0, 4, 2);
            const s4 = new e3.ay();
            s4.emplaceBack(0, 0, 0, 0), s4.emplaceBack(e3.Y, 0, e3.Y, 0), s4.emplaceBack(0, e3.Y, 0, e3.Y), s4.emplaceBack(e3.Y, e3.Y, e3.Y, e3.Y), this.mercatorBoundsBuffer = t4.createVertexBuffer(s4, e3.aU.members), this.mercatorBoundsSegments = e3.aE.simpleSegment(0, 0, 4, 2);
            const n3 = new e3.az();
            n3.emplaceBack(0, 1, 2), n3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t4.createIndexBuffer(n3);
            const a4 = new e3.aR();
            for (const e4 of [0, 1, 3, 2, 0]) a4.emplaceBack(e4);
            this.debugIndexBuffer = t4.createIndexBuffer(a4), this.emptyTexture = new e3.T(t4, new e3.h({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t4.gl.RGBA), this.identityMat = e3.a9.create();
            const l4 = this.context.gl;
            this.stencilClearMode = new Dt({ func: l4.ALWAYS, mask: 0 }, 0, 255, l4.ZERO, l4.ZERO, l4.ZERO), this.loadTimeStamps.push(performance.now());
          }
          getMercatorTileBoundsBuffers() {
            return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
          }
          getTileBoundsBuffers(e4) {
            return e4._makeTileBoundsBuffers(this.context, this.transform.projection), e4._tileBoundsBuffer ? { tileBoundsBuffer: e4._tileBoundsBuffer, tileBoundsIndexBuffer: e4._tileBoundsIndexBuffer, tileBoundsSegments: e4._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
          }
          clearStencil() {
            const e4 = this.context.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e4.TRIANGLES, Ct.disabled, this.stencilClearMode, At.disabled, Mt.disabled, cr(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          resetStencilClippingMasks() {
            this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
          }
          _renderTileClippingMasks(e4, t4, i4) {
            if (!t4 || this.currentStencilSource === t4.id || !e4.isTileClipped() || !i4 || 0 === i4.length) return;
            if (this._tileClippingMaskIDs && !this.terrain) {
              let e5 = false;
              for (const t5 of i4) if (void 0 === this._tileClippingMaskIDs[t5.key]) {
                e5 = true;
                break;
              }
              if (!e5) return;
            }
            this.currentStencilSource = t4.id;
            const o3 = this.context, r4 = o3.gl;
            this.nextStencilID + i4.length > 256 && this.clearStencil(), o3.setColorMode(At.disabled), o3.setDepthMode(Ct.disabled);
            const s4 = this.getOrCreateProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const e5 of i4) {
              const i5 = t4.getTile(e5), o4 = this._tileClippingMaskIDs[e5.key] = this.nextStencilID++, { tileBoundsBuffer: n3, tileBoundsIndexBuffer: a4, tileBoundsSegments: l4 } = this.getTileBoundsBuffers(i5);
              s4.draw(this, r4.TRIANGLES, Ct.disabled, new Dt({ func: r4.ALWAYS, mask: 0 }, o4, 255, r4.KEEP, r4.KEEP, r4.REPLACE), At.disabled, Mt.disabled, cr(e5.projMatrix), "$clipping", n3, a4, l4);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e4 = this.nextStencilID++, t4 = this.context.gl;
            return new Dt({ func: t4.NOTEQUAL, mask: 255 }, e4, 255, t4.KEEP, t4.KEEP, t4.REPLACE);
          }
          stencilModeForClipping(e4) {
            if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e4);
            const t4 = this.context.gl;
            return new Dt({ func: t4.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e4.key], 0, t4.KEEP, t4.KEEP, t4.REPLACE);
          }
          stencilConfigForOverlap(e4) {
            const t4 = this.context.gl, i4 = e4.sort((e5, t5) => t5.overscaledZ - e5.overscaledZ), o3 = i4[i4.length - 1].overscaledZ, r4 = i4[0].overscaledZ - o3 + 1;
            if (r4 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + r4 > 256 && this.clearStencil();
              const e5 = {};
              for (let i5 = 0; i5 < r4; i5++) e5[i5 + o3] = new Dt({ func: t4.GEQUAL, mask: 255 }, i5 + this.nextStencilID, 255, t4.KEEP, t4.KEEP, t4.REPLACE);
              return this.nextStencilID += r4, [e5, i4];
            }
            return [{ [o3]: Dt.disabled }, i4];
          }
          colorModeForRenderPass() {
            const t4 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i4 = 1 / 8;
              return new At([t4.CONSTANT_COLOR, t4.ONE, t4.CONSTANT_COLOR, t4.ONE], new e3.aA(i4, i4, i4, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? At.unblended : At.alphaBlended;
          }
          colorModeForDrapableLayerRenderPass(t4) {
            const i4 = this.context.gl;
            return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new At([i4.ONE, i4.ONE_MINUS_SRC_ALPHA, i4.CONSTANT_ALPHA, i4.ONE_MINUS_SRC_ALPHA], new e3.aA(0, 0, 0, void 0 === t4 ? 0 : t4), [true, true, true, true]) : this.colorModeForRenderPass();
          }
          depthModeForSublayer(e4, t4, i4, o3 = false) {
            if (!this.opaquePassEnabledForLayer() && !o3) return Ct.disabled;
            const r4 = 1 - ((1 + this.currentLayer) * this.numSublayers + e4) * this.depthEpsilon;
            return new Ct(i4 || this.context.gl.LEQUAL, t4, [r4, r4]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          updateAverageFPS() {
            const e4 = (/* @__PURE__ */ new Date()).getTime(), t4 = e4 - this._timeStamp;
            this._timeStamp = e4, this._fpsHistory.push(0 === t4 ? 0 : 1e3 / t4), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e5, t5) => e5 + t5 / this._fpsHistory.length, 0));
          }
          render(t4, i4) {
            this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t4.map.repaint, this.style = t4, this.options = i4;
            const o3 = this.style._mergedLayers, r4 = this.style.order.filter((e4) => {
              const t5 = o3[e4];
              return !(t5.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t5.type];
            }), s4 = r4.map((e4) => o3[e4]), n3 = this.style._mergedSourceCaches;
            this.imageManager = t4.imageManager, this.modelManager = t4.modelManager, this.symbolFadeChange = t4.placement.symbolFadeChange(e3.f.now()), this.imageManager.beginFrame();
            let a4 = 0, l4 = false;
            for (const e4 in n3) {
              const t5 = n3[e4];
              t5.used && (t5.prepare(this.context), t5.getSource().usedInConflation && ++a4);
            }
            for (const e4 of s4) e4.isHidden(this.transform.zoom) || this.prepareLayer(e4);
            const c4 = {}, h4 = {}, u5 = {}, d3 = {}, _4 = {};
            for (const e4 in n3) {
              const t5 = n3[e4];
              c4[e4] = t5.getVisibleCoordinates(), h4[e4] = c4[e4].slice().reverse(), u5[e4] = t5.getVisibleCoordinates(true).reverse(), d3[e4] = t5.getShadowCasterCoordinates(), _4[e4] = t5.sortCoordinatesByDistance(c4[e4]);
            }
            const p4 = (e4) => {
              const t5 = this.style.getLayerSourceCache(e4);
              return t5 && t5.used ? t5.getSource() : null;
            };
            if (a4) {
              const e4 = [];
              for (const t5 of s4) this.layerUsedInConflation(t5, p4(t5)) && e4.push(t5);
              if (e4 && e4.length > 1) {
                const t5 = [];
                for (const i5 of e4) {
                  const e5 = this.style.getLayerSourceCache(i5);
                  e5 && e5.used && e5.getSource().usedInConflation && t5.push({ layer: i5.fqid, cache: e5 });
                }
                this.replacementSource.setSources(t5), l4 = true;
              }
            }
            l4 || this.replacementSource.clear(), this.conflationActive = l4, this.minCutoffZoom = 0, this.longestCutoffRange = 0;
            for (const e4 of s4) {
              const t5 = e4.cutoffRange();
              if (this.longestCutoffRange = Math.max(t5, this.longestCutoffRange), t5 > 0) {
                const t6 = p4(e4);
                t6 && (this.minCutoffZoom = Math.max(t6.minzoom, this.minCutoffZoom)), e4.minzoom && (this.minCutoffZoom = Math.max(e4.minzoom, this.minCutoffZoom));
              }
            }
            this.opaquePassCutoff = 1 / 0;
            for (let e4 = 0; e4 < s4.length; e4++) if (s4[e4].is3D()) {
              this.opaquePassCutoff = e4;
              break;
            }
            const f4 = this.style && this.style.fog;
            f4 ? (this._fogVisible = 0 !== f4.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = f4.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = false, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(u5), this.opaquePassCutoff = 0);
            const m4 = this._shadowRenderer;
            if (m4) {
              m4.updateShadowParameters(this.transform, this.style.directionalLight);
              for (const e4 in n3) for (const t5 of c4[e4]) {
                let e5 = { min: 0, max: 0 };
                this.terrain && (e5 = this.terrain.getMinMaxForTile(t5) || e5), m4.addShadowReceiver(t5.toUnwrapped(), e5.min, e5.max);
              }
            }
            if ("globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e3.d4(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Os(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), !e3.d5(this.context.gl)) return;
            this.renderPass = "offscreen";
            for (const e4 of s4) {
              const i5 = t4.getLayerSourceCache(e4);
              if (!e4.hasOffscreenPass() || e4.isHidden(this.transform.zoom)) continue;
              const o4 = i5 ? h4[i5.id] : void 0;
              ("custom" === e4.type || "raster" === e4.type || "raster-particle" === e4.type || e4.isSky() || o4 && o4.length) && this.renderLayer(this, i5, e4, o4);
            }
            this.depthRangeFor3D = [0, 1 - (s4.length + 2) * this.numSublayers * this.depthEpsilon];
            const g5 = this.terrain;
            g5 && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && !this.transform.isOrthographic && g5.drawDepth(), this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, d3)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
            const v4 = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), x5 = (() => {
              if (i4.showOverdrawInspector) return e3.aA.black;
              if (this.style.fog && this.transform.projection.supportsFog && !v4) {
                const t5 = this.style.fog.properties.get("color").toArray01();
                return new e3.aA(...t5);
              }
              if (this.style.fog && this.transform.projection.supportsFog && v4) {
                const t5 = this.style.fog.properties.get("space-color").toArray01();
                return new e3.aA(...t5);
              }
              return e3.aA.transparent;
            })();
            if (this.context.clear({ color: x5, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i4.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && v4 && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = r4.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const e4 = s4[this.currentLayer], i5 = t4.getLayerSourceCache(e4);
              if (e4.isSky()) continue;
              const o4 = i5 ? (e4.is3D() ? _4 : h4)[i5.id] : void 0;
              this._renderTileClippingMasks(e4, i5, o4), this.renderLayer(this, i5, e4, o4);
            }
            if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && v4 && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e3.W(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < r4.length; this.currentLayer++) {
              const e4 = s4[this.currentLayer], i5 = t4.getLayerSourceCache(e4);
              e4.isSky() && this.renderLayer(this, i5, e4, i5 ? h4[i5.id] : void 0);
            }
            function y4(e4, t5) {
              let i5;
              return t5 && (i5 = ("symbol" === e4.type ? u5 : e4.is3D() ? _4 : h4)[t5.id]), i5;
            }
            if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
              for (this.renderElevatedRasterBackface = true, this.currentLayer = 0; this.currentLayer < r4.length; ) {
                const e4 = s4[this.currentLayer];
                if ("raster" === e4.type) {
                  const i5 = t4.getLayerSourceCache(e4);
                  this.renderLayer(this, i5, e4, y4(e4, i5));
                }
                ++this.currentLayer;
              }
              this.renderElevatedRasterBackface = false;
            }
            this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
            let b4 = 0;
            for (m4 && (b4 = m4.getShadowCastingLayerCount()); this.currentLayer < r4.length; ) {
              const e4 = s4[this.currentLayer], i5 = t4.getLayerSourceCache(e4);
              if (e4.isSky()) ++this.currentLayer;
              else if (g5 && this.style.isLayerDraped(e4)) {
                if (e4.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = g5.renderBatch(this.currentLayer);
              } else {
                if (this._renderTileClippingMasks(e4, i5, i5 ? c4[i5.id] : void 0), this.renderLayer(this, i5, e4, y4(e4, i5)), !g5 && m4 && b4 > 0 && e4.hasShadowPass() && 0 == --b4 && (m4.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                  const e5 = this.currentLayer;
                  for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e5; this.currentLayer++) {
                    const e6 = s4[this.currentLayer];
                    if (!e6.hasLightBeamPass()) continue;
                    const i6 = t4.getLayerSourceCache(e6);
                    this.renderLayer(this, i6, e6, i6 ? h4[i6.id] : void 0);
                  }
                  this.currentLayer = e5, this.renderPass = "translucent";
                }
                ++this.currentLayer;
              }
            }
            if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
              let i5 = null;
              s4.forEach((e4) => {
                const o4 = t4.getLayerSourceCache(e4);
                o4 && !e4.isHidden(this.transform.zoom) && o4.getVisibleCoordinates().length && (!i5 || i5.getSource().maxzoom < o4.getSource().maxzoom) && (i5 = o4);
              }), i5 && this.options.showTileBoundaries && $s.debug(this, i5, i5.getVisibleCoordinates(), e3.aA.red, false, this.options.showParseStatus);
            }
            this.terrain && this._debugParams.showTerrainProxyTiles && $s.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e3.aA(1, 0.8, 0.1, 1), true, this.options.showParseStatus), this.options.showPadding && function(e4) {
              const t5 = e4.transform.padding;
              Ts(e4, e4.transform.height - (t5.top || 0), 3, gs), Ts(e4, t5.bottom || 0, 3, vs), Es(e4, t5.left || 0, 3, xs), Es(e4, e4.transform.width - (t5.right || 0), 3, ys);
              const i5 = e4.transform.centerPoint;
              !function(e5, t6, i6, o4) {
                Ss(e5, t6 - 1, i6 - 10, 2, 20, o4), Ss(e5, t6 - 10, i6 - 1, 20, 2, o4);
              }(e4, i5.x, e4.transform.height - i5.y, bs);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), l4 || (this.conflationActive = false);
          }
          prepareLayer(e4) {
            this.gpuTimingStart(e4);
            const { unsupportedLayers: t4 } = this.transform.projection, i4 = !t4 || !t4.includes(e4.type);
            if (Xs[e4.type] && (i4 || this.terrain && "custom" === e4.type)) {
              const t5 = this.style.getLayerSourceCache(e4);
              Xs[e4.type](e4, t5, this);
            }
            this.gpuTimingEnd();
          }
          renderLayer(e4, t4, i4, o3) {
            i4.isHidden(this.transform.zoom) || ("background" === i4.type || "sky" === i4.type || "custom" === i4.type || "model" === i4.type || "raster" === i4.type || "raster-particle" === i4.type || o3 && o3.length) && (this.id = i4.id, this.gpuTimingStart(i4), (!e4.transform.projection.unsupportedLayers || !e4.transform.projection.unsupportedLayers.includes(i4.type) || e4.terrain && "custom" === i4.type) && $s[i4.type](e4, t4, i4, o3, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
          }
          gpuTimingStart(e4) {
            if (!this.options.gpuTiming) return;
            const t4 = this.context.extTimerQuery, i4 = this.context.gl;
            let o3 = this.gpuTimers[e4.id];
            o3 || (o3 = this.gpuTimers[e4.id] = { calls: 0, cpuTime: 0, query: i4.createQuery() }), o3.calls++, i4.beginQuery(t4.TIME_ELAPSED_EXT, o3.query);
          }
          gpuTimingDeferredRenderStart() {
            if (this.options.gpuTimingDeferredRender) {
              const e4 = this.context.extTimerQuery, t4 = this.context.gl, i4 = t4.createQuery();
              this.deferredRenderGpuTimeQueries.push(i4), t4.beginQuery(e4.TIME_ELAPSED_EXT, i4);
            }
          }
          gpuTimingDeferredRenderEnd() {
            this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
          }
          gpuTimingEnd() {
            this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            const e4 = this.gpuTimers;
            return this.gpuTimers = {}, e4;
          }
          collectDeferredRenderGpuQueries() {
            const e4 = this.deferredRenderGpuTimeQueries;
            return this.deferredRenderGpuTimeQueries = [], e4;
          }
          queryGpuTimers(e4) {
            const t4 = {};
            for (const i4 in e4) {
              const o3 = e4[i4], r4 = this.context.extTimerQuery, s4 = r4.getQueryParameter(o3.query, this.context.gl.QUERY_RESULT) / 1e6;
              r4.deleteQueryEXT(o3.query), t4[i4] = s4;
            }
            return t4;
          }
          queryGpuTimeDeferredRender(e4) {
            if (!this.options.gpuTimingDeferredRender) return 0;
            const t4 = this.context.extTimerQuery, i4 = this.context.gl;
            let o3 = 0;
            for (const r4 of e4) o3 += t4.getQueryParameter(r4, i4.QUERY_RESULT) / 1e6, t4.deleteQueryEXT(r4);
            return o3;
          }
          translatePosMatrix(t4, i4, o3, r4, s4) {
            if (!o3[0] && !o3[1]) return t4;
            const n3 = s4 ? "map" === r4 ? this.transform.angle : 0 : "viewport" === r4 ? -this.transform.angle : 0;
            if (n3) {
              const e4 = Math.sin(n3), t5 = Math.cos(n3);
              o3 = [o3[0] * t5 - o3[1] * e4, o3[0] * e4 + o3[1] * t5];
            }
            const a4 = [s4 ? o3[0] : e3.a6(i4, o3[0], this.transform.zoom), s4 ? o3[1] : e3.a6(i4, o3[1], this.transform.zoom), 0], l4 = new Float32Array(16);
            return e3.a9.translate(l4, t4, a4), l4;
          }
          saveTileTexture(e4) {
            const t4 = e4.size[0], i4 = this._tileTextures[t4];
            i4 ? i4.push(e4) : this._tileTextures[t4] = [e4];
          }
          getTileTexture(e4) {
            const t4 = this._tileTextures[e4];
            return t4 && t4.length > 0 ? t4.pop() : null;
          }
          isPatternMissing(e4, t4) {
            return null === e4 || void 0 !== e4 && !this.imageManager.getPattern(e4.toString(), t4);
          }
          terrainRenderModeElevated() {
            return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
          }
          linearFloatFilteringSupported() {
            return null != this.context.extTextureFloatLinear;
          }
          currentGlobalDefines(e4, t4, i4) {
            const o3 = void 0 === i4 ? this.terrain && this.terrain.renderingToTexture : i4, r4 = this.terrain && 0 === this.terrain.exaggeration(), s4 = [];
            return this.style && this.style.enable3dLights() && ("globeRaster" === e4 || "terrainRaster" === e4 ? (s4.push("LIGHTING_3D_MODE"), s4.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o3 || s4.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass ? this._shadowMapDebug || s4.push("DEPTH_TEXTURE") : this.shadowRenderer && (this.shadowRenderer.useNormalOffset ? s4.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET") : s4.push("RENDER_SHADOWS", "DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (s4.push("TERRAIN"), this.linearFloatFilteringSupported() && s4.push("TERRAIN_DEM_FLOAT_FORMAT"), r4 && s4.push("ZERO_EXAGGERATION")), "globe" === this.transform.projection.name && s4.push("GLOBE"), !this._fogVisible || o3 || void 0 !== t4 && !t4 || s4.push("FOG", "FOG_DITHERING"), o3 && s4.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && s4.push("OVERDRAW_INSPECTOR"), s4;
          }
          getOrCreateProgram(e4, t4) {
            this.cache = this.cache || {};
            const i4 = t4 && t4.defines || [], o3 = t4 && t4.config, r4 = this.currentGlobalDefines(e4, t4 && t4.overrideFog, t4 && t4.overrideRtt).concat(i4), s4 = vr.cacheKey(qo[e4], e4, r4, o3);
            return this.cache[s4] || (this.cache[s4] = new vr(this.context, e4, qo[e4], o3, Qr[e4], r4)), this.cache[s4];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e4 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e4.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e3.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy();
          }
          prepareDrawTile() {
            this.terrain && this.terrain.prepareDrawTile();
          }
          uploadCommonLightUniforms(t4, i4) {
            if (this.style.enable3dLights()) {
              const o3 = this.style.directionalLight, r4 = this.style.ambientLight;
              if (o3 && r4) {
                const s4 = ((t5, i5) => {
                  const o4 = t5.properties.get("direction"), r5 = t5.properties.get("color").toArray01(), s5 = t5.properties.get("intensity"), n3 = i5.properties.get("color").toArray01(), a4 = i5.properties.get("intensity"), l4 = [o4.x, o4.y, o4.z], c4 = e3.cs(n3, a4), h4 = e3.cs(r5, s5);
                  return { u_lighting_ambient_color: c4, u_lighting_directional_dir: l4, u_lighting_directional_color: h4, u_ground_radiance: fr(l4, h4, c4) };
                })(o3, r4);
                i4.setLightsUniformValues(t4, s4);
              }
            }
          }
          uploadCommonUniforms(t4, i4, o3, r4, s4) {
            if (this.uploadCommonLightUniforms(t4, i4), this.terrain && this.terrain.renderingToTexture) return;
            const n3 = this.style.fog;
            if (n3) {
              const s5 = n3.getOpacity(this.transform.pitch), a4 = ((t5, i5, o4, r5, s6, n4, a5, l4, c4, h4, u5, d3) => {
                const _4 = t5.transform, p4 = i5.properties.get("color").toArray01();
                p4[3] = r5;
                const f4 = t5.frameCounter / 1e3 % 1, [m4, g5] = i5.properties.get("vertical-range");
                return { u_fog_matrix: o4 ? _4.calculateFogTileMatrix(o4) : d3 || t5.identityMat, u_fog_range: i5.getFovAdjustedRange(_4._fov), u_fog_color: p4, u_fog_horizon_blend: i5.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(m4, g5), g5], u_fog_temporal_offset: f4, u_frustum_tl: s6, u_frustum_tr: n4, u_frustum_br: a5, u_frustum_bl: l4, u_globe_pos: c4, u_globe_radius: h4, u_viewport: u5, u_globe_transition: e3.W(_4.zoom), u_is_globe: +("globe" === _4.projection.name) };
              })(this, n3, o3, s5, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e3.f.devicePixelRatio, this.transform.height * e3.f.devicePixelRatio], r4);
              i4.setFogUniformValues(t4, a4);
            }
            s4 && i4.setCutoffUniformValues(t4, s4.uniformValues);
          }
          setTileLoadedFlag(e4) {
            this.tileLoaded = e4;
          }
          saveCanvasCopy() {
            const e4 = this.canvasCopy();
            e4 && (this.frameCopies.push(e4), this.tileLoaded = false);
          }
          canvasCopy() {
            const e4 = this.context.gl, t4 = e4.createTexture();
            return e4.bindTexture(e4.TEXTURE_2D, t4), e4.copyTexImage2D(e4.TEXTURE_2D, 0, e4.RGBA, 0, 0, e4.drawingBufferWidth, e4.drawingBufferHeight, 0), t4;
          }
          getCanvasCopiesAndTimestamps() {
            return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
          }
          averageElevationNeedsEasing() {
            if (!this.transform._elevation) return false;
            const e4 = this.style && this.style.fog;
            return !!e4 && 0 !== e4.getOpacity(this.transform.pitch);
          }
          getBackgroundTiles() {
            const e4 = this._backgroundTiles, t4 = this._backgroundTiles = {}, i4 = this.transform.coveringTiles({ tileSize: 512 });
            for (const o3 of i4) t4[o3.key] = e4[o3.key] || new Nt(o3, 512, this.transform.tileZoom, this);
            return t4;
          }
          clearBackgroundTiles() {
            this._backgroundTiles = {};
          }
          layerUsedInConflation(e4, t4) {
            return !(!e4.is3D() || e4.minzoom && e4.minzoom > this.transform.zoom || "building" !== e4.sourceLayer && (!t4 || "batched-model" !== t4.type));
          }
          isTileAffectedByFog(e4) {
            if (!this.style || !this.style.fog) return false;
            if ("globe" === this.transform.projection.name) return true;
            let t4 = this._cachedTileFogOpacities[e4.key];
            return t4 || (this._cachedTileFogOpacities[e4.key] = t4 = this.style.fog.getOpacityForTile(e4)), t4[0] >= _e || t4[1] >= _e;
          }
        }
        function Js(e4, t4) {
          let i4 = false, o3 = null;
          const r4 = () => {
            o3 = null, i4 && (e4(), o3 = setTimeout(r4, t4), i4 = false);
          };
          return () => (i4 = true, o3 || r4(), o3);
        }
        class Ks {
          constructor(t4) {
            this._hashName = t4 && encodeURIComponent(t4), e3.a$(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Js(this._updateHashUnthrottled.bind(this), 300);
          }
          addTo(e4) {
            return this._map = e4, window.addEventListener("hashchange", this._onHashChange, false), e4.on("moveend", this._updateHash), this;
          }
          remove() {
            return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
          }
          getHashString() {
            const e4 = this._map;
            if (!e4) return "";
            const t4 = en2(e4);
            if (this._hashName) {
              const e5 = this._hashName;
              let i4 = false;
              const o3 = location.hash.slice(1).split("&").map((o4) => {
                const r4 = o4.split("=")[0];
                return r4 === e5 ? (i4 = true, `${r4}=${t4}`) : o4;
              }).filter((e6) => e6);
              return i4 || o3.push(`${e5}=${t4}`), `#${o3.join("&")}`;
            }
            return `#${t4}`;
          }
          _getCurrentHash() {
            const e4 = location.hash.replace("#", "");
            if (this._hashName) {
              let t4;
              return e4.split("&").map((e5) => e5.split("=")).forEach((e5) => {
                e5[0] === this._hashName && (t4 = e5);
              }), (t4 && t4[1] || "").split("/");
            }
            return e4.split("/");
          }
          _onHashChange() {
            const e4 = this._map;
            if (!e4) return false;
            const t4 = this._getCurrentHash();
            if (t4.length >= 3 && !t4.some((e5) => isNaN(e5))) {
              const i4 = e4.dragRotate.isEnabled() && e4.touchZoomRotate.isEnabled() ? +(t4[3] || 0) : e4.getBearing();
              return e4.jumpTo({ center: [+t4[2], +t4[1]], zoom: +t4[0], bearing: i4, pitch: +(t4[4] || 0) }), true;
            }
            return false;
          }
          _updateHashUnthrottled() {
            history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
          }
        }
        function en2(e4, t4) {
          const i4 = e4.getCenter(), o3 = Math.round(100 * e4.getZoom()) / 100, r4 = Math.ceil((o3 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), s4 = Math.pow(10, r4), n3 = Math.round(i4.lng * s4) / s4, a4 = Math.round(i4.lat * s4) / s4, l4 = e4.getBearing(), c4 = e4.getPitch();
          let h4 = t4 ? `/${n3}/${a4}/${o3}` : `${o3}/${a4}/${n3}`;
          return (l4 || c4) && (h4 += "/" + Math.round(10 * l4) / 10), c4 && (h4 += `/${Math.round(c4)}`), h4;
        }
        const tn2 = { linearity: 0.3, easing: e3.d6(0, 0, 0.3, 1) }, on = e3.e({ deceleration: 2500, maxSpeed: 1400 }, tn2), rn = e3.e({ deceleration: 20, maxSpeed: 1400 }, tn2), sn = e3.e({ deceleration: 1e3, maxSpeed: 360 }, tn2), nn2 = e3.e({ deceleration: 1e3, maxSpeed: 90 }, tn2);
        class an {
          constructor(e4) {
            this._map = e4, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t4) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e3.f.now(), settings: t4 });
          }
          _drainInertiaBuffer() {
            const t4 = this._inertiaBuffer, i4 = e3.f.now();
            for (; t4.length > 0 && i4 - t4[0].time > 160; ) t4.shift();
          }
          _onMoveEnd(t4) {
            if (this._map._prefersReducedMotion()) return;
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i4 = { zoom: 0, bearing: 0, pitch: 0, pan: new e3.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: e4 } of this._inertiaBuffer) i4.zoom += e4.zoomDelta || 0, i4.bearing += e4.bearingDelta || 0, i4.pitch += e4.pitchDelta || 0, e4.panDelta && i4.pan._add(e4.panDelta), e4.around && (i4.around = e4.around), e4.pinchAround && (i4.pinchAround = e4.pinchAround);
            const o3 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r4 = {};
            if (i4.pan.mag()) {
              const s4 = cn(i4.pan.mag(), o3, e3.e({}, on, t4 || {}));
              r4.offset = i4.pan.mult(s4.amount / i4.pan.mag()), r4.center = this._map.transform.center, ln(r4, s4);
            }
            if (i4.zoom) {
              const e4 = cn(i4.zoom, o3, rn);
              r4.zoom = this._map.transform.zoom + e4.amount, ln(r4, e4);
            }
            if (i4.bearing) {
              const t5 = cn(i4.bearing, o3, sn);
              r4.bearing = this._map.transform.bearing + e3.ad(t5.amount, -179, 179), ln(r4, t5);
            }
            if (i4.pitch) {
              const e4 = cn(i4.pitch, o3, nn2);
              r4.pitch = this._map.transform.pitch + e4.amount, ln(r4, e4);
            }
            if (r4.zoom || r4.bearing) {
              const e4 = void 0 === i4.pinchAround ? i4.around : i4.pinchAround;
              r4.around = e4 ? this._map.unproject(e4) : this._map.getCenter();
            }
            return this.clear(), r4.noMoveStart = true, r4;
          }
        }
        function ln(e4, t4) {
          (!e4.duration || e4.duration < t4.duration) && (e4.duration = t4.duration, e4.easing = t4.easing);
        }
        function cn(t4, i4, o3) {
          const { maxSpeed: r4, linearity: s4, deceleration: n3 } = o3, a4 = e3.ad(t4 * s4 / (i4 / 1e3), -r4, r4), l4 = Math.abs(a4) / (n3 * s4);
          return { easing: o3.easing, duration: 1e3 * l4, amount: a4 * (l4 / 2) };
        }
        class hn extends e3.b {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t4, i4, o3, r4 = {}) {
            const s4 = p3(i4.getCanvasContainer(), o3), n3 = i4.unproject(s4);
            super(t4, e3.e({ point: s4, lngLat: n3, originalEvent: o3 }, r4)), this._defaultPrevented = false, this.target = i4;
          }
        }
        class un extends e3.b {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t4, i4, o3) {
            const r4 = "touchend" === t4 ? o3.changedTouches : o3.touches, s4 = f3(i4.getCanvasContainer(), r4), n3 = s4.map((e4) => i4.unproject(e4)), a4 = s4.reduce((e4, t5, i5, o4) => e4.add(t5.div(o4.length)), new e3.P(0, 0));
            super(t4, { points: s4, point: a4, lngLats: n3, lngLat: i4.unproject(a4), originalEvent: o3 }), this._defaultPrevented = false;
          }
        }
        class dn extends e3.b {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e4, t4, i4) {
            super(e4, { originalEvent: i4 }), this._defaultPrevented = false;
          }
        }
        class _n {
          constructor(e4, t4) {
            this._map = e4, this._clickTolerance = t4.clickTolerance;
          }
          reset() {
            this._mousedownPos = void 0;
          }
          wheel(e4) {
            return this._firePreventable(new dn(e4.type, this._map, e4));
          }
          mousedown(e4, t4) {
            return this._mousedownPos = t4, this._firePreventable(new hn(e4.type, this._map, e4));
          }
          mouseup(e4) {
            this._map.fire(new hn(e4.type, this._map, e4));
          }
          preclick(t4) {
            const i4 = e3.e({}, t4);
            i4.type = "preclick", this._map.fire(new hn(i4.type, this._map, i4));
          }
          click(e4, t4) {
            this._mousedownPos && this._mousedownPos.dist(t4) >= this._clickTolerance || (this.preclick(e4), this._map.fire(new hn(e4.type, this._map, e4)));
          }
          dblclick(e4) {
            return this._firePreventable(new hn(e4.type, this._map, e4));
          }
          mouseover(e4) {
            this._map.fire(new hn(e4.type, this._map, e4));
          }
          mouseout(e4) {
            this._map.fire(new hn(e4.type, this._map, e4));
          }
          touchstart(e4) {
            return this._firePreventable(new un(e4.type, this._map, e4));
          }
          touchmove(e4) {
            this._map.fire(new un(e4.type, this._map, e4));
          }
          touchend(e4) {
            this._map.fire(new un(e4.type, this._map, e4));
          }
          touchcancel(e4) {
            this._map.fire(new un(e4.type, this._map, e4));
          }
          _firePreventable(e4) {
            if (this._map.fire(e4), e4.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class pn {
          constructor(e4) {
            this._map = e4;
          }
          reset() {
            this._delayContextMenu = false, this._contextMenuEvent = void 0;
          }
          mousemove(e4) {
            this._map.fire(new hn(e4.type, this._map, e4));
          }
          mousedown() {
            this._delayContextMenu = true;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new hn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e4) {
            this._delayContextMenu ? this._contextMenuEvent = e4 : this._map.fire(new hn(e4.type, this._map, e4)), this._map.listens("contextmenu") && e4.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class fn {
          constructor(e4, t4) {
            this._map = e4, this._el = e4.getCanvasContainer(), this._container = e4.getContainer(), this._clickTolerance = t4.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e4, t4) {
            this.isEnabled() && e4.shiftKey && 0 === e4.button && (h3(), this._startPos = this._lastPos = t4, this._active = true);
          }
          mousemoveWindow(e4, t4) {
            if (!this._active) return;
            const i4 = t4, o3 = this._startPos, r4 = this._lastPos;
            if (!o3 || !r4 || r4.equals(i4) || !this._box && i4.dist(o3) < this._clickTolerance) return;
            this._lastPos = i4, this._box || (this._box = s3("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e4));
            const n3 = Math.min(o3.x, i4.x), a4 = Math.max(o3.x, i4.x), l4 = Math.min(o3.y, i4.y), c4 = Math.max(o3.y, i4.y);
            this._map._requestDomTask(() => {
              this._box && (this._box.style.transform = `translate(${n3}px,${l4}px)`, this._box.style.width = a4 - n3 + "px", this._box.style.height = c4 - l4 + "px");
            });
          }
          mouseupWindow(t4, i4) {
            if (!this._active) return;
            const o3 = this._startPos, r4 = i4;
            if (o3 && 0 === t4.button) {
              if (this.reset(), _3(), o3.x !== r4.x || o3.y !== r4.y) return this._map.fire(new e3.b("boxzoomend", { originalEvent: t4 })), { cameraAnimation: (e4) => e4.fitScreenCoordinates(o3, r4, this._map.getBearing(), { linear: false }) };
              this._fireEvent("boxzoomcancel", t4);
            }
          }
          keydown(e4) {
            this._active && 27 === e4.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e4));
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u4(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t4, i4) {
            return this._map.fire(new e3.b(t4, { originalEvent: i4 }));
          }
        }
        function mn(e4, t4) {
          const i4 = {};
          for (let o3 = 0; o3 < e4.length; o3++) i4[e4[o3].identifier] = t4[o3];
          return i4;
        }
        class gn {
          constructor(e4) {
            this.reset(), this.numTouches = e4.numTouches;
          }
          reset() {
            this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
          }
          touchstart(t4, i4, o3) {
            (this.centroid || o3.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t4.timeStamp), o3.length === this.numTouches && (this.centroid = function(t5) {
              const i5 = new e3.P(0, 0);
              for (const e4 of t5) i5._add(e4);
              return i5.div(t5.length);
            }(i4), this.touches = mn(o3, i4)));
          }
          touchmove(e4, t4, i4) {
            if (this.aborted || !this.centroid) return;
            const o3 = mn(i4, t4);
            for (const e5 in this.touches) {
              const t5 = o3[e5];
              (!t5 || t5.dist(this.touches[e5]) > 30) && (this.aborted = true);
            }
          }
          touchend(e4, t4, i4) {
            if ((!this.centroid || e4.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i4.length) {
              const e5 = !this.aborted && this.centroid;
              if (this.reset(), e5) return e5;
            }
          }
        }
        class vn {
          constructor(e4) {
            this.singleTap = new gn(e4), this.numTaps = e4.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
          }
          touchstart(e4, t4, i4) {
            this.singleTap.touchstart(e4, t4, i4);
          }
          touchmove(e4, t4, i4) {
            this.singleTap.touchmove(e4, t4, i4);
          }
          touchend(e4, t4, i4) {
            const o3 = this.singleTap.touchend(e4, t4, i4);
            if (o3) {
              const t5 = e4.timeStamp - this.lastTime < 500, i5 = !this.lastTap || this.lastTap.dist(o3) < 30;
              if (t5 && i5 || this.reset(), this.count++, this.lastTime = e4.timeStamp, this.lastTap = o3, this.count === this.numTaps) return this.reset(), o3;
            }
          }
        }
        class xn {
          constructor() {
            this._zoomIn = new vn({ numTouches: 1, numTaps: 2 }), this._zoomOut = new vn({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e4, t4, i4) {
            this._zoomIn.touchstart(e4, t4, i4), this._zoomOut.touchstart(e4, t4, i4);
          }
          touchmove(e4, t4, i4) {
            this._zoomIn.touchmove(e4, t4, i4), this._zoomOut.touchmove(e4, t4, i4);
          }
          touchend(e4, t4, i4) {
            const o3 = this._zoomIn.touchend(e4, t4, i4), r4 = this._zoomOut.touchend(e4, t4, i4);
            return o3 ? (this._active = true, e4.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t5) => t5.easeTo({ duration: 300, zoom: t5.getZoom() + 1, around: t5.unproject(o3) }, { originalEvent: e4 }) }) : r4 ? (this._active = true, e4.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t5) => t5.easeTo({ duration: 300, zoom: t5.getZoom() - 1, around: t5.unproject(r4) }, { originalEvent: e4 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        const yn = { 0: 1, 2: 2 };
        class bn {
          constructor(e4) {
            this.reset(), this._clickTolerance = e4.clickTolerance || 1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
          }
          _correctButton(e4, t4) {
            return false;
          }
          _move(e4, t4) {
            return {};
          }
          mousedown(e4, t4) {
            if (this._lastPoint) return;
            const i4 = m3(e4);
            this._correctButton(e4, i4) && (this._lastPoint = t4, this._eventButton = i4);
          }
          mousemoveWindow(e4, t4) {
            const i4 = this._lastPoint;
            if (i4) {
              if (e4.preventDefault(), null != this._eventButton && function(e5, t5) {
                const i5 = yn[t5];
                return void 0 === e5.buttons || (e5.buttons & i5) !== i5;
              }(e4, this._eventButton)) this.reset();
              else if (this._moved || !(t4.dist(i4) < this._clickTolerance)) return this._moved = true, this._lastPoint = t4, this._move(i4, t4);
            }
          }
          mouseupWindow(e4) {
            this._lastPoint && m3(e4) === this._eventButton && (this._moved && _3(), this.reset());
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class wn extends bn {
          mousedown(e4, t4) {
            super.mousedown(e4, t4), this._lastPoint && (this._active = true);
          }
          _correctButton(e4, t4) {
            return 0 === t4 && !e4.ctrlKey;
          }
          _move(e4, t4) {
            return { around: t4, panDelta: t4.sub(e4) };
          }
        }
        class Tn extends bn {
          _correctButton(e4, t4) {
            return 0 === t4 && e4.ctrlKey || 2 === t4;
          }
          _move(e4, t4) {
            const i4 = 0.8 * (t4.x - e4.x);
            if (i4) return this._active = true, { bearingDelta: i4 };
          }
          contextmenu(e4) {
            e4.preventDefault();
          }
        }
        class En extends bn {
          _correctButton(e4, t4) {
            return 0 === t4 && e4.ctrlKey || 2 === t4;
          }
          _move(e4, t4) {
            const i4 = -0.5 * (t4.y - e4.y);
            if (i4) return this._active = true, { pitchDelta: i4 };
          }
          contextmenu(e4) {
            e4.preventDefault();
          }
        }
        class Sn {
          constructor(t4, i4) {
            this._map = t4, this._el = t4.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i4.clickTolerance || 1, this.reset(), e3.a$(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new e3.P(0, 0);
          }
          touchstart(e4, t4, i4) {
            return this._calculateTransform(e4, t4, i4);
          }
          touchmove(t4, i4, o3) {
            if (this._active && !(o3.length < this._minTouches)) {
              if (this._map._cooperativeGestures && !this._map.isMoving()) {
                if (1 === o3.length && !e3.d7()) return void this._showTouchPanBlockerAlert();
                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              return t4.cancelable && t4.preventDefault(), this._calculateTransform(t4, i4, o3);
            }
          }
          touchend(e4, t4, i4) {
            this._calculateTransform(e4, t4, i4), this._active && i4.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t4, i4, o3) {
            o3.length > 0 && (this._active = true);
            const r4 = mn(o3, i4), s4 = new e3.P(0, 0), n3 = new e3.P(0, 0);
            let a4 = 0;
            for (const e4 in r4) {
              const t5 = r4[e4], i5 = this._touches[e4];
              i5 && (s4._add(t5), n3._add(t5.sub(i5)), a4++, r4[e4] = t5);
            }
            if (this._touches = r4, a4 < this._minTouches || !n3.mag()) return;
            const l4 = n3.div(a4);
            return this._sum._add(l4), this._sum.mag() < this._clickTolerance ? void 0 : { around: s4.div(a4), panDelta: l4 };
          }
          enable() {
            this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
          }
          disable() {
            this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          _addTouchPanBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = s3("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showTouchPanBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
            }, 500);
          }
        }
        class Cn {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, this._firstTwoTouches = void 0;
          }
          _start(e4) {
          }
          _move(e4, t4, i4) {
            return {};
          }
          touchstart(e4, t4, i4) {
            this._firstTwoTouches || i4.length < 2 || (this._firstTwoTouches = [i4[0].identifier, i4[1].identifier], this._start([t4[0], t4[1]]));
          }
          touchmove(e4, t4, i4) {
            const o3 = this._firstTwoTouches;
            if (!o3) return;
            e4.preventDefault();
            const [r4, s4] = o3, n3 = In(i4, t4, r4), a4 = In(i4, t4, s4);
            if (!n3 || !a4) return;
            const l4 = this._aroundCenter ? null : n3.add(a4).div(2);
            return this._move([n3, a4], l4, e4);
          }
          touchend(e4, t4, i4) {
            if (!this._firstTwoTouches) return;
            const [o3, r4] = this._firstTwoTouches, s4 = In(i4, t4, o3), n3 = In(i4, t4, r4);
            s4 && n3 || (this._active && _3(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e4) {
            this._enabled = true, this._aroundCenter = !!e4 && "center" === e4.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function In(e4, t4, i4) {
          for (let o3 = 0; o3 < e4.length; o3++) if (e4[o3].identifier === i4) return t4[o3];
        }
        function Dn(e4, t4) {
          return Math.log(e4 / t4) / Math.LN2;
        }
        class Rn extends Cn {
          reset() {
            super.reset(), this._distance = 0, this._startDistance = 0;
          }
          _start(e4) {
            this._startDistance = this._distance = e4[0].dist(e4[1]);
          }
          _move(e4, t4) {
            const i4 = this._distance;
            if (this._distance = e4[0].dist(e4[1]), this._active || !(Math.abs(Dn(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Dn(this._distance, i4), pinchAround: t4 };
          }
        }
        function An(e4, t4) {
          return 180 * e4.angleWith(t4) / Math.PI;
        }
        class Pn extends Cn {
          reset() {
            super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
          }
          _start(e4) {
            this._startVector = this._vector = e4[0].sub(e4[1]), this._minDiameter = e4[0].dist(e4[1]);
          }
          _move(e4, t4) {
            const i4 = this._vector;
            if (this._vector = e4[0].sub(e4[1]), i4 && (this._active || !this._isBelowThreshold(this._vector))) return this._active = true, { bearingDelta: An(this._vector, i4), pinchAround: t4 };
          }
          _isBelowThreshold(e4) {
            this._minDiameter = Math.min(this._minDiameter, e4.mag());
            const t4 = 25 / (Math.PI * this._minDiameter) * 360, i4 = this._startVector;
            if (!i4) return false;
            const o3 = An(e4, i4);
            return Math.abs(o3) < t4;
          }
        }
        function Ln(e4) {
          return Math.abs(e4.y) > Math.abs(e4.x);
        }
        class Mn extends Cn {
          constructor(e4) {
            super(), this._map = e4;
          }
          reset() {
            super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
          }
          _start(e4) {
            this._lastPoints = e4, Ln(e4[0].sub(e4[1])) && (this._valid = false);
          }
          _move(t4, i4, o3) {
            const r4 = this._lastPoints;
            if (!r4) return;
            const s4 = t4[0].sub(r4[0]), n3 = t4[1].sub(r4[1]);
            return this._map._cooperativeGestures && !e3.d7() && o3.touches.length < 3 || (this._valid = this.gestureBeginsVertically(s4, n3, o3.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t4, this._active = true, { pitchDelta: (s4.y + n3.y) / 2 * -0.5 });
          }
          gestureBeginsVertically(e4, t4, i4) {
            if (void 0 !== this._valid) return this._valid;
            const o3 = e4.mag() >= 2, r4 = t4.mag() >= 2;
            if (!o3 && !r4) return;
            if (!o3 || !r4) return null == this._firstMove && (this._firstMove = i4), i4 - this._firstMove < 100 && void 0;
            const s4 = e4.y > 0 == t4.y > 0;
            return Ln(e4) && Ln(t4) && s4;
          }
        }
        const zn = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class On {
          constructor() {
            const e4 = zn;
            this._panStep = e4.panStep, this._bearingStep = e4.bearingStep, this._pitchStep = e4.pitchStep, this._rotationDisabled = false;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          keydown(e4) {
            if (e4.altKey || e4.ctrlKey || e4.metaKey) return;
            let t4 = 0, i4 = 0, o3 = 0, r4 = 0, s4 = 0;
            switch (e4.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                t4 = 1;
                break;
              case 189:
              case 109:
              case 173:
                t4 = -1;
                break;
              case 37:
                e4.shiftKey ? i4 = -1 : (e4.preventDefault(), r4 = -1);
                break;
              case 39:
                e4.shiftKey ? i4 = 1 : (e4.preventDefault(), r4 = 1);
                break;
              case 38:
                e4.shiftKey ? o3 = 1 : (e4.preventDefault(), s4 = -1);
                break;
              case 40:
                e4.shiftKey ? o3 = -1 : (e4.preventDefault(), s4 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i4 = 0, o3 = 0), { cameraAnimation: (n3) => {
              const a4 = n3.getZoom();
              n3.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Fn, zoom: t4 ? Math.round(a4) + t4 * (e4.shiftKey ? 2 : 1) : a4, bearing: n3.getBearing() + i4 * this._bearingStep, pitch: n3.getPitch() + o3 * this._pitchStep, offset: [-r4 * this._panStep, -s4 * this._panStep], center: n3.getCenter() }, { originalEvent: e4 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function Fn(e4) {
          return e4 * (2 - e4);
        }
        const Bn = 4.000244140625, kn = 1 / 450;
        class Nn {
          constructor(t4, i4) {
            this._map = t4, this._el = t4.getCanvasContainer(), this._handler = i4, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = kn, e3.a$(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
          }
          setZoomRate(e4) {
            this._defaultZoomRate = e4;
          }
          setWheelZoomRate(e4) {
            this._wheelZoomRate = e4;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e4) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e4 && "center" === e4.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
          }
          disable() {
            this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
          }
          wheel(t4) {
            if (!this.isEnabled()) return;
            if (this._map._cooperativeGestures) {
              if (!(t4.ctrlKey || t4.metaKey || this.isZooming() || e3.d7())) return void this._showBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            let i4 = t4.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t4.deltaY : t4.deltaY;
            const o3 = e3.f.now(), r4 = o3 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o3, 0 !== i4 && i4 % Bn == 0 ? this._type = "wheel" : 0 !== i4 && Math.abs(i4) < 4 ? this._type = "trackpad" : r4 > 400 ? (this._type = null, this._lastValue = i4, this._timeout = setTimeout(this._onTimeout, 40, t4)) : this._type || (this._type = Math.abs(r4 * i4) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i4 += this._lastValue)), t4.shiftKey && i4 && (i4 /= 4), this._type && (this._lastWheelEvent = t4, this._delta -= i4, this._active || this._start(t4)), t4.preventDefault();
          }
          _onTimeout(e4) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e4);
          }
          _start(e4) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const t4 = p3(this._el, e4);
            this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t4, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId) return;
            if (this._frameId = null, !this.isActive()) return;
            const t4 = this._map.transform;
            "wheel" === this._type && t4.projection.wrap && (t4._center.lng >= 180 || t4._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
            const i4 = () => t4._terrainEnabled() && this._aroundCoord ? t4.computeZoomRelativeTo(this._aroundCoord) : t4.zoom;
            if (0 !== this._delta) {
              const e4 = "wheel" === this._type && Math.abs(this._delta) > Bn ? this._wheelZoomRate : this._defaultZoomRate;
              let o4 = 2 / (1 + Math.exp(-Math.abs(this._delta * e4)));
              this._delta < 0 && 0 !== o4 && (o4 = 1 / o4);
              const r5 = i4(), s5 = Math.pow(2, r5), n4 = "number" == typeof this._targetZoom ? t4.zoomScale(this._targetZoom) : s5;
              this._targetZoom = Math.min(t4.maxZoom, Math.max(t4.minZoom, t4.scaleZoom(n4 * o4))), "wheel" === this._type && (this._startZoom = r5, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
            }
            const o3 = "number" == typeof this._targetZoom ? this._targetZoom : i4(), r4 = this._startZoom, s4 = this._easing;
            let n3, a4 = false;
            if ("wheel" === this._type && r4 && s4) {
              const t5 = Math.min((e3.f.now() - this._lastWheelEventTime) / 200, 1), i5 = s4(t5);
              n3 = e3.X(r4, o3, i5), t5 < 1 ? this._frameId || (this._frameId = true) : a4 = true;
            } else n3 = o3, a4 = true;
            this._active = true, a4 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200));
            let l4 = n3 - i4();
            return l4 * this._lastDelta < 0 && (l4 = 0), { noInertia: true, needsRenderFrame: !a4, zoomDelta: l4, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t4) {
            let i4 = e3.d8;
            if (this._prevEase) {
              const t5 = this._prevEase, o3 = (e3.f.now() - t5.start) / t5.duration, r4 = t5.easing(o3 + 0.01) - t5.easing(o3), s4 = 0.27 / Math.sqrt(r4 * r4 + 1e-4) * 0.01, n3 = Math.sqrt(0.0729 - s4 * s4);
              i4 = e3.d6(s4, n3, 0.25, 1);
            }
            return this._prevEase = { start: e3.f.now(), duration: t4, easing: i4 }, i4;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          _addScrollZoomBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = s3("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
            }, 200);
          }
        }
        class Un {
          constructor(e4, t4) {
            this._clickZoom = e4, this._tapZoom = t4;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Gn {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          blur() {
            this.reset();
          }
          dblclick(e4, t4) {
            return e4.preventDefault(), { cameraAnimation: (i4) => {
              i4.easeTo({ duration: 300, zoom: i4.getZoom() + (e4.shiftKey ? -1 : 1), around: i4.unproject(t4) }, { originalEvent: e4 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class jn {
          constructor() {
            this._tap = new vn({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
          }
          touchstart(e4, t4, i4) {
            this._swipePoint || (this._tapTime && e4.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i4.length > 0 && (this._swipePoint = t4[0], this._swipeTouch = i4[0].identifier) : this._tap.touchstart(e4, t4, i4));
          }
          touchmove(e4, t4, i4) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i4[0].identifier !== this._swipeTouch) return;
                const o3 = t4[0], r4 = o3.y - this._swipePoint.y;
                return this._swipePoint = o3, e4.preventDefault(), this._active = true, { zoomDelta: r4 / 128 };
              }
            } else this._tap.touchmove(e4, t4, i4);
          }
          touchend(e4, t4, i4) {
            this._tapTime ? this._swipePoint && 0 === i4.length && this.reset() : this._tap.touchend(e4, t4, i4) && (this._tapTime = e4.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Vn {
          constructor(e4, t4, i4) {
            this._el = e4, this._mousePan = t4, this._touchPan = i4;
          }
          enable(e4) {
            this._inertiaOptions = e4 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Zn {
          constructor(e4, t4, i4) {
            this._pitchWithRotate = e4.pitchWithRotate, this._mouseRotate = t4, this._mousePitch = i4;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class Wn {
          constructor(e4, t4, i4, o3) {
            this._el = e4, this._touchZoom = t4, this._touchRotate = i4, this._tapDragZoom = o3, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e4) {
            this._touchZoom.enable(e4), this._rotationDisabled || this._touchRotate.enable(e4), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const Hn = (e4) => e4.zoom || e4.drag || e4.pitch || e4.rotate;
        class qn extends e3.b {
        }
        class Qn {
          constructor() {
            this.constants = [1, 1, 0.01], this.radius = 0;
          }
          setup(t4, i4) {
            const o3 = e3.Q.sub([], i4, t4);
            this.radius = e3.Q.length(o3[2] < 0 ? e3.Q.div([], o3, this.constants) : [o3[0], o3[1], 0]);
          }
          projectRay(t4) {
            e3.Q.div(t4, t4, this.constants), e3.Q.normalize(t4, t4), e3.Q.mul(t4, t4, this.constants);
            const i4 = e3.Q.scale([], t4, this.radius);
            if (i4[2] > 0) {
              const t5 = e3.Q.scale([], [0, 0, 1], e3.Q.dot(i4, [0, 0, 1])), o3 = e3.Q.scale([], e3.Q.normalize([], [i4[0], i4[1], 0]), this.radius), r4 = e3.Q.add([], i4, e3.Q.scale([], e3.Q.sub([], e3.Q.add([], o3, t5), i4), 2));
              i4[0] = r4[0], i4[1] = r4[1];
            }
            return i4;
          }
        }
        function $n(e4) {
          return e4.panDelta && e4.panDelta.mag() || e4.zoomDelta || e4.bearingDelta || e4.pitchDelta;
        }
        class Xn {
          constructor(t4, i4) {
            this._map = t4, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new an(t4), this._bearingSnap = i4.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Qn(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i4), e3.a$(["handleEvent", "handleWindowEvent"], this);
            const o3 = this._el;
            this._listeners = [[o3, "touchstart", { passive: true }], [o3, "touchmove", { passive: false }], [o3, "touchend", void 0], [o3, "touchcancel", void 0], [o3, "mousedown", void 0], [o3, "mousemove", void 0], [o3, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o3, "mouseover", void 0], [o3, "mouseout", void 0], [o3, "dblclick", void 0], [o3, "click", void 0], [o3, "keydown", { capture: false }], [o3, "keyup", void 0], [o3, "wheel", { passive: false }], [o3, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [e4, t5, i5] of this._listeners) {
              const o4 = e4 === document ? this.handleWindowEvent : this.handleEvent;
              e4.addEventListener(t5, o4, i5);
            }
          }
          destroy() {
            for (const [e4, t4, i4] of this._listeners) {
              const o3 = e4 === document ? this.handleWindowEvent : this.handleEvent;
              e4.removeEventListener(t4, o3, i4);
            }
          }
          _addDefaultHandlers(e4) {
            const t4 = this._map, i4 = t4.getCanvasContainer();
            this._add("mapEvent", new _n(t4, e4));
            const o3 = t4.boxZoom = new fn(t4, e4);
            this._add("boxZoom", o3);
            const r4 = new xn(), s4 = new Gn();
            t4.doubleClickZoom = new Un(s4, r4), this._add("tapZoom", r4), this._add("clickZoom", s4);
            const n3 = new jn();
            this._add("tapDragZoom", n3);
            const a4 = t4.touchPitch = new Mn(t4);
            this._add("touchPitch", a4);
            const l4 = new Tn(e4), c4 = new En(e4);
            t4.dragRotate = new Zn(e4, l4, c4), this._add("mouseRotate", l4, ["mousePitch"]), this._add("mousePitch", c4, ["mouseRotate"]);
            const h4 = new wn(e4), u5 = new Sn(t4, e4);
            t4.dragPan = new Vn(i4, h4, u5), this._add("mousePan", h4), this._add("touchPan", u5, ["touchZoom", "touchRotate"]);
            const d3 = new Pn(), _4 = new Rn();
            t4.touchZoomRotate = new Wn(i4, _4, d3, n3), this._add("touchRotate", d3, ["touchPan", "touchZoom"]), this._add("touchZoom", _4, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new pn(t4));
            const p4 = t4.scrollZoom = new Nn(t4, this);
            this._add("scrollZoom", p4, ["mousePan"]);
            const f4 = t4.keyboard = new On();
            this._add("keyboard", f4);
            for (const i5 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) e4.interactive && e4[i5] && t4[i5].enable(e4[i5]);
          }
          _add(e4, t4, i4) {
            this._handlers.push({ handlerName: e4, handler: t4, allowed: i4 }), this._handlersById[e4] = t4;
          }
          stop(e4) {
            if (!this._updatingCamera) {
              for (const { handler: e5 } of this._handlers) e5.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e4), this._changes = [], this._originalZoom = void 0;
            }
          }
          isActive() {
            for (const { handler: e4 } of this._handlers) if (e4.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Hn(this._eventsInProgress) || this.isZooming();
          }
          _isDragging() {
            return !!this._eventsInProgress.drag;
          }
          _blockedByActive(e4, t4, i4) {
            for (const o3 in e4) if (o3 !== i4 && (!t4 || t4.indexOf(o3) < 0)) return true;
            return false;
          }
          handleWindowEvent(e4) {
            this.handleEvent(e4, `${e4.type}Window`);
          }
          _getMapTouches(e4) {
            const t4 = [];
            for (const i4 of e4) this._el.contains(i4.target) && t4.push(i4);
            return t4;
          }
          handleEvent(e4, t4) {
            this._updatingCamera = true;
            const i4 = "renderFrame" === e4.type, o3 = i4 ? void 0 : e4, r4 = { needsRenderFrame: false }, s4 = {}, n3 = {}, a4 = e4.touches ? this._getMapTouches(e4.touches) : void 0, l4 = a4 ? f3(this._el, a4) : i4 ? void 0 : p3(this._el, e4);
            for (const { handlerName: i5, handler: c5, allowed: h5 } of this._handlers) {
              if (!c5.isEnabled()) continue;
              let u5;
              this._blockedByActive(n3, h5, i5) ? c5.reset() : c5[t4 || e4.type] && (u5 = c5[t4 || e4.type](e4, l4, a4), this.mergeHandlerResult(r4, s4, u5, i5, o3), u5 && u5.needsRenderFrame && this._triggerRenderFrame()), (u5 || c5.isActive()) && (n3[i5] = c5);
            }
            const c4 = {};
            for (const e5 in this._previousActiveHandlers) n3[e5] || (c4[e5] = o3);
            this._previousActiveHandlers = n3, (Object.keys(c4).length || $n(r4)) && (this._changes.push([r4, s4, c4]), this._triggerRenderFrame()), (Object.keys(n3).length || $n(r4)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: h4 } = r4;
            h4 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h4(this._map));
          }
          mergeHandlerResult(t4, i4, o3, r4, s4) {
            if (!o3) return;
            e3.e(t4, o3);
            const n3 = { handlerName: r4, originalEvent: o3.originalEvent || s4 };
            void 0 !== o3.zoomDelta && (i4.zoom = n3), void 0 !== o3.panDelta && (i4.drag = n3), void 0 !== o3.pitchDelta && (i4.pitch = n3), void 0 !== o3.bearingDelta && (i4.rotate = n3);
          }
          _applyChanges() {
            const t4 = {}, i4 = {}, o3 = {};
            for (const [r4, s4, n3] of this._changes) r4.panDelta && (t4.panDelta = (t4.panDelta || new e3.P(0, 0))._add(r4.panDelta)), r4.zoomDelta && (t4.zoomDelta = (t4.zoomDelta || 0) + r4.zoomDelta), r4.bearingDelta && (t4.bearingDelta = (t4.bearingDelta || 0) + r4.bearingDelta), r4.pitchDelta && (t4.pitchDelta = (t4.pitchDelta || 0) + r4.pitchDelta), void 0 !== r4.around && (t4.around = r4.around), void 0 !== r4.aroundCoord && (t4.aroundCoord = r4.aroundCoord), void 0 !== r4.pinchAround && (t4.pinchAround = r4.pinchAround), r4.noInertia && (t4.noInertia = r4.noInertia), e3.e(i4, s4), e3.e(o3, n3);
            this._updateMapTransform(t4, i4, o3), this._changes = [];
          }
          _updateMapTransform(t4, i4, o3) {
            const r4 = this._map, s4 = r4.transform, n3 = (e4) => [e4.x, e4.y, e4.z];
            if (((e4) => {
              const t5 = this._eventsInProgress.drag;
              return t5 && !this._handlersById[t5.handlerName].isActive();
            })() && !$n(t4)) {
              const e4 = s4.zoom;
              s4.cameraElevationReference = "sea", null != this._originalZoom && s4._orthographicProjectionAtLowPitch && "globe" !== s4.projection.name && 0 === s4.pitch ? (s4.cameraElevationReference = "ground", s4.zoom = this._originalZoom) : (s4.recenterOnTerrain(), s4.cameraElevationReference = "ground"), e4 !== s4.zoom && this._map._update(true);
            }
            if (s4._isCameraConstrained && r4._stop(true), !$n(t4)) return void this._fireEvents(i4, o3, true);
            let { panDelta: a4, zoomDelta: l4, bearingDelta: c4, pitchDelta: h4, around: u5, aroundCoord: d3, pinchAround: _4 } = t4;
            s4._isCameraConstrained && (l4 > 0 && (l4 = 0), s4._isCameraConstrained = false), void 0 !== _4 && (u5 = _4), (l4 || ((e4) => i4[e4] && !this._eventsInProgress[e4])("drag")) && u5 && (this._dragOrigin = n3(s4.pointCoordinate3D(u5)), this._originalZoom = s4.zoom, this._trackingEllipsoid.setup(s4._camera.position, this._dragOrigin)), s4.cameraElevationReference = "sea", r4._stop(true), u5 = u5 || r4.transform.centerPoint, c4 && (s4.bearing += c4), h4 && (s4.pitch += h4), s4._updateCameraState();
            const p4 = [0, 0, 0];
            if (a4) if ("mercator" === s4.projection.name) {
              const e4 = this._trackingEllipsoid.projectRay(s4.screenPointToMercatorRay(u5).dir), t5 = this._trackingEllipsoid.projectRay(s4.screenPointToMercatorRay(u5.sub(a4)).dir);
              p4[0] = t5[0] - e4[0], p4[1] = t5[1] - e4[1];
            } else {
              const t5 = s4.pointCoordinate(u5);
              if ("globe" === s4.projection.name) {
                a4 = a4.rotate(-s4.angle);
                const i5 = s4._pixelsPerMercatorPixel / s4.worldSize;
                p4[0] = -a4.x * e3.d9(e3.ax(t5.y)) * i5, p4[1] = -a4.y * e3.d9(s4.center.lat) * i5;
              } else {
                const e4 = s4.pointCoordinate(u5.sub(a4));
                t5 && e4 && (p4[0] = e4.x - t5.x, p4[1] = e4.y - t5.y);
              }
            }
            const f4 = s4.zoom, m4 = [0, 0, 0];
            if (l4) {
              const t5 = n3(d3 || s4.pointCoordinate3D(u5)), i5 = { dir: e3.Q.normalize([], e3.Q.sub([], t5, s4._camera.position)) };
              if (i5.dir[2] < 0) {
                const o4 = s4.zoomDeltaToMovement(t5, l4);
                e3.Q.scale(m4, i5.dir, o4);
              }
            }
            const g5 = e3.Q.add(p4, p4, m4);
            s4._translateCameraConstrained(g5), l4 && Math.abs(s4.zoom - f4) > 1e-4 && s4.recenterOnTerrain(), s4.cameraElevationReference = "ground", this._map._update(), t4.noInertia || this._inertia.record(t4), this._fireEvents(i4, o3, true);
          }
          _fireEvents(t4, i4, o3) {
            const r4 = Hn(this._eventsInProgress), s4 = Hn(t4), n3 = {};
            for (const e4 in t4) {
              const { originalEvent: i5 } = t4[e4];
              this._eventsInProgress[e4] || (n3[`${e4}start`] = i5), this._eventsInProgress[e4] = t4[e4];
            }
            !r4 && s4 && this._fireEvent("movestart", s4.originalEvent);
            for (const e4 in n3) this._fireEvent(e4, n3[e4]);
            s4 && this._fireEvent("move", s4.originalEvent);
            for (const e4 in t4) {
              const { originalEvent: i5 } = t4[e4];
              this._fireEvent(e4, i5);
            }
            const a4 = {};
            let l4;
            for (const e4 in this._eventsInProgress) {
              const { handlerName: t5, originalEvent: o4 } = this._eventsInProgress[e4];
              this._handlersById[t5].isActive() || (delete this._eventsInProgress[e4], l4 = i4[t5] || o4, a4[`${e4}end`] = l4);
            }
            for (const e4 in a4) this._fireEvent(e4, a4[e4]);
            const c4 = Hn(this._eventsInProgress);
            if (o3 && (r4 || s4) && !c4) {
              this._updatingCamera = true;
              const t5 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i5 = (e4) => 0 !== e4 && -this._bearingSnap < e4 && e4 < this._bearingSnap;
              t5 ? (i5(t5.bearing || this._map.getBearing()) && (t5.bearing = 0), this._map.easeTo(t5, { originalEvent: l4 })) : (this._map.fire(new e3.b("moveend", { originalEvent: l4 })), i5(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
            }
          }
          _fireEvent(t4, i4) {
            this._map.fire(new e3.b(t4, i4 ? { originalEvent: i4 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e4) => {
              this._frameId = void 0, this.handleEvent(new qn("renderFrame", { timeStamp: e4 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        const Yn = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Jn extends e3.E {
          constructor(t4, i4) {
            super(), this._moving = false, this._zooming = false, this.transform = t4, this._bearingSnap = i4.bearingSnap, this._respectPrefersReducedMotion = false !== i4.respectPrefersReducedMotion, e3.a$(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new e3.bq(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e4, t4) {
            return this.jumpTo({ center: e4 }, t4);
          }
          panBy(t4, i4, o3) {
            return t4 = e3.P.convert(t4).mult(-1), this.panTo(this.transform.center, e3.e({ offset: t4 }, i4), o3);
          }
          panTo(t4, i4, o3) {
            return this.easeTo(e3.e({ center: t4 }, i4), o3);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e4, t4) {
            return this.jumpTo({ zoom: e4 }, t4), this;
          }
          zoomTo(t4, i4, o3) {
            return this.easeTo(e3.e({ zoom: t4 }, i4), o3);
          }
          zoomIn(e4, t4) {
            return this.zoomTo(this.getZoom() + 1, e4, t4), this;
          }
          zoomOut(e4, t4) {
            return this.zoomTo(this.getZoom() - 1, e4, t4), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e4, t4) {
            return this.jumpTo({ bearing: e4 }, t4), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e4, t4) {
            return this.jumpTo({ padding: e4 }, t4), this;
          }
          rotateTo(t4, i4, o3) {
            return this.easeTo(e3.e({ bearing: t4 }, i4), o3);
          }
          resetNorth(t4, i4) {
            return this.rotateTo(0, e3.e({ duration: 1e3 }, t4), i4), this;
          }
          resetNorthPitch(t4, i4) {
            return this.easeTo(e3.e({ bearing: 0, pitch: 0, duration: 1e3 }, t4), i4), this;
          }
          snapToNorth(e4, t4) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e4, t4) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e4, t4) {
            return this.jumpTo({ pitch: e4 }, t4), this;
          }
          cameraForBounds(t4, i4) {
            t4 = e3.ag.convert(t4);
            const o3 = i4 && i4.bearing || 0, r4 = i4 && i4.pitch || 0, s4 = t4.getNorthWest(), n3 = t4.getSouthEast();
            return this._cameraForBounds(this.transform, s4, n3, o3, r4, i4);
          }
          _extendPadding(t4) {
            const i4 = { top: 0, right: 0, bottom: 0, left: 0 };
            return null == t4 ? e3.e({}, i4, this.transform.padding) : "number" == typeof t4 ? { top: t4, bottom: t4, right: t4, left: t4 } : e3.e({}, i4, t4);
          }
          _extendCameraOptions(t4) {
            return (t4 = e3.e({ offset: [0, 0], maxZoom: this.transform.maxZoom }, t4)).padding = this._extendPadding(t4.padding), t4;
          }
          _minimumAABBFrustumDistance(e4, t4) {
            const i4 = t4.max[0] - t4.min[0], o3 = t4.max[1] - t4.min[1];
            return i4 / o3 > e4.aspect ? i4 / (2 * Math.tan(0.5 * e4.fovX) * e4.aspect) : o3 / (2 * Math.tan(0.5 * e4.fovY) * e4.aspect);
          }
          _cameraForBoundsOnGlobe(t4, i4, o3, r4, s4, n3) {
            const a4 = t4.clone(), l4 = this._extendCameraOptions(n3);
            a4.bearing = r4, a4.pitch = s4;
            const c4 = e3.bq.convert(i4), h4 = e3.bq.convert(o3), u5 = 0.5 * (c4.lat + h4.lat), d3 = 0.5 * (c4.lng + h4.lng), _4 = e3.da(u5, d3), p4 = e3.Q.normalize([], _4), f4 = e3.Q.normalize([], e3.Q.cross([], p4, [0, 1, 0])), m4 = e3.Q.cross([], f4, p4), g5 = [f4[0], f4[1], f4[2], 0, m4[0], m4[1], m4[2], 0, p4[0], p4[1], p4[2], 0, 0, 0, 0, 1], v4 = [_4, e3.da(c4.lat, c4.lng), e3.da(h4.lat, c4.lng), e3.da(h4.lat, h4.lng), e3.da(c4.lat, h4.lng), e3.da(u5, c4.lng), e3.da(u5, h4.lng), e3.da(c4.lat, d3), e3.da(h4.lat, d3)];
            let x5 = e3.bV.fromPoints(v4.map((t5) => [e3.Q.dot(f4, t5), e3.Q.dot(m4, t5), e3.Q.dot(p4, t5)]));
            const y4 = e3.Q.transformMat4([], x5.center, g5);
            0 === e3.Q.squaredLength(y4) && e3.Q.set(y4, 0, 0, 1), e3.Q.normalize(y4, y4), e3.Q.scale(y4, y4, e3.ae), a4.center = e3.db(y4);
            const b4 = a4.getWorldToCameraMatrix(), w5 = e3.a9.invert(new Float64Array(16), b4);
            x5 = e3.bV.applyTransform(x5, e3.a9.multiply([], b4, g5));
            const T5 = this._extendAABB(x5, a4, l4, r4);
            if (!T5) return void e3.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            x5 = T5, e3.Q.transformMat4(y4, y4, b4);
            const E3 = 0.5 * (x5.max[2] - x5.min[2]), S3 = this._minimumAABBFrustumDistance(a4, x5), C4 = e3.Q.scale([], [0, 0, 1], E3), I4 = e3.Q.add(C4, y4, C4), D4 = S3 + (0 === a4.pitch ? 0 : e3.Q.distance(y4, I4)), R2 = a4.globeCenterInViewSpace, A4 = e3.Q.sub([], y4, [R2[0], R2[1], R2[2]]);
            e3.Q.normalize(A4, A4), e3.Q.scale(A4, A4, D4);
            const P4 = e3.Q.add([], y4, A4);
            e3.Q.transformMat4(P4, P4, w5);
            const L4 = e3.dc / e3.ae, M3 = e3.Q.length(P4), z4 = e3.bo(Math.max(M3 * L4 - e3.dc, Number.EPSILON), 0), O3 = Math.min(a4.zoomFromMercatorZAdjusted(z4), l4.maxZoom);
            return O3 > 0.5 * (e3.bJ + e3.bA) ? (a4.setProjection({ name: "mercator" }), a4.zoom = O3, this._cameraForBounds(a4, i4, o3, r4, s4, n3)) : { center: a4.center, zoom: O3, bearing: r4, pitch: s4 };
          }
          _extendAABB(t4, i4, o3, r4) {
            const s4 = 0.5 * ((o3.padding.left || 0) + (o3.padding.right || 0)), n3 = 0.5 * ((o3.padding.top || 0) + (o3.padding.bottom || 0)), a4 = n3, l4 = s4, c4 = s4, h4 = n3, u5 = i4.width - (l4 + c4), d3 = i4.height - (a4 + h4), _4 = e3.Q.sub([], t4.max, t4.min), p4 = Math.min(u5 / _4[0], d3 / _4[1]), f4 = Math.min(i4.scaleZoom(i4.scale * p4), o3.maxZoom);
            if (isNaN(f4)) return null;
            const m4 = i4.scale / i4.zoomScale(f4), g5 = new e3.bV([t4.min[0] - l4 * m4, t4.min[1] - h4 * m4, t4.min[2]], [t4.max[0] + c4 * m4, t4.max[1] + a4 * m4, t4.max[2]]), v4 = ("number" == typeof o3.offset.x && "number" == typeof o3.offset.y ? new e3.P(o3.offset.x, o3.offset.y) : e3.P.convert(o3.offset)).rotate(-e3.bm(r4));
            return g5.center[0] -= v4.x * m4, g5.center[1] += v4.y * m4, g5;
          }
          queryTerrainElevation(t4, i4) {
            const o3 = this.transform.elevation;
            return o3 ? (i4 = e3.e({}, { exaggerated: true }, i4), o3.getAtPoint(e3.O.fromLngLat(t4), null, i4.exaggerated)) : null;
          }
          _cameraForBounds(t4, i4, o3, r4, s4, n3) {
            if ("globe" === t4.projection.name) return this._cameraForBoundsOnGlobe(t4, i4, o3, r4, s4, n3);
            const a4 = t4.clone(), l4 = this._extendCameraOptions(n3);
            a4.bearing = r4, a4.pitch = s4;
            const c4 = e3.bq.convert(i4), h4 = e3.bq.convert(o3), u5 = new e3.bq(c4.lng, h4.lat), d3 = new e3.bq(h4.lng, c4.lat), _4 = a4.project(c4), p4 = a4.project(h4), f4 = this.queryTerrainElevation(c4), m4 = this.queryTerrainElevation(h4), g5 = this.queryTerrainElevation(u5), v4 = this.queryTerrainElevation(d3), x5 = [[_4.x, _4.y, Math.min(f4 || 0, m4 || 0, g5 || 0, v4 || 0)], [p4.x, p4.y, Math.max(f4 || 0, m4 || 0, g5 || 0, v4 || 0)]];
            let y4 = e3.bV.fromPoints(x5);
            const b4 = a4.getWorldToCameraMatrix(), w5 = e3.a9.invert(new Float64Array(16), b4);
            y4 = e3.bV.applyTransform(y4, b4);
            const T5 = this._extendAABB(y4, a4, l4, r4);
            if (!T5) return void e3.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            y4 = T5;
            const E3 = 0.5 * e3.Q.sub([], y4.max, y4.min)[2], S3 = this._minimumAABBFrustumDistance(a4, y4), C4 = [0, 0, 1, 0];
            e3.aa.transformMat4(C4, C4, b4), e3.aa.normalize(C4, C4);
            const I4 = e3.Q.scale([], C4, S3 + E3), D4 = e3.Q.add([], y4.center, I4);
            e3.Q.transformMat4(y4.center, y4.center, w5), e3.Q.transformMat4(D4, D4, w5);
            const R2 = [y4.center[0], y4.center[1], D4[2] * a4.pixelsPerMeter];
            e3.Q.scale(R2, R2, 1 / a4.worldSize);
            const A4 = e3.aw(R2[0]), P4 = e3.ax(R2[1]), L4 = Math.min(a4._zoomFromMercatorZ(R2[2]), l4.maxZoom), M3 = new e3.bq(A4, P4);
            return a4.mercatorFromTransition && L4 < 0.5 * (e3.bJ + e3.bA) ? (a4.setProjection({ name: "globe" }), a4.zoom = L4, this._cameraForBounds(a4, i4, o3, r4, s4, n3)) : { center: M3, zoom: L4, bearing: r4, pitch: s4 };
          }
          fitBounds(e4, t4, i4) {
            const o3 = this.cameraForBounds(e4, t4);
            return this._fitInternal(o3, t4, i4);
          }
          fitScreenCoordinates(t4, i4, o3, r4, s4) {
            const n3 = e3.P.convert(t4), a4 = e3.P.convert(i4), l4 = new e3.P(Math.min(n3.x, a4.x), Math.min(n3.y, a4.y)), c4 = new e3.P(Math.max(n3.x, a4.x), Math.max(n3.y, a4.y));
            if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(n3, a4)) return this;
            const h4 = this.transform.pointLocation3D(l4), u5 = this.transform.pointLocation3D(c4), d3 = this.transform.pointLocation3D(new e3.P(l4.x, c4.y)), _4 = this.transform.pointLocation3D(new e3.P(c4.x, l4.y)), p4 = [Math.min(h4.lng, u5.lng, d3.lng, _4.lng), Math.min(h4.lat, u5.lat, d3.lat, _4.lat)], f4 = [Math.max(h4.lng, u5.lng, d3.lng, _4.lng), Math.max(h4.lat, u5.lat, d3.lat, _4.lat)], m4 = r4 && r4.pitch ? r4.pitch : this.getPitch(), g5 = this._cameraForBounds(this.transform, p4, f4, o3, m4, r4);
            return this._fitInternal(g5, r4, s4);
          }
          _fitInternal(t4, i4, o3) {
            return t4 ? (i4 = e3.e(t4, i4)).linear ? this.easeTo(i4, o3) : this.flyTo(i4, o3) : this;
          }
          jumpTo(t4, i4) {
            this.stop();
            const o3 = t4.preloadOnly ? this.transform.clone() : this.transform;
            let r4 = false, s4 = false, n3 = false;
            return "zoom" in t4 && o3.zoom !== +t4.zoom && (r4 = true, o3.zoom = +t4.zoom), void 0 !== t4.center && (o3.center = e3.bq.convert(t4.center)), "bearing" in t4 && o3.bearing !== +t4.bearing && (s4 = true, o3.bearing = +t4.bearing), "pitch" in t4 && o3.pitch !== +t4.pitch && (n3 = true, o3.pitch = +t4.pitch), null == t4.padding || o3.isPaddingEqual(t4.padding) || (o3.padding = t4.padding), t4.preloadOnly ? (this._preloadTiles(o3), this) : (this.fire(new e3.b("movestart", i4)).fire(new e3.b("move", i4)), r4 && this.fire(new e3.b("zoomstart", i4)).fire(new e3.b("zoom", i4)).fire(new e3.b("zoomend", i4)), s4 && this.fire(new e3.b("rotatestart", i4)).fire(new e3.b("rotate", i4)).fire(new e3.b("rotateend", i4)), n3 && this.fire(new e3.b("pitchstart", i4)).fire(new e3.b("pitch", i4)).fire(new e3.b("pitchend", i4)), this.fire(new e3.b("moveend", i4)));
          }
          getFreeCameraOptions() {
            return this.transform.projection.supportsFreeCamera || e3.w(Yn), this.transform.getFreeCameraOptions();
          }
          setFreeCameraOptions(t4, i4) {
            const o3 = this.transform;
            if (!o3.projection.supportsFreeCamera) return e3.w(Yn), this;
            this.stop();
            const r4 = o3.zoom, s4 = o3.pitch, n3 = o3.bearing;
            o3.setFreeCameraOptions(t4);
            const a4 = r4 !== o3.zoom, l4 = s4 !== o3.pitch, c4 = n3 !== o3.bearing;
            return this.fire(new e3.b("movestart", i4)).fire(new e3.b("move", i4)), a4 && this.fire(new e3.b("zoomstart", i4)).fire(new e3.b("zoom", i4)).fire(new e3.b("zoomend", i4)), c4 && this.fire(new e3.b("rotatestart", i4)).fire(new e3.b("rotate", i4)).fire(new e3.b("rotateend", i4)), l4 && this.fire(new e3.b("pitchstart", i4)).fire(new e3.b("pitch", i4)).fire(new e3.b("pitchend", i4)), this.fire(new e3.b("moveend", i4)), this;
          }
          easeTo(t4, i4) {
            this._stop(false, t4.easeId), (false === (t4 = e3.e({ offset: [0, 0], duration: 500, easing: e3.d8 }, t4)).animate || this._prefersReducedMotion(t4)) && (t4.duration = 0);
            const o3 = this.transform, r4 = this.getZoom(), s4 = this.getBearing(), n3 = this.getPitch(), a4 = this.getPadding(), l4 = "zoom" in t4 ? +t4.zoom : r4, c4 = "bearing" in t4 ? this._normalizeBearing(t4.bearing, s4) : s4, h4 = "pitch" in t4 ? +t4.pitch : n3, u5 = this._extendPadding(t4.padding), d3 = e3.P.convert(t4.offset);
            let _4, p4, f4;
            if ("globe" === o3.projection.name) {
              const i5 = e3.O.fromLngLat(o3.center), r5 = d3.rotate(-o3.angle);
              i5.x += r5.x / o3.worldSize, i5.y += r5.y / o3.worldSize;
              const s5 = i5.toLngLat(), n4 = e3.bq.convert(t4.center || s5);
              this._normalizeCenter(n4), _4 = o3.centerPoint.add(r5), p4 = new e3.P(i5.x, i5.y).mult(o3.worldSize), f4 = new e3.P(e3.a8(n4.lng), e3.ah(n4.lat)).mult(o3.worldSize).sub(p4);
            } else {
              _4 = o3.centerPoint.add(d3);
              const i5 = o3.pointLocation(_4), r5 = e3.bq.convert(t4.center || i5);
              this._normalizeCenter(r5), p4 = o3.project(i5), f4 = o3.project(r5).sub(p4);
            }
            const m4 = o3.zoomScale(l4 - r4);
            let g5, v4;
            t4.around && (g5 = e3.bq.convert(t4.around), v4 = o3.locationPoint(g5));
            const x5 = this._zooming || l4 !== r4, y4 = this._rotating || s4 !== c4, b4 = this._pitching || h4 !== n3, w5 = !o3.isPaddingEqual(u5), T5 = (o4) => (T6) => {
              if (x5 && (o4.zoom = e3.X(r4, l4, T6)), y4 && (o4.bearing = e3.X(s4, c4, T6)), b4 && (o4.pitch = e3.X(n3, h4, T6)), w5 && (o4.interpolatePadding(a4, u5, T6), _4 = o4.centerPoint.add(d3)), g5) o4.setLocationAtPoint(g5, v4);
              else {
                const e4 = o4.zoomScale(o4.zoom - r4), t5 = l4 > r4 ? Math.min(2, m4) : Math.max(0.5, m4), i5 = Math.pow(t5, 1 - T6), s5 = o4.unproject(p4.add(f4.mult(T6 * i5)).mult(e4));
                o4.setLocationAtPoint(o4.renderWorldCopies ? s5.wrap() : s5, _4);
              }
              return t4.preloadOnly || this._fireMoveEvents(i4), o4;
            };
            if (t4.preloadOnly) {
              const e4 = this._emulate(T5, t4.duration, o3);
              return this._preloadTiles(e4), this;
            }
            const E3 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = x5, this._rotating = y4, this._pitching = b4, this._padding = w5, this._easeId = t4.easeId, this._prepareEase(i4, t4.noMoveStart, E3), this._ease(T5(o3), (e4) => {
              "sea" === o3.cameraElevationReference && o3.recenterOnTerrain(), this._afterEase(i4, e4);
            }, t4), this;
          }
          _prepareEase(t4, i4, o3 = {}) {
            this._moving = true, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i4 || o3.moving || this.fire(new e3.b("movestart", t4)), this._zooming && !o3.zooming && this.fire(new e3.b("zoomstart", t4)), this._rotating && !o3.rotating && this.fire(new e3.b("rotatestart", t4)), this._pitching && !o3.pitching && this.fire(new e3.b("pitchstart", t4));
          }
          _fireMoveEvents(t4) {
            this.fire(new e3.b("move", t4)), this._zooming && this.fire(new e3.b("zoom", t4)), this._rotating && this.fire(new e3.b("rotate", t4)), this._pitching && this.fire(new e3.b("pitch", t4));
          }
          _afterEase(t4, i4) {
            if (this._easeId && i4 && this._easeId === i4) return;
            this._easeId = void 0, this.transform.cameraElevationReference = "ground";
            const o3 = this._zooming, r4 = this._rotating, s4 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o3 && this.fire(new e3.b("zoomend", t4)), r4 && this.fire(new e3.b("rotateend", t4)), s4 && this.fire(new e3.b("pitchend", t4)), this.fire(new e3.b("moveend", t4));
          }
          flyTo(t4, i4) {
            if (this._prefersReducedMotion(t4)) {
              const o4 = e3.af(t4, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(o4, i4);
            }
            this.stop(), t4 = e3.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e3.d8 }, t4);
            const o3 = this.transform, r4 = this.getZoom(), s4 = this.getBearing(), n3 = this.getPitch(), a4 = this.getPadding(), l4 = "zoom" in t4 ? e3.ad(+t4.zoom, o3.minZoom, o3.maxZoom) : r4, c4 = "bearing" in t4 ? this._normalizeBearing(t4.bearing, s4) : s4, h4 = "pitch" in t4 ? +t4.pitch : n3, u5 = this._extendPadding(t4.padding), d3 = o3.zoomScale(l4 - r4), _4 = e3.P.convert(t4.offset);
            let p4 = o3.centerPoint.add(_4);
            const f4 = o3.pointLocation(p4), m4 = e3.bq.convert(t4.center || f4);
            this._normalizeCenter(m4);
            const g5 = o3.project(f4), v4 = o3.project(m4).sub(g5);
            let x5 = t4.curve;
            const y4 = Math.max(o3.width, o3.height), b4 = y4 / d3, w5 = v4.mag();
            if ("minZoom" in t4) {
              const i5 = e3.ad(Math.min(t4.minZoom, r4, l4), o3.minZoom, o3.maxZoom), s5 = y4 / o3.zoomScale(i5 - r4);
              x5 = Math.sqrt(s5 / w5 * 2);
            }
            const T5 = x5 * x5;
            function E3(e4) {
              const t5 = (b4 * b4 - y4 * y4 + (e4 ? -1 : 1) * T5 * T5 * w5 * w5) / (2 * (e4 ? b4 : y4) * T5 * w5);
              return Math.log(Math.sqrt(t5 * t5 + 1) - t5);
            }
            function S3(e4) {
              return (Math.exp(e4) - Math.exp(-e4)) / 2;
            }
            function C4(e4) {
              return (Math.exp(e4) + Math.exp(-e4)) / 2;
            }
            const I4 = E3(0);
            let D4 = function(e4) {
              return C4(I4) / C4(I4 + x5 * e4);
            }, R2 = function(e4) {
              return y4 * ((C4(I4) * (S3(t5 = I4 + x5 * e4) / C4(t5)) - S3(I4)) / T5) / w5;
              var t5;
            }, A4 = (E3(1) - I4) / x5;
            if (Math.abs(w5) < 1e-6 || !isFinite(A4)) {
              if (Math.abs(y4 - b4) < 1e-6) return this.easeTo(t4, i4);
              const e4 = b4 < y4 ? -1 : 1;
              A4 = Math.abs(Math.log(b4 / y4)) / x5, R2 = function() {
                return 0;
              }, D4 = function(t5) {
                return Math.exp(e4 * x5 * t5);
              };
            }
            t4.duration = "duration" in t4 ? +t4.duration : 1e3 * A4 / ("screenSpeed" in t4 ? +t4.screenSpeed / x5 : +t4.speed), t4.maxDuration && t4.duration > t4.maxDuration && (t4.duration = 0);
            const P4 = s4 !== c4, L4 = h4 !== n3, M3 = !o3.isPaddingEqual(u5), z4 = (o4) => (d4) => {
              const f5 = d4 * A4, x6 = 1 / D4(f5);
              o4.zoom = 1 === d4 ? l4 : r4 + o4.scaleZoom(x6), P4 && (o4.bearing = e3.X(s4, c4, d4)), L4 && (o4.pitch = e3.X(n3, h4, d4)), M3 && (o4.interpolatePadding(a4, u5, d4), p4 = o4.centerPoint.add(_4));
              const y5 = 1 === d4 ? m4 : o4.unproject(g5.add(v4.mult(R2(f5))).mult(x6));
              return o4.setLocationAtPoint(o4.renderWorldCopies ? y5.wrap() : y5, p4), o4._updateCameraOnTerrain(), t4.preloadOnly || this._fireMoveEvents(i4), o4;
            };
            if (t4.preloadOnly) {
              const e4 = this._emulate(z4, t4.duration, o3);
              return this._preloadTiles(e4), this;
            }
            return this._zooming = true, this._rotating = P4, this._pitching = L4, this._padding = M3, this._prepareEase(i4, false), this._ease(z4(o3), () => this._afterEase(i4), t4), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _requestRenderFrame(e4) {
          }
          _cancelRenderFrame(e4) {
          }
          _stop(e4, t4) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
              const e5 = this._onEaseEnd;
              this._onEaseEnd = void 0, e5.call(this, t4);
            }
            if (!e4) {
              const e5 = this.handlers;
              e5 && e5.stop(false);
            }
            return this;
          }
          _ease(t4, i4, o3) {
            false === o3.animate || 0 === o3.duration ? (t4(1), i4()) : (this._easeStart = e3.f.now(), this._easeOptions = o3, this._onEaseFrame = t4, this._onEaseEnd = i4, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            const t4 = Math.min((e3.f.now() - this._easeStart) / this._easeOptions.duration, 1), i4 = this._onEaseFrame;
            i4 && i4(this._easeOptions.easing(t4)), t4 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(t4, i4) {
            t4 = e3.bk(t4, -180, 180);
            const o3 = Math.abs(t4 - i4);
            return Math.abs(t4 - 360 - i4) < o3 && (t4 -= 360), Math.abs(t4 + 360 - i4) < o3 && (t4 += 360), t4;
          }
          _normalizeCenter(e4) {
            const t4 = this.transform;
            if (t4.maxBounds) return;
            if ("globe" !== t4.projection.name && !t4.renderWorldCopies) return;
            const i4 = e4.lng - t4.center.lng;
            e4.lng += i4 > 180 ? -360 : i4 < -180 ? 360 : 0;
          }
          _prefersReducedMotion(t4) {
            return this._respectPrefersReducedMotion && e3.f.prefersReducedMotion && !(t4 && t4.essential);
          }
          _emulate(e4, t4, i4) {
            const o3 = Math.ceil(15 * t4 / 1e3), r4 = [], s4 = e4(i4.clone());
            for (let e5 = 0; e5 <= o3; e5++) {
              const t5 = s4(e5 / o3);
              r4.push(t5.clone());
            }
            return r4;
          }
          _preloadTiles(e4, t4) {
          }
        }
        class Kn {
          constructor(t4 = {}) {
            this.options = t4, e3.a$(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e4) {
            const t4 = this.options && this.options.compact;
            return this._map = e4, this._container = s3("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = s3("button", "mapboxgl-ctrl-attrib-button", this._container), s3("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = s3("div", "mapboxgl-ctrl-attrib-inner", this._container), t4 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t4 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e4, t4) {
            const i4 = this._map._getUIString(`AttributionControl.${t4}`);
            e4.removeAttribute("title"), e4.firstElementChild && e4.firstElementChild.setAttribute("title", i4);
          }
          _toggleAttribution() {
            this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
          }
          _updateEditLink() {
            let t4 = this._editLink;
            t4 || (t4 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
            const i4 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e3.dd.ACCESS_TOKEN }];
            if (t4) {
              const o3 = i4.reduce((e4, t5, o4) => (t5.value && (e4 += `${t5.key}=${t5.value}${o4 < i4.length - 1 ? "&" : ""}`), e4), "?");
              t4.href = `${e3.dd.FEEDBACK_URL}/${o3}#${en2(this._map, true)}`, t4.rel = "noopener nofollow", this._setElementTitle(t4, "MapFeedback");
            }
          }
          _updateData(e4) {
            !e4 || "metadata" !== e4.sourceDataType && "visibility" !== e4.sourceDataType && "style" !== e4.dataType || (this._updateAttributions(), this._updateEditLink());
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e4 = [];
            if (this._map.style.stylesheet) {
              const e5 = this._map.style.stylesheet;
              this.styleOwner = e5.owner, this.styleId = e5.id;
            }
            const t4 = this._map.style._mergedSourceCaches;
            for (const i5 in t4) {
              const o3 = t4[i5];
              if (o3.used) {
                const t5 = o3.getSource();
                t5.attribution && e4.indexOf(t5.attribution) < 0 && e4.push(t5.attribution);
              }
            }
            e4.sort((e5, t5) => e5.length - t5.length), e4 = e4.filter((t5, i5) => {
              for (let o3 = i5 + 1; o3 < e4.length; o3++) if (e4[o3].indexOf(t5) >= 0) return false;
              return true;
            }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e4 = [...this.options.customAttribution, ...e4] : e4.unshift(this.options.customAttribution));
            const i4 = e4.join(" | ");
            i4 !== this._attribHTML && (this._attribHTML = i4, e4.length ? (this._innerContainer.innerHTML = i4, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
          }
        }
        class ea {
          constructor() {
            e3.a$(["_updateLogo", "_updateCompact"], this);
          }
          onAdd(e4) {
            this._map = e4, this._container = s3("div", "mapboxgl-ctrl");
            const t4 = s3("a", "mapboxgl-ctrl-logo");
            return t4.target = "_blank", t4.rel = "noopener nofollow", t4.href = "https://www.mapbox.com/", t4.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t4.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t4), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _updateLogo(e4) {
            e4 && "metadata" !== e4.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
          }
          _logoRequired() {
            if (!this._map.style) return true;
            const e4 = this._map.style._sourceCaches;
            if (0 === Object.entries(e4).length) return true;
            for (const t4 in e4) {
              const i4 = e4[t4].getSource();
              if (i4.hasOwnProperty("mapbox_logo") && !i4.mapbox_logo) return false;
            }
            return true;
          }
          _updateCompact() {
            const e4 = this._container.children;
            if (e4.length) {
              const t4 = e4[0];
              this._map.getCanvasContainer().offsetWidth < 250 ? t4.classList.add("mapboxgl-compact") : t4.classList.remove("mapboxgl-compact");
            }
          }
        }
        class ta {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e4) {
            const t4 = ++this._id;
            return this._queue.push({ callback: e4, id: t4, cancelled: false }), t4;
          }
          remove(e4) {
            const t4 = this._currentlyRunning, i4 = t4 ? this._queue.concat(t4) : this._queue;
            for (const t5 of i4) if (t5.id === e4) return void (t5.cancelled = true);
          }
          run(e4 = 0) {
            const t4 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i4 of t4) if (!i4.cancelled && (i4.callback(e4), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        function ia(t4, i4, o3) {
          if (t4 = new e3.bq(t4.lng, t4.lat), i4) {
            const r4 = new e3.bq(t4.lng - 360, t4.lat), s4 = new e3.bq(t4.lng + 360, t4.lat), n3 = 360 * Math.ceil(Math.abs(t4.lng - o3.center.lng) / 360), a4 = o3.locationPoint(t4).distSqr(i4), l4 = i4.x < 0 || i4.y < 0 || i4.x > o3.width || i4.y > o3.height;
            o3.locationPoint(r4).distSqr(i4) < a4 && (l4 || Math.abs(r4.lng - o3.center.lng) < n3) ? t4 = r4 : o3.locationPoint(s4).distSqr(i4) < a4 && (l4 || Math.abs(s4.lng - o3.center.lng) < n3) && (t4 = s4);
          }
          for (; Math.abs(t4.lng - o3.center.lng) > 180; ) {
            const e4 = o3.locationPoint(t4);
            if (e4.x >= 0 && e4.y >= 0 && e4.x <= o3.width && e4.y <= o3.height) break;
            t4.lng > o3.center.lng ? t4.lng -= 360 : t4.lng += 360;
          }
          return t4;
        }
        const oa = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        class ra extends e3.E {
          constructor(t4, i4) {
            if (super(), (t4 instanceof HTMLElement || i4) && (t4 = e3.e({ element: t4 }, i4)), e3.a$(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t4 && t4.anchor || "center", this._color = t4 && t4.color || "#3FB1CE", this._scale = t4 && t4.scale || 1, this._draggable = t4 && t4.draggable || false, this._clickTolerance = t4 && t4.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t4 && t4.rotation || 0, this._rotationAlignment = t4 && t4.rotationAlignment || "auto", this._pitchAlignment = t4 && t4.pitchAlignment && t4.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t4 && t4.occludedOpacity || 0.2, t4 && t4.element) this._element = t4.element, this._offset = e3.P.convert(t4 && t4.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = s3("div");
              const i5 = 41, o4 = 27, r5 = n2("svg", { display: "block", height: i5 * this._scale + "px", width: o4 * this._scale + "px", viewBox: `0 0 ${o4} ${i5}` }, this._element), a4 = n2("radialGradient", { id: "shadowGradient" }, n2("defs", {}, r5));
              n2("stop", { offset: "10%", "stop-opacity": 0.4 }, a4), n2("stop", { offset: "100%", "stop-opacity": 0.05 }, a4), n2("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r5), n2("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r5), n2("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r5), n2("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r5), this._offset = e3.P.convert(t4 && t4.offset || [0, -14]);
            }
            this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e4) => {
              e4.preventDefault();
            }), this._element.addEventListener("mousedown", (e4) => {
              e4.preventDefault();
            });
            const o3 = this._element.classList;
            for (const e4 in oa) o3.remove(`mapboxgl-marker-anchor-${e4}`);
            o3.add(`mapboxgl-marker-anchor-${this._anchor}`);
            const r4 = t4 && t4.className ? t4.className.trim().split(/\s+/) : [];
            o3.add(...r4), this._popup = null;
          }
          addTo(e4) {
            return e4 === this._map || (this.remove(), this._map = e4, e4.getCanvasContainer().appendChild(this._element), e4.on("move", this._updateMoving), e4.on("moveend", this._update), e4.on("remove", this._clearFadeTimer), e4._addMarker(this), this.setDraggable(this._draggable), this._update(), e4.on("click", this._onMapClick)), this;
          }
          remove() {
            const e4 = this._map;
            return e4 && (e4.off("click", this._onMapClick), e4.off("move", this._updateMoving), e4.off("moveend", this._update), e4.off("mousedown", this._addDragHandler), e4.off("touchstart", this._addDragHandler), e4.off("mouseup", this._onUp), e4.off("touchend", this._onUp), e4.off("mousemove", this._onMove), e4.off("touchmove", this._onMove), e4.off("remove", this._clearFadeTimer), e4._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t4) {
            return this._lngLat = e3.bq.convert(t4), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e4) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e4) {
              if (!("offset" in e4.options)) {
                const t4 = 38.1, i4 = 13.5, o3 = Math.sqrt(Math.pow(i4, 2) / 2);
                e4.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t4], "bottom-left": [o3, -1 * (t4 - i4 + o3)], "bottom-right": [-o3, -1 * (t4 - i4 + o3)], left: [i4, -1 * (t4 - i4)], right: [-i4, -1 * (t4 - i4)] } : this._offset;
              }
              this._popup = e4, e4._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
            }
            return this;
          }
          _onKeyPress(e4) {
            const t4 = e4.code, i4 = e4.charCode || e4.keyCode;
            "Space" !== t4 && "Enter" !== t4 && 32 !== i4 && 13 !== i4 || this.togglePopup();
          }
          _onMapClick(e4) {
            const t4 = e4.originalEvent.target, i4 = this._element;
            this._popup && (t4 === i4 || i4.contains(t4)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e4 = this._popup;
            return e4 ? (e4.isOpen() ? (e4.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e4.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
          }
          _behindTerrain() {
            const e4 = this._map, t4 = this._pos;
            if (!e4 || !t4) return false;
            const i4 = e4.unproject(t4), o3 = e4.getFreeCameraOptions();
            if (!o3.position) return false;
            const r4 = o3.position.toLngLat();
            return r4.distanceTo(i4) < 0.9 * r4.distanceTo(this._lngLat);
          }
          _evaluateOpacity() {
            const t4 = this._map;
            if (!t4) return;
            const i4 = this._pos;
            if (!i4 || i4.x < 0 || i4.x > t4.transform.width || i4.y < 0 || i4.y > t4.transform.height) return void this._clearFadeTimer();
            const o3 = t4.unproject(i4);
            let r4;
            t4._showingGlobe() && e3.de(t4.transform, this._lngLat) ? r4 = 0 : (r4 = 1 - t4._queryFogOpacity(o3), t4.transform._terrainEnabled() && t4.getTerrain() && this._behindTerrain() && (r4 *= this._occludedOpacity)), this._element.style.opacity = `${r4}`, this._element.style.pointerEvents = r4 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r4), this._fadeTimer = null;
          }
          _clearFadeTimer() {
            this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
          }
          _updateDOM() {
            const e4 = this._pos;
            if (!e4 || !this._map) return;
            const t4 = this._offset.mult(this._scale);
            this._element.style.transform = `
            translate(${e4.x}px,${e4.y}px)
            ${oa[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t4.x}px,${t4.y}px)
        `;
          }
          _calculateXYTransform() {
            const t4 = this._pos, i4 = this._map, o3 = this.getPitchAlignment();
            if (!i4 || !t4 || "map" !== o3) return "";
            if (!i4._showingGlobe()) {
              const e4 = i4.getPitch();
              return e4 ? `rotateX(${e4}deg)` : "";
            }
            const r4 = e3.bI(e3.df(i4.transform, this._lngLat)), s4 = t4.sub(e3.dg(i4.transform)), n3 = Math.abs(s4.x) + Math.abs(s4.y);
            if (0 === n3) return "";
            const a4 = r4 / n3;
            return `rotateX(${-s4.y * a4}deg) rotateY(${s4.x * a4}deg)`;
          }
          _calculateZTransform() {
            const t4 = this._pos, i4 = this._map;
            if (!i4 || !t4) return "";
            let o3 = 0;
            const r4 = this.getRotationAlignment();
            if ("map" === r4) if (i4._showingGlobe()) {
              const t5 = i4.project(new e3.bq(this._lngLat.lng, this._lngLat.lat + 1e-3)), r5 = i4.project(new e3.bq(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t5);
              o3 = e3.bI(Math.atan2(r5.y, r5.x)) - 90;
            } else o3 = -i4.getBearing();
            else if ("horizon" === r4) {
              const r5 = e3.S(4, 6, i4.getZoom()), s4 = e3.dg(i4.transform);
              s4.y += r5 * i4.transform.height;
              const n3 = t4.sub(s4), a4 = e3.bI(Math.atan2(n3.y, n3.x));
              o3 = (a4 > 90 ? a4 - 270 : a4 + 90) * (1 - r5);
            }
            return o3 += this._rotation, o3 ? `rotateZ(${o3}deg)` : "";
          }
          _update(e4) {
            cancelAnimationFrame(this._updateFrameId);
            const t4 = this._map;
            t4 && (t4.transform.renderWorldCopies && (this._lngLat = ia(this._lngLat, this._pos, t4.transform)), this._pos = t4.project(this._lngLat), true === e4 ? this._updateFrameId = requestAnimationFrame(() => {
              this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
            }) : this._pos = this._pos.round(), t4._requestDomTask(() => {
              this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t4._showingGlobe() || t4.getTerrain() || t4.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
            }));
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t4) {
            return this._offset = e3.P.convert(t4), this._update(), this;
          }
          addClassName(e4) {
            return this._element.classList.add(e4), this;
          }
          removeClassName(e4) {
            return this._element.classList.remove(e4), this;
          }
          toggleClassName(e4) {
            return this._element.classList.toggle(e4);
          }
          _onMove(t4) {
            const i4 = this._map;
            if (!i4) return;
            const o3 = this._pointerdownPos, r4 = this._positionDelta;
            if (o3 && r4) {
              if (!this._isDragging) {
                const e4 = this._clickTolerance || i4._clickTolerance;
                if (t4.point.dist(o3) < e4) return;
                this._isDragging = true;
              }
              this._pos = t4.point.sub(r4), this._lngLat = i4.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e3.b("dragstart"))), this.fire(new e3.b("drag"));
            }
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
            const t4 = this._map;
            t4 && (t4.off("mousemove", this._onMove), t4.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e3.b("dragend")), this._state = "inactive";
          }
          _addDragHandler(e4) {
            const t4 = this._map, i4 = this._pos;
            t4 && i4 && this._element.contains(e4.originalEvent.target) && (e4.preventDefault(), this._positionDelta = e4.point.sub(i4), this._pointerdownPos = e4.point, this._state = "pending", t4.on("mousemove", this._onMove), t4.on("touchmove", this._onMove), t4.once("mouseup", this._onUp), t4.once("touchend", this._onUp));
          }
          setDraggable(e4) {
            this._draggable = !!e4;
            const t4 = this._map;
            return t4 && (e4 ? (t4.on("mousedown", this._addDragHandler), t4.on("touchstart", this._addDragHandler)) : (t4.off("mousedown", this._addDragHandler), t4.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e4) {
            return this._rotation = e4 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e4) {
            return this._rotationAlignment = e4 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
          }
          setPitchAlignment(e4) {
            return this._pitchAlignment = e4 || "auto", this._update(), this;
          }
          getPitchAlignment() {
            return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
          }
          setOccludedOpacity(e4) {
            return this._occludedOpacity = e4 || 0.2, this._update(), this;
          }
          getOccludedOpacity() {
            return this._occludedOpacity;
          }
        }
        const sa = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, na = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function aa(t4 = new e3.P(0, 0), i4 = "bottom") {
          if ("number" == typeof t4) {
            const o3 = Math.round(Math.sqrt(0.5 * Math.pow(t4, 2)));
            switch (i4) {
              case "top":
                return new e3.P(0, t4);
              case "top-left":
                return new e3.P(o3, o3);
              case "top-right":
                return new e3.P(-o3, o3);
              case "bottom":
                return new e3.P(0, -t4);
              case "bottom-left":
                return new e3.P(o3, -o3);
              case "bottom-right":
                return new e3.P(-o3, -o3);
              case "left":
                return new e3.P(t4, 0);
              case "right":
                return new e3.P(-t4, 0);
            }
            return new e3.P(0, 0);
          }
          return t4 instanceof e3.P || Array.isArray(t4) ? e3.P.convert(t4) : e3.P.convert(t4[i4] || [0, 0]);
        }
        class la {
          constructor(e4) {
            this.jumpTo(e4);
          }
          getValue(t4) {
            if (t4 <= this._startTime) return this._start;
            if (t4 >= this._endTime) return this._end;
            const i4 = e3.ch((t4 - this._startTime) / (this._endTime - this._startTime));
            return this._start * (1 - i4) + this._end * i4;
          }
          isEasing(e4) {
            return e4 >= this._startTime && e4 <= this._endTime;
          }
          jumpTo(e4) {
            this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e4, this._end = e4;
          }
          easeTo(e4, t4, i4) {
            this._start = this.getValue(t4), this._end = e4, this._startTime = t4, this._endTime = t4 + i4;
          }
        }
        class ca {
          registerParameter(e4, t4, i4, o3, r4) {
          }
          registerButton(e4, t4, i4) {
          }
          registerBinding(e4, t4, i4, o3) {
          }
          refreshUI() {
          }
        }
        const ha = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, ua = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true, collectResourceTiming: false, testMode: false }, da = { showCompass: true, showZoom: true, visualizePitch: false };
        class _a {
          constructor(t4, i4, o3 = false) {
            this._clickTolerance = 10, this.element = i4, this.mouseRotate = new Tn({ clickTolerance: t4.dragRotate._mouseRotate._clickTolerance }), this.map = t4, o3 && (this.mousePitch = new En({ clickTolerance: t4.dragRotate._mousePitch._clickTolerance })), e3.a$(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i4.addEventListener("mousedown", this.mousedown), i4.addEventListener("touchstart", this.touchstart, { passive: false }), i4.addEventListener("touchmove", this.touchmove), i4.addEventListener("touchend", this.touchend), i4.addEventListener("touchcancel", this.reset);
          }
          down(e4, t4) {
            this.mouseRotate.mousedown(e4, t4), this.mousePitch && this.mousePitch.mousedown(e4, t4), h3();
          }
          move(e4, t4) {
            const i4 = this.map, o3 = this.mouseRotate.mousemoveWindow(e4, t4), r4 = o3 && o3.bearingDelta;
            if (r4 && i4.setBearing(i4.getBearing() + r4), this.mousePitch) {
              const o4 = this.mousePitch.mousemoveWindow(e4, t4), r5 = o4 && o4.pitchDelta;
              r5 && i4.setPitch(i4.getPitch() + r5);
            }
          }
          off() {
            const e4 = this.element;
            e4.removeEventListener("mousedown", this.mousedown), e4.removeEventListener("touchstart", this.touchstart, { passive: false }), e4.removeEventListener("touchmove", this.touchmove), e4.removeEventListener("touchend", this.touchend), e4.removeEventListener("touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            u4(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
          }
          mousedown(t4) {
            this.down(e3.e({}, t4, { ctrlKey: true, preventDefault: () => t4.preventDefault() }), p3(this.element, t4)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
          }
          mousemove(e4) {
            this.move(e4, p3(this.element, e4));
          }
          mouseup(e4) {
            this.mouseRotate.mouseupWindow(e4), this.mousePitch && this.mousePitch.mouseupWindow(e4), this.offTemp();
          }
          touchstart(e4) {
            1 !== e4.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = f3(this.element, e4.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e4.preventDefault() }, this._startPos));
          }
          touchmove(e4) {
            1 !== e4.targetTouches.length ? this.reset() : (this._lastPos = f3(this.element, e4.targetTouches)[0], this.move({ preventDefault: () => e4.preventDefault() }, this._lastPos));
          }
          touchend(e4) {
            0 === e4.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        const pa = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, fa = { maxWidth: 100, unit: "metric" }, ma = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, ga = { version: e3.du, supported: i3, setRTLTextPlugin: e3.dw, getRTLTextPluginStatus: e3.dx, Map: class extends Jn {
          constructor(t4) {
            const i4 = t4;
            if (null != (t4 = e3.e({}, ua, t4)).minZoom && null != t4.maxZoom && t4.minZoom > t4.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != t4.minPitch && null != t4.maxPitch && t4.minPitch > t4.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != t4.minPitch && t4.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (null != t4.maxPitch && t4.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (t4.antialias && e3.dh(window) && (t4.antialias = false, e3.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new po(t4.minZoom, t4.maxZoom, t4.minPitch, t4.maxPitch, t4.renderWorldCopies), t4), this._repaint = !!t4.repaint, this._interactive = t4.interactive, this._minTileCacheSize = t4.minTileCacheSize, this._maxTileCacheSize = t4.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t4.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t4.preserveDrawingBuffer, this._antialias = t4.antialias, this._trackResize = t4.trackResize, this._bearingSnap = t4.bearingSnap, this._refreshExpiredTiles = t4.refreshExpiredTiles, this._fadeDuration = t4.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t4.crossSourceCollisions, this._collectResourceTiming = t4.collectResourceTiming, this._language = this._parseLanguage(t4.language), this._worldview = t4.worldview, this._renderTaskQueue = new ta(), this._domRenderTaskQueue = new ta(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e3.aF(), this._locale = e3.e({}, ha, t4.locale), this._clickTolerance = t4.clickTolerance, this._cooperativeGestures = t4.cooperativeGestures, this._performanceMetricsCollection = t4.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = true, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new la(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._requestManager = new e3.di(t4.transformRequest, t4.accessToken, t4.testMode), this._silenceAuthErrors = !!t4.testMode, this._contextCreateOptions = t4.contextCreateOptions ? __spreadValues({}, t4.contextCreateOptions) : {}, "string" == typeof t4.container) {
              const e4 = document.getElementById(t4.container);
              if (!e4) throw new Error(`Container '${t4.container.toString()}' not found.`);
              this._container = e4;
            } else {
              if (!(t4.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = t4.container;
            }
            if (this._container.childNodes.length > 0 && e3.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t4.maxBounds && this.setMaxBounds(t4.maxBounds), e3.a$(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp = t4.devtools ? new ca(this) : new ca(), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: true }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: true }, () => {
              this._update();
            }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
            if (this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, false), window.addEventListener("resize", this._onWindowResize, false), window.addEventListener("orientationchange", this._onWindowResize, false), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.addEventListener("visibilitychange", this._onVisibilityChange, false), this.handlers = new Xn(this, t4), this._localFontFamily = t4.localFontFamily, this._localIdeographFontFamily = t4.localIdeographFontFamily, (t4.style || !t4.testMode) && this.setStyle(t4.style || e3.dd.DEFAULT_STYLE, { config: t4.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t4.projection && this.setProjection(t4.projection), t4.hash && (this._hash = new Ks("string" == typeof t4.hash && t4.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
              null == i4.center && null == i4.zoom || (this.transform._unmodified = false), this.jumpTo({ center: t4.center, zoom: t4.zoom, bearing: t4.bearing, pitch: t4.pitch });
              const o3 = t4.bounds;
              o3 && (this.resize(), this.fitBounds(o3, e3.e({}, t4.fitBoundsOptions, { duration: 0 })));
            }
            this.resize(), t4.attributionControl && this.addControl(new Kn({ customAttribution: t4.customAttribution })), this._logoControl = new ea(), this.addControl(this._logoControl, t4.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
            }), this.on("data", (t5) => {
              this._update("style" === t5.dataType), this.fire(new e3.b(`${t5.dataType}data`, t5));
            }), this.on("dataloading", (t5) => {
              this.fire(new e3.b(`${t5.dataType}dataloading`, t5));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(t4, i4) {
            if (void 0 === i4 && (i4 = t4.getDefaultPosition ? t4.getDefaultPosition() : "top-right"), !t4 || !t4.onAdd) return this.fire(new e3.a(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const o3 = t4.onAdd(this);
            this._controls.push(t4);
            const r4 = this._controlPositions[i4];
            return -1 !== i4.indexOf("bottom") ? r4.insertBefore(o3, r4.firstChild) : r4.appendChild(o3), this;
          }
          removeControl(t4) {
            if (!t4 || !t4.onRemove) return this.fire(new e3.a(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i4 = this._controls.indexOf(t4);
            return i4 > -1 && this._controls.splice(i4, 1), t4.onRemove(this), this;
          }
          hasControl(e4) {
            return this._controls.indexOf(e4) > -1;
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          resize(t4) {
            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
            const i4 = !this._moving;
            return i4 && this.fire(new e3.b("movestart", t4)).fire(new e3.b("move", t4)), this.fire(new e3.b("resize", t4)), i4 && this.fire(new e3.b("moveend", t4)), this;
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds() || null;
          }
          setMaxBounds(t4) {
            return this.transform.setMaxBounds(e3.ag.convert(t4)), this._update();
          }
          setMinZoom(t4) {
            if ((t4 = null == t4 ? -2 : t4) >= -2 && t4 <= this.transform.maxZoom) return this.transform.minZoom = t4, this._update(), this.getZoom() < t4 ? this.setZoom(t4) : this.fire(new e3.b("zoomstart")).fire(new e3.b("zoom")).fire(new e3.b("zoomend")), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t4) {
            if ((t4 = null == t4 ? 22 : t4) >= this.transform.minZoom) return this.transform.maxZoom = t4, this._update(), this.getZoom() > t4 ? this.setZoom(t4) : this.fire(new e3.b("zoomstart")).fire(new e3.b("zoom")).fire(new e3.b("zoomend")), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t4) {
            if ((t4 = null == t4 ? 0 : t4) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (t4 >= 0 && t4 <= this.transform.maxPitch) return this.transform.minPitch = t4, this._update(), this.getPitch() < t4 ? this.setPitch(t4) : this.fire(new e3.b("pitchstart")).fire(new e3.b("pitch")).fire(new e3.b("pitchend")), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t4) {
            if ((t4 = null == t4 ? 85 : t4) > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (t4 >= this.transform.minPitch) return this.transform.maxPitch = t4, this._update(), this.getPitch() > t4 ? this.setPitch(t4) : this.fire(new e3.b("pitchstart")).fire(new e3.b("pitch")).fire(new e3.b("pitchend")), this;
            throw new Error("maxPitch must be greater than or equal to minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(e4) {
            return this.transform.renderWorldCopies = e4, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
          }
          getLanguage() {
            return this._language;
          }
          _parseLanguage(e4) {
            return "auto" === e4 ? navigator.language : Array.isArray(e4) ? 0 === e4.length ? void 0 : e4.map((e5) => "auto" === e5 ? navigator.language : e5) : e4;
          }
          setLanguage(e4) {
            const t4 = this._parseLanguage(e4);
            if (!this.style || t4 === this._language) return this;
            this._language = t4, this.style.reloadSources();
            for (const e5 of this._controls) e5._setLanguage && e5._setLanguage(this._language);
            return this;
          }
          getWorldview() {
            return this._worldview;
          }
          setWorldview(e4) {
            return this.style && e4 !== this._worldview ? (this._worldview = e4, this.style.reloadSources(), this) : this;
          }
          getProjection() {
            return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
          }
          _showingGlobe() {
            return "globe" === this.transform.projection.name;
          }
          setProjection(e4) {
            return this._lazyInitEmptyStyle(), e4 ? "string" == typeof e4 && (e4 = { name: e4 }) : e4 = null, this._useExplicitProjection = !!e4, this._prioritizeAndUpdateProjection(e4, this.style.projection);
          }
          _updateProjectionTransition() {
            if ("globe" !== this.getProjection().name) return;
            const t4 = this.transform, i4 = t4.projection.name;
            let o3;
            "globe" === i4 && t4.zoom >= e3.bA ? (t4.setMercatorFromTransition(), o3 = true) : "mercator" === i4 && t4.zoom < e3.bA && (t4.setProjection({ name: "globe" }), o3 = true), o3 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
          }
          _prioritizeAndUpdateProjection(e4, t4) {
            return this._updateProjection(e4 || t4 || { name: "mercator" });
          }
          _updateProjection(t4) {
            let i4;
            return i4 = "globe" === t4.name && this.transform.zoom >= e3.bA ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t4), this.style.applyProjectionUpdate(), i4 && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(true), this._forceMarkerAndPopupUpdate(true)), this;
          }
          project(t4) {
            return this.transform.locationPoint3D(e3.bq.convert(t4));
          }
          unproject(t4) {
            return this.transform.pointLocation3D(e3.P.convert(t4));
          }
          isMoving() {
            return this._moving || this.handlers && this.handlers.isMoving() || false;
          }
          isZooming() {
            return this._zooming || this.handlers && this.handlers.isZooming() || false;
          }
          isRotating() {
            return this._rotating || this.handlers && this.handlers.isRotating() || false;
          }
          _isDragging() {
            return this.handlers && this.handlers._isDragging() || false;
          }
          _createDelegatedListener(e4, t4, i4) {
            if ("mouseenter" === e4 || "mouseover" === e4) {
              let o3 = false;
              const r4 = (r5) => {
                const s5 = t4.filter((e5) => this.getLayer(e5)), n3 = s5.length ? this.queryRenderedFeatures(r5.point, { layers: s5 }) : [];
                n3.length ? o3 || (o3 = true, i4.call(this, new hn(e4, this, r5.originalEvent, { features: n3 }))) : o3 = false;
              }, s4 = () => {
                o3 = false;
              };
              return { layers: new Set(t4), listener: i4, delegates: { mousemove: r4, mouseout: s4 } };
            }
            if ("mouseleave" === e4 || "mouseout" === e4) {
              let o3 = false;
              const r4 = (r5) => {
                const s5 = t4.filter((e5) => this.getLayer(e5));
                (s5.length ? this.queryRenderedFeatures(r5.point, { layers: s5 }) : []).length ? o3 = true : o3 && (o3 = false, i4.call(this, new hn(e4, this, r5.originalEvent)));
              }, s4 = (t5) => {
                o3 && (o3 = false, i4.call(this, new hn(e4, this, t5.originalEvent)));
              };
              return { layers: new Set(t4), listener: i4, delegates: { mousemove: r4, mouseout: s4 } };
            }
            {
              const o3 = (e5) => {
                const o4 = t4.filter((e6) => this.getLayer(e6)), r4 = o4.length ? this.queryRenderedFeatures(e5.point, { layers: o4 }) : [];
                r4.length && (e5.features = r4, i4.call(this, e5), delete e5.features);
              };
              return { layers: new Set(t4), listener: i4, delegates: { [e4]: o3 } };
            }
          }
          on(e4, t4, i4) {
            if (void 0 === i4) return super.on(e4, t4);
            if (Array.isArray(t4) || (t4 = [t4]), t4) {
              for (const e5 of t4) if (!this._isValidId(e5)) return this;
            }
            const o3 = this._createDelegatedListener(e4, t4, i4);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e4] = this._delegatedListeners[e4] || [], this._delegatedListeners[e4].push(o3);
            for (const e5 in o3.delegates) this.on(e5, o3.delegates[e5]);
            return this;
          }
          once(e4, t4, i4) {
            if (void 0 === i4) return super.once(e4, t4);
            if (Array.isArray(t4) || (t4 = [t4]), t4) {
              for (const e5 of t4) if (!this._isValidId(e5)) return this;
            }
            const o3 = this._createDelegatedListener(e4, t4, i4);
            for (const e5 in o3.delegates) this.once(e5, o3.delegates[e5]);
            return this;
          }
          off(e4, t4, i4) {
            if (void 0 === i4) return super.off(e4, t4);
            t4 = new Set(Array.isArray(t4) ? t4 : [t4]);
            for (const e5 of t4) if (!this._isValidId(e5)) return this;
            const o3 = (e5, t5) => {
              if (e5.size !== t5.size) return false;
              for (const i5 of e5) if (!t5.has(i5)) return false;
              return true;
            }, r4 = this._delegatedListeners ? this._delegatedListeners[e4] : void 0;
            return r4 && ((e5) => {
              for (let r5 = 0; r5 < e5.length; r5++) {
                const s4 = e5[r5];
                if (s4.listener === i4 && o3(s4.layers, t4)) {
                  for (const e6 in s4.delegates) this.off(e6, s4.delegates[e6]);
                  return e5.splice(r5, 1), this;
                }
              }
            })(r4), this;
          }
          queryRenderedFeatures(t4, i4) {
            if (!this.style) return [];
            if (void 0 !== i4 || void 0 === t4 || t4 instanceof e3.P || Array.isArray(t4) || (i4 = t4, t4 = void 0), t4 = t4 || [[0, 0], [this.transform.width, this.transform.height]], (i4 = i4 || {}).layers && Array.isArray(i4.layers)) {
              for (const e4 of i4.layers) if (!this._isValidId(e4)) return [];
            }
            return this.style.queryRenderedFeatures(t4, i4, this.transform);
          }
          querySourceFeatures(e4, t4) {
            return this._isValidId(e4) ? this.style.querySourceFeatures(e4, t4) : [];
          }
          isPointOnSurface(t4) {
            const { name: i4 } = this.transform.projection;
            return "globe" !== i4 && "mercator" !== i4 && e3.w(`${i4} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e3.P.convert(t4));
          }
          setStyle(t4, i4) {
            return i4 = e3.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i4), this.style && t4 && false !== i4.diff && i4.localFontFamily === this._localFontFamily && i4.localIdeographFontFamily === this._localIdeographFontFamily && !i4.config ? (this.style._diffStyle(t4, (o3, r4) => {
              o3 ? (e3.w(`Unable to perform style diff: ${String(o3.message || o3.error || o3)}. Rebuilding the style from scratch.`), this._updateStyle(t4, i4)) : r4 && this._update(true);
            }, () => {
              this._postStyleLoadEvent();
            }), this) : (this._localIdeographFontFamily = i4.localIdeographFontFamily, this._localFontFamily = i4.localFontFamily, this._updateStyle(t4, i4));
          }
          _getUIString(e4) {
            const t4 = this._locale[e4];
            if (null == t4) throw new Error(`Missing UI string '${e4}'`);
            return t4;
          }
          _updateStyle(t4, i4) {
            if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), t4) {
              const o3 = e3.e({}, i4);
              i4 && i4.config && (o3.initialConfig = i4.config, delete o3.config), this.style = new Ao(this, o3).setEventedParent(this, { style: this.style }).load(t4);
            }
            return this._updateTerrain(), this;
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Ao(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : (e3.w("There is no style added to the map."), false);
          }
          _isValidId(t4) {
            return null == t4 ? (this.fire(new e3.a(new Error("IDs can't be empty."))), false) : !e3.c9(t4) || (this.fire(new e3.a(new Error(`IDs can't contain special symbols: "${t4}".`))), false);
          }
          addSource(e4, t4) {
            return this._isValidId(e4) ? (this._lazyInitEmptyStyle(), this.style.addSource(e4, t4), this._update(true)) : this;
          }
          isSourceLoaded(e4) {
            return !!this._isValidId(e4) && !!this.style && this.style._isSourceCacheLoaded(e4);
          }
          areTilesLoaded() {
            return this.style.areTilesLoaded();
          }
          addSourceType(e4, t4, i4) {
            this._lazyInitEmptyStyle(), this.style.addSourceType(e4, t4, i4);
          }
          removeSource(e4) {
            return this._isValidId(e4) ? (this.style.removeSource(e4), this._updateTerrain(), this._update(true)) : this;
          }
          getSource(e4) {
            return this._isValidId(e4) ? this.style.getOwnSource(e4) : null;
          }
          addImage(t4, i4, { pixelRatio: o3 = 1, sdf: r4 = false, stretchX: s4, stretchY: n3, content: a4 } = {}) {
            if (this._lazyInitEmptyStyle(), i4 instanceof HTMLImageElement || ImageBitmap && i4 instanceof ImageBitmap) {
              const { width: l4, height: c4, data: h4 } = e3.f.getImageData(i4);
              this.style.addImage(t4, { data: new e3.h({ width: l4, height: c4 }, h4), pixelRatio: o3, stretchX: s4, stretchY: n3, content: a4, sdf: r4, version: 0 });
            } else if (void 0 === i4.width || void 0 === i4.height) this.fire(new e3.a(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            else {
              const { width: l4, height: c4 } = i4, h4 = i4;
              this.style.addImage(t4, { data: new e3.h({ width: l4, height: c4 }, new Uint8Array(h4.data)), pixelRatio: o3, stretchX: s4, stretchY: n3, content: a4, sdf: r4, version: 0, userImage: h4 }), h4.onAdd && h4.onAdd(this, t4);
            }
          }
          updateImage(t4, i4) {
            this._lazyInitEmptyStyle();
            const o3 = this.style.getImage(t4);
            if (!o3) return void this.fire(new e3.a(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const r4 = i4 instanceof HTMLImageElement || ImageBitmap && i4 instanceof ImageBitmap ? e3.f.getImageData(i4) : i4, { width: s4, height: n3 } = r4, a4 = r4.data;
            if (void 0 === s4 || void 0 === n3) return void this.fire(new e3.a(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (s4 !== o3.data.width || n3 !== o3.data.height) return void this.fire(new e3.a(new Error(`The width and height of the updated image (${s4}, ${n3})
                must be that same as the previous version of the image
                (${o3.data.width}, ${o3.data.height})`)));
            const l4 = !(i4 instanceof HTMLImageElement || ImageBitmap && i4 instanceof ImageBitmap);
            o3.data.replace(a4, l4), this.style.updateImage(t4, o3);
          }
          hasImage(t4) {
            return t4 ? !!this.style && !!this.style.getImage(t4) : (this.fire(new e3.a(new Error("Missing required image id"))), false);
          }
          removeImage(e4) {
            this.style.removeImage(e4);
          }
          loadImage(t4, i4) {
            e3.d(this._requestManager.transformRequest(t4, e3.R.Image), (t5, o3) => {
              i4(t5, o3 instanceof HTMLImageElement ? e3.f.getImageData(o3) : o3);
            });
          }
          listImages() {
            return this.style.listImages();
          }
          addModel(e4, t4) {
            this._lazyInitEmptyStyle(), this.style.addModel(e4, t4);
          }
          hasModel(t4) {
            return t4 ? this.style.hasModel(t4) : (this.fire(new e3.a(new Error("Missing required model id"))), false);
          }
          removeModel(e4) {
            this.style.removeModel(e4);
          }
          listModels() {
            return this.style.listModels();
          }
          addLayer(e4, t4) {
            return this._isValidId(e4.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e4, t4), this._update(true)) : this;
          }
          getSlot(e4) {
            const t4 = this.getLayer(e4);
            return t4 && t4.slot || null;
          }
          setSlot(e4, t4) {
            return this.style.setSlot(e4, t4), this.style.mergeLayers(), this._update(true);
          }
          addImport(e4, t4) {
            return this.style.addImport(e4, t4), this;
          }
          updateImport(e4, t4) {
            return "string" != typeof t4 && t4.id !== e4 ? (this.removeImport(e4), this.addImport(t4)) : (this.style.updateImport(e4, t4), this._update(true));
          }
          removeImport(e4) {
            return this.style.removeImport(e4), this;
          }
          moveImport(e4, t4) {
            return this.style.moveImport(e4, t4), this._update(true);
          }
          moveLayer(e4, t4) {
            return this._isValidId(e4) ? (this.style.moveLayer(e4, t4), this._update(true)) : this;
          }
          removeLayer(e4) {
            return this._isValidId(e4) ? (this.style.removeLayer(e4), this._update(true)) : this;
          }
          getLayer(e4) {
            return this._isValidId(e4) ? this.style.getOwnLayer(e4) : null;
          }
          setLayerZoomRange(e4, t4, i4) {
            return this._isValidId(e4) ? (this.style.setLayerZoomRange(e4, t4, i4), this._update(true)) : this;
          }
          setFilter(e4, t4, i4 = {}) {
            return this._isValidId(e4) ? (this.style.setFilter(e4, t4, i4), this._update(true)) : this;
          }
          getFilter(e4) {
            return this._isValidId(e4) ? this.style.getFilter(e4) : null;
          }
          setPaintProperty(e4, t4, i4, o3 = {}) {
            return this._isValidId(e4) ? (this.style.setPaintProperty(e4, t4, i4, o3), this._update(true)) : this;
          }
          getPaintProperty(e4, t4) {
            return this._isValidId(e4) ? this.style.getPaintProperty(e4, t4) : null;
          }
          setLayoutProperty(e4, t4, i4, o3 = {}) {
            return this._isValidId(e4) ? (this.style.setLayoutProperty(e4, t4, i4, o3), this._update(true)) : this;
          }
          getLayoutProperty(e4, t4) {
            return this._isValidId(e4) ? this.style.getLayoutProperty(e4, t4) : null;
          }
          getSchema(e4) {
            return this.style.getSchema(e4);
          }
          setSchema(e4, t4) {
            return this.style.setSchema(e4, t4), this._update(true);
          }
          getConfig(e4) {
            return this.style.getConfig(e4);
          }
          setConfig(e4, t4) {
            return this.style.setConfig(e4, t4), this._update(true);
          }
          getConfigProperty(e4, t4) {
            return this.style.getConfigProperty(e4, t4);
          }
          setConfigProperty(e4, t4, i4) {
            return this.style.setConfigProperty(e4, t4, i4), this._update(true);
          }
          setLights(e4) {
            if (this._lazyInitEmptyStyle(), e4 && 1 === e4.length && "flat" === e4[0].type) {
              const t4 = e4[0];
              t4.properties ? this.style.setFlatLight(t4.properties, t4.id, {}) : this.style.setFlatLight({}, "flat");
            } else this.style.setLights(e4), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = true);
            return this._update(true);
          }
          getLights() {
            const e4 = this.style.getLights() || [];
            return 0 === e4.length && e4.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), e4;
          }
          setLight(e4, t4 = {}) {
            return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: e4 }]);
          }
          getLight() {
            return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
          }
          setTerrain(e4) {
            return this._lazyInitEmptyStyle(), !e4 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e4), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
          }
          getTerrain() {
            return this.style ? this.style.getTerrain() : null;
          }
          setFog(e4) {
            return this._lazyInitEmptyStyle(), this.style.setFog(e4), this._update(true);
          }
          getFog() {
            return this.style ? this.style.getFog() : null;
          }
          setCamera(e4) {
            return this.style.setCamera(e4), this._triggerCameraUpdate(e4);
          }
          _triggerCameraUpdate(e4) {
            return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e4["camera-projection"]));
          }
          getCamera() {
            return this.style.camera;
          }
          _queryFogOpacity(t4) {
            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e3.bq.convert(t4), this.transform) : 0;
          }
          setFeatureState(e4, t4) {
            return this._isValidId(e4.source) ? (this.style.setFeatureState(e4, t4), this._update()) : this;
          }
          removeFeatureState(e4, t4) {
            return this._isValidId(e4.source) ? (this.style.removeFeatureState(e4, t4), this._update()) : this;
          }
          getFeatureState(e4) {
            return this._isValidId(e4.source) ? this.style.getFeatureState(e4) : null;
          }
          _updateContainerDimensions() {
            if (!this._container) return;
            const e4 = this._container.getBoundingClientRect().width || 400, t4 = this._container.getBoundingClientRect().height || 300;
            let i4, o3, r4, s4 = this._container;
            for (; s4 && (!o3 || !r4); ) {
              const e5 = window.getComputedStyle(s4).transform;
              e5 && "none" !== e5 && (i4 = e5.match(/matrix.*\((.+)\)/)[1].split(", "), i4[0] && "0" !== i4[0] && "1" !== i4[0] && (o3 = i4[0]), i4[3] && "0" !== i4[3] && "1" !== i4[3] && (r4 = i4[3])), s4 = s4.parentElement;
            }
            this._containerWidth = o3 ? Math.abs(e4 / o3) : e4, this._containerHeight = r4 ? Math.abs(t4 / r4) : t4;
          }
          _detectMissingCSS() {
            "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e3.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }
          _setupContainer() {
            const e4 = this._container;
            e4.classList.add("mapboxgl-map"), (this._missingCSSCanary = s3("div", "mapboxgl-canary", e4)).style.visibility = "hidden", this._detectMissingCSS();
            const t4 = this._canvasContainer = s3("div", "mapboxgl-canvas-container", e4);
            this._canvas = s3("canvas", "mapboxgl-canvas", t4), this._interactive && (t4.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
            const i4 = this._controlContainer = s3("div", "mapboxgl-control-container", e4), o3 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e5) => {
              o3[e5] = s3("div", `mapboxgl-ctrl-${e5}`, i4);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t4, i4) {
            const o3 = e3.f.devicePixelRatio || 1;
            this._canvas.width = o3 * Math.ceil(t4), this._canvas.height = o3 * Math.ceil(i4), this._canvas.style.width = `${t4}px`, this._canvas.style.height = `${i4}px`;
          }
          _addMarker(e4) {
            this._markers.push(e4);
          }
          _removeMarker(e4) {
            const t4 = this._markers.indexOf(e4);
            -1 !== t4 && this._markers.splice(t4, 1);
          }
          _addPopup(e4) {
            this._popups.push(e4);
          }
          _removePopup(e4) {
            const t4 = this._popups.indexOf(e4);
            -1 !== t4 && this._popups.splice(t4, 1);
          }
          _setupPainter() {
            const t4 = e3.e({}, i3.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o3 = this._canvas.getContext("webgl2", t4);
            o3 ? (e3.dj(o3, true), this.painter = new Ys(o3, this._contextCreateOptions, this.transform, this._tp), this.on("data", (e4) => {
              "source" === e4.dataType && this.painter.setTileLoadedFlag(true);
            }), e3.dk.testSupport(o3)) : this.fire(new e3.a(new Error("Failed to initialize WebGL")));
          }
          _contextLost(t4) {
            t4.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e3.b("webglcontextlost", { originalEvent: t4 }));
          }
          _contextRestored(t4) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new e3.b("webglcontextrestored", { originalEvent: t4 }));
          }
          _onMapScroll(e4) {
            if (e4.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(e4) {
            return this.style ? (this._styleDirty = this._styleDirty || e4, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(e4) {
            return this._update(), this._renderTaskQueue.add(e4);
          }
          _cancelRenderFrame(e4) {
            this._renderTaskQueue.remove(e4);
          }
          _requestDomTask(e4) {
            !this.loaded() || this.loaded() && !this.isMoving() ? e4() : this._domRenderTaskQueue.add(e4);
          }
          _render(t4) {
            let i4;
            this.fire(new e3.b("renderstart"));
            const o3 = this.painter.context.extTimerQuery, r4 = e3.f.now(), s4 = this.painter.context.gl;
            if (this.listens("gpu-timing-frame") && (i4 = s4.createQuery(), s4.beginQuery(o3.TIME_ELAPSED_EXT, i4)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t4), this._domRenderTaskQueue.run(t4), this._removed) return;
            this._updateProjectionTransition();
            const n3 = this._isInitialLoad ? 0 : this._fadeDuration;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const t5 = this.transform.zoom, i5 = this.transform.pitch, o4 = e3.f.now(), r5 = new e3.N(t5, { now: o4, fadeDuration: n3, pitch: i5, transition: this.style.transition });
              this.style.update(r5);
            }
            this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
            let a4 = false;
            if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), a4 = this._updateAverageElevation(r4), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : a4 = this._updateAverageElevation(r4), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n3, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n3, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e3.b("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e3.b("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i4) {
              const t5 = e3.f.now() - r4;
              s4.endQuery(o3.TIME_ELAPSED_EXT), setTimeout(() => {
                const o4 = s4.getQueryParameter(i4, s4.QUERY_RESULT) / 1e6;
                s4.deleteQuery(i4), this.fire(new e3.b("gpu-timing-frame", { cpuTime: t5, gpuTime: o4 }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              const t5 = this.painter.collectGpuTimers();
              setTimeout(() => {
                const i5 = this.painter.queryGpuTimers(t5);
                this.fire(new e3.b("gpu-timing-layer", { layerTimes: i5 }));
              }, 50);
            }
            if (this.listens("gpu-timing-deferred-render")) {
              const t5 = this.painter.collectDeferredRenderGpuQueries();
              setTimeout(() => {
                const i5 = this.painter.queryGpuTimeDeferredRender(t5);
                this.fire(new e3.b("gpu-timing-deferred-render", { gpuTime: i5 }));
              }, 50);
            }
            const l4 = this._sourcesDirty || this._styleDirty || this._placementDirty || a4;
            if (l4 || this._repaint) this.triggerRepaint();
            else {
              const t5 = !this.isMoving() && this.loaded();
              if (t5 && (a4 = this._updateAverageElevation(r4, true)), a4) this.triggerRepaint();
              else if (this._triggerFrame(false), t5 && (this.fire(new e3.b("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                const t6 = this._calculateSpeedIndex();
                this.fire(new e3.b("speedindexcompleted", { speedIndex: t6 })), this.speedIndexTiming = false;
              }
            }
            !this._loaded || this._fullyLoaded || l4 || (this._fullyLoaded = true, this._performanceMetricsCollection && e3.dl(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
          }
          _forceMarkerAndPopupUpdate(e4) {
            for (const t4 of this._markers) e4 && !this.getRenderWorldCopies() && (t4._lngLat = t4._lngLat.wrap()), t4._update();
            for (const t4 of this._popups) !e4 || this.getRenderWorldCopies() || t4._trackPointer || (t4._lngLat = t4._lngLat.wrap()), t4._update();
          }
          _updateAverageElevation(e4, t4 = false) {
            const i4 = (e5) => (this.transform.averageElevation = e5, this._update(false), true);
            if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i4(0);
            const o3 = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
            if (o3 || (t4 || e4 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e4)) {
              const t5 = this.transform.averageElevation;
              let r4 = this.transform.sampleAverageElevation();
              this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(r4) ? r4 = 0 : this._averageElevationLastSampledAt = e4;
              const s4 = Math.abs(t5 - r4);
              if (s4 > 1) {
                if (this._isInitialLoad || o3) return this._averageElevation.jumpTo(r4), i4(r4);
                this._averageElevation.easeTo(r4, e4, 300);
              } else if (s4 > 1e-4) return this._averageElevation.jumpTo(r4), i4(r4);
            }
            return !!this._averageElevation.isEasing(e4) && i4(this._averageElevation.getValue(e4));
          }
          _authenticate() {
            e3.dm(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t4) => {
              if (t4 && (t4.message === e3.dn || 401 === t4.status)) {
                const t5 = this.painter.context.gl;
                e3.dj(t5, false), this._logoControl instanceof ea && this._logoControl._updateLogo(), t5 && t5.clear(t5.DEPTH_BUFFER_BIT | t5.COLOR_BUFFER_BIT | t5.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e3.a(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
              }
            }), e3.dp(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
            });
          }
          _postStyleLoadEvent() {
            this.style.globalId && e3.dq(this._requestManager._customAccessToken, { map: this, skuToken: this._requestManager._skuToken, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
          }
          _updateTerrain() {
            const e4 = this._isDragging();
            this.painter.updateTerrain(this.style, e4);
          }
          _calculateSpeedIndex() {
            const e4 = this.painter.canvasCopy(), t4 = this.painter.getCanvasCopiesAndTimestamps();
            t4.timeStamps.push(performance.now());
            const i4 = this.painter.context.gl, o3 = i4.createFramebuffer();
            function r4(e5) {
              i4.framebufferTexture2D(i4.FRAMEBUFFER, i4.COLOR_ATTACHMENT0, i4.TEXTURE_2D, e5, 0);
              const t5 = new Uint8Array(i4.drawingBufferWidth * i4.drawingBufferHeight * 4);
              return i4.readPixels(0, 0, i4.drawingBufferWidth, i4.drawingBufferHeight, i4.RGBA, i4.UNSIGNED_BYTE, t5), t5;
            }
            return i4.bindFramebuffer(i4.FRAMEBUFFER, o3), this._canvasPixelComparison(r4(e4), t4.canvasCopies.map(r4), t4.timeStamps);
          }
          _canvasPixelComparison(e4, t4, i4) {
            let o3 = i4[1] - i4[0];
            const r4 = e4.length / 4;
            for (let s4 = 0; s4 < t4.length; s4++) {
              const n3 = t4[s4];
              let a4 = 0;
              for (let t5 = 0; t5 < n3.length; t5 += 4) n3[t5] === e4[t5] && n3[t5 + 1] === e4[t5 + 1] && n3[t5 + 2] === e4[t5 + 2] && n3[t5 + 3] === e4[t5 + 3] && (a4 += 1);
              o3 += (i4[s4 + 2] - i4[s4 + 1]) * (1 - a4 / r4);
            }
            return o3;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const e4 of this._controls) e4.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, false), window.removeEventListener("orientationchange", this._onWindowResize, false), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.removeEventListener("online", this._onWindowOnline, false), window.removeEventListener("visibilitychange", this._onVisibilityChange, false);
            const t4 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            t4 && t4.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), e3.dr(this.painter.context.gl), e3.ds.remove(), e3.dt.remove(), this._removed = true, this.fire(new e3.b("remove"));
          }
          triggerRepaint() {
            this._triggerFrame(true);
          }
          _triggerFrame(t4) {
            this._renderNextFrame = this._renderNextFrame || t4, this.style && !this._frame && (this._frame = e3.f.frame((e4) => {
              const t5 = !!this._renderNextFrame;
              this._frame = null, this._renderNextFrame = null, t5 && this._render(e4);
            }));
          }
          _preloadTiles(t4) {
            const i4 = this.style ? this.style.getSourceCaches() : [];
            return e3.b4(i4, (e4, i5) => e4._preloadTiles(t4, i5), () => {
              this.triggerRepaint();
            }), this;
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(e4) {
            this._trackResize && this.resize({ originalEvent: e4 })._update();
          }
          _onVisibilityChange() {
            "hidden" === document.visibilityState && this._visibilityHidden++;
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(e4) {
            this._showTileBoundaries !== e4 && (this._showTileBoundaries = e4, this._tp.refreshUI(), this._update());
          }
          get showParseStatus() {
            return !!this._showParseStatus;
          }
          set showParseStatus(e4) {
            this._showParseStatus !== e4 && (this._showParseStatus = e4, this._tp.refreshUI(), this._update());
          }
          get showTerrainWireframe() {
            return !!this._showTerrainWireframe;
          }
          set showTerrainWireframe(e4) {
            this._showTerrainWireframe !== e4 && (this._showTerrainWireframe = e4, this._tp.refreshUI(), this._update());
          }
          get showLayers2DWireframe() {
            return !!this._showLayers2DWireframe;
          }
          set showLayers2DWireframe(e4) {
            this._showLayers2DWireframe !== e4 && (this._showLayers2DWireframe = e4, this._tp.refreshUI(), this._update());
          }
          get showLayers3DWireframe() {
            return !!this._showLayers3DWireframe;
          }
          set showLayers3DWireframe(e4) {
            this._showLayers3DWireframe !== e4 && (this._showLayers3DWireframe = e4, this._tp.refreshUI(), this._update());
          }
          get speedIndexTiming() {
            return !!this._speedIndexTiming;
          }
          set speedIndexTiming(e4) {
            this._speedIndexTiming !== e4 && (this._speedIndexTiming = e4, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(e4) {
            this._showPadding !== e4 && (this._showPadding = e4, this._tp.refreshUI(), this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(e4) {
            this._showCollisionBoxes !== e4 && (this._showCollisionBoxes = e4, this._tp.refreshUI(), e4 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(e4) {
            this._showOverdrawInspector !== e4 && (this._showOverdrawInspector = e4, this._tp.refreshUI(), this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(e4) {
            this._repaint !== e4 && (this._repaint = e4, this._tp.refreshUI(), this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(e4) {
            this._vertices = e4, this._update();
          }
          get showTileAABBs() {
            return !!this._showTileAABBs;
          }
          set showTileAABBs(e4) {
            this._showTileAABBs !== e4 && (this._showTileAABBs = e4, this._tp.refreshUI(), e4 && this._update());
          }
          _setCacheLimits(t4, i4) {
            e3.dv(t4, i4);
          }
          get version() {
            return e3.du;
          }
        }, NavigationControl: class {
          constructor(t4) {
            this.options = e3.e({}, da, t4), this._container = s3("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e4) => e4.preventDefault()), this.options.showZoom && (e3.a$(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e4) => {
              this._map && this._map.zoomIn({}, { originalEvent: e4 });
            }), s3("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e4) => {
              this._map && this._map.zoomOut({}, { originalEvent: e4 });
            }), s3("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e3.a$(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e4) => {
              const t5 = this._map;
              t5 && (this.options.visualizePitch ? t5.resetNorthPitch({}, { originalEvent: e4 }) : t5.resetNorth({}, { originalEvent: e4 }));
            }), this._compassIcon = s3("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          _updateZoomButtons() {
            const e4 = this._map;
            if (!e4) return;
            const t4 = e4.getZoom(), i4 = t4 === e4.getMaxZoom(), o3 = t4 === e4.getMinZoom();
            this._zoomInButton.disabled = i4, this._zoomOutButton.disabled = o3, this._zoomInButton.setAttribute("aria-disabled", i4.toString()), this._zoomOutButton.setAttribute("aria-disabled", o3.toString());
          }
          _rotateCompassArrow() {
            const e4 = this._map;
            if (!e4) return;
            const t4 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e4.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e4.transform.pitch}deg) rotateZ(${e4.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e4.transform.angle * (180 / Math.PI)}deg)`;
            e4._requestDomTask(() => {
              this._compassIcon && (this._compassIcon.style.transform = t4);
            });
          }
          onAdd(e4) {
            return this._map = e4, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e4.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e4.on("pitch", this._rotateCompassArrow), e4.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new _a(e4, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            const e4 = this._map;
            e4 && (this._container.remove(), this.options.showZoom && e4.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e4.off("pitch", this._rotateCompassArrow), e4.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
          }
          _createButton(e4, t4) {
            const i4 = s3("button", e4, this._container);
            return i4.type = "button", i4.addEventListener("click", t4), i4;
          }
          _setButtonTitle(e4, t4) {
            if (!this._map) return;
            const i4 = this._map._getUIString(`NavigationControl.${t4}`);
            e4.setAttribute("aria-label", i4), e4.firstElementChild && e4.firstElementChild.setAttribute("title", i4);
          }
        }, GeolocateControl: class extends e3.E {
          constructor(t4) {
            super();
            const i4 = navigator.geolocation;
            this.options = e3.e({ geolocation: i4 }, pa, t4), e3.a$(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Js(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
          }
          onAdd(e4) {
            return this._map = e4, this._container = s3("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
          }
          _checkGeolocationSupport(e4) {
            const t4 = (t5 = !!this.options.geolocation) => {
              this._supportsGeolocation = t5, e4(t5);
            };
            void 0 !== this._supportsGeolocation ? e4(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({ name: "geolocation" }).then((e5) => t4("denied" !== e5.state)).catch(() => t4()) : t4();
          }
          _isOutOfMapMaxBounds(e4) {
            const t4 = this._map.getMaxBounds(), i4 = e4.coords;
            return !!t4 && (i4.longitude < t4.getWest() || i4.longitude > t4.getEast() || i4.latitude < t4.getSouth() || i4.latitude > t4.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }
          _onSuccess(t4) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t4)) return this._setErrorState(), this.fire(new e3.b("outofmaxbounds", t4)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = t4, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
              this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t4), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t4), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e3.b("geolocate", t4)), this._finish();
            }
          }
          _updateCamera(t4) {
            const i4 = new e3.bq(t4.coords.longitude, t4.coords.latitude), o3 = t4.coords.accuracy, r4 = this._map.getBearing(), s4 = e3.e({ bearing: r4 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i4.toBounds(o3), s4, { geolocateSource: true });
          }
          _updateMarker(t4) {
            if (t4) {
              const i4 = new e3.bq(t4.coords.longitude, t4.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i4).addTo(this._map), this._userLocationDotMarker.setLngLat(i4).addTo(this._map), this._accuracy = t4.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            const t4 = this._map.transform, i4 = e3.bo(1, t4._center.lat) * t4.worldSize, o3 = Math.ceil(2 * this._accuracy * i4);
            this._circleElement.style.width = `${o3}px`, this._circleElement.style.height = `${o3}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _updateMarkerRotation() {
            this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
          }
          _onError(t4) {
            if (this._map) {
              if (this.options.trackUserLocation) if (1 === t4.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", e4), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e4), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else {
                if (3 === t4.code && this._noTimeout) return;
                this._setErrorState();
              }
              "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e3.b("error", t4)), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _setupUI(t4) {
            if (void 0 !== this._map) {
              if (this._container.addEventListener("contextmenu", (e4) => e4.preventDefault()), this._geolocateButton = s3("button", "mapboxgl-ctrl-geolocate", this._container), s3("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t4) {
                e3.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const t5 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t5), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t5);
              } else {
                const e4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.setAttribute("aria-label", e4), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e4);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = s3("div", "mapboxgl-user-location"), this._dotElement.appendChild(s3("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(s3("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new ra({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = s3("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ra({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t5) => {
                t5.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t5.originalEvent && "resize" === t5.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e3.b("trackuserlocationend")));
              });
            }
          }
          _onDeviceOrientation(e4) {
            this._userLocationDotMarker && (e4.webkitCompassHeading ? this._heading = e4.webkitCompassHeading : true === e4.absolute && (this._heading = -1 * e4.alpha), this._updateMarkerRotationThrottled());
          }
          trigger() {
            if (!this._setup) return e3.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new e3.b("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e3.b("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e3.b("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let e4;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e4 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e4 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e4), this.options.showUserHeading && this._addDeviceOrientationListener();
              }
            } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _addDeviceOrientationListener() {
            const e4 = () => {
              "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
            };
            "undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t4) => {
              "granted" === t4 && e4();
            }).catch(console.error) : e4();
          }
          _clearWatch() {
            this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: Kn, ScaleControl: class {
          constructor(t4) {
            this.options = e3.e({}, fa, t4), this._isNumberFormatSupported = function() {
              try {
                return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), true;
              } catch (e4) {
                return false;
              }
            }(), e3.a$(["_update", "_setScale", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _update() {
            const e4 = this.options.maxWidth || 100, t4 = this._map, i4 = t4._containerHeight / 2, o3 = t4._containerWidth / 2 - e4 / 2, r4 = t4.unproject([o3, i4]), s4 = t4.unproject([o3 + e4, i4]), n3 = r4.distanceTo(s4);
            if ("imperial" === this.options.unit) {
              const t5 = 3.2808 * n3;
              t5 > 5280 ? this._setScale(e4, t5 / 5280, "mile") : this._setScale(e4, t5, "foot");
            } else "nautical" === this.options.unit ? this._setScale(e4, n3 / 1852, "nautical-mile") : n3 >= 1e3 ? this._setScale(e4, n3 / 1e3, "kilometer") : this._setScale(e4, n3, "meter");
          }
          _setScale(e4, t4, i4) {
            this._map._requestDomTask(() => {
              const o3 = function(e5) {
                const t5 = Math.pow(10, `${Math.floor(e5)}`.length - 1);
                let i5 = e5 / t5;
                return i5 = i5 >= 10 ? 10 : i5 >= 5 ? 5 : i5 >= 3 ? 3 : i5 >= 2 ? 2 : i5 >= 1 ? 1 : function(e6) {
                  const t6 = Math.pow(10, Math.ceil(-Math.log(e6) / Math.LN10));
                  return Math.round(e6 * t6) / t6;
                }(i5), t5 * i5;
              }(t4), r4 = o3 / t4;
              this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i4 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i4 }).format(o3) : `${o3}&nbsp;${ma[i4]}`, this._container.style.width = e4 * r4 + "px";
            });
          }
          onAdd(e4) {
            return this._map = e4, this._language = e4.getLanguage(), this._container = s3("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e4.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("move", this._update), this._map = void 0;
          }
          _setLanguage(e4) {
            this._language = e4, this._update();
          }
          setUnit(e4) {
            this.options.unit = e4, this._update();
          }
        }, FullscreenControl: class {
          constructor(t4) {
            this._fullscreen = false, t4 && t4.container && (t4.container instanceof HTMLElement ? this._container = t4.container : e3.w("Full screen control 'container' must be a DOM element.")), e3.a$(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
          }
          onAdd(t4) {
            return this._map = t4, this._container || (this._container = this._map.getContainer()), this._controlContainer = s3("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e3.w("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
          }
          _setupUI() {
            const e4 = this._fullscreenButton = s3("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
            s3("span", "mapboxgl-ctrl-icon", e4).setAttribute("aria-hidden", "true"), e4.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const e4 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", e4), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e4);
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, Popup: class extends e3.E {
          constructor(t4) {
            super(), this.options = e3.e(Object.create(sa), t4), e3.a$(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t4 && t4.className ? t4.className.trim().split(/\s+/) : []);
          }
          addTo(t4) {
            return this._map && this.remove(), this._map = t4, this.options.closeOnClick && t4.on("preclick", this._onClose), this.options.closeOnMove && t4.on("move", this._onClose), t4.on("remove", this.remove), this._update(), t4._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t4.on("mousemove", this._onMouseEvent), t4.on("mouseup", this._onMouseEvent), t4._canvasContainer.classList.add("mapboxgl-track-pointer")) : t4.on("move", this._update), this.fire(new e3.b("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
            const t4 = this._map;
            return t4 && (t4.off("move", this._update), t4.off("move", this._onClose), t4.off("preclick", this._onClose), t4.off("click", this._onClose), t4.off("remove", this.remove), t4.off("mousemove", this._onMouseEvent), t4.off("mouseup", this._onMouseEvent), t4.off("drag", this._onMouseEvent), t4._canvasContainer && t4._canvasContainer.classList.remove("mapboxgl-track-pointer"), t4._removePopup(this), this._map = void 0), this.fire(new e3.b("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t4) {
            this._lngLat = e3.bq.convert(t4), this._pos = null, this._trackPointer = false, this._update();
            const i4 = this._map;
            return i4 && (i4.on("move", this._update), i4.off("mousemove", this._onMouseEvent), i4._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }
          trackPointer() {
            this._trackPointer = true, this._pos = null, this._update();
            const e4 = this._map;
            return e4 && (e4.off("move", this._update), e4.on("mousemove", this._onMouseEvent), e4.on("drag", this._onMouseEvent), e4._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(e4) {
            return this.setDOMContent(document.createTextNode(e4));
          }
          setHTML(e4) {
            const t4 = document.createDocumentFragment(), i4 = document.createElement("body");
            let o3;
            for (i4.innerHTML = e4; o3 = i4.firstChild, o3; ) t4.appendChild(o3);
            return this.setDOMContent(t4);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(e4) {
            return this.options.maxWidth = e4, this._update(), this;
          }
          setDOMContent(e4) {
            let t4 = this._content;
            if (t4) for (; t4.hasChildNodes(); ) t4.firstChild && t4.removeChild(t4.firstChild);
            else t4 = this._content = s3("div", "mapboxgl-popup-content", this._container || void 0);
            if (t4.appendChild(e4), this.options.closeButton) {
              const e5 = this._closeButton = s3("button", "mapboxgl-popup-close-button", t4);
              e5.type = "button", e5.setAttribute("aria-label", "Close popup"), e5.setAttribute("aria-hidden", "true"), e5.innerHTML = "&#215;", e5.addEventListener("click", this._onClose);
            }
            return this._update(), this._focusFirstElement(), this;
          }
          addClassName(e4) {
            return this._classList.add(e4), this._updateClassList(), this;
          }
          removeClassName(e4) {
            return this._classList.delete(e4), this._updateClassList(), this;
          }
          setOffset(e4) {
            return this.options.offset = e4, this._update(), this;
          }
          toggleClassName(e4) {
            let t4;
            return this._classList.delete(e4) ? t4 = false : (this._classList.add(e4), t4 = true), this._updateClassList(), t4;
          }
          _onMouseEvent(e4) {
            this._update(e4.point);
          }
          _getAnchor(e4) {
            if (this.options.anchor) return this.options.anchor;
            const t4 = this._map, i4 = this._container, o3 = this._pos;
            if (!t4 || !i4 || !o3) return "bottom";
            const r4 = i4.offsetWidth, s4 = i4.offsetHeight, n3 = o3.x < r4 / 2, a4 = o3.x > t4.transform.width - r4 / 2;
            if (o3.y + e4 < s4) return n3 ? "top-left" : a4 ? "top-right" : "top";
            if (o3.y > t4.transform.height - s4) {
              if (n3) return "bottom-left";
              if (a4) return "bottom-right";
            }
            return n3 ? "left" : a4 ? "right" : "bottom";
          }
          _updateClassList() {
            const e4 = this._container;
            if (!e4) return;
            const t4 = [...this._classList];
            t4.push("mapboxgl-popup"), this._anchor && t4.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t4.push("mapboxgl-popup-track-pointer"), e4.className = t4.join(" ");
          }
          _update(t4) {
            const i4 = this._map, o3 = this._content;
            if (!i4 || !this._lngLat && !this._trackPointer || !o3) return;
            let r4 = this._container;
            if (r4 || (r4 = this._container = s3("div", "mapboxgl-popup", i4.getContainer()), this._tip = s3("div", "mapboxgl-popup-tip", r4), r4.appendChild(o3)), this.options.maxWidth && r4.style.maxWidth !== this.options.maxWidth && (r4.style.maxWidth = this.options.maxWidth), i4.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = ia(this._lngLat, this._pos, i4.transform)), !this._trackPointer || t4) {
              const e4 = this._pos = this._trackPointer && t4 ? t4 : i4.project(this._lngLat), o4 = aa(this.options.offset), r5 = this._anchor = this._getAnchor(o4.y), s4 = aa(this.options.offset, r5), n3 = e4.add(s4).round();
              i4._requestDomTask(() => {
                this._container && r5 && (this._container.style.transform = `${oa[r5]} translate(${n3.x}px,${n3.y}px)`);
              });
            }
            if (!this._marker && i4._showingGlobe()) {
              const t5 = e3.de(i4.transform, this._lngLat) ? 0 : 1;
              this._setOpacity(t5);
            }
            this._updateClassList();
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const e4 = this._container.querySelector(na);
            e4 && e4.focus();
          }
          _onClose() {
            this.remove();
          }
          _setOpacity(e4) {
            this._container && (this._container.style.opacity = `${e4}`), this._content && (this._content.style.pointerEvents = e4 ? "auto" : "none");
          }
        }, Marker: ra, Style: Ao, LngLat: e3.bq, LngLatBounds: e3.ag, Point: e3.P, MercatorCoordinate: e3.O, FreeCameraOptions: co, Evented: e3.E, config: e3.dd, prewarm: e3.dy, clearPrewarmedResources: e3.dz, get accessToken() {
          return e3.dd.ACCESS_TOKEN;
        }, set accessToken(t4) {
          e3.dd.ACCESS_TOKEN = t4;
        }, get baseApiUrl() {
          return e3.dd.API_URL;
        }, set baseApiUrl(t4) {
          e3.dd.API_URL = t4;
        }, get workerCount() {
          return e3.dA.workerCount;
        }, set workerCount(t4) {
          e3.dA.workerCount = t4;
        }, get maxParallelImageRequests() {
          return e3.dd.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(t4) {
          e3.dd.MAX_PARALLEL_IMAGE_REQUESTS = t4;
        }, clearStorage(t4) {
          e3.dB(t4);
        }, get workerUrl() {
          return e3.dC.workerUrl;
        }, set workerUrl(t4) {
          e3.dC.workerUrl = t4;
        }, get workerClass() {
          return e3.dC.workerClass;
        }, set workerClass(t4) {
          e3.dC.workerClass = t4;
        }, get workerParams() {
          return e3.dC.workerParams;
        }, set workerParams(t4) {
          e3.dC.workerParams = t4;
        }, get dracoUrl() {
          return e3.dD();
        }, set dracoUrl(t4) {
          e3.dE(t4);
        }, get meshoptUrl() {
          return e3.dF();
        }, set meshoptUrl(t4) {
          e3.dG(t4);
        }, setNow: e3.f.setNow, restoreNow: e3.f.restoreNow };
        return ga;
      });
      var mapboxgl$1 = mapboxgl2;
      return mapboxgl$1;
    });
  }
});

// node_modules/@angular/core/fesm2022/primitives/signals.mjs
function defaultEquals(a3, b3) {
  return Object.is(a3, b3);
}
var activeConsumer = null;
var inNotificationPhase = false;
var epoch = 1;
var SIGNAL = /* @__PURE__ */ Symbol("SIGNAL");
function setActiveConsumer(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
function getActiveConsumer() {
  return activeConsumer;
}
var REACTIVE_NODE = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: false,
  producerNode: void 0,
  producerLastReadVersion: void 0,
  producerIndexOfThis: void 0,
  nextProducerIndex: 0,
  liveConsumerNode: void 0,
  liveConsumerIndexOfThis: void 0,
  consumerAllowSignalWrites: false,
  consumerIsAlwaysLive: false,
  producerMustRecompute: () => false,
  producerRecomputeValue: () => {
  },
  consumerMarkedDirty: () => {
  },
  consumerOnSignalRead: () => {
  }
};
function producerAccessed(node) {
  if (inNotificationPhase) {
    throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? `Assertion error: signal read during notification phase` : "");
  }
  if (activeConsumer === null) {
    return;
  }
  activeConsumer.consumerOnSignalRead(node);
  const idx = activeConsumer.nextProducerIndex++;
  assertConsumerNode(activeConsumer);
  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {
    if (consumerIsLive(activeConsumer)) {
      const staleProducer = activeConsumer.producerNode[idx];
      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);
    }
  }
  if (activeConsumer.producerNode[idx] !== node) {
    activeConsumer.producerNode[idx] = node;
    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;
  }
  activeConsumer.producerLastReadVersion[idx] = node.version;
}
function producerIncrementEpoch() {
  epoch++;
}
function producerUpdateValueVersion(node) {
  if (consumerIsLive(node) && !node.dirty) {
    return;
  }
  if (!node.dirty && node.lastCleanEpoch === epoch) {
    return;
  }
  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
    node.dirty = false;
    node.lastCleanEpoch = epoch;
    return;
  }
  node.producerRecomputeValue(node);
  node.dirty = false;
  node.lastCleanEpoch = epoch;
}
function producerNotifyConsumers(node) {
  if (node.liveConsumerNode === void 0) {
    return;
  }
  const prev = inNotificationPhase;
  inNotificationPhase = true;
  try {
    for (const consumer of node.liveConsumerNode) {
      if (!consumer.dirty) {
        consumerMarkDirty(consumer);
      }
    }
  } finally {
    inNotificationPhase = prev;
  }
}
function producerUpdatesAllowed() {
  return activeConsumer?.consumerAllowSignalWrites !== false;
}
function consumerMarkDirty(node) {
  node.dirty = true;
  producerNotifyConsumers(node);
  node.consumerMarkedDirty?.(node);
}
function consumerBeforeComputation(node) {
  node && (node.nextProducerIndex = 0);
  return setActiveConsumer(node);
}
function consumerAfterComputation(node, prevConsumer) {
  setActiveConsumer(prevConsumer);
  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {
    return;
  }
  if (consumerIsLive(node)) {
    for (let i3 = node.nextProducerIndex; i3 < node.producerNode.length; i3++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i3], node.producerIndexOfThis[i3]);
    }
  }
  while (node.producerNode.length > node.nextProducerIndex) {
    node.producerNode.pop();
    node.producerLastReadVersion.pop();
    node.producerIndexOfThis.pop();
  }
}
function consumerPollProducersForChange(node) {
  assertConsumerNode(node);
  for (let i3 = 0; i3 < node.producerNode.length; i3++) {
    const producer = node.producerNode[i3];
    const seenVersion = node.producerLastReadVersion[i3];
    if (seenVersion !== producer.version) {
      return true;
    }
    producerUpdateValueVersion(producer);
    if (seenVersion !== producer.version) {
      return true;
    }
  }
  return false;
}
function consumerDestroy(node) {
  assertConsumerNode(node);
  if (consumerIsLive(node)) {
    for (let i3 = 0; i3 < node.producerNode.length; i3++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i3], node.producerIndexOfThis[i3]);
    }
  }
  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;
  if (node.liveConsumerNode) {
    node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;
  }
}
function producerAddLiveConsumer(node, consumer, indexOfThis) {
  assertProducerNode(node);
  assertConsumerNode(node);
  if (node.liveConsumerNode.length === 0) {
    for (let i3 = 0; i3 < node.producerNode.length; i3++) {
      node.producerIndexOfThis[i3] = producerAddLiveConsumer(node.producerNode[i3], node, i3);
    }
  }
  node.liveConsumerIndexOfThis.push(indexOfThis);
  return node.liveConsumerNode.push(consumer) - 1;
}
function producerRemoveLiveConsumerAtIndex(node, idx) {
  assertProducerNode(node);
  assertConsumerNode(node);
  if (typeof ngDevMode !== "undefined" && ngDevMode && idx >= node.liveConsumerNode.length) {
    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);
  }
  if (node.liveConsumerNode.length === 1) {
    for (let i3 = 0; i3 < node.producerNode.length; i3++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i3], node.producerIndexOfThis[i3]);
    }
  }
  const lastIdx = node.liveConsumerNode.length - 1;
  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];
  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];
  node.liveConsumerNode.length--;
  node.liveConsumerIndexOfThis.length--;
  if (idx < node.liveConsumerNode.length) {
    const idxProducer = node.liveConsumerIndexOfThis[idx];
    const consumer = node.liveConsumerNode[idx];
    assertConsumerNode(consumer);
    consumer.producerIndexOfThis[idxProducer] = idx;
  }
}
function consumerIsLive(node) {
  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;
}
function assertConsumerNode(node) {
  node.producerNode ??= [];
  node.producerIndexOfThis ??= [];
  node.producerLastReadVersion ??= [];
}
function assertProducerNode(node) {
  node.liveConsumerNode ??= [];
  node.liveConsumerIndexOfThis ??= [];
}
function createComputed(computation) {
  const node = Object.create(COMPUTED_NODE);
  node.computation = computation;
  const computed = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  computed[SIGNAL] = node;
  return computed;
}
var UNSET = /* @__PURE__ */ Symbol("UNSET");
var COMPUTING = /* @__PURE__ */ Symbol("COMPUTING");
var ERRORED = /* @__PURE__ */ Symbol("ERRORED");
var COMPUTED_NODE = /* @__PURE__ */ (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
    value: UNSET,
    dirty: true,
    error: null,
    equal: defaultEquals,
    producerMustRecompute(node) {
      return node.value === UNSET || node.value === COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === COMPUTING) {
        throw new Error("Detected cycle in computations.");
      }
      const oldValue = node.value;
      node.value = COMPUTING;
      const prevConsumer = consumerBeforeComputation(node);
      let newValue;
      try {
        newValue = node.computation();
      } catch (err) {
        newValue = ERRORED;
        node.error = err;
      } finally {
        consumerAfterComputation(node, prevConsumer);
      }
      if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue)) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  });
})();
function defaultThrowError() {
  throw new Error();
}
var throwInvalidWriteToSignalErrorFn = defaultThrowError;
function throwInvalidWriteToSignalError() {
  throwInvalidWriteToSignalErrorFn();
}
function setThrowInvalidWriteToSignalError(fn) {
  throwInvalidWriteToSignalErrorFn = fn;
}
var postSignalSetFn = null;
function createSignal(initialValue) {
  const node = Object.create(SIGNAL_NODE);
  node.value = initialValue;
  const getter = () => {
    producerAccessed(node);
    return node.value;
  };
  getter[SIGNAL] = node;
  return getter;
}
function signalSetFn(node, newValue) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError();
  }
  if (!node.equal(node.value, newValue)) {
    node.value = newValue;
    signalValueChanged(node);
  }
}
function signalUpdateFn(node, updater) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError();
  }
  signalSetFn(node, updater(node.value));
}
var SIGNAL_NODE = /* @__PURE__ */ (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
    equal: defaultEquals,
    value: void 0
  });
})();
function signalValueChanged(node) {
  node.version++;
  producerIncrementEpoch();
  producerNotifyConsumers(node);
  postSignalSetFn?.();
}

// node_modules/rxjs/dist/esm/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  const _super = (instance) => {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  const ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {
  _super(this);
  this.message = errors ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i3) => `${i3 + 1}) ${err.toString()}`).join("\n  ")}` : "";
  this.name = "UnsubscriptionError";
  this.errors = errors;
});

// node_modules/rxjs/dist/esm/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    const index3 = arr.indexOf(item);
    0 <= index3 && arr.splice(index3, 1);
  }
}

// node_modules/rxjs/dist/esm/internal/Subscription.js
var Subscription = class _Subscription {
  constructor(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  unsubscribe() {
    let errors;
    if (!this.closed) {
      this.closed = true;
      const { _parentage } = this;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          for (const parent2 of _parentage) {
            parent2.remove(this);
          }
        } else {
          _parentage.remove(this);
        }
      }
      const { initialTeardown: initialFinalizer } = this;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e3) {
          errors = e3 instanceof UnsubscriptionError ? e3.errors : [e3];
        }
      }
      const { _finalizers } = this;
      if (_finalizers) {
        this._finalizers = null;
        for (const finalizer of _finalizers) {
          try {
            execFinalizer(finalizer);
          } catch (err) {
            errors = errors !== null && errors !== void 0 ? errors : [];
            if (err instanceof UnsubscriptionError) {
              errors = [...errors, ...err.errors];
            } else {
              errors.push(err);
            }
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  }
  add(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof _Subscription) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  }
  _hasParent(parent2) {
    const { _parentage } = this;
    return _parentage === parent2 || Array.isArray(_parentage) && _parentage.includes(parent2);
  }
  _addParent(parent2) {
    const { _parentage } = this;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent2), _parentage) : _parentage ? [_parentage, parent2] : parent2;
  }
  _removeParent(parent2) {
    const { _parentage } = this;
    if (_parentage === parent2) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent2);
    }
  }
  remove(teardown) {
    const { _finalizers } = this;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof _Subscription) {
      teardown._removeParent(this);
    }
  }
};
Subscription.EMPTY = (() => {
  const empty = new Subscription();
  empty.closed = true;
  return empty;
})();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout(handler, timeout, ...args) {
    const { delegate } = timeoutProvider;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout(handler, timeout, ...args);
    }
    return setTimeout(handler, timeout, ...args);
  },
  clearTimeout(handle) {
    const { delegate } = timeoutProvider;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(() => {
    const { onUnhandledError } = config;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = (() => createNotification("C", void 0, void 0))();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    const isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      const { errorThrown, error } = context;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm/internal/Subscriber.js
var Subscriber = class extends Subscription {
  constructor(destination) {
    super();
    this.isStopped = false;
    if (destination) {
      this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(this);
      }
    } else {
      this.destination = EMPTY_OBSERVER;
    }
  }
  static create(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  }
  next(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  }
  error(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  }
  complete() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  }
  unsubscribe() {
    if (!this.closed) {
      this.isStopped = true;
      super.unsubscribe();
      this.destination = null;
    }
  }
  _next(value) {
    this.destination.next(value);
  }
  _error(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  }
  _complete() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }
};
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = class {
  constructor(partialObserver) {
    this.partialObserver = partialObserver;
  }
  next(value) {
    const { partialObserver } = this;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  }
  error(err) {
    const { partialObserver } = this;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  }
  complete() {
    const { partialObserver } = this;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  }
};
var SafeSubscriber = class extends Subscriber {
  constructor(observerOrNext, error, complete) {
    super();
    let partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      let context2;
      if (this && config.useDeprecatedNextContext) {
        context2 = Object.create(observerOrNext);
        context2.unsubscribe = () => this.unsubscribe();
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context2),
          error: observerOrNext.error && bind(observerOrNext.error, context2),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context2)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    this.destination = new ConsumerObserver(partialObserver);
  }
};
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  const { onStoppedNotification } = config;
  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm/internal/symbol/observable.js
var observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();

// node_modules/rxjs/dist/esm/internal/util/identity.js
function identity(x4) {
  return x4;
}

// node_modules/rxjs/dist/esm/internal/util/pipe.js
function pipe(...fns) {
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input2) {
    return fns.reduce((prev, fn) => fn(prev), input2);
  };
}

// node_modules/rxjs/dist/esm/internal/Observable.js
var Observable = class _Observable {
  constructor(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  lift(operator) {
    const observable2 = new _Observable();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  }
  subscribe(observerOrNext, error, complete) {
    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(() => {
      const { operator, source } = this;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));
    });
    return subscriber;
  }
  _trySubscribe(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  }
  forEach(next, promiseCtor) {
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor((resolve, reject) => {
      const subscriber = new SafeSubscriber({
        next: (value) => {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      this.subscribe(subscriber);
    });
  }
  _subscribe(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  }
  [observable]() {
    return this;
  }
  pipe(...operations) {
    return pipeFromArray(operations)(this);
  }
  toPromise(promiseCtor) {
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor((resolve, reject) => {
      let value;
      this.subscribe((x4) => value = x4, (err) => reject(err), () => resolve(value));
    });
  }
};
Observable.create = (subscribe) => {
  return new Observable(subscribe);
};
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return (source) => {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = class extends Subscriber {
  constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    super(destination);
    this.onFinalize = onFinalize;
    this.shouldUnsubscribe = shouldUnsubscribe;
    this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : super._next;
    this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : super._error;
    this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : super._complete;
  }
  unsubscribe() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      const { closed } = this;
      super.unsubscribe();
      !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  }
};

// node_modules/rxjs/dist/esm/internal/operators/refCount.js
function refCount() {
  return operate((source, subscriber) => {
    let connection = null;
    source._refCount++;
    const refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, () => {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      const sharedConnection = source._connection;
      const conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm/internal/observable/ConnectableObservable.js
var ConnectableObservable = class extends Observable {
  constructor(source, subjectFactory) {
    super();
    this.source = source;
    this.subjectFactory = subjectFactory;
    this._subject = null;
    this._refCount = 0;
    this._connection = null;
    if (hasLift(source)) {
      this.lift = source.lift;
    }
  }
  _subscribe(subscriber) {
    return this.getSubject().subscribe(subscriber);
  }
  getSubject() {
    const subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  }
  _teardown() {
    this._refCount = 0;
    const { _connection } = this;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  }
  connect() {
    let connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      const subject = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject, void 0, () => {
        this._teardown();
        subject.complete();
      }, (err) => {
        this._teardown();
        subject.error(err);
      }, () => this._teardown())));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  }
  refCount() {
    return refCount()(this);
  }
};

// node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {
  _super(this);
  this.name = "ObjectUnsubscribedError";
  this.message = "object unsubscribed";
});

// node_modules/rxjs/dist/esm/internal/Subject.js
var Subject = class extends Observable {
  constructor() {
    super();
    this.closed = false;
    this.currentObservers = null;
    this.observers = [];
    this.isStopped = false;
    this.hasError = false;
    this.thrownError = null;
  }
  lift(operator) {
    const subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  }
  _throwIfClosed() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  }
  next(value) {
    errorContext(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        if (!this.currentObservers) {
          this.currentObservers = Array.from(this.observers);
        }
        for (const observer of this.currentObservers) {
          observer.next(value);
        }
      }
    });
  }
  error(err) {
    errorContext(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        this.hasError = this.isStopped = true;
        this.thrownError = err;
        const { observers } = this;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  }
  complete() {
    errorContext(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        this.isStopped = true;
        const { observers } = this;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  }
  unsubscribe() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  }
  get observed() {
    var _a;
    return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
  }
  _trySubscribe(subscriber) {
    this._throwIfClosed();
    return super._trySubscribe(subscriber);
  }
  _subscribe(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  }
  _innerSubscribe(subscriber) {
    const { hasError, isStopped, observers } = this;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(() => {
      this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  }
  _checkFinalizedStatuses(subscriber) {
    const { hasError, thrownError, isStopped } = this;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  }
  asObservable() {
    const observable2 = new Observable();
    observable2.source = this;
    return observable2;
  }
};
Subject.create = (destination, source) => {
  return new AnonymousSubject(destination, source);
};
var AnonymousSubject = class extends Subject {
  constructor(destination, source) {
    super();
    this.destination = destination;
    this.source = source;
  }
  next(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  }
  error(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  }
  complete() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  _subscribe(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  }
};

// node_modules/rxjs/dist/esm/internal/BehaviorSubject.js
var BehaviorSubject = class extends Subject {
  constructor(_value) {
    super();
    this._value = _value;
  }
  get value() {
    return this.getValue();
  }
  _subscribe(subscriber) {
    const subscription = super._subscribe(subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  }
  getValue() {
    const { hasError, thrownError, _value } = this;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  }
  next(value) {
    super.next(this._value = value);
  }
};

// node_modules/rxjs/dist/esm/internal/observable/empty.js
var EMPTY = new Observable((subscriber) => subscriber.complete());

// node_modules/rxjs/dist/esm/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i3 = 0;
  if (m3) return m3.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i3 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i3++], done: !o2 };
    }
  };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v3) {
  return this instanceof __await ? (this.v = v3, this) : new __await(v3);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g4 = generator.apply(thisArg, _arguments || []), i3, q3 = [];
  return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3;
  function verb(n2) {
    if (g4[n2]) i3[n2] = function(v3) {
      return new Promise(function(a3, b3) {
        q3.push([n2, v3, a3, b3]) > 1 || resume(n2, v3);
      });
    };
  }
  function resume(n2, v3) {
    try {
      step(g4[n2](v3));
    } catch (e3) {
      settle(q3[0][3], e3);
    }
  }
  function step(r3) {
    r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q3[0][2], r3);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f3, v3) {
    if (f3(v3), q3.shift(), q3.length) resume(q3[0][0], q3[0][1]);
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o2[Symbol.asyncIterator], i3;
  return m3 ? m3.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3);
  function verb(n2) {
    i3[n2] = o2[n2] && function(v3) {
      return new Promise(function(resolve, reject) {
        v3 = o2[n2](v3), settle(resolve, reject, v3.done, v3.value);
      });
    };
  }
  function settle(resolve, reject, d2, v3) {
    Promise.resolve(v3).then(function(v4) {
      resolve({ value: v4, done: d2 });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm/internal/util/isArrayLike.js
var isArrayLike = (x4) => x4 && typeof x4.length === "number" && typeof x4 !== "function";

// node_modules/rxjs/dist/esm/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js
function isInteropObservable(input2) {
  return isFunction(input2[observable]);
}

// node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input2) {
  return new TypeError(`You provided ${input2 !== null && typeof input2 === "object" ? "an invalid object" : `'${input2}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);
}

// node_modules/rxjs/dist/esm/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm/internal/util/isIterable.js
function isIterable(input2) {
  return isFunction(input2 === null || input2 === void 0 ? void 0 : input2[iterator]);
}

// node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {
    const reader = readableStream.getReader();
    try {
      while (true) {
        const { value, done } = yield __await(reader.read());
        if (done) {
          return yield __await(void 0);
        }
        yield yield __await(value);
      }
    } finally {
      reader.releaseLock();
    }
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm/internal/observable/innerFrom.js
function innerFrom(input2) {
  if (input2 instanceof Observable) {
    return input2;
  }
  if (input2 != null) {
    if (isInteropObservable(input2)) {
      return fromInteropObservable(input2);
    }
    if (isArrayLike(input2)) {
      return fromArrayLike(input2);
    }
    if (isPromise(input2)) {
      return fromPromise(input2);
    }
    if (isAsyncIterable(input2)) {
      return fromAsyncIterable(input2);
    }
    if (isIterable(input2)) {
      return fromIterable(input2);
    }
    if (isReadableStreamLike(input2)) {
      return fromReadableStreamLike(input2);
    }
  }
  throw createInvalidObservableTypeError(input2);
}
function fromInteropObservable(obj) {
  return new Observable((subscriber) => {
    const obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable((subscriber) => {
    for (let i3 = 0; i3 < array.length && !subscriber.closed; i3++) {
      subscriber.next(array[i3]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable((subscriber) => {
    promise.then((value) => {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, (err) => subscriber.error(err)).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable((subscriber) => {
    for (const value of iterable) {
      subscriber.next(value);
      if (subscriber.closed) {
        return;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable((subscriber) => {
    process2(asyncIterable, subscriber).catch((err) => subscriber.error(err));
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_1, _a;
  return __awaiter(this, void 0, void 0, function* () {
    try {
      for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done; ) {
        const value = asyncIterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)) yield _a.call(asyncIterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}

// node_modules/rxjs/dist/esm/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {
  const scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm/internal/operators/observeOn.js
function observeOn(scheduler, delay = 0) {
  return operate((source, subscriber) => {
    source.subscribe(createOperatorSubscriber(subscriber, (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay), () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay), (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay = 0) {
  return operate((source, subscriber) => {
    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js
function scheduleObservable(input2, scheduler) {
  return innerFrom(input2).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js
function schedulePromise(input2, scheduler) {
  return innerFrom(input2).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js
function scheduleArray(input2, scheduler) {
  return new Observable((subscriber) => {
    let i3 = 0;
    return scheduler.schedule(function() {
      if (i3 === input2.length) {
        subscriber.complete();
      } else {
        subscriber.next(input2[i3++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js
function scheduleIterable(input2, scheduler) {
  return new Observable((subscriber) => {
    let iterator2;
    executeSchedule(subscriber, scheduler, () => {
      iterator2 = input2[iterator]();
      executeSchedule(subscriber, scheduler, () => {
        let value;
        let done;
        try {
          ({ value, done } = iterator2.next());
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return () => isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input2, scheduler) {
  if (!input2) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable((subscriber) => {
    executeSchedule(subscriber, scheduler, () => {
      const iterator2 = input2[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, () => {
        iterator2.next().then((result) => {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input2, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input2), scheduler);
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js
function scheduled(input2, scheduler) {
  if (input2 != null) {
    if (isInteropObservable(input2)) {
      return scheduleObservable(input2, scheduler);
    }
    if (isArrayLike(input2)) {
      return scheduleArray(input2, scheduler);
    }
    if (isPromise(input2)) {
      return schedulePromise(input2, scheduler);
    }
    if (isAsyncIterable(input2)) {
      return scheduleAsyncIterable(input2, scheduler);
    }
    if (isIterable(input2)) {
      return scheduleIterable(input2, scheduler);
    }
    if (isReadableStreamLike(input2)) {
      return scheduleReadableStreamLike(input2, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input2);
}

// node_modules/rxjs/dist/esm/internal/observable/from.js
function from(input2, scheduler) {
  return scheduler ? scheduled(input2, scheduler) : innerFrom(input2);
}

// node_modules/rxjs/dist/esm/internal/observable/of.js
function of(...args) {
  const scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;
  const init = (subscriber) => subscriber.error(errorFactory());
  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init, 0, subscriber) : init);
}

// node_modules/rxjs/dist/esm/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
}

// node_modules/rxjs/dist/esm/internal/util/EmptyError.js
var EmptyError = createErrorClass((_super) => function EmptyErrorImpl() {
  _super(this);
  this.name = "EmptyError";
  this.message = "no elements in sequence";
});

// node_modules/rxjs/dist/esm/internal/operators/map.js
function map(project, thisArg) {
  return operate((source, subscriber) => {
    let index3 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      subscriber.next(project.call(thisArg, value, index3++));
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js
var { isArray } = Array;
function callOrApply(fn, args) {
  return isArray(args) ? fn(...args) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map((args) => callOrApply(fn, args));
}

// node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js
var { isArray: isArray2 } = Array;
var { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    const first2 = args[0];
    if (isArray2(first2)) {
      return { args: first2, keys: null };
    }
    if (isPOJO(first2)) {
      const keys = getKeys(first2);
      return {
        args: keys.map((key) => first2[key]),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce((result, key, i3) => (result[key] = values[i3], result), {});
}

// node_modules/rxjs/dist/esm/internal/observable/combineLatest.js
function combineLatest(...args) {
  const scheduler = popScheduler(args);
  const resultSelector = popResultSelector(args);
  const { args: observables, keys } = argsArgArrayOrObject(args);
  if (observables.length === 0) {
    return from([], scheduler);
  }
  const result = new Observable(combineLatestInit(observables, scheduler, keys ? (values) => createObject(keys, values) : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform = identity) {
  return (subscriber) => {
    maybeSchedule(scheduler, () => {
      const { length } = observables;
      const values = new Array(length);
      let active = length;
      let remainingFirstValues = length;
      for (let i3 = 0; i3 < length; i3++) {
        maybeSchedule(scheduler, () => {
          const source = from(observables[i3], scheduler);
          let hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            values[i3] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, () => {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  const buffer = [];
  let active = 0;
  let index3 = 0;
  let isComplete = false;
  const checkComplete = () => {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  const outerNext = (value) => active < concurrent ? doInnerSub(value) : buffer.push(value);
  const doInnerSub = (value) => {
    expand && subscriber.next(value);
    active++;
    let innerComplete = false;
    innerFrom(project(value, index3++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, () => {
      innerComplete = true;
    }, void 0, () => {
      if (innerComplete) {
        try {
          active--;
          while (buffer.length && active < concurrent) {
            const bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));
            } else {
              doInnerSub(bufferedValue);
            }
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {
    isComplete = true;
    checkComplete();
  }));
  return () => {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent = Infinity) {
  if (isFunction(resultSelector)) {
    return mergeMap((a3, i3) => map((b3, ii) => resultSelector(a3, b3, i3, ii))(innerFrom(project(a3, i3))), concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));
}

// node_modules/rxjs/dist/esm/internal/operators/mergeAll.js
function mergeAll(concurrent = Infinity) {
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm/internal/observable/concat.js
function concat(...args) {
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable((subscriber) => {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm/internal/observable/forkJoin.js
function forkJoin(...args) {
  const resultSelector = popResultSelector(args);
  const { args: sources, keys } = argsArgArrayOrObject(args);
  const result = new Observable((subscriber) => {
    const { length } = sources;
    if (!length) {
      subscriber.complete();
      return;
    }
    const values = new Array(length);
    let remainingCompletions = length;
    let remainingEmissions = length;
    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      let hasValue = false;
      innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, (value) => {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex] = value;
      }, () => remainingCompletions--, void 0, () => {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? createObject(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}

// node_modules/rxjs/dist/esm/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate((source, subscriber) => {
    let index3 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index3++) && subscriber.next(value)));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/catchError.js
function catchError(selector) {
  return operate((source, subscriber) => {
    let innerSub = null;
    let syncUnsub = false;
    let handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, (err) => {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return (source, subscriber) => {
    let hasState = hasSeed;
    let state = seed;
    let index3 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      const i3 = index3++;
      state = hasState ? accumulator(state, value, i3) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && (() => {
      hasState && subscriber.next(state);
      subscriber.complete();
    })));
  };
}

// node_modules/rxjs/dist/esm/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}

// node_modules/rxjs/dist/esm/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  return operate((source, subscriber) => {
    let hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      hasValue = true;
      subscriber.next(value);
    }, () => {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/take.js
function take(count) {
  return count <= 0 ? () => EMPTY : operate((source, subscriber) => {
    let seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/mapTo.js
function mapTo(value) {
  return map(() => value);
}

// node_modules/rxjs/dist/esm/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory = defaultErrorFactory) {
  return operate((source, subscriber) => {
    let hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      hasValue = true;
      subscriber.next(value);
    }, () => hasValue ? subscriber.complete() : subscriber.error(errorFactory())));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}

// node_modules/rxjs/dist/esm/internal/operators/finalize.js
function finalize(callback) {
  return operate((source, subscriber) => {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

// node_modules/rxjs/dist/esm/internal/operators/first.js
function first(predicate, defaultValue) {
  const hasDefaultValue = arguments.length >= 2;
  return (source) => source.pipe(predicate ? filter((v3, i3) => predicate(v3, i3, source)) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));
}

// node_modules/rxjs/dist/esm/internal/operators/takeLast.js
function takeLast(count) {
  return count <= 0 ? () => EMPTY : operate((source, subscriber) => {
    let buffer = [];
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      buffer.push(value);
      count < buffer.length && buffer.shift();
    }, () => {
      for (const value of buffer) {
        subscriber.next(value);
      }
      subscriber.complete();
    }, void 0, () => {
      buffer = null;
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/last.js
function last2(predicate, defaultValue) {
  const hasDefaultValue = arguments.length >= 2;
  return (source) => source.pipe(predicate ? filter((v3, i3) => predicate(v3, i3, source)) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));
}

// node_modules/rxjs/dist/esm/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

// node_modules/rxjs/dist/esm/internal/operators/startWith.js
function startWith(...values) {
  const scheduler = popScheduler(values);
  return operate((source, subscriber) => {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate((source, subscriber) => {
    let innerSubscriber = null;
    let index3 = 0;
    let isComplete = false;
    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      let innerIndex = 0;
      const outerIndex = index3++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {
        innerSubscriber = null;
        checkComplete();
      }));
    }, () => {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate((source, subscriber) => {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  const tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate((source, subscriber) => {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    let isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, (value) => {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, () => {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, (err) => {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, () => {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/@angular/core/fesm2022/core.mjs
var ERROR_DETAILS_PAGE_BASE_URL = "https://angular.dev/errors";
var XSS_SECURITY_URL = "https://g.co/ng/security#xss";
var RuntimeError = class extends Error {
  constructor(code, message) {
    super(formatRuntimeError(code, message));
    this.code = code;
  }
};
function formatRuntimeError(code, message) {
  const fullCode = `NG0${Math.abs(code)}`;
  let errorMessage = `${fullCode}${message ? ": " + message : ""}`;
  if (ngDevMode && code < 0) {
    const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
    const separator = addPeriodSeparator ? "." : "";
    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
  }
  return errorMessage;
}
var REQUIRED_UNSET_VALUE = /* @__PURE__ */ Symbol("InputSignalNode#UNSET");
var INPUT_SIGNAL_NODE = /* @__PURE__ */ (() => {
  return __spreadProps(__spreadValues({}, SIGNAL_NODE), {
    transformFn: void 0,
    applyValueToInputSignal(node, value) {
      signalSetFn(node, value);
    }
  });
})();
function createInputSignal(initialValue, options) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  node.value = initialValue;
  node.transformFn = options?.transform;
  function inputValueFn() {
    producerAccessed(node);
    if (node.value === REQUIRED_UNSET_VALUE) {
      throw new RuntimeError(-950, ngDevMode && "Input is required but no value is available yet.");
    }
    return node.value;
  }
  inputValueFn[SIGNAL] = node;
  if (ngDevMode) {
    inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;
  }
  return inputValueFn;
}
function noSideEffects(fn) {
  return { toString: fn }.toString();
}
var ANNOTATIONS = "__annotations__";
var PARAMETERS = "__parameters__";
var PROP_METADATA = "__prop__metadata__";
function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, ...args);
        return this;
      }
      const annotationInstance = new DecoratorFactory(...args);
      return function TypeDecorator(cls) {
        if (typeFn)
          typeFn(cls, ...args);
        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
        annotations.push(annotationInstance);
        if (additionalProcessing)
          additionalProcessing(cls);
        return cls;
      };
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
  });
}
function makeMetadataCtor(props) {
  return function ctor(...args) {
    if (props) {
      const values = props(...args);
      for (const propName in values) {
        this[propName] = values[propName];
      }
    }
  };
}
function makeParamDecorator(name, props, parentClass) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const annotationInstance = new ParamDecoratorFactory(...args);
      ParamDecorator.annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index3) {
        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
        while (parameters.length <= index3) {
          parameters.push(null);
        }
        (parameters[index3] = parameters[index3] || []).push(annotationInstance);
        return cls;
      }
    }
    if (parentClass) {
      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  });
}
function makePropDecorator(name, props, parentClass, additionalProcessing) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const decoratorInstance = new PropDecoratorFactory(...args);
      function PropDecorator(target, name2) {
        if (target === void 0) {
          throw new Error("Standard Angular field decorators are not supported in JIT mode.");
        }
        const constructor = target.constructor;
        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
        meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
        meta[name2].unshift(decoratorInstance);
        if (additionalProcessing)
          additionalProcessing(target, name2, ...args);
      }
      return PropDecorator;
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  });
}
var _global = globalThis;
function ngDevModeResetPerfCounters() {
  const locationString = typeof location !== "undefined" ? location.toString() : "";
  const newCounters = {
    namedConstructors: locationString.indexOf("ngDevMode=namedConstructors") != -1,
    firstCreatePass: 0,
    tNode: 0,
    tView: 0,
    rendererCreateTextNode: 0,
    rendererSetText: 0,
    rendererCreateElement: 0,
    rendererAddEventListener: 0,
    rendererSetAttribute: 0,
    rendererRemoveAttribute: 0,
    rendererSetProperty: 0,
    rendererSetClassName: 0,
    rendererAddClass: 0,
    rendererRemoveClass: 0,
    rendererSetStyle: 0,
    rendererRemoveStyle: 0,
    rendererDestroy: 0,
    rendererDestroyNode: 0,
    rendererMoveNode: 0,
    rendererRemoveNode: 0,
    rendererAppendChild: 0,
    rendererInsertBefore: 0,
    rendererCreateComment: 0,
    hydratedNodes: 0,
    hydratedComponents: 0,
    dehydratedViewsRemoved: 0,
    dehydratedViewsCleanupRuns: 0,
    componentsSkippedHydration: 0
  };
  const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
  if (!allowNgDevModeTrue) {
    _global["ngDevMode"] = false;
  } else {
    if (typeof _global["ngDevMode"] !== "object") {
      _global["ngDevMode"] = {};
    }
    Object.assign(_global["ngDevMode"], newCounters);
  }
  return newCounters;
}
function initNgDevMode() {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (typeof ngDevMode !== "object" || Object.keys(ngDevMode).length === 0) {
      ngDevModeResetPerfCounters();
    }
    return typeof ngDevMode !== "undefined" && !!ngDevMode;
  }
  return false;
}
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (let key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error("Could not find renamed property on target object.");
}
function fillProperties(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function stringify(token) {
  if (typeof token === "string") {
    return token;
  }
  if (Array.isArray(token)) {
    return "[" + token.map(stringify).join(", ") + "]";
  }
  if (token == null) {
    return "" + token;
  }
  if (token.overriddenName) {
    return `${token.overriddenName}`;
  }
  if (token.name) {
    return `${token.name}`;
  }
  const res = token.toString();
  if (res == null) {
    return "" + res;
  }
  const newLineIndex = res.indexOf("\n");
  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}
function concatStringsWithSpace(before, after) {
  return before == null || before === "" ? after === null ? "" : after : after == null || after === "" ? before : before + " " + after;
}
var __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function() {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type) {
  return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn) {
  return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}
function assertNumber(actual, msg) {
  if (!(typeof actual === "number")) {
    throwError2(msg, typeof actual, "number", "===");
  }
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
  assertNumber(actual, "Expected a number");
  assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
  assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
}
function assertString(actual, msg) {
  if (!(typeof actual === "string")) {
    throwError2(msg, actual === null ? "null" : typeof actual, "string", "===");
  }
}
function assertFunction(actual, msg) {
  if (!(typeof actual === "function")) {
    throwError2(msg, actual === null ? "null" : typeof actual, "function", "===");
  }
}
function assertEqual(actual, expected, msg) {
  if (!(actual == expected)) {
    throwError2(msg, actual, expected, "==");
  }
}
function assertNotEqual(actual, expected, msg) {
  if (!(actual != expected)) {
    throwError2(msg, actual, expected, "!=");
  }
}
function assertSame(actual, expected, msg) {
  if (!(actual === expected)) {
    throwError2(msg, actual, expected, "===");
  }
}
function assertNotSame(actual, expected, msg) {
  if (!(actual !== expected)) {
    throwError2(msg, actual, expected, "!==");
  }
}
function assertLessThan(actual, expected, msg) {
  if (!(actual < expected)) {
    throwError2(msg, actual, expected, "<");
  }
}
function assertLessThanOrEqual(actual, expected, msg) {
  if (!(actual <= expected)) {
    throwError2(msg, actual, expected, "<=");
  }
}
function assertGreaterThan(actual, expected, msg) {
  if (!(actual > expected)) {
    throwError2(msg, actual, expected, ">");
  }
}
function assertGreaterThanOrEqual(actual, expected, msg) {
  if (!(actual >= expected)) {
    throwError2(msg, actual, expected, ">=");
  }
}
function assertDefined(actual, msg) {
  if (actual == null) {
    throwError2(msg, actual, null, "!=");
  }
}
function throwError2(msg, actual, expected, comparison) {
  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
  if (!(node instanceof Node)) {
    throwError2(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
  }
}
function assertElement(node) {
  if (!(node instanceof Element)) {
    throwError2(`The provided value must be an element but got ${stringify(node)}`);
  }
}
function assertIndexInRange(arr, index3) {
  assertDefined(arr, "Array must be defined.");
  const maxLen = arr.length;
  if (index3 < 0 || index3 >= maxLen) {
    throwError2(`Index expected to be less than ${maxLen} but got ${index3}`);
  }
}
function assertOneOf(value, ...validValues) {
  if (validValues.indexOf(value) !== -1)
    return true;
  throwError2(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
}
function assertNotReactive(fn) {
  if (getActiveConsumer() !== null) {
    throwError2(`${fn}() should never be called in a reactive context.`);
  }
}
function \u0275\u0275defineInjectable(opts) {
  return {
    token: opts.token,
    providedIn: opts.providedIn || null,
    factory: opts.factory,
    value: void 0
  };
}
function \u0275\u0275defineInjector(options) {
  return { providers: options.providers || [], imports: options.imports || [] };
}
function getInjectableDef(type) {
  return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);
}
function isInjectable(type) {
  return getInjectableDef(type) !== null;
}
function getOwnDefinition(type, field) {
  return type.hasOwnProperty(field) ? type[field] : null;
}
function getInheritedInjectableDef(type) {
  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
  if (def) {
    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.
This will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`);
    return def;
  } else {
    return null;
  }
}
function getInjectorDef(type) {
  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;
}
var NG_PROV_DEF = getClosureSafeProperty({ \u0275prov: getClosureSafeProperty });
var NG_INJ_DEF = getClosureSafeProperty({ \u0275inj: getClosureSafeProperty });
var NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });
var NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });
var InjectionToken = class {
  /**
   * @param _desc   Description for the token,
   *                used only for debugging purposes,
   *                it should but does not need to be unique
   * @param options Options for the token's usage, as described above
   */
  constructor(_desc, options) {
    this._desc = _desc;
    this.ngMetadataName = "InjectionToken";
    this.\u0275prov = void 0;
    if (typeof options == "number") {
      (typeof ngDevMode === "undefined" || ngDevMode) && assertLessThan(options, 0, "Only negative numbers are supported here");
      this.__NG_ELEMENT_ID__ = options;
    } else if (options !== void 0) {
      this.\u0275prov = \u0275\u0275defineInjectable({
        token: this,
        providedIn: options.providedIn || "root",
        factory: options.factory
      });
    }
  }
  /**
   * @internal
   */
  get multi() {
    return this;
  }
  toString() {
    return `InjectionToken ${this._desc}`;
  }
};
var _injectorProfilerContext;
function getInjectorProfilerContext() {
  !ngDevMode && throwError2("getInjectorProfilerContext should never be called in production mode");
  return _injectorProfilerContext;
}
function setInjectorProfilerContext(context2) {
  !ngDevMode && throwError2("setInjectorProfilerContext should never be called in production mode");
  const previous = _injectorProfilerContext;
  _injectorProfilerContext = context2;
  return previous;
}
var injectorProfilerCallback = null;
var setInjectorProfiler = (injectorProfiler2) => {
  !ngDevMode && throwError2("setInjectorProfiler should never be called in production mode");
  injectorProfilerCallback = injectorProfiler2;
};
function injectorProfiler(event) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  if (injectorProfilerCallback != null) {
    injectorProfilerCallback(event);
  }
}
function emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  let token;
  if (typeof eventProvider === "function") {
    token = eventProvider;
  } else if (eventProvider instanceof InjectionToken) {
    token = eventProvider;
  } else {
    token = resolveForwardRef(eventProvider.provide);
  }
  let provider = eventProvider;
  if (eventProvider instanceof InjectionToken) {
    provider = eventProvider.\u0275prov || eventProvider;
  }
  injectorProfiler({
    type: 2,
    context: getInjectorProfilerContext(),
    providerRecord: { token, provider, isViewProvider }
  });
}
function emitInstanceCreatedByInjectorEvent(instance) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 1,
    context: getInjectorProfilerContext(),
    instance: { value: instance }
  });
}
function emitInjectEvent(token, value, flags) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 0,
    context: getInjectorProfilerContext(),
    service: { token, value, flags }
  });
}
function runInInjectorProfilerContext(injector, token, callback) {
  !ngDevMode && throwError2("runInInjectorProfilerContext should never be called in production mode");
  const prevInjectContext = setInjectorProfilerContext({ injector, token });
  try {
    callback();
  } finally {
    setInjectorProfilerContext(prevInjectContext);
  }
}
function isEnvironmentProviders(value) {
  return value && !!value.\u0275providers;
}
var NG_COMP_DEF = getClosureSafeProperty({ \u0275cmp: getClosureSafeProperty });
var NG_DIR_DEF = getClosureSafeProperty({ \u0275dir: getClosureSafeProperty });
var NG_PIPE_DEF = getClosureSafeProperty({ \u0275pipe: getClosureSafeProperty });
var NG_MOD_DEF = getClosureSafeProperty({ \u0275mod: getClosureSafeProperty });
var NG_FACTORY_DEF = getClosureSafeProperty({ \u0275fac: getClosureSafeProperty });
var NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });
var NG_ENV_ID = getClosureSafeProperty({ __NG_ENV_ID__: getClosureSafeProperty });
function renderStringify(value) {
  if (typeof value === "string")
    return value;
  if (value == null)
    return "";
  return String(value);
}
function stringifyForError(value) {
  if (typeof value === "function")
    return value.name || value.toString();
  if (typeof value === "object" && value != null && typeof value.type === "function") {
    return value.type.name || value.type.toString();
  }
  return renderStringify(value);
}
function throwCyclicDependencyError(token, path) {
  const depPath = path ? `. Dependency path: ${path.join(" > ")} > ${token}` : "";
  throw new RuntimeError(-200, ngDevMode ? `Circular dependency in DI detected for ${token}${depPath}` : token);
}
function throwMixedMultiProviderError() {
  throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers, provider) {
  if (ngModuleType && providers) {
    const providerDetail = providers.map((v3) => v3 == provider ? "?" + provider + "?" : "...");
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`);
  } else if (isEnvironmentProviders(provider)) {
    if (provider.\u0275fromNgModule) {
      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
    } else {
      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
    }
  } else {
    throw new Error("Invalid provider");
  }
}
function throwProviderNotFoundError(token, injectorName) {
  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ""}`;
  throw new RuntimeError(-201, errorMessage);
}
var InjectFlags;
(function(InjectFlags2) {
  InjectFlags2[InjectFlags2["Default"] = 0] = "Default";
  InjectFlags2[InjectFlags2["Host"] = 1] = "Host";
  InjectFlags2[InjectFlags2["Self"] = 2] = "Self";
  InjectFlags2[InjectFlags2["SkipSelf"] = 4] = "SkipSelf";
  InjectFlags2[InjectFlags2["Optional"] = 8] = "Optional";
})(InjectFlags || (InjectFlags = {}));
var _injectImplementation;
function getInjectImplementation() {
  return _injectImplementation;
}
function setInjectImplementation(impl) {
  const previous = _injectImplementation;
  _injectImplementation = impl;
  return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
  const injectableDef = getInjectableDef(token);
  if (injectableDef && injectableDef.providedIn == "root") {
    return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
  }
  if (flags & InjectFlags.Optional)
    return null;
  if (notFoundValue !== void 0)
    return notFoundValue;
  throwProviderNotFoundError(token, "Injector");
}
function assertInjectImplementationNotEqual(fn) {
  ngDevMode && assertNotEqual(_injectImplementation, fn, "Calling \u0275\u0275inject would cause infinite recursion");
}
var _THROW_IF_NOT_FOUND = {};
var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
var DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
var NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
var NG_TOKEN_PATH = "ngTokenPath";
var NEW_LINE = /\n/gm;
var NO_NEW_LINE = "\u0275";
var SOURCE = "__source";
var _currentInjector = void 0;
function getCurrentInjector() {
  return _currentInjector;
}
function setCurrentInjector(injector) {
  const former = _currentInjector;
  _currentInjector = injector;
  return former;
}
function injectInjectorOnly(token, flags = InjectFlags.Default) {
  if (_currentInjector === void 0) {
    throw new RuntimeError(-203, ngDevMode && `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
  } else if (_currentInjector === null) {
    return injectRootLimpMode(token, void 0, flags);
  } else {
    const value = _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
    ngDevMode && emitInjectEvent(token, value, flags);
    return value;
  }
}
function \u0275\u0275inject(token, flags = InjectFlags.Default) {
  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function \u0275\u0275invalidFactoryDep(index3) {
  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index3} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index3} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
}
function inject(token, flags = InjectFlags.Default) {
  return \u0275\u0275inject(token, convertToBitFlags(flags));
}
function convertToBitFlags(flags) {
  if (typeof flags === "undefined" || typeof flags === "number") {
    return flags;
  }
  return 0 | // comment to force a line break in the formatter
  (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
}
function injectArgs(types) {
  const args = [];
  for (let i3 = 0; i3 < types.length; i3++) {
    const arg = resolveForwardRef(types[i3]);
    if (Array.isArray(arg)) {
      if (arg.length === 0) {
        throw new RuntimeError(900, ngDevMode && "Arguments array must have arguments.");
      }
      let type = void 0;
      let flags = InjectFlags.Default;
      for (let j4 = 0; j4 < arg.length; j4++) {
        const meta = arg[j4];
        const flag = getInjectFlag(meta);
        if (typeof flag === "number") {
          if (flag === -1) {
            type = meta.token;
          } else {
            flags |= flag;
          }
        } else {
          type = meta;
        }
      }
      args.push(\u0275\u0275inject(type, flags));
    } else {
      args.push(\u0275\u0275inject(arg));
    }
  }
  return args;
}
function attachInjectFlag(decorator, flag) {
  decorator[DI_DECORATOR_FLAG] = flag;
  decorator.prototype[DI_DECORATOR_FLAG] = flag;
  return decorator;
}
function getInjectFlag(token) {
  return token[DI_DECORATOR_FLAG];
}
function catchInjectorError(e3, token, injectorErrorName, source) {
  const tokenPath = e3[NG_TEMP_TOKEN_PATH];
  if (token[SOURCE]) {
    tokenPath.unshift(token[SOURCE]);
  }
  e3.message = formatError("\n" + e3.message, tokenPath, injectorErrorName, source);
  e3[NG_TOKEN_PATH] = tokenPath;
  e3[NG_TEMP_TOKEN_PATH] = null;
  throw e3;
}
function formatError(text, obj, injectorErrorName, source = null) {
  text = text && text.charAt(0) === "\n" && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;
  let context2 = stringify(obj);
  if (Array.isArray(obj)) {
    context2 = obj.map(stringify).join(" -> ");
  } else if (typeof obj === "object") {
    let parts = [];
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        let value = obj[key];
        parts.push(key + ":" + (typeof value === "string" ? JSON.stringify(value) : stringify(value)));
      }
    }
    context2 = `{${parts.join(", ")}}`;
  }
  return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context2}]: ${text.replace(NEW_LINE, "\n  ")}`;
}
var Inject = attachInjectFlag(
  // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.
  makeParamDecorator("Inject", (token) => ({ token })),
  -1
  /* DecoratorFlags.Inject */
);
var Optional = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Optional"),
    8
    /* InternalInjectFlags.Optional */
  )
);
var Self = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Self"),
    2
    /* InternalInjectFlags.Self */
  )
);
var SkipSelf = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("SkipSelf"),
    4
    /* InternalInjectFlags.SkipSelf */
  )
);
var Host = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Host"),
    1
    /* InternalInjectFlags.Host */
  )
);
function getFactoryDef(type, throwNotFound) {
  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
    throw new Error(`Type ${stringify(type)} does not have '\u0275fac' property.`);
  }
  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
}
function arrayEquals(a3, b3, identityAccessor) {
  if (a3.length !== b3.length)
    return false;
  for (let i3 = 0; i3 < a3.length; i3++) {
    let valueA = a3[i3];
    let valueB = b3[i3];
    if (identityAccessor) {
      valueA = identityAccessor(valueA);
      valueB = identityAccessor(valueB);
    }
    if (valueB !== valueA) {
      return false;
    }
  }
  return true;
}
function flatten(list) {
  return list.flat(Number.POSITIVE_INFINITY);
}
function deepForEach(input2, fn) {
  input2.forEach((value) => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
}
function addToArray(arr, index3, value) {
  if (index3 >= arr.length) {
    arr.push(value);
  } else {
    arr.splice(index3, 0, value);
  }
}
function removeFromArray(arr, index3) {
  if (index3 >= arr.length - 1) {
    return arr.pop();
  } else {
    return arr.splice(index3, 1)[0];
  }
}
function newArray(size, value) {
  const list = [];
  for (let i3 = 0; i3 < size; i3++) {
    list.push(value);
  }
  return list;
}
function arraySplice(array, index3, count) {
  const length = array.length - count;
  while (index3 < length) {
    array[index3] = array[index3 + count];
    index3++;
  }
  while (count--) {
    array.pop();
  }
}
function arrayInsert2(array, index3, value1, value2) {
  ngDevMode && assertLessThanOrEqual(index3, array.length, "Can't insert past array end.");
  let end = array.length;
  if (end == index3) {
    array.push(value1, value2);
  } else if (end === 1) {
    array.push(value2, array[0]);
    array[0] = value1;
  } else {
    end--;
    array.push(array[end - 1], array[end]);
    while (end > index3) {
      const previousEnd = end - 2;
      array[end] = array[previousEnd];
      end--;
    }
    array[index3] = value1;
    array[index3 + 1] = value2;
  }
}
function keyValueArraySet(keyValueArray, key, value) {
  let index3 = keyValueArrayIndexOf(keyValueArray, key);
  if (index3 >= 0) {
    keyValueArray[index3 | 1] = value;
  } else {
    index3 = ~index3;
    arrayInsert2(keyValueArray, index3, key, value);
  }
  return index3;
}
function keyValueArrayGet(keyValueArray, key) {
  const index3 = keyValueArrayIndexOf(keyValueArray, key);
  if (index3 >= 0) {
    return keyValueArray[index3 | 1];
  }
  return void 0;
}
function keyValueArrayIndexOf(keyValueArray, key) {
  return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array, value, shift) {
  ngDevMode && assertEqual(Array.isArray(array), true, "Expecting an array");
  let start = 0;
  let end = array.length >> shift;
  while (end !== start) {
    const middle = start + (end - start >> 1);
    const current = array[middle << shift];
    if (value === current) {
      return middle << shift;
    } else if (current > value) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }
  return ~(end << shift);
}
var EMPTY_OBJ = {};
var EMPTY_ARRAY = [];
if ((typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode()) {
  Object.freeze(EMPTY_OBJ);
  Object.freeze(EMPTY_ARRAY);
}
var ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? "ENVIRONMENT_INITIALIZER" : "");
var INJECTOR$1 = new InjectionToken(
  ngDevMode ? "INJECTOR" : "",
  // Disable tslint because this is const enum which gets inlined not top level prop access.
  // tslint:disable-next-line: no-toplevel-property-access
  -1
  /* InjectorMarkers.Injector */
);
var INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? "INJECTOR_DEF_TYPES" : "");
var NullInjector = class {
  get(token, notFoundValue = THROW_IF_NOT_FOUND) {
    if (notFoundValue === THROW_IF_NOT_FOUND) {
      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
      error.name = "NullInjectorError";
      throw error;
    }
    return notFoundValue;
  }
};
var ChangeDetectionStrategy;
(function(ChangeDetectionStrategy2) {
  ChangeDetectionStrategy2[ChangeDetectionStrategy2["OnPush"] = 0] = "OnPush";
  ChangeDetectionStrategy2[ChangeDetectionStrategy2["Default"] = 1] = "Default";
})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
var ViewEncapsulation$1;
(function(ViewEncapsulation2) {
  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
var InputFlags;
(function(InputFlags2) {
  InputFlags2[InputFlags2["None"] = 0] = "None";
  InputFlags2[InputFlags2["SignalBased"] = 1] = "SignalBased";
  InputFlags2[InputFlags2["HasDecoratorInputTransform"] = 2] = "HasDecoratorInputTransform";
})(InputFlags || (InputFlags = {}));
function classIndexOf(className, classToSearch, startingIndex) {
  ngDevMode && assertNotEqual(classToSearch, "", 'can not look for "" string.');
  let end = className.length;
  while (true) {
    const foundIndex = className.indexOf(classToSearch, startingIndex);
    if (foundIndex === -1)
      return foundIndex;
    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
      const length = classToSearch.length;
      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
        return foundIndex;
      }
    }
    startingIndex = foundIndex + 1;
  }
}
function setUpAttributes(renderer, native, attrs) {
  let i3 = 0;
  while (i3 < attrs.length) {
    const value = attrs[i3];
    if (typeof value === "number") {
      if (value !== 0) {
        break;
      }
      i3++;
      const namespaceURI = attrs[i3++];
      const attrName = attrs[i3++];
      const attrVal = attrs[i3++];
      ngDevMode && ngDevMode.rendererSetAttribute++;
      renderer.setAttribute(native, attrName, attrVal, namespaceURI);
    } else {
      const attrName = value;
      const attrVal = attrs[++i3];
      ngDevMode && ngDevMode.rendererSetAttribute++;
      if (isAnimationProp(attrName)) {
        renderer.setProperty(native, attrName, attrVal);
      } else {
        renderer.setAttribute(native, attrName, attrVal);
      }
      i3++;
    }
  }
  return i3;
}
function isNameOnlyAttributeMarker(marker) {
  return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name) {
  return name.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
  if (src === null || src.length === 0) {
  } else if (dst === null || dst.length === 0) {
    dst = src.slice();
  } else {
    let srcMarker = -1;
    for (let i3 = 0; i3 < src.length; i3++) {
      const item = src[i3];
      if (typeof item === "number") {
        srcMarker = item;
      } else {
        if (srcMarker === 0) {
        } else if (srcMarker === -1 || srcMarker === 2) {
          mergeHostAttribute(dst, srcMarker, item, null, src[++i3]);
        } else {
          mergeHostAttribute(dst, srcMarker, item, null, null);
        }
      }
    }
  }
  return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value) {
  let i3 = 0;
  let markerInsertPosition = dst.length;
  if (marker === -1) {
    markerInsertPosition = -1;
  } else {
    while (i3 < dst.length) {
      const dstValue = dst[i3++];
      if (typeof dstValue === "number") {
        if (dstValue === marker) {
          markerInsertPosition = -1;
          break;
        } else if (dstValue > marker) {
          markerInsertPosition = i3 - 1;
          break;
        }
      }
    }
  }
  while (i3 < dst.length) {
    const item = dst[i3];
    if (typeof item === "number") {
      break;
    } else if (item === key1) {
      if (key2 === null) {
        if (value !== null) {
          dst[i3 + 1] = value;
        }
        return;
      } else if (key2 === dst[i3 + 1]) {
        dst[i3 + 2] = value;
        return;
      }
    }
    i3++;
    if (key2 !== null)
      i3++;
    if (value !== null)
      i3++;
  }
  if (markerInsertPosition !== -1) {
    dst.splice(markerInsertPosition, 0, marker);
    i3 = markerInsertPosition + 1;
  }
  dst.splice(i3++, 0, key1);
  if (key2 !== null) {
    dst.splice(i3++, 0, key2);
  }
  if (value !== null) {
    dst.splice(i3++, 0, value);
  }
}
var NG_TEMPLATE_SELECTOR = "ng-template";
function isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {
  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
  let i3 = 0;
  if (isProjectionMode) {
    for (; i3 < attrs.length && typeof attrs[i3] === "string"; i3 += 2) {
      if (attrs[i3] === "class" && classIndexOf(attrs[i3 + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {
        return true;
      }
    }
  } else if (isInlineTemplate(tNode)) {
    return false;
  }
  i3 = attrs.indexOf(1, i3);
  if (i3 > -1) {
    let item;
    while (++i3 < attrs.length && typeof (item = attrs[i3]) === "string") {
      if (item.toLowerCase() === cssClassToMatch) {
        return true;
      }
    }
  }
  return false;
}
function isInlineTemplate(tNode) {
  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
  return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
  ngDevMode && assertDefined(selector[0], "Selector should have a tag name");
  let mode = 4;
  const nodeAttrs = tNode.attrs;
  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;
  let skipToNextSelector = false;
  for (let i3 = 0; i3 < selector.length; i3++) {
    const current = selector[i3];
    if (typeof current === "number") {
      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
        return false;
      }
      if (skipToNextSelector && isPositive(current))
        continue;
      skipToNextSelector = false;
      mode = current | mode & 1;
      continue;
    }
    if (skipToNextSelector)
      continue;
    if (mode & 4) {
      mode = 2 | mode & 1;
      if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
      }
    } else if (mode & 8) {
      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
      }
    } else {
      const selectorAttrValue = selector[++i3];
      const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
      if (attrIndexInNode === -1) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
        continue;
      }
      if (selectorAttrValue !== "") {
        let nodeAttrValue;
        if (attrIndexInNode > nameOnlyMarkerIdx) {
          nodeAttrValue = "";
        } else {
          ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, "We do not match directives on namespaced attributes");
          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
        }
        if (mode & 2 && selectorAttrValue !== nodeAttrValue) {
          if (isPositive(mode))
            return false;
          skipToNextSelector = true;
        }
      }
    }
  }
  return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
  return (mode & 1) === 0;
}
function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
  if (attrs === null)
    return -1;
  let i3 = 0;
  if (isProjectionMode || !isInlineTemplate2) {
    let bindingsMode = false;
    while (i3 < attrs.length) {
      const maybeAttrName = attrs[i3];
      if (maybeAttrName === name) {
        return i3;
      } else if (maybeAttrName === 3 || maybeAttrName === 6) {
        bindingsMode = true;
      } else if (maybeAttrName === 1 || maybeAttrName === 2) {
        let value = attrs[++i3];
        while (typeof value === "string") {
          value = attrs[++i3];
        }
        continue;
      } else if (maybeAttrName === 4) {
        break;
      } else if (maybeAttrName === 0) {
        i3 += 4;
        continue;
      }
      i3 += bindingsMode ? 1 : 2;
    }
    return -1;
  } else {
    return matchTemplateAttribute(attrs, name);
  }
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
  for (let i3 = 0; i3 < selector.length; i3++) {
    if (isNodeMatchingSelector(tNode, selector[i3], isProjectionMode)) {
      return true;
    }
  }
  return false;
}
function getProjectAsAttrValue(tNode) {
  const nodeAttrs = tNode.attrs;
  if (nodeAttrs != null) {
    const ngProjectAsAttrIdx = nodeAttrs.indexOf(
      5
      /* AttributeMarker.ProjectAs */
    );
    if ((ngProjectAsAttrIdx & 1) === 0) {
      return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
  }
  return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
  for (let i3 = 0; i3 < nodeAttrs.length; i3++) {
    const nodeAttr = nodeAttrs[i3];
    if (isNameOnlyAttributeMarker(nodeAttr)) {
      return i3;
    }
  }
  return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name) {
  let i3 = attrs.indexOf(
    4
    /* AttributeMarker.Template */
  );
  if (i3 > -1) {
    i3++;
    while (i3 < attrs.length) {
      const attr = attrs[i3];
      if (typeof attr === "number")
        return -1;
      if (attr === name)
        return i3;
      i3++;
    }
  }
  return -1;
}
function isSelectorInSelectorList(selector, list) {
  selectorListLoop: for (let i3 = 0; i3 < list.length; i3++) {
    const currentSelectorInList = list[i3];
    if (selector.length !== currentSelectorInList.length) {
      continue;
    }
    for (let j4 = 0; j4 < selector.length; j4++) {
      if (selector[j4] !== currentSelectorInList[j4]) {
        continue selectorListLoop;
      }
    }
    return true;
  }
  return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
  return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
}
function stringifyCSSSelector(selector) {
  let result = selector[0];
  let i3 = 1;
  let mode = 2;
  let currentChunk = "";
  let isNegativeMode = false;
  while (i3 < selector.length) {
    let valueOrMarker = selector[i3];
    if (typeof valueOrMarker === "string") {
      if (mode & 2) {
        const attrValue = selector[++i3];
        currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
      } else if (mode & 8) {
        currentChunk += "." + valueOrMarker;
      } else if (mode & 4) {
        currentChunk += " " + valueOrMarker;
      }
    } else {
      if (currentChunk !== "" && !isPositive(valueOrMarker)) {
        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        currentChunk = "";
      }
      mode = valueOrMarker;
      isNegativeMode = isNegativeMode || !isPositive(mode);
    }
    i3++;
  }
  if (currentChunk !== "") {
    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
  }
  return result;
}
function stringifyCSSSelectorList(selectorList) {
  return selectorList.map(stringifyCSSSelector).join(",");
}
function extractAttrsAndClassesFromSelector(selector) {
  const attrs = [];
  const classes = [];
  let i3 = 1;
  let mode = 2;
  while (i3 < selector.length) {
    let valueOrMarker = selector[i3];
    if (typeof valueOrMarker === "string") {
      if (mode === 2) {
        if (valueOrMarker !== "") {
          attrs.push(valueOrMarker, selector[++i3]);
        }
      } else if (mode === 8) {
        classes.push(valueOrMarker);
      }
    } else {
      if (!isPositive(mode))
        break;
      mode = valueOrMarker;
    }
    i3++;
  }
  return { attrs, classes };
}
function \u0275\u0275defineComponent(componentDefinition) {
  return noSideEffects(() => {
    (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
    const baseDef = getNgDirectiveDef(componentDefinition);
    const def = __spreadProps(__spreadValues({}, baseDef), {
      decls: componentDefinition.decls,
      vars: componentDefinition.vars,
      template: componentDefinition.template,
      consts: componentDefinition.consts || null,
      ngContentSelectors: componentDefinition.ngContentSelectors,
      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
      directiveDefs: null,
      // assigned in noSideEffects
      pipeDefs: null,
      // assigned in noSideEffects
      dependencies: baseDef.standalone && componentDefinition.dependencies || null,
      getStandaloneInjector: null,
      signals: componentDefinition.signals ?? false,
      data: componentDefinition.data || {},
      encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
      styles: componentDefinition.styles || EMPTY_ARRAY,
      _: null,
      schemas: componentDefinition.schemas || null,
      tView: null,
      id: ""
    });
    initFeatures(def);
    const dependencies = componentDefinition.dependencies;
    def.directiveDefs = extractDefListOrFactory(
      dependencies,
      /* pipeDef */
      false
    );
    def.pipeDefs = extractDefListOrFactory(
      dependencies,
      /* pipeDef */
      true
    );
    def.id = getComponentId(def);
    return def;
  });
}
function extractDirectiveDef(type) {
  return getComponentDef(type) || getDirectiveDef(type);
}
function nonNull(value) {
  return value !== null;
}
function \u0275\u0275defineNgModule(def) {
  return noSideEffects(() => {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || EMPTY_ARRAY,
      declarations: def.declarations || EMPTY_ARRAY,
      imports: def.imports || EMPTY_ARRAY,
      exports: def.exports || EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    return res;
  });
}
function parseAndConvertBindingsForDefinition(obj, declaredInputs) {
  if (obj == null)
    return EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      const value = obj[minifiedKey];
      let publicName;
      let declaredName;
      let inputFlags = InputFlags.None;
      if (Array.isArray(value)) {
        inputFlags = value[0];
        publicName = value[1];
        declaredName = value[2] ?? publicName;
      } else {
        publicName = value;
        declaredName = value;
      }
      if (declaredInputs) {
        newLookup[publicName] = inputFlags !== InputFlags.None ? [minifiedKey, inputFlags] : minifiedKey;
        declaredInputs[publicName] = declaredName;
      } else {
        newLookup[publicName] = minifiedKey;
      }
    }
  }
  return newLookup;
}
function \u0275\u0275defineDirective(directiveDefinition) {
  return noSideEffects(() => {
    const def = getNgDirectiveDef(directiveDefinition);
    initFeatures(def);
    return def;
  });
}
function \u0275\u0275definePipe(pipeDef) {
  return {
    type: pipeDef.type,
    name: pipeDef.name,
    factory: null,
    pure: pipeDef.pure !== false,
    standalone: pipeDef.standalone === true,
    onDestroy: pipeDef.type.prototype.ngOnDestroy || null
  };
}
function getComponentDef(type) {
  return type[NG_COMP_DEF] || null;
}
function getDirectiveDef(type) {
  return type[NG_DIR_DEF] || null;
}
function getPipeDef$1(type) {
  return type[NG_PIPE_DEF] || null;
}
function isStandalone(type) {
  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
  return def !== null ? def.standalone : false;
}
function getNgModuleDef(type, throwNotFound) {
  const ngModuleDef = type[NG_MOD_DEF] || null;
  if (!ngModuleDef && throwNotFound === true) {
    throw new Error(`Type ${stringify(type)} does not have '\u0275mod' property.`);
  }
  return ngModuleDef;
}
function getNgDirectiveDef(directiveDefinition) {
  const declaredInputs = {};
  return {
    type: directiveDefinition.type,
    providersResolver: null,
    factory: null,
    hostBindings: directiveDefinition.hostBindings || null,
    hostVars: directiveDefinition.hostVars || 0,
    hostAttrs: directiveDefinition.hostAttrs || null,
    contentQueries: directiveDefinition.contentQueries || null,
    declaredInputs,
    inputTransforms: null,
    inputConfig: directiveDefinition.inputs || EMPTY_OBJ,
    exportAs: directiveDefinition.exportAs || null,
    standalone: directiveDefinition.standalone === true,
    signals: directiveDefinition.signals === true,
    selectors: directiveDefinition.selectors || EMPTY_ARRAY,
    viewQuery: directiveDefinition.viewQuery || null,
    features: directiveDefinition.features || null,
    setInput: null,
    findHostDirectiveDefs: null,
    hostDirectives: null,
    inputs: parseAndConvertBindingsForDefinition(directiveDefinition.inputs, declaredInputs),
    outputs: parseAndConvertBindingsForDefinition(directiveDefinition.outputs),
    debugInfo: null
  };
}
function initFeatures(definition) {
  definition.features?.forEach((fn) => fn(definition));
}
function extractDefListOrFactory(dependencies, pipeDef) {
  if (!dependencies) {
    return null;
  }
  const defExtractor = pipeDef ? getPipeDef$1 : extractDirectiveDef;
  return () => (typeof dependencies === "function" ? dependencies() : dependencies).map((dep) => defExtractor(dep)).filter(nonNull);
}
var GENERATED_COMP_IDS = /* @__PURE__ */ new Map();
function getComponentId(componentDef) {
  let hash = 0;
  const hashSelectors = [
    componentDef.selectors,
    componentDef.ngContentSelectors,
    componentDef.hostVars,
    componentDef.hostAttrs,
    componentDef.consts,
    componentDef.vars,
    componentDef.decls,
    componentDef.encapsulation,
    componentDef.standalone,
    componentDef.signals,
    componentDef.exportAs,
    JSON.stringify(componentDef.inputs),
    JSON.stringify(componentDef.outputs),
    // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not
    // match in the server and browser bundles.
    Object.getOwnPropertyNames(componentDef.type.prototype),
    !!componentDef.contentQueries,
    !!componentDef.viewQuery
  ].join("|");
  for (const char of hashSelectors) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  const compId = "c" + hash;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (GENERATED_COMP_IDS.has(compId)) {
      const previousCompDefType = GENERATED_COMP_IDS.get(compId);
      if (previousCompDefType !== componentDef.type) {
        console.warn(formatRuntimeError(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
      }
    } else {
      GENERATED_COMP_IDS.set(compId, componentDef.type);
    }
  }
  return compId;
}
function makeEnvironmentProviders(providers) {
  return {
    \u0275providers: providers
  };
}
function importProvidersFrom(...sources) {
  return {
    \u0275providers: internalImportProvidersFrom(true, sources),
    \u0275fromNgModule: true
  };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
  const providersOut = [];
  const dedup = /* @__PURE__ */ new Set();
  let injectorTypesWithProviders;
  const collectProviders = (provider) => {
    providersOut.push(provider);
  };
  deepForEach(sources, (source) => {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && checkForStandaloneCmp) {
      const cmpDef = getComponentDef(source);
      if (cmpDef?.standalone) {
        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
      }
    }
    const internalSource = source;
    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {
      injectorTypesWithProviders ||= [];
      injectorTypesWithProviders.push(internalSource);
    }
  });
  if (injectorTypesWithProviders !== void 0) {
    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);
  }
  return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, visitor) {
  for (let i3 = 0; i3 < typesWithProviders.length; i3++) {
    const { ngModule, providers } = typesWithProviders[i3];
    deepForEachProvider(providers, (provider) => {
      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
      visitor(provider, ngModule);
    });
  }
}
function walkProviderTree(container, visitor, parents, dedup) {
  container = resolveForwardRef(container);
  if (!container)
    return false;
  let defType = null;
  let injDef = getInjectorDef(container);
  const cmpDef = !injDef && getComponentDef(container);
  if (!injDef && !cmpDef) {
    const ngModule = container.ngModule;
    injDef = getInjectorDef(ngModule);
    if (injDef) {
      defType = ngModule;
    } else {
      return false;
    }
  } else if (cmpDef && !cmpDef.standalone) {
    return false;
  } else {
    defType = container;
  }
  if (ngDevMode && parents.indexOf(defType) !== -1) {
    const defName = stringify(defType);
    const path = parents.map(stringify);
    throwCyclicDependencyError(defName, path);
  }
  const isDuplicate = dedup.has(defType);
  if (cmpDef) {
    if (isDuplicate) {
      return false;
    }
    dedup.add(defType);
    if (cmpDef.dependencies) {
      const deps = typeof cmpDef.dependencies === "function" ? cmpDef.dependencies() : cmpDef.dependencies;
      for (const dep of deps) {
        walkProviderTree(dep, visitor, parents, dedup);
      }
    }
  } else if (injDef) {
    if (injDef.imports != null && !isDuplicate) {
      ngDevMode && parents.push(defType);
      dedup.add(defType);
      let importTypesWithProviders;
      try {
        deepForEach(injDef.imports, (imported) => {
          if (walkProviderTree(imported, visitor, parents, dedup)) {
            importTypesWithProviders ||= [];
            importTypesWithProviders.push(imported);
          }
        });
      } finally {
        ngDevMode && parents.pop();
      }
      if (importTypesWithProviders !== void 0) {
        processInjectorTypesWithProviders(importTypesWithProviders, visitor);
      }
    }
    if (!isDuplicate) {
      const factory = getFactoryDef(defType) || (() => new defType());
      visitor({ provide: defType, useFactory: factory, deps: EMPTY_ARRAY }, defType);
      visitor({ provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true }, defType);
      visitor({ provide: ENVIRONMENT_INITIALIZER, useValue: () => \u0275\u0275inject(defType), multi: true }, defType);
    }
    const defProviders = injDef.providers;
    if (defProviders != null && !isDuplicate) {
      const injectorType = container;
      deepForEachProvider(defProviders, (provider) => {
        ngDevMode && validateProvider(provider, defProviders, injectorType);
        visitor(provider, injectorType);
      });
    }
  } else {
    return false;
  }
  return defType !== container && container.providers !== void 0;
}
function validateProvider(provider, providers, containerType) {
  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
    return;
  }
  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
  if (!classRef) {
    throwInvalidProviderError(containerType, providers, provider);
  }
}
function deepForEachProvider(providers, fn) {
  for (let provider of providers) {
    if (isEnvironmentProviders(provider)) {
      provider = provider.\u0275providers;
    }
    if (Array.isArray(provider)) {
      deepForEachProvider(provider, fn);
    } else {
      fn(provider);
    }
  }
}
var USE_VALUE$1 = getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isValueProvider(value) {
  return value !== null && typeof value == "object" && USE_VALUE$1 in value;
}
function isExistingProvider(value) {
  return !!(value && value.useExisting);
}
function isFactoryProvider(value) {
  return !!(value && value.useFactory);
}
function isTypeProvider(value) {
  return typeof value === "function";
}
function isClassProvider(value) {
  return !!value.useClass;
}
var INJECTOR_SCOPE = new InjectionToken(ngDevMode ? "Set Injector scope." : "");
var NOT_YET = {};
var CIRCULAR = {};
var NULL_INJECTOR = void 0;
function getNullInjector() {
  if (NULL_INJECTOR === void 0) {
    NULL_INJECTOR = new NullInjector();
  }
  return NULL_INJECTOR;
}
var EnvironmentInjector = class {
};
var R3Injector = class extends EnvironmentInjector {
  /**
   * Flag indicating that this injector was previously destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  constructor(providers, parent2, source, scopes) {
    super();
    this.parent = parent2;
    this.source = source;
    this.scopes = scopes;
    this.records = /* @__PURE__ */ new Map();
    this._ngOnDestroyHooks = /* @__PURE__ */ new Set();
    this._onDestroyHooks = [];
    this._destroyed = false;
    forEachSingleProvider(providers, (provider) => this.processProvider(provider));
    this.records.set(INJECTOR$1, makeRecord(void 0, this));
    if (scopes.has("environment")) {
      this.records.set(EnvironmentInjector, makeRecord(void 0, this));
    }
    const record = this.records.get(INJECTOR_SCOPE);
    if (record != null && typeof record.value === "string") {
      this.scopes.add(record.value);
    }
    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, InjectFlags.Self));
  }
  /**
   * Destroy the injector and release references to every instance or provider associated with it.
   *
   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a
   * hook was found.
   */
  destroy() {
    this.assertNotDestroyed();
    this._destroyed = true;
    const prevConsumer = setActiveConsumer(null);
    try {
      for (const service of this._ngOnDestroyHooks) {
        service.ngOnDestroy();
      }
      const onDestroyHooks = this._onDestroyHooks;
      this._onDestroyHooks = [];
      for (const hook of onDestroyHooks) {
        hook();
      }
    } finally {
      this.records.clear();
      this._ngOnDestroyHooks.clear();
      this.injectorDefTypes.clear();
      setActiveConsumer(prevConsumer);
    }
  }
  onDestroy(callback) {
    this.assertNotDestroyed();
    this._onDestroyHooks.push(callback);
    return () => this.removeOnDestroy(callback);
  }
  runInContext(fn) {
    this.assertNotDestroyed();
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });
    }
    try {
      return fn();
    } finally {
      setCurrentInjector(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
    this.assertNotDestroyed();
    if (token.hasOwnProperty(NG_ENV_ID)) {
      return token[NG_ENV_ID](this);
    }
    flags = convertToBitFlags(flags);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({ injector: this, token });
    }
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (!(flags & InjectFlags.SkipSelf)) {
        let record = this.records.get(token);
        if (record === void 0) {
          const def = couldBeInjectableType(token) && getInjectableDef(token);
          if (def && this.injectableDefInScope(def)) {
            if (ngDevMode) {
              runInInjectorProfilerContext(this, token, () => {
                emitProviderConfiguredEvent(token);
              });
            }
            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
          } else {
            record = null;
          }
          this.records.set(token, record);
        }
        if (record != null) {
          return this.hydrate(token, record);
        }
      }
      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
      notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
      return nextInjector.get(token, notFoundValue);
    } catch (e3) {
      if (e3.name === "NullInjectorError") {
        const path = e3[NG_TEMP_TOKEN_PATH] = e3[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(stringify(token));
        if (previousInjector) {
          throw e3;
        } else {
          return catchInjectorError(e3, token, "R3InjectorError", this.source);
        }
      } else {
        throw e3;
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
      setCurrentInjector(previousInjector);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  /** @internal */
  resolveInjectorInitializers() {
    const prevConsumer = setActiveConsumer(null);
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });
    }
    try {
      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, InjectFlags.Self);
      if (ngDevMode && !Array.isArray(initializers)) {
        throw new RuntimeError(-209, `Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
      }
      for (const initializer of initializers) {
        initializer();
      }
    } finally {
      setCurrentInjector(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      setActiveConsumer(prevConsumer);
    }
  }
  toString() {
    const tokens = [];
    const records = this.records;
    for (const token of records.keys()) {
      tokens.push(stringify(token));
    }
    return `R3Injector[${tokens.join(", ")}]`;
  }
  assertNotDestroyed() {
    if (this._destroyed) {
      throw new RuntimeError(205, ngDevMode && "Injector has already been destroyed.");
    }
  }
  /**
   * Process a `SingleProvider` and add it.
   */
  processProvider(provider) {
    provider = resolveForwardRef(provider);
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
    const record = providerToRecord(provider);
    if (ngDevMode) {
      runInInjectorProfilerContext(this, token, () => {
        if (isValueProvider(provider)) {
          emitInstanceCreatedByInjectorEvent(provider.useValue);
        }
        emitProviderConfiguredEvent(provider);
      });
    }
    if (!isTypeProvider(provider) && provider.multi === true) {
      let multiRecord = this.records.get(token);
      if (multiRecord) {
        if (ngDevMode && multiRecord.multi === void 0) {
          throwMixedMultiProviderError();
        }
      } else {
        multiRecord = makeRecord(void 0, NOT_YET, true);
        multiRecord.factory = () => injectArgs(multiRecord.multi);
        this.records.set(token, multiRecord);
      }
      token = provider;
      multiRecord.multi.push(provider);
    } else {
      if (ngDevMode) {
        const existing = this.records.get(token);
        if (existing && existing.multi !== void 0) {
          throwMixedMultiProviderError();
        }
      }
    }
    this.records.set(token, record);
  }
  hydrate(token, record) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (ngDevMode && record.value === CIRCULAR) {
        throwCyclicDependencyError(stringify(token));
      } else if (record.value === NOT_YET) {
        record.value = CIRCULAR;
        if (ngDevMode) {
          runInInjectorProfilerContext(this, token, () => {
            record.value = record.factory();
            emitInstanceCreatedByInjectorEvent(record.value);
          });
        } else {
          record.value = record.factory();
        }
      }
      if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
        this._ngOnDestroyHooks.add(record.value);
      }
      return record.value;
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
  injectableDefInScope(def) {
    if (!def.providedIn) {
      return false;
    }
    const providedIn = resolveForwardRef(def.providedIn);
    if (typeof providedIn === "string") {
      return providedIn === "any" || this.scopes.has(providedIn);
    } else {
      return this.injectorDefTypes.has(providedIn);
    }
  }
  removeOnDestroy(callback) {
    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
    if (destroyCBIdx !== -1) {
      this._onDestroyHooks.splice(destroyCBIdx, 1);
    }
  }
};
function injectableDefOrInjectorDefFactory(token) {
  const injectableDef = getInjectableDef(token);
  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
  if (factory !== null) {
    return factory;
  }
  if (token instanceof InjectionToken) {
    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a \u0275prov definition.`);
  }
  if (token instanceof Function) {
    return getUndecoratedInjectableFactory(token);
  }
  throw new RuntimeError(204, ngDevMode && "unreachable");
}
function getUndecoratedInjectableFactory(token) {
  const paramLength = token.length;
  if (paramLength > 0) {
    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, "?").join(", ")}).`);
  }
  const inheritedInjectableDef = getInheritedInjectableDef(token);
  if (inheritedInjectableDef !== null) {
    return () => inheritedInjectableDef.factory(token);
  } else {
    return () => new token();
  }
}
function providerToRecord(provider) {
  if (isValueProvider(provider)) {
    return makeRecord(void 0, provider.useValue);
  } else {
    const factory = providerToFactory(provider);
    return makeRecord(factory, NOT_YET);
  }
}
function providerToFactory(provider, ngModuleType, providers) {
  let factory = void 0;
  if (ngDevMode && isEnvironmentProviders(provider)) {
    throwInvalidProviderError(void 0, providers, provider);
  }
  if (isTypeProvider(provider)) {
    const unwrappedProvider = resolveForwardRef(provider);
    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
  } else {
    if (isValueProvider(provider)) {
      factory = () => resolveForwardRef(provider.useValue);
    } else if (isFactoryProvider(provider)) {
      factory = () => provider.useFactory(...injectArgs(provider.deps || []));
    } else if (isExistingProvider(provider)) {
      factory = () => \u0275\u0275inject(resolveForwardRef(provider.useExisting));
    } else {
      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
      if (ngDevMode && !classRef) {
        throwInvalidProviderError(ngModuleType, providers, provider);
      }
      if (hasDeps(provider)) {
        factory = () => new classRef(...injectArgs(provider.deps));
      } else {
        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
      }
    }
  }
  return factory;
}
function makeRecord(factory, value, multi = false) {
  return {
    factory,
    value,
    multi: multi ? [] : void 0
  };
}
function hasDeps(value) {
  return !!value.deps;
}
function hasOnDestroy(value) {
  return value !== null && typeof value === "object" && typeof value.ngOnDestroy === "function";
}
function couldBeInjectableType(value) {
  return typeof value === "function" || typeof value === "object" && value instanceof InjectionToken;
}
function forEachSingleProvider(providers, fn) {
  for (const provider of providers) {
    if (Array.isArray(provider)) {
      forEachSingleProvider(provider, fn);
    } else if (provider && isEnvironmentProviders(provider)) {
      forEachSingleProvider(provider.\u0275providers, fn);
    } else {
      fn(provider);
    }
  }
}
function runInInjectionContext(injector, fn) {
  if (injector instanceof R3Injector) {
    injector.assertNotDestroyed();
  }
  let prevInjectorProfilerContext;
  if (ngDevMode) {
    prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });
  }
  const prevInjector = setCurrentInjector(injector);
  const previousInjectImplementation = setInjectImplementation(void 0);
  try {
    return fn();
  } finally {
    setCurrentInjector(prevInjector);
    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);
    setInjectImplementation(previousInjectImplementation);
  }
}
function isInInjectionContext() {
  return getInjectImplementation() !== void 0 || getCurrentInjector() != null;
}
function assertInInjectionContext(debugFn) {
  if (!isInInjectionContext()) {
    throw new RuntimeError(-203, ngDevMode && debugFn.name + "() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`");
  }
}
var FactoryTarget;
(function(FactoryTarget2) {
  FactoryTarget2[FactoryTarget2["Directive"] = 0] = "Directive";
  FactoryTarget2[FactoryTarget2["Component"] = 1] = "Component";
  FactoryTarget2[FactoryTarget2["Injectable"] = 2] = "Injectable";
  FactoryTarget2[FactoryTarget2["Pipe"] = 3] = "Pipe";
  FactoryTarget2[FactoryTarget2["NgModule"] = 4] = "NgModule";
})(FactoryTarget || (FactoryTarget = {}));
var R3TemplateDependencyKind;
(function(R3TemplateDependencyKind2) {
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["Directive"] = 0] = "Directive";
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["Pipe"] = 1] = "Pipe";
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["NgModule"] = 2] = "NgModule";
})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));
var ViewEncapsulation;
(function(ViewEncapsulation2) {
  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
})(ViewEncapsulation || (ViewEncapsulation = {}));
function getCompilerFacade(request) {
  const globalNg = _global["ng"];
  if (globalNg && globalNg.\u0275compilerFacade) {
    return globalNg.\u0275compilerFacade;
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.error(`JIT compilation failed for ${request.kind}`, request.type);
    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

`;
    if (request.usage === 1) {
      message += `The ${request.kind} is part of a library that has been partially compiled.
`;
      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
`;
      message += "\n";
      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
`;
    } else {
      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
`;
    }
    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
`;
    message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
    throw new Error(message);
  } else {
    throw new Error("JIT compiler unavailable");
  }
}
var angularCoreDiEnv = {
  "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
  "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
  "\u0275\u0275inject": \u0275\u0275inject,
  "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
  "resolveForwardRef": resolveForwardRef
};
var Type = Function;
function isType(v3) {
  return typeof v3 === "function";
}
var ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
var ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
var ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
var ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
function isDelegateCtor(typeStr) {
  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
var ReflectionCapabilities = class {
  constructor(reflect) {
    this._reflect = reflect || _global["Reflect"];
  }
  factory(t3) {
    return (...args) => new t3(...args);
  }
  /** @internal */
  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
    let result;
    if (typeof paramTypes === "undefined") {
      result = newArray(paramAnnotations.length);
    } else {
      result = newArray(paramTypes.length);
    }
    for (let i3 = 0; i3 < result.length; i3++) {
      if (typeof paramTypes === "undefined") {
        result[i3] = [];
      } else if (paramTypes[i3] && paramTypes[i3] != Object) {
        result[i3] = [paramTypes[i3]];
      } else {
        result[i3] = [];
      }
      if (paramAnnotations && paramAnnotations[i3] != null) {
        result[i3] = result[i3].concat(paramAnnotations[i3]);
      }
    }
    return result;
  }
  _ownParameters(type, parentCtor) {
    const typeStr = type.toString();
    if (isDelegateCtor(typeStr)) {
      return null;
    }
    if (type.parameters && type.parameters !== parentCtor.parameters) {
      return type.parameters;
    }
    const tsickleCtorParams = type.ctorParameters;
    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
      const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
      const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
      const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
      return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
    }
    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
    if (paramTypes || paramAnnotations) {
      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
    }
    return newArray(type.length);
  }
  parameters(type) {
    if (!isType(type)) {
      return [];
    }
    const parentCtor = getParentCtor(type);
    let parameters = this._ownParameters(type, parentCtor);
    if (!parameters && parentCtor !== Object) {
      parameters = this.parameters(parentCtor);
    }
    return parameters || [];
  }
  _ownAnnotations(typeOrFunc, parentCtor) {
    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
      let annotations = typeOrFunc.annotations;
      if (typeof annotations === "function" && annotations.annotations) {
        annotations = annotations.annotations;
      }
      return annotations;
    }
    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
    }
    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
      return typeOrFunc[ANNOTATIONS];
    }
    return null;
  }
  annotations(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return [];
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
    return parentAnnotations.concat(ownAnnotations);
  }
  _ownPropMetadata(typeOrFunc, parentCtor) {
    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
      let propMetadata = typeOrFunc.propMetadata;
      if (typeof propMetadata === "function" && propMetadata.propMetadata) {
        propMetadata = propMetadata.propMetadata;
      }
      return propMetadata;
    }
    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
      const propDecorators = typeOrFunc.propDecorators;
      const propMetadata = {};
      Object.keys(propDecorators).forEach((prop) => {
        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
      });
      return propMetadata;
    }
    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
      return typeOrFunc[PROP_METADATA];
    }
    return null;
  }
  propMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const propMetadata = {};
    if (parentCtor !== Object) {
      const parentPropMetadata = this.propMetadata(parentCtor);
      Object.keys(parentPropMetadata).forEach((propName) => {
        propMetadata[propName] = parentPropMetadata[propName];
      });
    }
    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
    if (ownPropMetadata) {
      Object.keys(ownPropMetadata).forEach((propName) => {
        const decorators = [];
        if (propMetadata.hasOwnProperty(propName)) {
          decorators.push(...propMetadata[propName]);
        }
        decorators.push(...ownPropMetadata[propName]);
        propMetadata[propName] = decorators;
      });
    }
    return propMetadata;
  }
  ownPropMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
  }
  hasLifecycleHook(type, lcProperty) {
    return type instanceof Type && lcProperty in type.prototype;
  }
};
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
  if (!decoratorInvocations) {
    return [];
  }
  return decoratorInvocations.map((decoratorInvocation) => {
    const decoratorType = decoratorInvocation.type;
    const annotationCls = decoratorType.annotationCls;
    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
    return new annotationCls(...annotationArgs);
  });
}
function getParentCtor(ctor) {
  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
  const parentCtor = parentProto ? parentProto.constructor : null;
  return parentCtor || Object;
}
var HOST = 0;
var TVIEW = 1;
var FLAGS = 2;
var PARENT = 3;
var NEXT = 4;
var T_HOST = 5;
var HYDRATION = 6;
var CLEANUP = 7;
var CONTEXT = 8;
var INJECTOR = 9;
var ENVIRONMENT = 10;
var RENDERER = 11;
var CHILD_HEAD = 12;
var CHILD_TAIL = 13;
var DECLARATION_VIEW = 14;
var DECLARATION_COMPONENT_VIEW = 15;
var DECLARATION_LCONTAINER = 16;
var PREORDER_HOOK_FLAGS = 17;
var QUERIES = 18;
var ID = 19;
var EMBEDDED_VIEW_INJECTOR = 20;
var ON_DESTROY_HOOKS = 21;
var EFFECTS_TO_SCHEDULE = 22;
var REACTIVE_TEMPLATE_CONSUMER = 23;
var HEADER_OFFSET = 25;
var TYPE = 1;
var NATIVE = 7;
var VIEW_REFS = 8;
var MOVED_VIEWS = 9;
var CONTAINER_HEADER_OFFSET = 10;
var LContainerFlags;
(function(LContainerFlags2) {
  LContainerFlags2[LContainerFlags2["None"] = 0] = "None";
  LContainerFlags2[LContainerFlags2["HasTransplantedViews"] = 2] = "HasTransplantedViews";
})(LContainerFlags || (LContainerFlags = {}));
function isLView(value) {
  return Array.isArray(value) && typeof value[TYPE] === "object";
}
function isLContainer(value) {
  return Array.isArray(value) && value[TYPE] === true;
}
function isContentQueryHost(tNode) {
  return (tNode.flags & 4) !== 0;
}
function isComponentHost(tNode) {
  return tNode.componentOffset > -1;
}
function isDirectiveHost(tNode) {
  return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
  return !!def.template;
}
function isRootView(target) {
  return (target[FLAGS] & 512) !== 0;
}
function isDestroyed(lView) {
  return (lView[FLAGS] & 256) === 256;
}
function assertTNodeForLView(tNode, lView) {
  assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeForTView(tNode, tView) {
  assertTNode(tNode);
  const tData = tView.data;
  for (let i3 = HEADER_OFFSET; i3 < tData.length; i3++) {
    if (tData[i3] === tNode) {
      return;
    }
  }
  throwError2("This TNode does not belong to this TView.");
}
function assertTNode(tNode) {
  assertDefined(tNode, "TNode must be defined");
  if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
    throwError2("Not of type TNode, got: " + tNode);
  }
}
function assertTIcu(tIcu) {
  assertDefined(tIcu, "Expected TIcu to be defined");
  if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
    throwError2("Object is not of TIcu type.");
  }
}
function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have '\u0275cmp' property.") {
  if (!getComponentDef(actual)) {
    throwError2(msg);
  }
}
function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have '\u0275mod' property.") {
  if (!getNgModuleDef(actual)) {
    throwError2(msg);
  }
}
function assertHasParent(tNode) {
  assertDefined(tNode, "currentTNode should exist!");
  assertDefined(tNode.parent, "currentTNode should have a parent");
}
function assertLContainer(value) {
  assertDefined(value, "LContainer must be defined");
  assertEqual(isLContainer(value), true, "Expecting LContainer");
}
function assertLViewOrUndefined(value) {
  value && assertEqual(isLView(value), true, "Expecting LView or undefined or null");
}
function assertLView(value) {
  assertDefined(value, "LView must be defined");
  assertEqual(isLView(value), true, "Expecting LView");
}
function assertFirstCreatePass(tView, errMessage) {
  assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
}
function assertFirstUpdatePass(tView, errMessage) {
  assertEqual(tView.firstUpdatePass, true, errMessage || "Should only be called in first update pass.");
}
function assertDirectiveDef(obj) {
  if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
    throwError2(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
  }
}
function assertIndexInDeclRange(tView, index3) {
  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index3);
}
function assertIndexInExpandoRange(lView, index3) {
  const tView = lView[1];
  assertBetween(tView.expandoStartIndex, lView.length, index3);
}
function assertBetween(lower, upper, index3) {
  if (!(lower <= index3 && index3 < upper)) {
    throwError2(`Index out of range (expecting ${lower} <= ${index3} < ${upper})`);
  }
}
function assertProjectionSlots(lView, errMessage) {
  assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || "Components with projection nodes (<ng-content>) must have projection slots defined.");
}
function assertParentView(lView, errMessage) {
  assertDefined(lView, errMessage || "Component views should always have a parent view (component's host view)");
}
function assertNoDuplicateDirectives(directives) {
  if (directives.length < 2) {
    return;
  }
  const seenDirectives = /* @__PURE__ */ new Set();
  for (const current of directives) {
    if (seenDirectives.has(current)) {
      throw new RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);
    }
    seenDirectives.add(current);
  }
}
function assertNodeInjector(lView, injectorIndex) {
  assertIndexInExpandoRange(lView, injectorIndex);
  assertIndexInExpandoRange(
    lView,
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  );
  assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
  assertNumber(lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ], "injectorIndex should point to parent injector");
}
var SimpleChange = class {
  constructor(previousValue, currentValue, firstChange) {
    this.previousValue = previousValue;
    this.currentValue = currentValue;
    this.firstChange = firstChange;
  }
  /**
   * Check whether the new value is the first value assigned.
   */
  isFirstChange() {
    return this.firstChange;
  }
};
function applyValueToInputField(instance, inputSignalNode, privateName, value) {
  if (inputSignalNode !== null) {
    inputSignalNode.applyValueToInputSignal(inputSignalNode, value);
  } else {
    instance[privateName] = value;
  }
}
function \u0275\u0275NgOnChangesFeature() {
  return NgOnChangesFeatureImpl;
}
function NgOnChangesFeatureImpl(definition) {
  if (definition.type.prototype.ngOnChanges) {
    definition.setInput = ngOnChangesSetInput;
  }
  return rememberChangeHistoryAndInvokeOnChangesHook;
}
\u0275\u0275NgOnChangesFeature.ngInherit = true;
function rememberChangeHistoryAndInvokeOnChangesHook() {
  const simpleChangesStore = getSimpleChangesStore(this);
  const current = simpleChangesStore?.current;
  if (current) {
    const previous = simpleChangesStore.previous;
    if (previous === EMPTY_OBJ) {
      simpleChangesStore.previous = current;
    } else {
      for (let key in current) {
        previous[key] = current[key];
      }
    }
    simpleChangesStore.current = null;
    this.ngOnChanges(current);
  }
}
function ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {
  const declaredName = this.declaredInputs[publicName];
  ngDevMode && assertString(declaredName, "Name of input in ngOnChanges has to be a string");
  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });
  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
  const previous = simpleChangesStore.previous;
  const previousChange = previous[declaredName];
  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
  applyValueToInputField(instance, inputSignalNode, privateName, value);
}
var SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
function getSimpleChangesStore(instance) {
  return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store2) {
  return instance[SIMPLE_CHANGES_STORE] = store2;
}
var profilerCallback = null;
var setProfiler = (profiler2) => {
  profilerCallback = profiler2;
};
var profiler = function(event, instance, hookOrListener) {
  if (profilerCallback != null) {
    profilerCallback(event, instance, hookOrListener);
  }
};
var SVG_NAMESPACE = "svg";
var MATH_ML_NAMESPACE = "math";
function unwrapRNode(value) {
  while (Array.isArray(value)) {
    value = value[HOST];
  }
  return value;
}
function unwrapLView(value) {
  while (Array.isArray(value)) {
    if (typeof value[TYPE] === "object")
      return value;
    value = value[HOST];
  }
  return null;
}
function getNativeByIndex(index3, lView) {
  ngDevMode && assertIndexInRange(lView, index3);
  ngDevMode && assertGreaterThanOrEqual(index3, HEADER_OFFSET, "Expected to be past HEADER_OFFSET");
  return unwrapRNode(lView[index3]);
}
function getNativeByTNode(tNode, lView) {
  ngDevMode && assertTNodeForLView(tNode, lView);
  ngDevMode && assertIndexInRange(lView, tNode.index);
  const node = unwrapRNode(lView[tNode.index]);
  return node;
}
function getTNode(tView, index3) {
  ngDevMode && assertGreaterThan(index3, -1, "wrong index for TNode");
  ngDevMode && assertLessThan(index3, tView.data.length, "wrong index for TNode");
  const tNode = tView.data[index3];
  ngDevMode && tNode !== null && assertTNode(tNode);
  return tNode;
}
function load(view, index3) {
  ngDevMode && assertIndexInRange(view, index3);
  return view[index3];
}
function getComponentLViewByIndex(nodeIndex, hostView) {
  ngDevMode && assertIndexInRange(hostView, nodeIndex);
  const slotValue = hostView[nodeIndex];
  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
  return lView;
}
function isCreationMode(view) {
  return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
  return (view[FLAGS] & 128) === 128;
}
function viewAttachedToContainer(view) {
  return isLContainer(view[PARENT]);
}
function getConstant(consts, index3) {
  if (index3 === null || index3 === void 0)
    return null;
  ngDevMode && assertIndexInRange(consts, index3);
  return consts[index3];
}
function resetPreOrderHookFlags(lView) {
  lView[PREORDER_HOOK_FLAGS] = 0;
}
function markViewForRefresh(lView) {
  if (lView[FLAGS] & 1024) {
    return;
  }
  lView[FLAGS] |= 1024;
  if (viewAttachedToChangeDetector(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function walkUpViews(nestingLevel, currentView) {
  while (nestingLevel > 0) {
    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], "Declaration view should be defined if nesting level is greater than 0.");
    currentView = currentView[DECLARATION_VIEW];
    nestingLevel--;
  }
  return currentView;
}
function requiresRefreshOrTraversal(lView) {
  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);
}
function updateAncestorTraversalFlagsOnAttach(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    7
    /* NotificationSource.ViewAttached */
  );
  if (lView[FLAGS] & 64) {
    lView[FLAGS] |= 1024;
  }
  if (requiresRefreshOrTraversal(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function markAncestorsForTraversal(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    0
    /* NotificationSource.MarkAncestorsForTraversal */
  );
  let parent2 = getLViewParent(lView);
  while (parent2 !== null) {
    if (parent2[FLAGS] & 8192) {
      break;
    }
    parent2[FLAGS] |= 8192;
    if (!viewAttachedToChangeDetector(parent2)) {
      break;
    }
    parent2 = getLViewParent(parent2);
  }
}
function storeLViewOnDestroy(lView, onDestroyCallback) {
  if ((lView[FLAGS] & 256) === 256) {
    throw new RuntimeError(911, ngDevMode && "View has already been destroyed.");
  }
  if (lView[ON_DESTROY_HOOKS] === null) {
    lView[ON_DESTROY_HOOKS] = [];
  }
  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
}
function removeLViewOnDestroy(lView, onDestroyCallback) {
  if (lView[ON_DESTROY_HOOKS] === null)
    return;
  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
  if (destroyCBIdx !== -1) {
    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
  }
}
function getLViewParent(lView) {
  ngDevMode && assertLView(lView);
  const parent2 = lView[PARENT];
  return isLContainer(parent2) ? parent2[PARENT] : parent2;
}
var instructionState = {
  lFrame: createLFrame(null),
  bindingsEnabled: true,
  skipHydrationRootTNode: null
};
var CheckNoChangesMode;
(function(CheckNoChangesMode2) {
  CheckNoChangesMode2[CheckNoChangesMode2["Off"] = 0] = "Off";
  CheckNoChangesMode2[CheckNoChangesMode2["Exhaustive"] = 1] = "Exhaustive";
  CheckNoChangesMode2[CheckNoChangesMode2["OnlyDirtyViews"] = 2] = "OnlyDirtyViews";
})(CheckNoChangesMode || (CheckNoChangesMode = {}));
var _checkNoChangesMode = 0;
var _isRefreshingViews = false;
function getElementDepthCount() {
  return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
  return instructionState.bindingsEnabled;
}
function isInSkipHydrationBlock$1() {
  return instructionState.skipHydrationRootTNode !== null;
}
function isSkipHydrationRootTNode(tNode) {
  return instructionState.skipHydrationRootTNode === tNode;
}
function \u0275\u0275enableBindings() {
  instructionState.bindingsEnabled = true;
}
function \u0275\u0275disableBindings() {
  instructionState.bindingsEnabled = false;
}
function leaveSkipHydrationBlock() {
  instructionState.skipHydrationRootTNode = null;
}
function getLView() {
  return instructionState.lFrame.lView;
}
function getTView() {
  return instructionState.lFrame.tView;
}
function \u0275\u0275restoreView(viewToRestore) {
  instructionState.lFrame.contextLView = viewToRestore;
  return viewToRestore[CONTEXT];
}
function \u0275\u0275resetView(value) {
  instructionState.lFrame.contextLView = null;
  return value;
}
function getCurrentTNode() {
  let currentTNode = getCurrentTNodePlaceholderOk();
  while (currentTNode !== null && currentTNode.type === 64) {
    currentTNode = currentTNode.parent;
  }
  return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
  return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
  const lFrame = instructionState.lFrame;
  const currentTNode = lFrame.currentTNode;
  return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent) {
  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
  const lFrame = instructionState.lFrame;
  lFrame.currentTNode = tNode;
  lFrame.isParent = isParent;
}
function isCurrentTNodeParent() {
  return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
  instructionState.lFrame.isParent = false;
}
function getContextLView() {
  const contextLView = instructionState.lFrame.contextLView;
  ngDevMode && assertDefined(contextLView, "contextLView must be defined.");
  return contextLView;
}
function isInCheckNoChangesMode() {
  !ngDevMode && throwError2("Must never be called in production mode");
  return _checkNoChangesMode !== CheckNoChangesMode.Off;
}
function isExhaustiveCheckNoChanges() {
  !ngDevMode && throwError2("Must never be called in production mode");
  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;
}
function setIsInCheckNoChangesMode(mode) {
  !ngDevMode && throwError2("Must never be called in production mode");
  _checkNoChangesMode = mode;
}
function isRefreshingViews() {
  return _isRefreshingViews;
}
function setIsRefreshingViews(mode) {
  _isRefreshingViews = mode;
}
function getBindingRoot() {
  const lFrame = instructionState.lFrame;
  let index3 = lFrame.bindingRootIndex;
  if (index3 === -1) {
    index3 = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
  }
  return index3;
}
function getBindingIndex() {
  return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value) {
  return instructionState.lFrame.bindingIndex = value;
}
function nextBindingIndex() {
  return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count) {
  const lFrame = instructionState.lFrame;
  const index3 = lFrame.bindingIndex;
  lFrame.bindingIndex = lFrame.bindingIndex + count;
  return index3;
}
function isInI18nBlock() {
  return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock2) {
  instructionState.lFrame.inI18n = isInI18nBlock2;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
  const lFrame = instructionState.lFrame;
  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
  setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
  return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
  return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value) {
  instructionState.lFrame.currentQueryIndex = value;
}
function getDeclarationTNode(lView) {
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  }
  if (tView.type === 1) {
    return lView[T_HOST];
  }
  return null;
}
function enterDI(lView, tNode, flags) {
  ngDevMode && assertLViewOrUndefined(lView);
  if (flags & InjectFlags.SkipSelf) {
    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
    let parentTNode = tNode;
    let parentLView = lView;
    while (true) {
      ngDevMode && assertDefined(parentTNode, "Parent TNode should be defined");
      parentTNode = parentTNode.parent;
      if (parentTNode === null && !(flags & InjectFlags.Host)) {
        parentTNode = getDeclarationTNode(parentLView);
        if (parentTNode === null)
          break;
        ngDevMode && assertDefined(parentLView, "Parent LView should be defined");
        parentLView = parentLView[DECLARATION_VIEW];
        if (parentTNode.type & (2 | 8)) {
          break;
        }
      } else {
        break;
      }
    }
    if (parentTNode === null) {
      return false;
    } else {
      tNode = parentTNode;
      lView = parentLView;
    }
  }
  ngDevMode && assertTNodeForLView(tNode, lView);
  const lFrame = instructionState.lFrame = allocLFrame();
  lFrame.currentTNode = tNode;
  lFrame.lView = lView;
  return true;
}
function enterView(newView) {
  ngDevMode && assertNotEqual(newView[0], newView[1], "????");
  ngDevMode && assertLViewOrUndefined(newView);
  const newLFrame = allocLFrame();
  if (ngDevMode) {
    assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
    assertEqual(newLFrame.lView, null, "Expected clean LFrame");
    assertEqual(newLFrame.tView, null, "Expected clean LFrame");
    assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
    assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
    assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
  }
  const tView = newView[TVIEW];
  instructionState.lFrame = newLFrame;
  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
  newLFrame.currentTNode = tView.firstChild;
  newLFrame.lView = newView;
  newLFrame.tView = tView;
  newLFrame.contextLView = newView;
  newLFrame.bindingIndex = tView.bindingStartIndex;
  newLFrame.inI18n = false;
}
function allocLFrame() {
  const currentLFrame = instructionState.lFrame;
  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
  return newLFrame;
}
function createLFrame(parent2) {
  const lFrame = {
    currentTNode: null,
    isParent: true,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent: parent2,
    child: null,
    inI18n: false
  };
  parent2 !== null && (parent2.child = lFrame);
  return lFrame;
}
function leaveViewLight() {
  const oldLFrame = instructionState.lFrame;
  instructionState.lFrame = oldLFrame.parent;
  oldLFrame.currentTNode = null;
  oldLFrame.lView = null;
  return oldLFrame;
}
var leaveDI = leaveViewLight;
function leaveView() {
  const oldLFrame = leaveViewLight();
  oldLFrame.isParent = true;
  oldLFrame.tView = null;
  oldLFrame.selectedIndex = -1;
  oldLFrame.contextLView = null;
  oldLFrame.elementDepthCount = 0;
  oldLFrame.currentDirectiveIndex = -1;
  oldLFrame.currentNamespace = null;
  oldLFrame.bindingRootIndex = -1;
  oldLFrame.bindingIndex = -1;
  oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
  return contextLView[CONTEXT];
}
function getSelectedIndex() {
  return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index3) {
  ngDevMode && index3 !== -1 && assertGreaterThanOrEqual(index3, HEADER_OFFSET, "Index must be past HEADER_OFFSET (or -1).");
  ngDevMode && assertLessThan(index3, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
  instructionState.lFrame.selectedIndex = index3;
}
function getSelectedTNode() {
  const lFrame = instructionState.lFrame;
  return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function \u0275\u0275namespaceSVG() {
  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function \u0275\u0275namespaceMathML() {
  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function \u0275\u0275namespaceHTML() {
  namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
  instructionState.lFrame.currentNamespace = null;
}
function getNamespace$1() {
  return instructionState.lFrame.currentNamespace;
}
var _wasLastNodeCreated = true;
function wasLastNodeCreated() {
  return _wasLastNodeCreated;
}
function lastNodeWasCreated(flag) {
  _wasLastNodeCreated = flag;
}
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
  ngDevMode && assertFirstCreatePass(tView);
  const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;
  if (ngOnChanges) {
    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);
  }
  if (ngOnInit) {
    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);
  }
  if (ngDoCheck) {
    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);
  }
}
function registerPostOrderHooks(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let i3 = tNode.directiveStart, end = tNode.directiveEnd; i3 < end; i3++) {
    const directiveDef = tView.data[i3];
    ngDevMode && assertDefined(directiveDef, "Expecting DirectiveDef");
    const lifecycleHooks = directiveDef.type.prototype;
    const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;
    if (ngAfterContentInit) {
      (tView.contentHooks ??= []).push(-i3, ngAfterContentInit);
    }
    if (ngAfterContentChecked) {
      (tView.contentHooks ??= []).push(i3, ngAfterContentChecked);
      (tView.contentCheckHooks ??= []).push(i3, ngAfterContentChecked);
    }
    if (ngAfterViewInit) {
      (tView.viewHooks ??= []).push(-i3, ngAfterViewInit);
    }
    if (ngAfterViewChecked) {
      (tView.viewHooks ??= []).push(i3, ngAfterViewChecked);
      (tView.viewCheckHooks ??= []).push(i3, ngAfterViewChecked);
    }
    if (ngOnDestroy != null) {
      (tView.destroyHooks ??= []).push(i3, ngOnDestroy);
    }
  }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
  callHooks(lView, hooks, 3, nodeIndex);
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init pre-order hooks should not be called more than once");
  if ((lView[FLAGS] & 3) === initPhase) {
    callHooks(lView, hooks, initPhase, nodeIndex);
  }
}
function incrementInitPhaseFlags(lView, initPhase) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
  let flags = lView[FLAGS];
  if ((flags & 3) === initPhase) {
    flags &= 16383;
    flags += 1;
    lView[FLAGS] = flags;
  }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, "Hooks should never be run when in check no changes mode.");
  const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
  const max = arr.length - 1;
  let lastNodeIndexFound = 0;
  for (let i3 = startIndex; i3 < max; i3++) {
    const hook = arr[i3 + 1];
    if (typeof hook === "number") {
      lastNodeIndexFound = arr[i3];
      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
        break;
      }
    } else {
      const isInitHook = arr[i3] < 0;
      if (isInitHook) {
        currentView[PREORDER_HOOK_FLAGS] += 65536;
      }
      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
        callHook(currentView, initPhase, arr, i3);
        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i3 + 2;
      }
      i3++;
    }
  }
}
function callHookInternal(directive, hook) {
  profiler(4, directive, hook);
  const prevConsumer = setActiveConsumer(null);
  try {
    hook.call(directive);
  } finally {
    setActiveConsumer(prevConsumer);
    profiler(5, directive, hook);
  }
}
function callHook(currentView, initPhase, arr, i3) {
  const isInitHook = arr[i3] < 0;
  const hook = arr[i3 + 1];
  const directiveIndex = isInitHook ? -arr[i3] : arr[i3];
  const directive = currentView[directiveIndex];
  if (isInitHook) {
    const indexWithintInitPhase = currentView[FLAGS] >> 14;
    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
      currentView[FLAGS] += 16384;
      callHookInternal(directive, hook);
    }
  } else {
    callHookInternal(directive, hook);
  }
}
var NO_PARENT_INJECTOR = -1;
var NodeInjectorFactory = class {
  constructor(factory, isViewProvider, injectImplementation) {
    this.factory = factory;
    this.resolving = false;
    ngDevMode && assertDefined(factory, "Factory not specified");
    ngDevMode && assertEqual(typeof factory, "function", "Expected factory function.");
    this.canSeeViewProviders = isViewProvider;
    this.injectImpl = injectImplementation;
  }
};
function isFactory(obj) {
  return obj instanceof NodeInjectorFactory;
}
function toTNodeTypeAsString(tNodeType) {
  let text = "";
  tNodeType & 1 && (text += "|Text");
  tNodeType & 2 && (text += "|Element");
  tNodeType & 4 && (text += "|Container");
  tNodeType & 8 && (text += "|ElementContainer");
  tNodeType & 16 && (text += "|Projection");
  tNodeType & 32 && (text += "|IcuContainer");
  tNodeType & 64 && (text += "|Placeholder");
  return text.length > 0 ? text.substring(1) : text;
}
function hasClassInput(tNode) {
  return (tNode.flags & 8) !== 0;
}
function hasStyleInput(tNode) {
  return (tNode.flags & 16) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
  assertDefined(tNode, "should be called with a TNode");
  if ((tNode.type & expectedTypes) === 0) {
    throwError2(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
  }
}
function assertPureTNodeType(type) {
  if (!(type === 2 || //
  type === 1 || //
  type === 4 || //
  type === 8 || //
  type === 32 || //
  type === 16 || //
  type === 64)) {
    throwError2(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
  }
}
function hasParentInjector(parentLocation) {
  return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
  if (ngDevMode) {
    assertNumber(parentLocation, "Number expected");
    assertNotEqual(parentLocation, -1, "Not a valid state.");
    const parentInjectorIndex = parentLocation & 32767;
    assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
  }
  return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
  return parentLocation >> 16;
}
function getParentInjectorView(location2, startView) {
  let viewOffset = getParentInjectorViewOffset(location2);
  let parentView = startView;
  while (viewOffset > 0) {
    parentView = parentView[DECLARATION_VIEW];
    viewOffset--;
  }
  return parentView;
}
var includeViewProviders = true;
function setIncludeViewProviders(v3) {
  const oldValue = includeViewProviders;
  includeViewProviders = v3;
  return oldValue;
}
var BLOOM_SIZE = 256;
var BLOOM_MASK = BLOOM_SIZE - 1;
var BLOOM_BUCKET_BITS = 5;
var nextNgElementId = 0;
var NOT_FOUND = {};
function bloomAdd(injectorIndex, tView, type) {
  ngDevMode && assertEqual(tView.firstCreatePass, true, "expected firstCreatePass to be true");
  let id;
  if (typeof type === "string") {
    id = type.charCodeAt(0) || 0;
  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
    id = type[NG_ELEMENT_ID];
  }
  if (id == null) {
    id = type[NG_ELEMENT_ID] = nextNgElementId++;
  }
  const bloomHash = id & BLOOM_MASK;
  const mask = 1 << bloomHash;
  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
  const existingInjectorIndex = getInjectorIndex(tNode, lView);
  if (existingInjectorIndex !== -1) {
    return existingInjectorIndex;
  }
  const tView = lView[TVIEW];
  if (tView.firstCreatePass) {
    tNode.injectorIndex = lView.length;
    insertBloom(tView.data, tNode);
    insertBloom(lView, null);
    insertBloom(tView.blueprint, null);
  }
  const parentLoc = getParentInjectorLocation(tNode, lView);
  const injectorIndex = tNode.injectorIndex;
  if (hasParentInjector(parentLoc)) {
    const parentIndex = getParentInjectorIndex(parentLoc);
    const parentLView = getParentInjectorView(parentLoc, lView);
    const parentData = parentLView[TVIEW].data;
    for (let i3 = 0; i3 < 8; i3++) {
      lView[injectorIndex + i3] = parentLView[parentIndex + i3] | parentData[parentIndex + i3];
    }
  }
  lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] = parentLoc;
  return injectorIndex;
}
function insertBloom(arr, footer) {
  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
  if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been
  // copied down from the parent node. No injector has been created yet on this node.
  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values
  // might not have been calculated yet for this instance
  lView[
    tNode.injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] === null) {
    return -1;
  } else {
    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
    return tNode.injectorIndex;
  }
}
function getParentInjectorLocation(tNode, lView) {
  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
    return tNode.parent.injectorIndex;
  }
  let declarationViewOffset = 0;
  let parentTNode = null;
  let lViewCursor = lView;
  while (lViewCursor !== null) {
    parentTNode = getTNodeFromLView(lViewCursor);
    if (parentTNode === null) {
      return NO_PARENT_INJECTOR;
    }
    ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
    declarationViewOffset++;
    lViewCursor = lViewCursor[DECLARATION_VIEW];
    if (parentTNode.injectorIndex !== -1) {
      return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
  }
  return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
  bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
  ngDevMode && assertTNodeType(
    tNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  ngDevMode && assertDefined(tNode, "expecting tNode");
  if (attrNameToInject === "class") {
    return tNode.classes;
  }
  if (attrNameToInject === "style") {
    return tNode.styles;
  }
  const attrs = tNode.attrs;
  if (attrs) {
    const attrsLength = attrs.length;
    let i3 = 0;
    while (i3 < attrsLength) {
      const value = attrs[i3];
      if (isNameOnlyAttributeMarker(value))
        break;
      if (value === 0) {
        i3 = i3 + 2;
      } else if (typeof value === "number") {
        i3++;
        while (i3 < attrsLength && typeof attrs[i3] === "string") {
          i3++;
        }
      } else if (value === attrNameToInject) {
        return attrs[i3 + 1];
      } else {
        i3 = i3 + 2;
      }
    }
  }
  return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
  if (flags & InjectFlags.Optional || notFoundValue !== void 0) {
    return notFoundValue;
  } else {
    throwProviderNotFoundError(token, "NodeInjector");
  }
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
  if (flags & InjectFlags.Optional && notFoundValue === void 0) {
    notFoundValue = null;
  }
  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
    const moduleInjector = lView[INJECTOR];
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (moduleInjector) {
        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
      } else {
        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
    }
  }
  return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
  if (tNode !== null) {
    if (lView[FLAGS] & 2048 && // The token must be present on the current node injector when the `Self`
    // flag is set, so the lookup on embedded view injector(s) can be skipped.
    !(flags & InjectFlags.Self)) {
      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
      if (embeddedInjectorValue !== NOT_FOUND) {
        return embeddedInjectorValue;
      }
    }
    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
    if (value !== NOT_FOUND) {
      return value;
    }
  }
  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
  const bloomHash = bloomHashBitOrFactory(token);
  if (typeof bloomHash === "function") {
    if (!enterDI(lView, tNode, flags)) {
      return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    try {
      let value;
      if (ngDevMode) {
        runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {
          value = bloomHash(flags);
          if (value != null) {
            emitInstanceCreatedByInjectorEvent(value);
          }
        });
      } else {
        value = bloomHash(flags);
      }
      if (value == null && !(flags & InjectFlags.Optional)) {
        throwProviderNotFoundError(token);
      } else {
        return value;
      }
    } finally {
      leaveDI();
    }
  } else if (typeof bloomHash === "number") {
    let previousTView = null;
    let injectorIndex = getInjectorIndex(tNode, lView);
    let parentLocation = NO_PARENT_INJECTOR;
    let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
    if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
        injectorIndex = -1;
      } else {
        previousTView = lView[TVIEW];
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      }
    }
    while (injectorIndex !== -1) {
      ngDevMode && assertNodeInjector(lView, injectorIndex);
      const tView = lView[TVIEW];
      ngDevMode && assertTNodeForLView(tView.data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ], lView);
      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
        if (instance !== NOT_FOUND) {
          return instance;
        }
      }
      parentLocation = lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
        previousTView = tView;
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      } else {
        injectorIndex = -1;
      }
    }
  }
  return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
  const currentTView = lView[TVIEW];
  const tNode = currentTView.data[
    injectorIndex + 8
    /* NodeInjectorOffset.TNODE */
  ];
  const canAccessViewProviders = previousTView == null ? (
    // 1) This is the first invocation `previousTView == null` which means that we are at the
    // `TNode` of where injector is starting to look. In such a case the only time we are allowed
    // to look into the ViewProviders is if:
    // - we are on a component
    // - AND the injector set `includeViewProviders` to true (implying that the token can see
    // ViewProviders because it is the Component or a Service which itself was declared in
    // ViewProviders)
    isComponentHost(tNode) && includeViewProviders
  ) : (
    // 2) `previousTView != null` which means that we are now walking across the parent nodes.
    // In such a case we are only allowed to look into the ViewProviders if:
    // - We just crossed from child View to Parent View `previousTView != currentTView`
    // - AND the parent TNode is an Element.
    // This means that we just came from the Component's View and therefore are allowed to see
    // into the ViewProviders.
    previousTView != currentTView && (tNode.type & 3) !== 0
  );
  const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
  if (injectableIdx !== null) {
    return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
  } else {
    return NOT_FOUND;
  }
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
  const nodeProviderIndexes = tNode.providerIndexes;
  const tInjectables = tView.data;
  const injectablesStart = nodeProviderIndexes & 1048575;
  const directivesStart = tNode.directiveStart;
  const directiveEnd = tNode.directiveEnd;
  const cptViewProvidersCount = nodeProviderIndexes >> 20;
  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
  for (let i3 = startingIndex; i3 < endIndex; i3++) {
    const providerTokenOrDef = tInjectables[i3];
    if (i3 < directivesStart && token === providerTokenOrDef || i3 >= directivesStart && providerTokenOrDef.type === token) {
      return i3;
    }
  }
  if (isHostSpecialCase) {
    const dirDef = tInjectables[directivesStart];
    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
      return directivesStart;
    }
  }
  return null;
}
function getNodeInjectable(lView, tView, index3, tNode) {
  let value = lView[index3];
  const tData = tView.data;
  if (isFactory(value)) {
    const factory = value;
    if (factory.resolving) {
      throwCyclicDependencyError(stringifyForError(tData[index3]));
    }
    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
    factory.resolving = true;
    let prevInjectContext;
    if (ngDevMode) {
      const token = tData[index3].type || tData[index3];
      const injector = new NodeInjector(tNode, lView);
      prevInjectContext = setInjectorProfilerContext({ injector, token });
    }
    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
    const success = enterDI(lView, tNode, InjectFlags.Default);
    ngDevMode && assertEqual(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
    try {
      value = lView[index3] = factory.factory(void 0, tData, lView, tNode);
      ngDevMode && emitInstanceCreatedByInjectorEvent(value);
      if (tView.firstCreatePass && index3 >= tNode.directiveStart) {
        ngDevMode && assertDirectiveDef(tData[index3]);
        registerPreOrderHooks(index3, tData[index3], tView);
      }
    } finally {
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
      setIncludeViewProviders(previousIncludeViewProviders);
      factory.resolving = false;
      leaveDI();
    }
  }
  return value;
}
function bloomHashBitOrFactory(token) {
  ngDevMode && assertDefined(token, "token must be defined");
  if (typeof token === "string") {
    return token.charCodeAt(0) || 0;
  }
  const tokenId = (
    // First check with `hasOwnProperty` so we don't get an inherited ID.
    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0
  );
  if (typeof tokenId === "number") {
    if (tokenId >= 0) {
      return tokenId & BLOOM_MASK;
    } else {
      ngDevMode && assertEqual(tokenId, -1, "Expecting to get Special Injector Id");
      return createNodeInjector;
    }
  } else {
    return tokenId;
  }
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
  const mask = 1 << bloomHash;
  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
  return !!(value & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
}
function getNodeInjectorLView(nodeInjector) {
  return nodeInjector._lView;
}
function getNodeInjectorTNode(nodeInjector) {
  return nodeInjector._tNode;
}
var NodeInjector = class {
  constructor(_tNode, _lView) {
    this._tNode = _tNode;
    this._lView = _lView;
  }
  get(token, notFoundValue, flags) {
    return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);
  }
};
function createNodeInjector() {
  return new NodeInjector(getCurrentTNode(), getLView());
}
function \u0275\u0275getInheritedFactory(type) {
  return noSideEffects(() => {
    const ownConstructor = type.prototype.constructor;
    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
    const objectPrototype = Object.prototype;
    let parent2 = Object.getPrototypeOf(type.prototype).constructor;
    while (parent2 && parent2 !== objectPrototype) {
      const factory = parent2[NG_FACTORY_DEF] || getFactoryOf(parent2);
      if (factory && factory !== ownFactory) {
        return factory;
      }
      parent2 = Object.getPrototypeOf(parent2);
    }
    return (t3) => new t3();
  });
}
function getFactoryOf(type) {
  if (isForwardRef(type)) {
    return () => {
      const factory = getFactoryOf(resolveForwardRef(type));
      return factory && factory();
    };
  }
  return getFactoryDef(type);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
  let currentTNode = tNode;
  let currentLView = lView;
  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 && !(currentLView[FLAGS] & 512)) {
    ngDevMode && assertTNodeForLView(currentTNode, currentLView);
    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);
    if (nodeInjectorValue !== NOT_FOUND) {
      return nodeInjectorValue;
    }
    let parentTNode = currentTNode.parent;
    if (!parentTNode) {
      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];
      if (embeddedViewInjector) {
        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
        if (embeddedViewInjectorValue !== NOT_FOUND) {
          return embeddedViewInjectorValue;
        }
      }
      parentTNode = getTNodeFromLView(currentLView);
      currentLView = currentLView[DECLARATION_VIEW];
    }
    currentTNode = parentTNode;
  }
  return notFoundValue;
}
function getTNodeFromLView(lView) {
  const tView = lView[TVIEW];
  const tViewType = tView.type;
  if (tViewType === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  } else if (tViewType === 1) {
    return lView[T_HOST];
  }
  return null;
}
function \u0275\u0275injectAttribute(attrNameToInject) {
  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
}
var Attribute = makeParamDecorator("Attribute", (attributeName) => ({
  attributeName,
  __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName)
}));
var _reflect = null;
function getReflect() {
  return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type) {
  return convertDependencies(getReflect().parameters(type));
}
function convertDependencies(deps) {
  return deps.map((dep) => reflectDependency(dep));
}
function reflectDependency(dep) {
  const meta = {
    token: null,
    attribute: null,
    host: false,
    optional: false,
    self: false,
    skipSelf: false
  };
  if (Array.isArray(dep) && dep.length > 0) {
    for (let j4 = 0; j4 < dep.length; j4++) {
      const param = dep[j4];
      if (param === void 0) {
        continue;
      }
      const proto = Object.getPrototypeOf(param);
      if (param instanceof Optional || proto.ngMetadataName === "Optional") {
        meta.optional = true;
      } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
        meta.skipSelf = true;
      } else if (param instanceof Self || proto.ngMetadataName === "Self") {
        meta.self = true;
      } else if (param instanceof Host || proto.ngMetadataName === "Host") {
        meta.host = true;
      } else if (param instanceof Inject) {
        meta.token = param.token;
      } else if (param instanceof Attribute) {
        if (param.attributeName === void 0) {
          throw new RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
        }
        meta.attribute = param.attributeName;
      } else {
        meta.token = param;
      }
    }
  } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
    meta.token = null;
  } else {
    meta.token = dep;
  }
  return meta;
}
function compileInjectable(type, meta) {
  let ngInjectableDef = null;
  let ngFactoryDef = null;
  if (!type.hasOwnProperty(NG_PROV_DEF)) {
    Object.defineProperty(type, NG_PROV_DEF, {
      get: () => {
        if (ngInjectableDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/\u0275prov.js`, getInjectableMetadata(type, meta));
        }
        return ngInjectableDef;
      }
    });
  }
  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/\u0275fac.js`, {
            name: type.name,
            type,
            typeArgumentCount: 0,
            // In JIT mode types are not available nor used.
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Injectable
          });
        }
        return ngFactoryDef;
      },
      // Leave this configurable so that the factories from directives or pipes can take precedence.
      configurable: true
    });
  }
}
var USE_VALUE = getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isUseClassProvider(meta) {
  return meta.useClass !== void 0;
}
function isUseValueProvider(meta) {
  return USE_VALUE in meta;
}
function isUseFactoryProvider(meta) {
  return meta.useFactory !== void 0;
}
function isUseExistingProvider(meta) {
  return meta.useExisting !== void 0;
}
function getInjectableMetadata(type, srcMeta) {
  const meta = srcMeta || { providedIn: null };
  const compilerMeta = {
    name: type.name,
    type,
    typeArgumentCount: 0,
    providedIn: meta.providedIn
  };
  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
    compilerMeta.deps = convertDependencies(meta.deps);
  }
  if (isUseClassProvider(meta)) {
    compilerMeta.useClass = meta.useClass;
  } else if (isUseValueProvider(meta)) {
    compilerMeta.useValue = meta.useValue;
  } else if (isUseFactoryProvider(meta)) {
    compilerMeta.useFactory = meta.useFactory;
  } else if (isUseExistingProvider(meta)) {
    compilerMeta.useExisting = meta.useExisting;
  }
  return compilerMeta;
}
var Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type, meta) => compileInjectable(type, meta));
function createInjector(defType, parent2 = null, additionalProviders = null, name) {
  const injector = createInjectorWithoutInjectorInstances(defType, parent2, additionalProviders, name);
  injector.resolveInjectorInitializers();
  return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent2 = null, additionalProviders = null, name, scopes = /* @__PURE__ */ new Set()) {
  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];
  name = name || (typeof defType === "object" ? void 0 : stringify(defType));
  return new R3Injector(providers, parent2 || getNullInjector(), name || null, scopes);
}
var _Injector = class _Injector {
  static create(options, parent2) {
    if (Array.isArray(options)) {
      return createInjector({ name: "" }, parent2, options, "");
    } else {
      const name = options.name ?? "";
      return createInjector({ name }, options.parent, options.providers, name);
    }
  }
};
_Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
_Injector.NULL = new NullInjector();
_Injector.\u0275prov = \u0275\u0275defineInjectable({
  token: _Injector,
  providedIn: "any",
  factory: () => \u0275\u0275inject(INJECTOR$1)
});
_Injector.__NG_ELEMENT_ID__ = -1;
var Injector = _Injector;
var HOST_TAG_NAME = new InjectionToken(ngDevMode ? "HOST_TAG_NAME" : "");
HOST_TAG_NAME.__NG_ELEMENT_ID__ = (flags) => {
  const tNode = getCurrentTNode();
  if (tNode === null) {
    throw new RuntimeError(204, ngDevMode && "HOST_TAG_NAME can only be injected in directives and components during construction time (in a class constructor or as a class field initializer)");
  }
  if (tNode.type & 2) {
    return tNode.value;
  }
  if (flags & InjectFlags.Optional) {
    return null;
  }
  throw new RuntimeError(204, ngDevMode && `HOST_TAG_NAME was used on ${getDevModeNodeName(tNode)} which doesn't have an underlying element in the DOM. This is invalid, and so the dependency should be marked as optional.`);
};
function getDevModeNodeName(tNode) {
  if (tNode.type & 8) {
    return "an <ng-container>";
  } else if (tNode.type & 4) {
    return "an <ng-template>";
  } else {
    return "a node";
  }
}
var ERROR_ORIGINAL_ERROR = "ngOriginalError";
function getOriginalError(error) {
  return error[ERROR_ORIGINAL_ERROR];
}
var ErrorHandler = class {
  constructor() {
    this._console = console;
  }
  handleError(error) {
    const originalError = this._findOriginalError(error);
    this._console.error("ERROR", error);
    if (originalError) {
      this._console.error("ORIGINAL ERROR", originalError);
    }
  }
  /** @internal */
  _findOriginalError(error) {
    let e3 = error && getOriginalError(error);
    while (e3 && getOriginalError(e3)) {
      e3 = getOriginalError(e3);
    }
    return e3 || null;
  }
};
var INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "internal error handler" : "", {
  providedIn: "root",
  factory: () => {
    const userErrorHandler = inject(ErrorHandler);
    return userErrorHandler.handleError.bind(void 0);
  }
});
var _DestroyRef = class _DestroyRef {
};
_DestroyRef.__NG_ELEMENT_ID__ = injectDestroyRef;
_DestroyRef.__NG_ENV_ID__ = (injector) => injector;
var DestroyRef = _DestroyRef;
var NodeInjectorDestroyRef = class extends DestroyRef {
  constructor(_lView) {
    super();
    this._lView = _lView;
  }
  onDestroy(callback) {
    storeLViewOnDestroy(this._lView, callback);
    return () => removeLViewOnDestroy(this._lView, callback);
  }
};
function injectDestroyRef() {
  return new NodeInjectorDestroyRef(getLView());
}
var OutputEmitterRef = class {
  constructor() {
    this.destroyed = false;
    this.listeners = null;
    this.errorHandler = inject(ErrorHandler, { optional: true });
    this.destroyRef = inject(DestroyRef);
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
      this.listeners = null;
    });
  }
  subscribe(callback) {
    if (this.destroyed) {
      throw new RuntimeError(953, ngDevMode && "Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");
    }
    (this.listeners ??= []).push(callback);
    return {
      unsubscribe: () => {
        const idx = this.listeners?.indexOf(callback);
        if (idx !== void 0 && idx !== -1) {
          this.listeners?.splice(idx, 1);
        }
      }
    };
  }
  /** Emits a new value to the output. */
  emit(value) {
    if (this.destroyed) {
      throw new RuntimeError(953, ngDevMode && "Unexpected emit for destroyed `OutputRef`. The owning directive/component is destroyed.");
    }
    if (this.listeners === null) {
      return;
    }
    const previousConsumer = setActiveConsumer(null);
    try {
      for (const listenerFn of this.listeners) {
        try {
          listenerFn(value);
        } catch (err) {
          this.errorHandler?.handleError(err);
        }
      }
    } finally {
      setActiveConsumer(previousConsumer);
    }
  }
};
function inputFunction(initialValue, opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(initialValue, opts);
}
function inputRequiredFunction(opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
var input = (() => {
  inputFunction.required = inputRequiredFunction;
  return inputFunction;
})();
function injectElementRef() {
  return createElementRef(getCurrentTNode(), getLView());
}
function createElementRef(tNode, lView) {
  return new ElementRef(getNativeByTNode(tNode, lView));
}
var _ElementRef = class _ElementRef {
  constructor(nativeElement) {
    this.nativeElement = nativeElement;
  }
};
_ElementRef.__NG_ELEMENT_ID__ = injectElementRef;
var ElementRef = _ElementRef;
function unwrapElementRef(value) {
  return value instanceof ElementRef ? value.nativeElement : value;
}
var EventEmitter_ = class extends Subject {
  constructor(isAsync = false) {
    super();
    this.destroyRef = void 0;
    this.__isAsync = isAsync;
    if (isInInjectionContext()) {
      this.destroyRef = inject(DestroyRef, { optional: true }) ?? void 0;
    }
  }
  emit(value) {
    const prevConsumer = setActiveConsumer(null);
    try {
      super.next(value);
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
  subscribe(observerOrNext, error, complete) {
    let nextFn = observerOrNext;
    let errorFn = error || (() => null);
    let completeFn = complete;
    if (observerOrNext && typeof observerOrNext === "object") {
      const observer = observerOrNext;
      nextFn = observer.next?.bind(observer);
      errorFn = observer.error?.bind(observer);
      completeFn = observer.complete?.bind(observer);
    }
    if (this.__isAsync) {
      errorFn = _wrapInTimeout(errorFn);
      if (nextFn) {
        nextFn = _wrapInTimeout(nextFn);
      }
      if (completeFn) {
        completeFn = _wrapInTimeout(completeFn);
      }
    }
    const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });
    if (observerOrNext instanceof Subscription) {
      observerOrNext.add(sink);
    }
    return sink;
  }
};
function _wrapInTimeout(fn) {
  return (value) => {
    setTimeout(fn, void 0, value);
  };
}
var EventEmitter = EventEmitter_;
function symbolIterator() {
  return this._results[Symbol.iterator]();
}
var _QueryList = class _QueryList {
  /**
   * Returns `Observable` of `QueryList` notifying the subscriber of changes.
   */
  get changes() {
    return this._changes ??= new EventEmitter();
  }
  /**
   * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change
   *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in
   *     the same result)
   */
  constructor(_emitDistinctChangesOnly = false) {
    this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
    this.dirty = true;
    this._onDirty = void 0;
    this._results = [];
    this._changesDetected = false;
    this._changes = void 0;
    this.length = 0;
    this.first = void 0;
    this.last = void 0;
    const proto = _QueryList.prototype;
    if (!proto[Symbol.iterator])
      proto[Symbol.iterator] = symbolIterator;
  }
  /**
   * Returns the QueryList entry at `index`.
   */
  get(index3) {
    return this._results[index3];
  }
  /**
   * See
   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
   */
  map(fn) {
    return this._results.map(fn);
  }
  filter(fn) {
    return this._results.filter(fn);
  }
  /**
   * See
   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
   */
  find(fn) {
    return this._results.find(fn);
  }
  /**
   * See
   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
   */
  reduce(fn, init) {
    return this._results.reduce(fn, init);
  }
  /**
   * See
   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
   */
  forEach(fn) {
    this._results.forEach(fn);
  }
  /**
   * See
   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
   */
  some(fn) {
    return this._results.some(fn);
  }
  /**
   * Returns a copy of the internal results list as an Array.
   */
  toArray() {
    return this._results.slice();
  }
  toString() {
    return this._results.toString();
  }
  /**
   * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that
   * on change detection, it will not notify of changes to the queries, unless a new change
   * occurs.
   *
   * @param resultsTree The query results to store
   * @param identityAccessor Optional function for extracting stable object identity from a value
   *    in the array. This function is executed for each element of the query result list while
   *    comparing current query list with the new one (provided as a first argument of the `reset`
   *    function) to detect if the lists are different. If the function is not provided, elements
   *    are compared as is (without any pre-processing).
   */
  reset(resultsTree, identityAccessor) {
    this.dirty = false;
    const newResultFlat = flatten(resultsTree);
    if (this._changesDetected = !arrayEquals(this._results, newResultFlat, identityAccessor)) {
      this._results = newResultFlat;
      this.length = newResultFlat.length;
      this.last = newResultFlat[this.length - 1];
      this.first = newResultFlat[0];
    }
  }
  /**
   * Triggers a change event by emitting on the `changes` {@link EventEmitter}.
   */
  notifyOnChanges() {
    if (this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly))
      this._changes.emit(this);
  }
  /** @internal */
  onDirty(cb) {
    this._onDirty = cb;
  }
  /** internal */
  setDirty() {
    this.dirty = true;
    this._onDirty?.();
  }
  /** internal */
  destroy() {
    if (this._changes !== void 0) {
      this._changes.complete();
      this._changes.unsubscribe();
    }
  }
};
Symbol.iterator;
var QueryList = _QueryList;
function hasInSkipHydrationBlockFlag(tNode) {
  return (tNode.flags & 128) === 128;
}
var TRACKED_LVIEWS = /* @__PURE__ */ new Map();
var uniqueIdCounter = 0;
function getUniqueLViewId() {
  return uniqueIdCounter++;
}
function registerLView(lView) {
  ngDevMode && assertNumber(lView[ID], "LView must have an ID in order to be registered");
  TRACKED_LVIEWS.set(lView[ID], lView);
}
function getLViewById(id) {
  ngDevMode && assertNumber(id, "ID used for LView lookup must be a number");
  return TRACKED_LVIEWS.get(id) || null;
}
function unregisterLView(lView) {
  ngDevMode && assertNumber(lView[ID], "Cannot stop tracking an LView that does not have an ID");
  TRACKED_LVIEWS.delete(lView[ID]);
}
var LContext = class {
  /** Component's parent view data. */
  get lView() {
    return getLViewById(this.lViewId);
  }
  constructor(lViewId, nodeIndex, native) {
    this.lViewId = lViewId;
    this.nodeIndex = nodeIndex;
    this.native = native;
  }
};
function getLContext(target) {
  let mpValue = readPatchedData(target);
  if (mpValue) {
    if (isLView(mpValue)) {
      const lView = mpValue;
      let nodeIndex;
      let component = void 0;
      let directives = void 0;
      if (isComponentInstance(target)) {
        nodeIndex = findViaComponent(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided component was not found in the application");
        }
        component = target;
      } else if (isDirectiveInstance(target)) {
        nodeIndex = findViaDirective(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided directive was not found in the application");
        }
        directives = getDirectivesAtNodeIndex(nodeIndex, lView);
      } else {
        nodeIndex = findViaNativeElement(lView, target);
        if (nodeIndex == -1) {
          return null;
        }
      }
      const native = unwrapRNode(lView[nodeIndex]);
      const existingCtx = readPatchedData(native);
      const context2 = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
      if (component && context2.component === void 0) {
        context2.component = component;
        attachPatchData(context2.component, context2);
      }
      if (directives && context2.directives === void 0) {
        context2.directives = directives;
        for (let i3 = 0; i3 < directives.length; i3++) {
          attachPatchData(directives[i3], context2);
        }
      }
      attachPatchData(context2.native, context2);
      mpValue = context2;
    }
  } else {
    const rElement = target;
    ngDevMode && assertDomNode(rElement);
    let parent2 = rElement;
    while (parent2 = parent2.parentNode) {
      const parentContext = readPatchedData(parent2);
      if (parentContext) {
        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
        if (!lView) {
          return null;
        }
        const index3 = findViaNativeElement(lView, rElement);
        if (index3 >= 0) {
          const native = unwrapRNode(lView[index3]);
          const context2 = createLContext(lView, index3, native);
          attachPatchData(native, context2);
          mpValue = context2;
          break;
        }
      }
    }
  }
  return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
  return new LContext(lView[ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
  let patchedData = readPatchedData(componentInstance);
  let lView;
  if (isLView(patchedData)) {
    const contextLView = patchedData;
    const nodeIndex = findViaComponent(contextLView, componentInstance);
    lView = getComponentLViewByIndex(nodeIndex, contextLView);
    const context2 = createLContext(contextLView, nodeIndex, lView[HOST]);
    context2.component = componentInstance;
    attachPatchData(componentInstance, context2);
    attachPatchData(context2.native, context2);
  } else {
    const context2 = patchedData;
    const contextLView = context2.lView;
    ngDevMode && assertLView(contextLView);
    lView = getComponentLViewByIndex(context2.nodeIndex, contextLView);
  }
  return lView;
}
var MONKEY_PATCH_KEY_NAME = "__ngContext__";
function attachPatchData(target, data) {
  ngDevMode && assertDefined(target, "Target expected");
  if (isLView(data)) {
    target[MONKEY_PATCH_KEY_NAME] = data[ID];
    registerLView(data);
  } else {
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
}
function readPatchedData(target) {
  ngDevMode && assertDefined(target, "Target expected");
  const data = target[MONKEY_PATCH_KEY_NAME];
  return typeof data === "number" ? getLViewById(data) : data || null;
}
function readPatchedLView(target) {
  const value = readPatchedData(target);
  if (value) {
    return isLView(value) ? value : value.lView;
  }
  return null;
}
function isComponentInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275cmp;
}
function isDirectiveInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275dir;
}
function findViaNativeElement(lView, target) {
  const tView = lView[TVIEW];
  for (let i3 = HEADER_OFFSET; i3 < tView.bindingStartIndex; i3++) {
    if (unwrapRNode(lView[i3]) === target) {
      return i3;
    }
  }
  return -1;
}
function traverseNextElement(tNode) {
  if (tNode.child) {
    return tNode.child;
  } else if (tNode.next) {
    return tNode.next;
  } else {
    while (tNode.parent && !tNode.parent.next) {
      tNode = tNode.parent;
    }
    return tNode.parent && tNode.parent.next;
  }
}
function findViaComponent(lView, componentInstance) {
  const componentIndices = lView[TVIEW].components;
  if (componentIndices) {
    for (let i3 = 0; i3 < componentIndices.length; i3++) {
      const elementComponentIndex = componentIndices[i3];
      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
      if (componentView[CONTEXT] === componentInstance) {
        return elementComponentIndex;
      }
    }
  } else {
    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
    const rootComponent = rootComponentView[CONTEXT];
    if (rootComponent === componentInstance) {
      return HEADER_OFFSET;
    }
  }
  return -1;
}
function findViaDirective(lView, directiveInstance) {
  let tNode = lView[TVIEW].firstChild;
  while (tNode) {
    const directiveIndexStart = tNode.directiveStart;
    const directiveIndexEnd = tNode.directiveEnd;
    for (let i3 = directiveIndexStart; i3 < directiveIndexEnd; i3++) {
      if (lView[i3] === directiveInstance) {
        return tNode.index;
      }
    }
    tNode = traverseNextElement(tNode);
  }
  return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  if (tNode.directiveStart === 0)
    return EMPTY_ARRAY;
  const results = [];
  for (let i3 = tNode.directiveStart; i3 < tNode.directiveEnd; i3++) {
    const directiveInstance = lView[i3];
    if (!isComponentInstance(directiveInstance)) {
      results.push(directiveInstance);
    }
  }
  return results;
}
function getComponentAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  const { directiveStart, componentOffset } = tNode;
  return componentOffset > -1 ? lView[directiveStart + componentOffset] : null;
}
function getRootView(componentOrLView) {
  ngDevMode && assertDefined(componentOrLView, "component");
  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
  while (lView && !(lView[FLAGS] & 512)) {
    lView = getLViewParent(lView);
  }
  ngDevMode && assertLView(lView);
  return lView;
}
function getRootContext(viewOrComponent) {
  const rootView = getRootView(viewOrComponent);
  ngDevMode && assertDefined(rootView[CONTEXT], "Root view has no context. Perhaps it is disconnected?");
  return rootView[CONTEXT];
}
function getFirstLContainer(lView) {
  return getNearestLContainer(lView[CHILD_HEAD]);
}
function getNextLContainer(container) {
  return getNearestLContainer(container[NEXT]);
}
function getNearestLContainer(viewOrContainer) {
  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
    viewOrContainer = viewOrContainer[NEXT];
  }
  return viewOrContainer;
}
function getComponent$1(element) {
  ngDevMode && assertDomElement(element);
  const context2 = getLContext(element);
  if (context2 === null)
    return null;
  if (context2.component === void 0) {
    const lView = context2.lView;
    if (lView === null) {
      return null;
    }
    context2.component = getComponentAtNodeIndex(context2.nodeIndex, lView);
  }
  return context2.component;
}
function getContext(element) {
  assertDomElement(element);
  const context2 = getLContext(element);
  const lView = context2 ? context2.lView : null;
  return lView === null ? null : lView[CONTEXT];
}
function getOwningComponent(elementOrDir) {
  const context2 = getLContext(elementOrDir);
  let lView = context2 ? context2.lView : null;
  if (lView === null)
    return null;
  let parent2;
  while (lView[TVIEW].type === 2 && (parent2 = getLViewParent(lView))) {
    lView = parent2;
  }
  return lView[FLAGS] & 512 ? null : lView[CONTEXT];
}
function getRootComponents(elementOrDir) {
  const lView = readPatchedLView(elementOrDir);
  return lView !== null ? [getRootContext(lView)] : [];
}
function getInjector(elementOrDir) {
  const context2 = getLContext(elementOrDir);
  const lView = context2 ? context2.lView : null;
  if (lView === null)
    return Injector.NULL;
  const tNode = lView[TVIEW].data[context2.nodeIndex];
  return new NodeInjector(tNode, lView);
}
function getDirectives(node) {
  if (node instanceof Text) {
    return [];
  }
  const context2 = getLContext(node);
  const lView = context2 ? context2.lView : null;
  if (lView === null) {
    return [];
  }
  const tView = lView[TVIEW];
  const nodeIndex = context2.nodeIndex;
  if (!tView?.data[nodeIndex]) {
    return [];
  }
  if (context2.directives === void 0) {
    context2.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
  }
  return context2.directives === null ? [] : [...context2.directives];
}
function getDirectiveMetadata$1(directiveOrComponentInstance) {
  const { constructor } = directiveOrComponentInstance;
  if (!constructor) {
    throw new Error("Unable to find the instance constructor");
  }
  const componentDef = getComponentDef(constructor);
  if (componentDef) {
    const inputs = extractInputDebugMetadata(componentDef.inputs);
    return {
      inputs,
      outputs: componentDef.outputs,
      encapsulation: componentDef.encapsulation,
      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
  }
  const directiveDef = getDirectiveDef(constructor);
  if (directiveDef) {
    const inputs = extractInputDebugMetadata(directiveDef.inputs);
    return { inputs, outputs: directiveDef.outputs };
  }
  return null;
}
function getHostElement(componentOrDirective) {
  return getLContext(componentOrDirective).native;
}
function getListeners(element) {
  ngDevMode && assertDomElement(element);
  const lContext = getLContext(element);
  const lView = lContext === null ? null : lContext.lView;
  if (lView === null)
    return [];
  const tView = lView[TVIEW];
  const lCleanup = lView[CLEANUP];
  const tCleanup = tView.cleanup;
  const listeners = [];
  if (tCleanup && lCleanup) {
    for (let i3 = 0; i3 < tCleanup.length; ) {
      const firstParam = tCleanup[i3++];
      const secondParam = tCleanup[i3++];
      if (typeof firstParam === "string") {
        const name = firstParam;
        const listenerElement = unwrapRNode(lView[secondParam]);
        const callback = lCleanup[tCleanup[i3++]];
        const useCaptureOrIndx = tCleanup[i3++];
        const type = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
        const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
        if (element == listenerElement) {
          listeners.push({ element, name, callback, useCapture, type });
        }
      }
    }
  }
  listeners.sort(sortListeners);
  return listeners;
}
function sortListeners(a3, b3) {
  if (a3.name == b3.name)
    return 0;
  return a3.name < b3.name ? -1 : 1;
}
function assertDomElement(value) {
  if (typeof Element !== "undefined" && !(value instanceof Element)) {
    throw new Error("Expecting instance of DOM Element");
  }
}
function extractInputDebugMetadata(inputs) {
  const res = {};
  for (const key in inputs) {
    if (!inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = inputs[key];
    if (value === void 0) {
      continue;
    }
    let minifiedName;
    if (Array.isArray(value)) {
      minifiedName = value[0];
    } else {
      minifiedName = value;
    }
    res[key] = minifiedName;
  }
  return res;
}
var DOCUMENT = void 0;
function setDocument(document2) {
  DOCUMENT = document2;
}
function getDocument() {
  if (DOCUMENT !== void 0) {
    return DOCUMENT;
  } else if (typeof document !== "undefined") {
    return document;
  }
  throw new RuntimeError(210, (typeof ngDevMode === "undefined" || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);
}
var APP_ID = new InjectionToken(ngDevMode ? "AppId" : "", {
  providedIn: "root",
  factory: () => DEFAULT_APP_ID
});
var DEFAULT_APP_ID = "ng";
var PLATFORM_INITIALIZER = new InjectionToken(ngDevMode ? "Platform Initializer" : "");
var PLATFORM_ID = new InjectionToken(ngDevMode ? "Platform ID" : "", {
  providedIn: "platform",
  factory: () => "unknown"
  // set a default platform name, when none set explicitly
});
var PACKAGE_ROOT_URL = new InjectionToken(ngDevMode ? "Application Packages Root URL" : "");
var ANIMATION_MODULE_TYPE = new InjectionToken(ngDevMode ? "AnimationModuleType" : "");
var CSP_NONCE = new InjectionToken(ngDevMode ? "CSP nonce" : "", {
  providedIn: "root",
  factory: () => {
    return getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null;
  }
});
var IMAGE_CONFIG_DEFAULTS = {
  breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  placeholderResolution: 30,
  disableImageSizeWarning: false,
  disableImageLazyLoadWarning: false
};
var IMAGE_CONFIG = new InjectionToken(ngDevMode ? "ImageConfig" : "", {
  providedIn: "root",
  factory: () => IMAGE_CONFIG_DEFAULTS
});
function makeStateKey(key) {
  return key;
}
function initTransferState() {
  const transferState = new TransferState();
  if (inject(PLATFORM_ID) === "browser") {
    transferState.store = retrieveTransferredState(getDocument(), inject(APP_ID));
  }
  return transferState;
}
var _TransferState = class _TransferState {
  constructor() {
    this.store = {};
    this.onSerializeCallbacks = {};
  }
  /**
   * Get the value corresponding to a key. Return `defaultValue` if key is not found.
   */
  get(key, defaultValue) {
    return this.store[key] !== void 0 ? this.store[key] : defaultValue;
  }
  /**
   * Set the value corresponding to a key.
   */
  set(key, value) {
    this.store[key] = value;
  }
  /**
   * Remove a key from the store.
   */
  remove(key) {
    delete this.store[key];
  }
  /**
   * Test whether a key exists in the store.
   */
  hasKey(key) {
    return this.store.hasOwnProperty(key);
  }
  /**
   * Indicates whether the state is empty.
   */
  get isEmpty() {
    return Object.keys(this.store).length === 0;
  }
  /**
   * Register a callback to provide the value for a key when `toJson` is called.
   */
  onSerialize(key, callback) {
    this.onSerializeCallbacks[key] = callback;
  }
  /**
   * Serialize the current state of the store to JSON.
   */
  toJson() {
    for (const key in this.onSerializeCallbacks) {
      if (this.onSerializeCallbacks.hasOwnProperty(key)) {
        try {
          this.store[key] = this.onSerializeCallbacks[key]();
        } catch (e3) {
          console.warn("Exception in onSerialize callback: ", e3);
        }
      }
    }
    return JSON.stringify(this.store).replace(/</g, "\\u003C");
  }
};
_TransferState.\u0275prov = \u0275\u0275defineInjectable({
  token: _TransferState,
  providedIn: "root",
  factory: initTransferState
});
var TransferState = _TransferState;
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + "-state");
  if (script?.textContent) {
    try {
      return JSON.parse(script.textContent);
    } catch (e3) {
      console.warn("Exception while restoring TransferState for app " + appId, e3);
    }
  }
  return {};
}
var REFERENCE_NODE_HOST = "h";
var REFERENCE_NODE_BODY = "b";
var NodeNavigationStep;
(function(NodeNavigationStep2) {
  NodeNavigationStep2["FirstChild"] = "f";
  NodeNavigationStep2["NextSibling"] = "n";
})(NodeNavigationStep || (NodeNavigationStep = {}));
var TRANSFER_STATE_TOKEN_ID = "__nghData__";
var NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
var _retrieveHydrationInfoImpl = () => null;
function retrieveHydrationInfo(rNode, injector, isRootView2 = false) {
  return _retrieveHydrationInfoImpl(rNode, injector, isRootView2);
}
var HydrationStatus;
(function(HydrationStatus2) {
  HydrationStatus2["Hydrated"] = "hydrated";
  HydrationStatus2["Skipped"] = "skipped";
  HydrationStatus2["Mismatched"] = "mismatched";
})(HydrationStatus || (HydrationStatus = {}));
var IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_HYDRATION_DOM_REUSE_ENABLED" : "");
var PRESERVE_HOST_CONTENT_DEFAULT = false;
var PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "PRESERVE_HOST_CONTENT" : "", {
  providedIn: "root",
  factory: () => PRESERVE_HOST_CONTENT_DEFAULT
});
var IS_I18N_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_I18N_HYDRATION_ENABLED" : "");
var IS_EVENT_REPLAY_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_EVENT_REPLAY_ENABLED" : "");
var policy$1;
function getPolicy$1() {
  if (policy$1 === void 0) {
    policy$1 = null;
    if (_global.trustedTypes) {
      try {
        policy$1 = _global.trustedTypes.createPolicy("angular", {
          createHTML: (s3) => s3,
          createScript: (s3) => s3,
          createScriptURL: (s3) => s3
        });
      } catch {
      }
    }
  }
  return policy$1;
}
function trustedHTMLFromString(html) {
  return getPolicy$1()?.createHTML(html) || html;
}
function trustedScriptURLFromString(url) {
  return getPolicy$1()?.createScriptURL(url) || url;
}
var policy;
function getPolicy() {
  if (policy === void 0) {
    policy = null;
    if (_global.trustedTypes) {
      try {
        policy = _global.trustedTypes.createPolicy("angular#unsafe-bypass", {
          createHTML: (s3) => s3,
          createScript: (s3) => s3,
          createScriptURL: (s3) => s3
        });
      } catch {
      }
    }
  }
  return policy;
}
function trustedHTMLFromStringBypass(html) {
  return getPolicy()?.createHTML(html) || html;
}
function trustedScriptFromStringBypass(script) {
  return getPolicy()?.createScript(script) || script;
}
function trustedScriptURLFromStringBypass(url) {
  return getPolicy()?.createScriptURL(url) || url;
}
var SafeValueImpl = class {
  constructor(changingThisBreaksApplicationSecurity) {
    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
  }
  toString() {
    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${XSS_SECURITY_URL})`;
  }
};
var SafeHtmlImpl = class extends SafeValueImpl {
  getTypeName() {
    return "HTML";
  }
};
var SafeStyleImpl = class extends SafeValueImpl {
  getTypeName() {
    return "Style";
  }
};
var SafeScriptImpl = class extends SafeValueImpl {
  getTypeName() {
    return "Script";
  }
};
var SafeUrlImpl = class extends SafeValueImpl {
  getTypeName() {
    return "URL";
  }
};
var SafeResourceUrlImpl = class extends SafeValueImpl {
  getTypeName() {
    return "ResourceURL";
  }
};
function unwrapSafeValue(value) {
  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
}
function allowSanitizationBypassAndThrow(value, type) {
  const actualType = getSanitizationBypassType(value);
  if (actualType != null && actualType !== type) {
    if (actualType === "ResourceURL" && type === "URL")
      return true;
    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);
  }
  return actualType === type;
}
function getSanitizationBypassType(value) {
  return value instanceof SafeValueImpl && value.getTypeName() || null;
}
function bypassSanitizationTrustHtml(trustedHtml) {
  return new SafeHtmlImpl(trustedHtml);
}
function bypassSanitizationTrustStyle(trustedStyle) {
  return new SafeStyleImpl(trustedStyle);
}
function bypassSanitizationTrustScript(trustedScript) {
  return new SafeScriptImpl(trustedScript);
}
function bypassSanitizationTrustUrl(trustedUrl) {
  return new SafeUrlImpl(trustedUrl);
}
function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
  return new SafeResourceUrlImpl(trustedResourceUrl);
}
function getInertBodyHelper(defaultDoc) {
  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
var DOMParserHelper = class {
  constructor(inertDocumentHelper) {
    this.inertDocumentHelper = inertDocumentHelper;
  }
  getInertBodyElement(html) {
    html = "<body><remove></remove>" + html;
    try {
      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), "text/html").body;
      if (body === null) {
        return this.inertDocumentHelper.getInertBodyElement(html);
      }
      body.removeChild(body.firstChild);
      return body;
    } catch {
      return null;
    }
  }
};
var InertDocumentHelper = class {
  constructor(defaultDoc) {
    this.defaultDoc = defaultDoc;
    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
  }
  getInertBodyElement(html) {
    const templateEl = this.inertDocument.createElement("template");
    templateEl.innerHTML = trustedHTMLFromString(html);
    return templateEl;
  }
};
function isDOMParserAvailable() {
  try {
    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
  } catch {
    return false;
  }
}
var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
function _sanitizeUrl(url) {
  url = String(url);
  if (url.match(SAFE_URL_PATTERN))
    return url;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);
  }
  return "unsafe:" + url;
}
function tagSet(tags) {
  const res = {};
  for (const t3 of tags.split(","))
    res[t3] = true;
  return res;
}
function merge(...sets) {
  const res = {};
  for (const s3 of sets) {
    for (const v3 in s3) {
      if (s3.hasOwnProperty(v3))
        res[v3] = true;
    }
  }
  return res;
}
var VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
var URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
var HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
var ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
var VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
var SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
var SanitizingHtmlSerializer = class {
  constructor() {
    this.sanitizedSomething = false;
    this.buf = [];
  }
  sanitizeChildren(el) {
    let current = el.firstChild;
    let traverseContent = true;
    let parentNodes = [];
    while (current) {
      if (current.nodeType === Node.ELEMENT_NODE) {
        traverseContent = this.startElement(current);
      } else if (current.nodeType === Node.TEXT_NODE) {
        this.chars(current.nodeValue);
      } else {
        this.sanitizedSomething = true;
      }
      if (traverseContent && current.firstChild) {
        parentNodes.push(current);
        current = getFirstChild(current);
        continue;
      }
      while (current) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          this.endElement(current);
        }
        let next = getNextSibling(current);
        if (next) {
          current = next;
          break;
        }
        current = parentNodes.pop();
      }
    }
    return this.buf.join("");
  }
  /**
   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should
   * be traversed. Element content must always be traversed (even if the element itself is not
   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.
   *
   * @param element The element to sanitize.
   * @return True if the element's contents should be traversed.
   */
  startElement(element) {
    const tagName = getNodeName(element).toLowerCase();
    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
      this.sanitizedSomething = true;
      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
    }
    this.buf.push("<");
    this.buf.push(tagName);
    const elAttrs = element.attributes;
    for (let i3 = 0; i3 < elAttrs.length; i3++) {
      const elAttr = elAttrs.item(i3);
      const attrName = elAttr.name;
      const lower = attrName.toLowerCase();
      if (!VALID_ATTRS.hasOwnProperty(lower)) {
        this.sanitizedSomething = true;
        continue;
      }
      let value = elAttr.value;
      if (URI_ATTRS[lower])
        value = _sanitizeUrl(value);
      this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
    }
    this.buf.push(">");
    return true;
  }
  endElement(current) {
    const tagName = getNodeName(current).toLowerCase();
    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
      this.buf.push("</");
      this.buf.push(tagName);
      this.buf.push(">");
    }
  }
  chars(chars) {
    this.buf.push(encodeEntities(chars));
  }
};
function isClobberedElement(parentNode, childNode) {
  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
}
function getNextSibling(node) {
  const nextSibling = node.nextSibling;
  if (nextSibling && node !== nextSibling.previousSibling) {
    throw clobberedElementError(nextSibling);
  }
  return nextSibling;
}
function getFirstChild(node) {
  const firstChild = node.firstChild;
  if (firstChild && isClobberedElement(node, firstChild)) {
    throw clobberedElementError(firstChild);
  }
  return firstChild;
}
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === "string" ? nodeName : "FORM";
}
function clobberedElementError(node) {
  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
}
var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
function encodeEntities(value) {
  return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match2) {
    const hi = match2.charCodeAt(0);
    const low = match2.charCodeAt(1);
    return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
  }).replace(NON_ALPHANUMERIC_REGEXP, function(match2) {
    return "&#" + match2.charCodeAt(0) + ";";
  }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var inertBodyHelper;
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
  let inertBodyElement = null;
  try {
    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    let mXSSAttempts = 5;
    let parsedHtml = unsafeHtml;
    do {
      if (mXSSAttempts === 0) {
        throw new Error("Failed to sanitize html because the input is unstable");
      }
      mXSSAttempts--;
      unsafeHtml = parsedHtml;
      parsedHtml = inertBodyElement.innerHTML;
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    } while (unsafeHtml !== parsedHtml);
    const sanitizer = new SanitizingHtmlSerializer();
    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && sanitizer.sanitizedSomething) {
      console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);
    }
    return trustedHTMLFromString(safeHtml);
  } finally {
    if (inertBodyElement) {
      const parent2 = getTemplateContent(inertBodyElement) || inertBodyElement;
      while (parent2.firstChild) {
        parent2.removeChild(parent2.firstChild);
      }
    }
  }
}
function getTemplateContent(el) {
  return "content" in el && isTemplateElement(el) ? el.content : null;
}
function isTemplateElement(el) {
  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
}
var SecurityContext;
(function(SecurityContext2) {
  SecurityContext2[SecurityContext2["NONE"] = 0] = "NONE";
  SecurityContext2[SecurityContext2["HTML"] = 1] = "HTML";
  SecurityContext2[SecurityContext2["STYLE"] = 2] = "STYLE";
  SecurityContext2[SecurityContext2["SCRIPT"] = 3] = "SCRIPT";
  SecurityContext2[SecurityContext2["URL"] = 4] = "URL";
  SecurityContext2[SecurityContext2["RESOURCE_URL"] = 5] = "RESOURCE_URL";
})(SecurityContext || (SecurityContext = {}));
function \u0275\u0275sanitizeHtml(unsafeHtml) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeHtml,
    "HTML"
    /* BypassType.Html */
  )) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
}
function \u0275\u0275sanitizeStyle(unsafeStyle) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeStyle,
    "Style"
    /* BypassType.Style */
  )) {
    return unwrapSafeValue(unsafeStyle);
  }
  return renderStringify(unsafeStyle);
}
function \u0275\u0275sanitizeUrl(unsafeUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeUrl,
    "URL"
    /* BypassType.Url */
  )) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl(renderStringify(unsafeUrl));
}
function \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeResourceUrl,
    "ResourceURL"
    /* BypassType.ResourceUrl */
  )) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
}
function \u0275\u0275sanitizeScript(unsafeScript) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeScript,
    "Script"
    /* BypassType.Script */
  )) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new RuntimeError(905, ngDevMode && "unsafe value used in a script context");
}
function \u0275\u0275trustConstantHtml(html) {
  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
  }
  return trustedHTMLFromString(html[0]);
}
function \u0275\u0275trustConstantResourceUrl(url) {
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
  }
  return trustedScriptURLFromString(url[0]);
}
function getUrlSanitizer(tag, prop) {
  if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
    return \u0275\u0275sanitizeResourceUrl;
  }
  return \u0275\u0275sanitizeUrl;
}
function \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
    throw new RuntimeError(306, errorMessage);
  }
}
function validateAgainstEventAttributes(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
    throw new RuntimeError(306, errorMessage);
  }
}
function getSanitizer() {
  const lView = getLView();
  return lView && lView[ENVIRONMENT].sanitizer;
}
var COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
var COMMENT_DELIMITER = /(<|>)/g;
var COMMENT_DELIMITER_ESCAPED = "\u200B$1\u200B";
function escapeCommentText(value) {
  return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
function normalizeDebugBindingName(name) {
  name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
  return `ng-reflect-${name}`;
}
var CAMEL_CASE_REGEXP = /([A-Z])/g;
function camelCaseToDashCase(input2) {
  return input2.replace(CAMEL_CASE_REGEXP, (...m3) => "-" + m3[1].toLowerCase());
}
function normalizeDebugBindingValue(value) {
  try {
    return value != null ? value.toString().slice(0, 30) : value;
  } catch (e3) {
    return "[ERROR] Exception while trying to serialize the value";
  }
}
var CUSTOM_ELEMENTS_SCHEMA = {
  name: "custom-elements"
};
var NO_ERRORS_SCHEMA = {
  name: "no-errors-schema"
};
var shouldThrowErrorOnUnknownElement = false;
var shouldThrowErrorOnUnknownProperty = false;
function validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {
  if (schemas === null)
    return;
  if (!hasDirectives && tagName !== null) {
    const isUnknown = (
      // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because
      // Domino doesn't expose HTMLUnknownElement globally.
      typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName)
    );
    if (isUnknown && !matchingSchemas(schemas, tagName)) {
      const isHostStandalone = isHostComponentStandalone(lView);
      const templateLocation = getTemplateLocationDetails(lView);
      const schemas2 = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
      let message = `'${tagName}' is not a known element${templateLocation}:
`;
      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared"}.
`;
      if (tagName && tagName.indexOf("-") > -1) {
        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.`;
      } else {
        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;
      }
      if (shouldThrowErrorOnUnknownElement) {
        throw new RuntimeError(304, message);
      } else {
        console.error(formatRuntimeError(304, message));
      }
    }
  }
}
function isPropertyValid(element, propName, tagName, schemas) {
  if (schemas === null)
    return true;
  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
    return true;
  }
  return typeof Node === "undefined" || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
  if (!tagName && nodeType === 4) {
    tagName = "ng-template";
  }
  const isHostStandalone = isHostComponentStandalone(lView);
  const templateLocation = getTemplateLocationDetails(lView);
  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
  const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared";
  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
    message += `
If the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
  } else {
    message += `
1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;
    if (tagName && tagName.indexOf("-") > -1) {
      message += `
2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      message += `
3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    } else {
      message += `
2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    }
  }
  reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
  if (shouldThrowErrorOnUnknownProperty) {
    throw new RuntimeError(303, message);
  } else {
    console.error(formatRuntimeError(303, message));
  }
}
function getDeclarationComponentDef(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  if (!context2)
    return null;
  return context2.constructor ? getComponentDef(context2.constructor) : null;
}
function isHostComponentStandalone(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const componentDef = getDeclarationComponentDef(lView);
  return !!componentDef?.standalone;
}
function getTemplateLocationDetails(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  return componentClassName ? ` (used in the '${componentClassName}' component template)` : "";
}
var KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([
  ["ngIf", "NgIf"],
  ["ngFor", "NgFor"],
  ["ngSwitchCase", "NgSwitchCase"],
  ["ngSwitchDefault", "NgSwitchDefault"]
]);
function matchingSchemas(schemas, tagName) {
  if (schemas !== null) {
    for (let i3 = 0; i3 < schemas.length; i3++) {
      const schema = schemas[i3];
      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
        return true;
      }
    }
  }
  return false;
}
function \u0275\u0275resolveWindow(element) {
  return element.ownerDocument.defaultView;
}
function \u0275\u0275resolveDocument(element) {
  return element.ownerDocument;
}
function \u0275\u0275resolveBody(element) {
  return element.ownerDocument.body;
}
var INTERPOLATION_DELIMITER = `\uFFFD`;
function maybeUnwrapFn(value) {
  if (value instanceof Function) {
    return value();
  } else {
    return value;
  }
}
function isPlatformBrowser(injector) {
  return (injector ?? inject(Injector)).get(PLATFORM_ID) === "browser";
}
var VALUE_STRING_LENGTH_LIMIT = 200;
function assertStandaloneComponentType(type) {
  assertComponentDef(type);
  const componentDef = getComponentDef(type);
  if (!componentDef.standalone) {
    throw new RuntimeError(907, `The ${stringifyForError(type)} component is not marked as standalone, but Angular expects to have a standalone component here. Please make sure the ${stringifyForError(type)} component has the \`standalone: true\` flag in the decorator.`);
  }
}
function assertComponentDef(type) {
  if (!getComponentDef(type)) {
    throw new RuntimeError(906, `The ${stringifyForError(type)} is not an Angular component, make sure it has the \`@Component\` decorator.`);
  }
}
function throwMultipleComponentError(tNode, first2, second) {
  throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first2)} and ${stringifyForError(second)}`);
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  const field = propName ? ` for '${propName}'` : "";
  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ""}`;
  if (creationMode) {
    msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
  }
  throw new RuntimeError(-100, msg);
}
function formatValue(value) {
  let strValue = String(value);
  try {
    if (Array.isArray(value) || strValue === "[object Object]") {
      strValue = JSON.stringify(value);
    }
  } catch (error) {
  }
  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + "\u2026" : strValue;
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
  let oldValue = prefix, newValue = prefix;
  for (let i3 = 0; i3 < chunks.length; i3++) {
    const slotIdx = rootIndex + i3;
    oldValue += `${lView[slotIdx]}${chunks[i3]}`;
    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i3]}`;
  }
  return { propName, oldValue, newValue };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
  const tData = lView[TVIEW].data;
  const metadata = tData[bindingIndex];
  if (typeof metadata === "string") {
    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
    }
    return { propName: metadata, oldValue, newValue };
  }
  if (metadata === null) {
    let idx = bindingIndex - 1;
    while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
      idx--;
    }
    const meta = tData[idx];
    if (typeof meta === "string") {
      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
      if (matches && matches.length - 1 > bindingIndex - idx) {
        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
      }
    }
  }
  return { propName: void 0, oldValue, newValue };
}
var RendererStyleFlags2;
(function(RendererStyleFlags22) {
  RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
  RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
var _icuContainerIterate;
function icuContainerIterate(tIcuContainerNode, lView) {
  return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
  if (_icuContainerIterate === void 0) {
    _icuContainerIterate = loader();
  }
}
function applyToElementOrContainer(action, renderer, parent2, lNodeToHandle, beforeNode) {
  if (lNodeToHandle != null) {
    let lContainer;
    let isComponent2 = false;
    if (isLContainer(lNodeToHandle)) {
      lContainer = lNodeToHandle;
    } else if (isLView(lNodeToHandle)) {
      isComponent2 = true;
      ngDevMode && assertDefined(lNodeToHandle[HOST], "HOST must be defined for a component LView");
      lNodeToHandle = lNodeToHandle[HOST];
    }
    const rNode = unwrapRNode(lNodeToHandle);
    if (action === 0 && parent2 !== null) {
      if (beforeNode == null) {
        nativeAppendChild(renderer, parent2, rNode);
      } else {
        nativeInsertBefore(renderer, parent2, rNode, beforeNode || null, true);
      }
    } else if (action === 1 && parent2 !== null) {
      nativeInsertBefore(renderer, parent2, rNode, beforeNode || null, true);
    } else if (action === 2) {
      nativeRemoveNode(renderer, rNode, isComponent2);
    } else if (action === 3) {
      ngDevMode && ngDevMode.rendererDestroyNode++;
      renderer.destroyNode(rNode);
    }
    if (lContainer != null) {
      applyContainer(renderer, action, lContainer, parent2, beforeNode);
    }
  }
}
function createTextNode(renderer, value) {
  ngDevMode && ngDevMode.rendererCreateTextNode++;
  ngDevMode && ngDevMode.rendererSetText++;
  return renderer.createText(value);
}
function updateTextNode(renderer, rNode, value) {
  ngDevMode && ngDevMode.rendererSetText++;
  renderer.setValue(rNode, value);
}
function createCommentNode(renderer, value) {
  ngDevMode && ngDevMode.rendererCreateComment++;
  return renderer.createComment(escapeCommentText(value));
}
function createElementNode(renderer, name, namespace) {
  ngDevMode && ngDevMode.rendererCreateElement++;
  return renderer.createElement(name, namespace);
}
function removeViewFromDOM(tView, lView) {
  detachViewFromDOM(tView, lView);
  lView[HOST] = null;
  lView[T_HOST] = null;
}
function addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
  lView[HOST] = parentNativeNode;
  lView[T_HOST] = parentTNode;
  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
}
function detachViewFromDOM(tView, lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    8
    /* NotificationSource.ViewDetachedFromDOM */
  );
  applyView(tView, lView, lView[RENDERER], 2, null, null);
}
function destroyViewTree(rootView) {
  let lViewOrLContainer = rootView[CHILD_HEAD];
  if (!lViewOrLContainer) {
    return cleanUpView(rootView[TVIEW], rootView);
  }
  while (lViewOrLContainer) {
    let next = null;
    if (isLView(lViewOrLContainer)) {
      next = lViewOrLContainer[CHILD_HEAD];
    } else {
      ngDevMode && assertLContainer(lViewOrLContainer);
      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
      if (firstView)
        next = firstView;
    }
    if (!next) {
      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
        if (isLView(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
        }
        lViewOrLContainer = lViewOrLContainer[PARENT];
      }
      if (lViewOrLContainer === null)
        lViewOrLContainer = rootView;
      if (isLView(lViewOrLContainer)) {
        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
      }
      next = lViewOrLContainer && lViewOrLContainer[NEXT];
    }
    lViewOrLContainer = next;
  }
}
function insertView(tView, lView, lContainer, index3) {
  ngDevMode && assertLView(lView);
  ngDevMode && assertLContainer(lContainer);
  const indexInContainer = CONTAINER_HEADER_OFFSET + index3;
  const containerLength = lContainer.length;
  if (index3 > 0) {
    lContainer[indexInContainer - 1][NEXT] = lView;
  }
  if (index3 < containerLength - CONTAINER_HEADER_OFFSET) {
    lView[NEXT] = lContainer[indexInContainer];
    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index3, lView);
  } else {
    lContainer.push(lView);
    lView[NEXT] = null;
  }
  lView[PARENT] = lContainer;
  const declarationLContainer = lView[DECLARATION_LCONTAINER];
  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
    trackMovedView(declarationLContainer, lView);
  }
  const lQueries = lView[QUERIES];
  if (lQueries !== null) {
    lQueries.insertView(tView);
  }
  updateAncestorTraversalFlagsOnAttach(lView);
  lView[FLAGS] |= 128;
}
function trackMovedView(declarationContainer, lView) {
  ngDevMode && assertDefined(lView, "LView required");
  ngDevMode && assertLContainer(declarationContainer);
  const movedViews = declarationContainer[MOVED_VIEWS];
  const parent2 = lView[PARENT];
  ngDevMode && assertDefined(parent2, "missing parent");
  if (isLView(parent2)) {
    declarationContainer[FLAGS] |= LContainerFlags.HasTransplantedViews;
  } else {
    const insertedComponentLView = parent2[PARENT][DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(insertedComponentLView, "Missing insertedComponentLView");
    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(declaredComponentLView, "Missing declaredComponentLView");
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[FLAGS] |= LContainerFlags.HasTransplantedViews;
    }
  }
  if (movedViews === null) {
    declarationContainer[MOVED_VIEWS] = [lView];
  } else {
    movedViews.push(lView);
  }
}
function detachMovedView(declarationContainer, lView) {
  ngDevMode && assertLContainer(declarationContainer);
  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
  const movedViews = declarationContainer[MOVED_VIEWS];
  const declarationViewIndex = movedViews.indexOf(lView);
  movedViews.splice(declarationViewIndex, 1);
}
function detachView(lContainer, removeIndex) {
  if (lContainer.length <= CONTAINER_HEADER_OFFSET)
    return;
  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
  const viewToDetach = lContainer[indexInContainer];
  if (viewToDetach) {
    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && declarationLContainer !== lContainer) {
      detachMovedView(declarationLContainer, viewToDetach);
    }
    if (removeIndex > 0) {
      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
    }
    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
    removeViewFromDOM(viewToDetach[TVIEW], viewToDetach);
    const lQueries = removedLView[QUERIES];
    if (lQueries !== null) {
      lQueries.detachView(removedLView[TVIEW]);
    }
    viewToDetach[PARENT] = null;
    viewToDetach[NEXT] = null;
    viewToDetach[FLAGS] &= ~128;
  }
  return viewToDetach;
}
function destroyLView(tView, lView) {
  if (!(lView[FLAGS] & 256)) {
    const renderer = lView[RENDERER];
    if (renderer.destroyNode) {
      applyView(tView, lView, renderer, 3, null, null);
    }
    destroyViewTree(lView);
  }
}
function cleanUpView(tView, lView) {
  if (lView[FLAGS] & 256) {
    return;
  }
  const prevConsumer = setActiveConsumer(null);
  try {
    lView[FLAGS] &= ~128;
    lView[FLAGS] |= 256;
    lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
    executeOnDestroys(tView, lView);
    processCleanups(tView, lView);
    if (lView[TVIEW].type === 1) {
      ngDevMode && ngDevMode.rendererDestroy++;
      lView[RENDERER].destroy();
    }
    const declarationContainer = lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && isLContainer(lView[PARENT])) {
      if (declarationContainer !== lView[PARENT]) {
        detachMovedView(declarationContainer, lView);
      }
      const lQueries = lView[QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(tView);
      }
    }
    unregisterLView(lView);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function processCleanups(tView, lView) {
  ngDevMode && assertNotReactive(processCleanups.name);
  const tCleanup = tView.cleanup;
  const lCleanup = lView[CLEANUP];
  if (tCleanup !== null) {
    for (let i3 = 0; i3 < tCleanup.length - 1; i3 += 2) {
      if (typeof tCleanup[i3] === "string") {
        const targetIdx = tCleanup[i3 + 3];
        ngDevMode && assertNumber(targetIdx, "cleanup target must be a number");
        if (targetIdx >= 0) {
          lCleanup[targetIdx]();
        } else {
          lCleanup[-targetIdx].unsubscribe();
        }
        i3 += 2;
      } else {
        const context2 = lCleanup[tCleanup[i3 + 1]];
        tCleanup[i3].call(context2);
      }
    }
  }
  if (lCleanup !== null) {
    lView[CLEANUP] = null;
  }
  const destroyHooks = lView[ON_DESTROY_HOOKS];
  if (destroyHooks !== null) {
    lView[ON_DESTROY_HOOKS] = null;
    for (let i3 = 0; i3 < destroyHooks.length; i3++) {
      const destroyHooksFn = destroyHooks[i3];
      ngDevMode && assertFunction(destroyHooksFn, "Expecting destroy hook to be a function.");
      destroyHooksFn();
    }
  }
}
function executeOnDestroys(tView, lView) {
  ngDevMode && assertNotReactive(executeOnDestroys.name);
  let destroyHooks;
  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
    for (let i3 = 0; i3 < destroyHooks.length; i3 += 2) {
      const context2 = lView[destroyHooks[i3]];
      if (!(context2 instanceof NodeInjectorFactory)) {
        const toCall = destroyHooks[i3 + 1];
        if (Array.isArray(toCall)) {
          for (let j4 = 0; j4 < toCall.length; j4 += 2) {
            const callContext = context2[toCall[j4]];
            const hook = toCall[j4 + 1];
            profiler(4, callContext, hook);
            try {
              hook.call(callContext);
            } finally {
              profiler(5, callContext, hook);
            }
          }
        } else {
          profiler(4, context2, toCall);
          try {
            toCall.call(context2);
          } finally {
            profiler(5, context2, toCall);
          }
        }
      }
    }
  }
}
function getParentRElement(tView, tNode, lView) {
  return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
  let parentTNode = tNode;
  while (parentTNode !== null && parentTNode.type & (8 | 32)) {
    tNode = parentTNode;
    parentTNode = tNode.parent;
  }
  if (parentTNode === null) {
    return lView[HOST];
  } else {
    ngDevMode && assertTNodeType(
      parentTNode,
      3 | 4
      /* TNodeType.Container */
    );
    const { componentOffset } = parentTNode;
    if (componentOffset > -1) {
      ngDevMode && assertTNodeForLView(parentTNode, lView);
      const { encapsulation } = tView.data[parentTNode.directiveStart + componentOffset];
      if (encapsulation === ViewEncapsulation$1.None || encapsulation === ViewEncapsulation$1.Emulated) {
        return null;
      }
    }
    return getNativeByTNode(parentTNode, lView);
  }
}
function nativeInsertBefore(renderer, parent2, child, beforeNode, isMove) {
  ngDevMode && ngDevMode.rendererInsertBefore++;
  renderer.insertBefore(parent2, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent2, child) {
  ngDevMode && ngDevMode.rendererAppendChild++;
  ngDevMode && assertDefined(parent2, "parent node must be defined");
  renderer.appendChild(parent2, child);
}
function nativeAppendOrInsertBefore(renderer, parent2, child, beforeNode, isMove) {
  if (beforeNode !== null) {
    nativeInsertBefore(renderer, parent2, child, beforeNode, isMove);
  } else {
    nativeAppendChild(renderer, parent2, child);
  }
}
function nativeRemoveChild(renderer, parent2, child, isHostElement) {
  renderer.removeChild(parent2, child, isHostElement);
}
function nativeParentNode(renderer, node) {
  return renderer.parentNode(node);
}
function nativeNextSibling(renderer, node) {
  return renderer.nextSibling(node);
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
  if (parentTNode.type & (8 | 32)) {
    return getNativeByTNode(parentTNode, lView);
  }
  return null;
}
var _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
var _processI18nInsertBefore;
function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
  _processI18nInsertBefore = processI18nInsertBefore2;
}
function appendChild(tView, lView, childRNode, childTNode) {
  const parentRNode = getParentRElement(tView, childTNode, lView);
  const renderer = lView[RENDERER];
  const parentTNode = childTNode.parent || lView[T_HOST];
  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
  if (parentRNode != null) {
    if (Array.isArray(childRNode)) {
      for (let i3 = 0; i3 < childRNode.length; i3++) {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i3], anchorNode, false);
      }
    } else {
      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
  }
  _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
  if (tNode !== null) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 32 | 16
      /* TNodeType.Projection */
    );
    const tNodeType = tNode.type;
    if (tNodeType & 3) {
      return getNativeByTNode(tNode, lView);
    } else if (tNodeType & 4) {
      return getBeforeNodeForView(-1, lView[tNode.index]);
    } else if (tNodeType & 8) {
      const elIcuContainerChild = tNode.child;
      if (elIcuContainerChild !== null) {
        return getFirstNativeNode(lView, elIcuContainerChild);
      } else {
        const rNodeOrLContainer = lView[tNode.index];
        if (isLContainer(rNodeOrLContainer)) {
          return getBeforeNodeForView(-1, rNodeOrLContainer);
        } else {
          return unwrapRNode(rNodeOrLContainer);
        }
      }
    } else if (tNodeType & 32) {
      let nextRNode = icuContainerIterate(tNode, lView);
      let rNode = nextRNode();
      return rNode || unwrapRNode(lView[tNode.index]);
    } else {
      const projectionNodes = getProjectionNodes(lView, tNode);
      if (projectionNodes !== null) {
        if (Array.isArray(projectionNodes)) {
          return projectionNodes[0];
        }
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        return getFirstNativeNode(parentView, projectionNodes);
      } else {
        return getFirstNativeNode(lView, tNode.next);
      }
    }
  }
  return null;
}
function getProjectionNodes(lView, tNode) {
  if (tNode !== null) {
    const componentView = lView[DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[T_HOST];
    const slotIdx = tNode.projection;
    ngDevMode && assertProjectionSlots(lView);
    return componentHost.projection[slotIdx];
  }
  return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
  if (nextViewIndex < lContainer.length) {
    const lView = lContainer[nextViewIndex];
    const firstTNodeOfView = lView[TVIEW].firstChild;
    if (firstTNodeOfView !== null) {
      return getFirstNativeNode(lView, firstTNodeOfView);
    }
  }
  return lContainer[NATIVE];
}
function nativeRemoveNode(renderer, rNode, isHostElement) {
  ngDevMode && ngDevMode.rendererRemoveNode++;
  const nativeParent = nativeParentNode(renderer, rNode);
  if (nativeParent) {
    nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);
  }
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
  while (tNode != null) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const rawSlotValue = lView[tNode.index];
    const tNodeType = tNode.type;
    if (isProjection) {
      if (action === 0) {
        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
        tNode.flags |= 2;
      }
    }
    if ((tNode.flags & 32) !== 32) {
      if (tNodeType & 8) {
        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
        }
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 16) {
        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
      } else {
        ngDevMode && assertTNodeType(
          tNode,
          3 | 4
          /* TNodeType.Container */
        );
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
  const renderer = lView[RENDERER];
  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
  const parentTNode = tProjectionNode.parent || lView[T_HOST];
  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
  const componentLView = lView[DECLARATION_COMPONENT_VIEW];
  const componentNode = componentLView[T_HOST];
  ngDevMode && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
  if (Array.isArray(nodeToProjectOrRNodes)) {
    for (let i3 = 0; i3 < nodeToProjectOrRNodes.length; i3++) {
      const rNode = nodeToProjectOrRNodes[i3];
      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
    }
  } else {
    let nodeToProject = nodeToProjectOrRNodes;
    const projectedComponentLView = componentLView[PARENT];
    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {
      nodeToProject.flags |= 128;
    }
    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
  }
}
function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
  ngDevMode && assertLContainer(lContainer);
  const anchor = lContainer[NATIVE];
  const native = unwrapRNode(lContainer);
  if (anchor !== native) {
    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
  }
  for (let i3 = CONTAINER_HEADER_OFFSET; i3 < lContainer.length; i3++) {
    const lView = lContainer[i3];
    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
  }
}
function applyStyling(renderer, isClassBased, rNode, prop, value) {
  if (isClassBased) {
    if (!value) {
      ngDevMode && ngDevMode.rendererRemoveClass++;
      renderer.removeClass(rNode, prop);
    } else {
      ngDevMode && ngDevMode.rendererAddClass++;
      renderer.addClass(rNode, prop);
    }
  } else {
    let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value == null) {
      ngDevMode && ngDevMode.rendererRemoveStyle++;
      renderer.removeStyle(rNode, prop, flags);
    } else {
      const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
      if (isImportant) {
        value = value.slice(0, -10);
        flags |= RendererStyleFlags2.Important;
      }
      ngDevMode && ngDevMode.rendererSetStyle++;
      renderer.setStyle(rNode, prop, value, flags);
    }
  }
}
function writeDirectStyle(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  renderer.setAttribute(element, "style", newValue);
  ngDevMode && ngDevMode.rendererSetStyle++;
}
function writeDirectClass(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  if (newValue === "") {
    renderer.removeAttribute(element, "class");
  } else {
    renderer.setAttribute(element, "class", newValue);
  }
  ngDevMode && ngDevMode.rendererSetClassName++;
}
function setupStaticAttributes(renderer, element, tNode) {
  const { mergedAttrs, classes, styles } = tNode;
  if (mergedAttrs !== null) {
    setUpAttributes(renderer, element, mergedAttrs);
  }
  if (classes !== null) {
    writeDirectClass(renderer, element, classes);
  }
  if (styles !== null) {
    writeDirectStyle(renderer, element, styles);
  }
}
var NO_CHANGE = typeof ngDevMode === "undefined" || ngDevMode ? { __brand__: "NO_CHANGE" } : {};
function \u0275\u0275advance(delta = 1) {
  ngDevMode && assertGreaterThan(delta, 0, "Can only advance forward");
  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());
}
function selectIndexInternal(tView, lView, index3, checkNoChangesMode) {
  ngDevMode && assertIndexInDeclRange(lView[TVIEW], index3);
  if (!checkNoChangesMode) {
    const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
    if (hooksInitPhaseCompleted) {
      const preOrderCheckHooks = tView.preOrderCheckHooks;
      if (preOrderCheckHooks !== null) {
        executeCheckHooks(lView, preOrderCheckHooks, index3);
      }
    } else {
      const preOrderHooks = tView.preOrderHooks;
      if (preOrderHooks !== null) {
        executeInitAndCheckHooks(lView, preOrderHooks, 0, index3);
      }
    }
  }
  setSelectedIndex(index3);
}
function \u0275\u0275directiveInject(token, flags = InjectFlags.Default) {
  const lView = getLView();
  if (lView === null) {
    ngDevMode && assertInjectImplementationNotEqual(\u0275\u0275directiveInject);
    return \u0275\u0275inject(token, flags);
  }
  const tNode = getCurrentTNode();
  const value = getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
  ngDevMode && emitInjectEvent(token, value, flags);
  return value;
}
function \u0275\u0275invalidFactory() {
  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : "invalid";
  throw new Error(msg);
}
function writeToDirectiveInput(def, instance, publicName, privateName, flags, value) {
  const prevConsumer = setActiveConsumer(null);
  try {
    let inputSignalNode = null;
    if ((flags & InputFlags.SignalBased) !== 0) {
      const field = instance[privateName];
      inputSignalNode = field[SIGNAL];
    }
    if (inputSignalNode !== null && inputSignalNode.transformFn !== void 0) {
      value = inputSignalNode.transformFn(value);
    }
    if ((flags & InputFlags.HasDecoratorInputTransform) !== 0) {
      value = def.inputTransforms[privateName].call(instance, value);
    }
    if (def.setInput !== null) {
      def.setInput(instance, inputSignalNode, value, publicName, privateName);
    } else {
      applyValueToInputField(instance, inputSignalNode, privateName, value);
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function processHostBindingOpCodes(tView, lView) {
  const hostBindingOpCodes = tView.hostBindingOpCodes;
  if (hostBindingOpCodes === null)
    return;
  try {
    for (let i3 = 0; i3 < hostBindingOpCodes.length; i3++) {
      const opCode = hostBindingOpCodes[i3];
      if (opCode < 0) {
        setSelectedIndex(~opCode);
      } else {
        const directiveIdx = opCode;
        const bindingRootIndx = hostBindingOpCodes[++i3];
        const hostBindingFn = hostBindingOpCodes[++i3];
        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
        const context2 = lView[directiveIdx];
        hostBindingFn(2, context2);
      }
    }
  } finally {
    setSelectedIndex(-1);
  }
}
function createLView(parentLView, tView, context2, flags, host, tHostNode, environment2, renderer, injector, embeddedViewInjector, hydrationInfo) {
  const lView = tView.blueprint.slice();
  lView[HOST] = host;
  lView[FLAGS] = flags | 4 | 128 | 8 | 64;
  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048) {
    lView[FLAGS] |= 2048;
  }
  resetPreOrderHookFlags(lView);
  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
  lView[CONTEXT] = context2;
  lView[ENVIRONMENT] = environment2 || parentLView && parentLView[ENVIRONMENT];
  ngDevMode && assertDefined(lView[ENVIRONMENT], "LViewEnvironment is required");
  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
  ngDevMode && assertDefined(lView[RENDERER], "Renderer is required");
  lView[INJECTOR] = injector || parentLView && parentLView[INJECTOR] || null;
  lView[T_HOST] = tHostNode;
  lView[ID] = getUniqueLViewId();
  lView[HYDRATION] = hydrationInfo;
  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
  ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
  return lView;
}
function getOrCreateTNode(tView, index3, type, name, attrs) {
  ngDevMode && index3 !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index3, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertPureTNodeType(type);
  let tNode = tView.data[index3];
  if (tNode === null) {
    tNode = createTNodeAtIndex(tView, index3, type, name, attrs);
    if (isInI18nBlock()) {
      tNode.flags |= 32;
    }
  } else if (tNode.type & 64) {
    tNode.type = type;
    tNode.value = name;
    tNode.attrs = attrs;
    const parent2 = getCurrentParentTNode();
    tNode.injectorIndex = parent2 === null ? -1 : parent2.injectorIndex;
    ngDevMode && assertTNodeForTView(tNode, tView);
    ngDevMode && assertEqual(index3, tNode.index, "Expecting same index");
  }
  setCurrentTNode(tNode, true);
  return tNode;
}
function createTNodeAtIndex(tView, index3, type, name, attrs) {
  const currentTNode = getCurrentTNodePlaceholderOk();
  const isParent = isCurrentTNodeParent();
  const parent2 = isParent ? currentTNode : currentTNode && currentTNode.parent;
  const tNode = tView.data[index3] = createTNode(tView, parent2, type, index3, name, attrs);
  if (tView.firstChild === null) {
    tView.firstChild = tNode;
  }
  if (currentTNode !== null) {
    if (isParent) {
      if (currentTNode.child == null && tNode.parent !== null) {
        currentTNode.child = tNode;
      }
    } else {
      if (currentTNode.next === null) {
        currentTNode.next = tNode;
        tNode.prev = currentTNode;
      }
    }
  }
  return tNode;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
  if (numSlotsToAlloc === 0)
    return -1;
  if (ngDevMode) {
    assertFirstCreatePass(tView);
    assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
    assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
    assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
    assertFirstUpdatePass(tView);
  }
  const allocIdx = lView.length;
  for (let i3 = 0; i3 < numSlotsToAlloc; i3++) {
    lView.push(initialValue);
    tView.blueprint.push(initialValue);
    tView.data.push(null);
  }
  return allocIdx;
}
function executeTemplate(tView, lView, templateFn, rf, context2) {
  const prevSelectedIndex = getSelectedIndex();
  const isUpdatePhase = rf & 2;
  try {
    setSelectedIndex(-1);
    if (isUpdatePhase && lView.length > HEADER_OFFSET) {
      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());
    }
    const preHookType = isUpdatePhase ? 2 : 0;
    profiler(preHookType, context2);
    templateFn(rf, context2);
  } finally {
    setSelectedIndex(prevSelectedIndex);
    const postHookType = isUpdatePhase ? 3 : 1;
    profiler(postHookType, context2);
  }
}
function executeContentQueries(tView, tNode, lView) {
  if (isContentQueryHost(tNode)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          const directiveInstance = lView[directiveIndex];
          ngDevMode && assertDefined(directiveIndex, "Incorrect reference to a directive defining a content query");
          def.contentQueries(1, directiveInstance, directiveIndex);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function createDirectivesInstances(tView, lView, tNode) {
  if (!getBindingsEnabled())
    return;
  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
  if ((tNode.flags & 64) === 64) {
    invokeDirectivesHostBindings(tView, lView, tNode);
  }
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    let localIndex = tNode.index + 1;
    for (let i3 = 0; i3 < localNames.length; i3 += 2) {
      const index3 = localNames[i3 + 1];
      const value = index3 === -1 ? localRefExtractor(tNode, viewData) : viewData[index3];
      viewData[localIndex++] = value;
    }
  }
}
function getOrCreateComponentTView(def) {
  const tView = def.tView;
  if (tView === null || tView.incompleteFirstPass) {
    const declTNode = null;
    return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
  }
  return tView;
}
function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
  ngDevMode && ngDevMode.tView++;
  const bindingStartIndex = HEADER_OFFSET + decls;
  const initialViewLength = bindingStartIndex + vars;
  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
  const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
  const tView = blueprint[TVIEW] = {
    type,
    blueprint,
    template: templateFn,
    queries: null,
    viewQuery,
    declTNode,
    data: blueprint.slice().fill(null, bindingStartIndex),
    bindingStartIndex,
    expandoStartIndex: initialViewLength,
    hostBindingOpCodes: null,
    firstCreatePass: true,
    firstUpdatePass: true,
    staticViewQueries: false,
    staticContentQueries: false,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof directives === "function" ? directives() : directives,
    pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
    firstChild: null,
    schemas,
    consts,
    incompleteFirstPass: false,
    ssrId
  };
  if (ngDevMode) {
    Object.seal(tView);
  }
  return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
  const blueprint = [];
  for (let i3 = 0; i3 < initialViewLength; i3++) {
    blueprint.push(i3 < bindingStartIndex ? null : NO_CHANGE);
  }
  return blueprint;
}
function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation$1.ShadowDom;
  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
  applyRootElementTransform(rootElement);
  return rootElement;
}
function applyRootElementTransform(rootElement) {
  _applyRootElementTransformImpl(rootElement);
}
var _applyRootElementTransformImpl = () => null;
function storeCleanupWithContext(tView, lView, context2, cleanupFn) {
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertDefined(context2, "Cleanup context is mandatory when registering framework-level destroy hooks");
  lCleanup.push(context2);
  if (tView.firstCreatePass) {
    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
  } else {
    if (ngDevMode) {
      Object.freeze(getOrCreateTViewCleanup(tView));
    }
  }
}
function createTNode(tView, tParent, type, index3, value, attrs) {
  ngDevMode && index3 !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index3, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'");
  ngDevMode && ngDevMode.tNode++;
  ngDevMode && tParent && assertTNodeForTView(tParent, tView);
  let injectorIndex = tParent ? tParent.injectorIndex : -1;
  let flags = 0;
  if (isInSkipHydrationBlock$1()) {
    flags |= 128;
  }
  const tNode = {
    type,
    index: index3,
    insertBeforeIndex: null,
    injectorIndex,
    directiveStart: -1,
    directiveEnd: -1,
    directiveStylingLast: -1,
    componentOffset: -1,
    propertyBindings: null,
    flags,
    providerIndexes: 0,
    value,
    attrs,
    mergedAttrs: null,
    localNames: null,
    initialInputs: void 0,
    inputs: null,
    outputs: null,
    tView: null,
    next: null,
    prev: null,
    projectionNext: null,
    child: null,
    parent: tParent,
    projection: null,
    styles: null,
    stylesWithoutHost: null,
    residualStyles: void 0,
    classes: null,
    classesWithoutHost: null,
    residualClasses: void 0,
    classBindings: 0,
    styleBindings: 0
  };
  if (ngDevMode) {
    Object.seal(tNode);
  }
  return tNode;
}
function captureNodeBindings(mode, aliasMap, directiveIndex, bindingsResult, hostDirectiveAliasMap) {
  for (let publicName in aliasMap) {
    if (!aliasMap.hasOwnProperty(publicName)) {
      continue;
    }
    const value = aliasMap[publicName];
    if (value === void 0) {
      continue;
    }
    bindingsResult ??= {};
    let internalName;
    let inputFlags = InputFlags.None;
    if (Array.isArray(value)) {
      internalName = value[0];
      inputFlags = value[1];
    } else {
      internalName = value;
    }
    let finalPublicName = publicName;
    if (hostDirectiveAliasMap !== null) {
      if (!hostDirectiveAliasMap.hasOwnProperty(publicName)) {
        continue;
      }
      finalPublicName = hostDirectiveAliasMap[publicName];
    }
    if (mode === 0) {
      addPropertyBinding(bindingsResult, directiveIndex, finalPublicName, internalName, inputFlags);
    } else {
      addPropertyBinding(bindingsResult, directiveIndex, finalPublicName, internalName);
    }
  }
  return bindingsResult;
}
function addPropertyBinding(bindings, directiveIndex, publicName, internalName, inputFlags) {
  let values;
  if (bindings.hasOwnProperty(publicName)) {
    (values = bindings[publicName]).push(directiveIndex, internalName);
  } else {
    values = bindings[publicName] = [directiveIndex, internalName];
  }
  if (inputFlags !== void 0) {
    values.push(inputFlags);
  }
}
function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefinitionMap) {
  ngDevMode && assertFirstCreatePass(tView);
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const tViewData = tView.data;
  const tNodeAttrs = tNode.attrs;
  const inputsFromAttrs = [];
  let inputsStore = null;
  let outputsStore = null;
  for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
    const directiveDef = tViewData[directiveIndex];
    const aliasData = hostDirectiveDefinitionMap ? hostDirectiveDefinitionMap.get(directiveDef) : null;
    const aliasedInputs = aliasData ? aliasData.inputs : null;
    const aliasedOutputs = aliasData ? aliasData.outputs : null;
    inputsStore = captureNodeBindings(0, directiveDef.inputs, directiveIndex, inputsStore, aliasedInputs);
    outputsStore = captureNodeBindings(1, directiveDef.outputs, directiveIndex, outputsStore, aliasedOutputs);
    const initialInputs = inputsStore !== null && tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(inputsStore, directiveIndex, tNodeAttrs) : null;
    inputsFromAttrs.push(initialInputs);
  }
  if (inputsStore !== null) {
    if (inputsStore.hasOwnProperty("class")) {
      tNode.flags |= 8;
    }
    if (inputsStore.hasOwnProperty("style")) {
      tNode.flags |= 16;
    }
  }
  tNode.initialInputs = inputsFromAttrs;
  tNode.inputs = inputsStore;
  tNode.outputs = outputsStore;
}
function mapPropName(name) {
  if (name === "class")
    return "className";
  if (name === "for")
    return "htmlFor";
  if (name === "formaction")
    return "formAction";
  if (name === "innerHtml")
    return "innerHTML";
  if (name === "readonly")
    return "readOnly";
  if (name === "tabindex")
    return "tabIndex";
  return name;
}
function elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {
  ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  const element = getNativeByTNode(tNode, lView);
  let inputData = tNode.inputs;
  let dataValue;
  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
    setInputsForProperty(tView, lView, dataValue, propName, value);
    if (isComponentHost(tNode))
      markDirtyIfOnPush(lView, tNode.index);
    if (ngDevMode) {
      setNgReflectProperties(lView, element, tNode.type, dataValue, value);
    }
  } else if (tNode.type & 3) {
    propName = mapPropName(propName);
    if (ngDevMode) {
      validateAgainstEventProperties(propName);
      if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {
        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
      }
      ngDevMode.rendererSetProperty++;
    }
    value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
    renderer.setProperty(element, propName, value);
  } else if (tNode.type & 12) {
    if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {
      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
  }
}
function markDirtyIfOnPush(lView, viewIndex) {
  ngDevMode && assertLView(lView);
  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
  if (!(childComponentLView[FLAGS] & 16)) {
    childComponentLView[FLAGS] |= 64;
  }
}
function setNgReflectProperty(lView, element, type, attrName, value) {
  const renderer = lView[RENDERER];
  attrName = normalizeDebugBindingName(attrName);
  const debugValue = normalizeDebugBindingValue(value);
  if (type & 3) {
    if (value == null) {
      renderer.removeAttribute(element, attrName);
    } else {
      renderer.setAttribute(element, attrName, debugValue);
    }
  } else {
    const textContent = escapeCommentText(`bindings=${JSON.stringify({ [attrName]: debugValue }, null, 2)}`);
    renderer.setValue(element, textContent);
  }
}
function setNgReflectProperties(lView, element, type, dataValue, value) {
  if (type & (3 | 4)) {
    for (let i3 = 0; i3 < dataValue.length; i3 += 3) {
      setNgReflectProperty(lView, element, type, dataValue[i3 + 1], value);
    }
  }
}
function resolveDirectives(tView, lView, tNode, localRefs) {
  ngDevMode && assertFirstCreatePass(tView);
  if (getBindingsEnabled()) {
    const exportsMap = localRefs === null ? null : { "": -1 };
    const matchResult = findDirectiveDefMatches(tView, tNode);
    let directiveDefs;
    let hostDirectiveDefs;
    if (matchResult === null) {
      directiveDefs = hostDirectiveDefs = null;
    } else {
      [directiveDefs, hostDirectiveDefs] = matchResult;
    }
    if (directiveDefs !== null) {
      initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs);
    }
    if (exportsMap)
      cacheMatchingLocalNames(tNode, localRefs, exportsMap);
  }
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
}
function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let i3 = 0; i3 < directives.length; i3++) {
    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, directives[i3].type);
  }
  initTNodeFlags(tNode, tView.data.length, directives.length);
  for (let i3 = 0; i3 < directives.length; i3++) {
    const def = directives[i3];
    if (def.providersResolver)
      def.providersResolver(def);
  }
  let preOrderHooksFound = false;
  let preOrderCheckHooksFound = false;
  let directiveIdx = allocExpando(tView, lView, directives.length, null);
  ngDevMode && assertSame(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
  for (let i3 = 0; i3 < directives.length; i3++) {
    const def = directives[i3];
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
    saveNameToExportMap(directiveIdx, def, exportsMap);
    if (def.contentQueries !== null)
      tNode.flags |= 4;
    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)
      tNode.flags |= 64;
    const lifeCycleHooks = def.type.prototype;
    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderHooks ??= []).push(tNode.index);
      preOrderHooksFound = true;
    }
    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderCheckHooks ??= []).push(tNode.index);
      preOrderCheckHooksFound = true;
    }
    directiveIdx++;
  }
  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
}
function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
  ngDevMode && assertFirstCreatePass(tView);
  const hostBindings = def.hostBindings;
  if (hostBindings) {
    let hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) {
      hostBindingOpCodes = tView.hostBindingOpCodes = [];
    }
    const elementIndx = ~tNode.index;
    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
      hostBindingOpCodes.push(elementIndx);
    }
    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
  }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
  let i3 = hostBindingOpCodes.length;
  while (i3 > 0) {
    const value = hostBindingOpCodes[--i3];
    if (typeof value === "number" && value < 0) {
      return value;
    }
  }
  return 0;
}
function instantiateAllDirectives(tView, lView, tNode, native) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  if (isComponentHost(tNode)) {
    ngDevMode && assertTNodeType(
      tNode,
      3
      /* TNodeType.AnyRNode */
    );
    addComponentLogic(lView, tNode, tView.data[start + tNode.componentOffset]);
  }
  if (!tView.firstCreatePass) {
    getOrCreateNodeInjectorForNode(tNode, lView);
  }
  attachPatchData(native, lView);
  const initialInputs = tNode.initialInputs;
  for (let i3 = start; i3 < end; i3++) {
    const def = tView.data[i3];
    const directive = getNodeInjectable(lView, tView, i3, tNode);
    attachPatchData(directive, lView);
    if (initialInputs !== null) {
      setInputsFromAttrs(lView, i3 - start, directive, def, tNode, initialInputs);
    }
    if (isComponentDef(def)) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      componentView[CONTEXT] = getNodeInjectable(lView, tView, i3, tNode);
    }
  }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const elementIndex = tNode.index;
  const currentDirectiveIndex = getCurrentDirectiveIndex();
  try {
    setSelectedIndex(elementIndex);
    for (let dirIndex = start; dirIndex < end; dirIndex++) {
      const def = tView.data[dirIndex];
      const directive = lView[dirIndex];
      setCurrentDirectiveIndex(dirIndex);
      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
        invokeHostBindingsInCreationMode(def, directive);
      }
    }
  } finally {
    setSelectedIndex(-1);
    setCurrentDirectiveIndex(currentDirectiveIndex);
  }
}
function invokeHostBindingsInCreationMode(def, directive) {
  if (def.hostBindings !== null) {
    def.hostBindings(1, directive);
  }
}
function findDirectiveDefMatches(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  const registry = tView.directiveRegistry;
  let matches = null;
  let hostDirectiveDefs = null;
  if (registry) {
    for (let i3 = 0; i3 < registry.length; i3++) {
      const def = registry[i3];
      if (isNodeMatchingSelectorList(
        tNode,
        def.selectors,
        /* isProjectionMode */
        false
      )) {
        matches || (matches = []);
        if (isComponentDef(def)) {
          if (ngDevMode) {
            assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);
            if (isComponentHost(tNode)) {
              throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);
            }
          }
          if (def.findHostDirectiveDefs !== null) {
            const hostDirectiveMatches = [];
            hostDirectiveDefs = hostDirectiveDefs || /* @__PURE__ */ new Map();
            def.findHostDirectiveDefs(def, hostDirectiveMatches, hostDirectiveDefs);
            matches.unshift(...hostDirectiveMatches, def);
            const componentOffset = hostDirectiveMatches.length;
            markAsComponentHost(tView, tNode, componentOffset);
          } else {
            matches.unshift(def);
            markAsComponentHost(tView, tNode, 0);
          }
        } else {
          hostDirectiveDefs = hostDirectiveDefs || /* @__PURE__ */ new Map();
          def.findHostDirectiveDefs?.(def, matches, hostDirectiveDefs);
          matches.push(def);
        }
      }
    }
  }
  ngDevMode && matches !== null && assertNoDuplicateDirectives(matches);
  return matches === null ? null : [matches, hostDirectiveDefs];
}
function markAsComponentHost(tView, hostTNode, componentOffset) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertGreaterThan(componentOffset, -1, "componentOffset must be great than -1");
  hostTNode.componentOffset = componentOffset;
  (tView.components ??= []).push(hostTNode.index);
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
  if (localRefs) {
    const localNames = tNode.localNames = [];
    for (let i3 = 0; i3 < localRefs.length; i3 += 2) {
      const index3 = exportsMap[localRefs[i3 + 1]];
      if (index3 == null)
        throw new RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i3 + 1]}' not found!`);
      localNames.push(localRefs[i3], index3);
    }
  }
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
  if (exportsMap) {
    if (def.exportAs) {
      for (let i3 = 0; i3 < def.exportAs.length; i3++) {
        exportsMap[def.exportAs[i3]] = directiveIdx;
      }
    }
    if (isComponentDef(def))
      exportsMap[""] = directiveIdx;
  }
}
function initTNodeFlags(tNode, index3, numberOfDirectives) {
  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
  tNode.flags |= 1;
  tNode.directiveStart = index3;
  tNode.directiveEnd = index3 + numberOfDirectives;
  tNode.providerIndexes = index3;
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, "Must be in Expando section");
  tView.data[directiveIndex] = def;
  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), \u0275\u0275directiveInject);
  tView.blueprint[directiveIndex] = nodeInjectorFactory;
  lView[directiveIndex] = nodeInjectorFactory;
  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function addComponentLogic(lView, hostTNode, def) {
  const native = getNativeByTNode(hostTNode, lView);
  const tView = getOrCreateComponentTView(def);
  const rendererFactory = lView[ENVIRONMENT].rendererFactory;
  let lViewFlags = 16;
  if (def.signals) {
    lViewFlags = 4096;
  } else if (def.onPush) {
    lViewFlags = 64;
  }
  const componentView = addToViewTree(lView, createLView(lView, tView, null, lViewFlags, native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
  lView[hostTNode.index] = componentView;
}
function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
  if (ngDevMode) {
    assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    validateAgainstEventAttributes(name);
    assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
  }
  const element = getNativeByTNode(tNode, lView);
  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);
}
function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
  if (value == null) {
    ngDevMode && ngDevMode.rendererRemoveAttribute++;
    renderer.removeAttribute(element, name, namespace);
  } else {
    ngDevMode && ngDevMode.rendererSetAttribute++;
    const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || "", name);
    renderer.setAttribute(element, name, strValue, namespace);
  }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
  const initialInputs = initialInputData[directiveIndex];
  if (initialInputs !== null) {
    for (let i3 = 0; i3 < initialInputs.length; ) {
      const publicName = initialInputs[i3++];
      const privateName = initialInputs[i3++];
      const flags = initialInputs[i3++];
      const value = initialInputs[i3++];
      writeToDirectiveInput(def, instance, publicName, privateName, flags, value);
      if (ngDevMode) {
        const nativeElement = getNativeByTNode(tNode, lView);
        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
      }
    }
  }
}
function generateInitialInputs(inputs, directiveIndex, attrs) {
  let inputsToStore = null;
  let i3 = 0;
  while (i3 < attrs.length) {
    const attrName = attrs[i3];
    if (attrName === 0) {
      i3 += 4;
      continue;
    } else if (attrName === 5) {
      i3 += 2;
      continue;
    }
    if (typeof attrName === "number")
      break;
    if (inputs.hasOwnProperty(attrName)) {
      if (inputsToStore === null)
        inputsToStore = [];
      const inputConfig = inputs[attrName];
      for (let j4 = 0; j4 < inputConfig.length; j4 += 3) {
        if (inputConfig[j4] === directiveIndex) {
          inputsToStore.push(attrName, inputConfig[j4 + 1], inputConfig[j4 + 2], attrs[i3 + 1]);
          break;
        }
      }
    }
    i3 += 2;
  }
  return inputsToStore;
}
function createLContainer(hostNative, currentView, native, tNode) {
  ngDevMode && assertLView(currentView);
  const lContainer = [
    hostNative,
    // host native
    true,
    // Boolean `true` in this position signifies that this is an `LContainer`
    0,
    // flags
    currentView,
    // parent
    null,
    // next
    tNode,
    // t_host
    null,
    // dehydrated views
    native,
    // native,
    null,
    // view refs
    null
    // moved views
  ];
  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
  return lContainer;
}
function refreshContentQueries(tView, lView) {
  const contentQueries = tView.contentQueries;
  if (contentQueries !== null) {
    const prevConsumer = setActiveConsumer(null);
    try {
      for (let i3 = 0; i3 < contentQueries.length; i3 += 2) {
        const queryStartIdx = contentQueries[i3];
        const directiveDefIdx = contentQueries[i3 + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && assertDefined(directiveDef, "DirectiveDef not found.");
          ngDevMode && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined");
          setCurrentQueryIndex(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function addToViewTree(lView, lViewOrLContainer) {
  if (lView[CHILD_HEAD]) {
    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
  } else {
    lView[CHILD_HEAD] = lViewOrLContainer;
  }
  lView[CHILD_TAIL] = lViewOrLContainer;
  return lViewOrLContainer;
}
function executeViewQueryFn(flags, viewQueryFn, component) {
  ngDevMode && assertDefined(viewQueryFn, "View queries function to execute must be defined.");
  setCurrentQueryIndex(0);
  const prevConsumer = setActiveConsumer(null);
  try {
    viewQueryFn(flags, component);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
  if (tData[bindingIndex] === null) {
    if (tNode.inputs == null || !tNode.inputs[propertyName]) {
      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
      propBindingIdxs.push(bindingIndex);
      let bindingMetadata = propertyName;
      if (interpolationParts.length > 0) {
        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
      }
      tData[bindingIndex] = bindingMetadata;
    }
  }
}
function getOrCreateLViewCleanup(view) {
  return view[CLEANUP] || (view[CLEANUP] = []);
}
function getOrCreateTViewCleanup(tView) {
  return tView.cleanup || (tView.cleanup = []);
}
function loadComponentRenderer(currentDef, tNode, lView) {
  if (currentDef === null || isComponentDef(currentDef)) {
    lView = unwrapLView(lView[tNode.index]);
  }
  return lView[RENDERER];
}
function handleError(lView, error) {
  const injector = lView[INJECTOR];
  const errorHandler2 = injector ? injector.get(ErrorHandler, null) : null;
  errorHandler2 && errorHandler2.handleError(error);
}
function setInputsForProperty(tView, lView, inputs, publicName, value) {
  for (let i3 = 0; i3 < inputs.length; ) {
    const index3 = inputs[i3++];
    const privateName = inputs[i3++];
    const flags = inputs[i3++];
    const instance = lView[index3];
    ngDevMode && assertIndexInRange(lView, index3);
    const def = tView.data[index3];
    writeToDirectiveInput(def, instance, publicName, privateName, flags, value);
  }
}
function textBindingInternal(lView, index3, value) {
  ngDevMode && assertString(value, "Value should be a string");
  ngDevMode && assertNotSame(value, NO_CHANGE, "value should not be NO_CHANGE");
  ngDevMode && assertIndexInRange(lView, index3);
  const element = getNativeByIndex(index3, lView);
  ngDevMode && assertDefined(element, "native element should exist");
  updateTextNode(lView[RENDERER], element, value);
}
function renderComponent(hostLView, componentHostIdx) {
  ngDevMode && assertEqual(isCreationMode(hostLView), true, "Should be run in creation mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  const componentTView = componentView[TVIEW];
  syncViewWithBlueprint(componentTView, componentView);
  const hostRNode = componentView[HOST];
  if (hostRNode !== null && componentView[HYDRATION] === null) {
    componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR]);
  }
  renderView(componentTView, componentView, componentView[CONTEXT]);
}
function syncViewWithBlueprint(tView, lView) {
  for (let i3 = lView.length; i3 < tView.blueprint.length; i3++) {
    lView.push(tView.blueprint[i3]);
  }
}
function renderView(tView, lView, context2) {
  ngDevMode && assertEqual(isCreationMode(lView), true, "Should be run in creation mode");
  ngDevMode && assertNotReactive(renderView.name);
  enterView(lView);
  try {
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(1, viewQuery, context2);
    }
    const templateFn = tView.template;
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 1, context2);
    }
    if (tView.firstCreatePass) {
      tView.firstCreatePass = false;
    }
    lView[QUERIES]?.finishViewCreation(tView);
    if (tView.staticContentQueries) {
      refreshContentQueries(tView, lView);
    }
    if (tView.staticViewQueries) {
      executeViewQueryFn(2, tView.viewQuery, context2);
    }
    const components = tView.components;
    if (components !== null) {
      renderChildComponents(lView, components);
    }
  } catch (error) {
    if (tView.firstCreatePass) {
      tView.incompleteFirstPass = true;
      tView.firstCreatePass = false;
    }
    throw error;
  } finally {
    lView[FLAGS] &= ~4;
    leaveView();
  }
}
function renderChildComponents(hostLView, components) {
  for (let i3 = 0; i3 < components.length; i3++) {
    renderComponent(hostLView, components[i3]);
  }
}
function createAndRenderEmbeddedLView(declarationLView, templateTNode, context2, options) {
  const prevConsumer = setActiveConsumer(null);
  try {
    const embeddedTView = templateTNode.tView;
    ngDevMode && assertDefined(embeddedTView, "TView must be defined for a template node.");
    ngDevMode && assertTNodeForLView(templateTNode, declarationLView);
    const isSignalView = declarationLView[FLAGS] & 4096;
    const viewFlags = isSignalView ? 4096 : 16;
    const embeddedLView = createLView(declarationLView, embeddedTView, context2, viewFlags, null, templateTNode, null, null, options?.injector ?? null, options?.embeddedViewInjector ?? null, options?.dehydratedView ?? null);
    const declarationLContainer = declarationLView[templateTNode.index];
    ngDevMode && assertLContainer(declarationLContainer);
    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
    const declarationViewLQueries = declarationLView[QUERIES];
    if (declarationViewLQueries !== null) {
      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
    }
    renderView(embeddedTView, embeddedLView, context2);
    return embeddedLView;
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function getLViewFromLContainer(lContainer, index3) {
  const adjustedIndex = CONTAINER_HEADER_OFFSET + index3;
  if (adjustedIndex < lContainer.length) {
    const lView = lContainer[adjustedIndex];
    ngDevMode && assertLView(lView);
    return lView;
  }
  return void 0;
}
function shouldAddViewToDom(tNode, dehydratedView) {
  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);
}
function addLViewToLContainer(lContainer, lView, index3, addToDOM = true) {
  const tView = lView[TVIEW];
  insertView(tView, lView, lContainer, index3);
  if (addToDOM) {
    const beforeNode = getBeforeNodeForView(index3, lContainer);
    const renderer = lView[RENDERER];
    const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
    if (parentRNode !== null) {
      addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
    }
  }
  const hydrationInfo = lView[HYDRATION];
  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {
    hydrationInfo.firstChild = null;
  }
}
function removeLViewFromLContainer(lContainer, index3) {
  const lView = detachView(lContainer, index3);
  if (lView !== void 0) {
    destroyLView(lView[TVIEW], lView);
  }
  return lView;
}
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
  while (tNode !== null) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const lNode = lView[tNode.index];
    if (lNode !== null) {
      result.push(unwrapRNode(lNode));
    }
    if (isLContainer(lNode)) {
      collectNativeNodesInLContainer(lNode, result);
    }
    const tNodeType = tNode.type;
    if (tNodeType & 8) {
      collectNativeNodes(tView, lView, tNode.child, result);
    } else if (tNodeType & 32) {
      const nextRNode = icuContainerIterate(tNode, lView);
      let rNode;
      while (rNode = nextRNode()) {
        result.push(rNode);
      }
    } else if (tNodeType & 16) {
      const nodesInSlot = getProjectionNodes(lView, tNode);
      if (Array.isArray(nodesInSlot)) {
        result.push(...nodesInSlot);
      } else {
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
  return result;
}
function collectNativeNodesInLContainer(lContainer, result) {
  for (let i3 = CONTAINER_HEADER_OFFSET; i3 < lContainer.length; i3++) {
    const lViewInAContainer = lContainer[i3];
    const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
    if (lViewFirstChildTNode !== null) {
      collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
    }
  }
  if (lContainer[NATIVE] !== lContainer[HOST]) {
    result.push(lContainer[NATIVE]);
  }
}
var freeConsumers = [];
function getOrBorrowReactiveLViewConsumer(lView) {
  return lView[REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);
}
function borrowReactiveLViewConsumer(lView) {
  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function maybeReturnReactiveLViewConsumer(consumer) {
  if (consumer.lView[REACTIVE_TEMPLATE_CONSUMER] === consumer) {
    return;
  }
  consumer.lView = null;
  freeConsumers.push(consumer);
}
var REACTIVE_LVIEW_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
  consumerIsAlwaysLive: true,
  consumerMarkedDirty: (node) => {
    markAncestorsForTraversal(node.lView);
  },
  consumerOnSignalRead() {
    this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
  }
});
var MAXIMUM_REFRESH_RERUNS$1 = 100;
function detectChangesInternal(lView, notifyErrorHandler = true, mode = 0) {
  const environment2 = lView[ENVIRONMENT];
  const rendererFactory = environment2.rendererFactory;
  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();
  if (!checkNoChangesMode) {
    rendererFactory.begin?.();
  }
  try {
    detectChangesInViewWhileDirty(lView, mode);
  } catch (error) {
    if (notifyErrorHandler) {
      handleError(lView, error);
    }
    throw error;
  } finally {
    if (!checkNoChangesMode) {
      rendererFactory.end?.();
      environment2.inlineEffectRunner?.flush();
    }
  }
}
function detectChangesInViewWhileDirty(lView, mode) {
  const lastIsRefreshingViewsValue = isRefreshingViews();
  try {
    setIsRefreshingViews(true);
    detectChangesInView(lView, mode);
    if (ngDevMode && isExhaustiveCheckNoChanges()) {
      return;
    }
    let retries = 0;
    while (requiresRefreshOrTraversal(lView)) {
      if (retries === MAXIMUM_REFRESH_RERUNS$1) {
        throw new RuntimeError(103, ngDevMode && "Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.");
      }
      retries++;
      detectChangesInView(
        lView,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  } finally {
    setIsRefreshingViews(lastIsRefreshingViewsValue);
  }
}
function checkNoChangesInternal(lView, mode, notifyErrorHandler = true) {
  setIsInCheckNoChangesMode(mode);
  try {
    detectChangesInternal(lView, notifyErrorHandler);
  } finally {
    setIsInCheckNoChangesMode(CheckNoChangesMode.Off);
  }
}
function refreshView(tView, lView, templateFn, context2) {
  ngDevMode && assertEqual(isCreationMode(lView), false, "Should be run in update mode");
  const flags = lView[FLAGS];
  if ((flags & 256) === 256)
    return;
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const isInExhaustiveCheckNoChangesPass = ngDevMode && isExhaustiveCheckNoChanges();
  !isInCheckNoChangesPass && lView[ENVIRONMENT].inlineEffectRunner?.flush();
  enterView(lView);
  let prevConsumer = null;
  let currentConsumer = null;
  if (!isInCheckNoChangesPass && viewShouldHaveReactiveConsumer(tView)) {
    currentConsumer = getOrBorrowReactiveLViewConsumer(lView);
    prevConsumer = consumerBeforeComputation(currentConsumer);
  }
  try {
    resetPreOrderHookFlags(lView);
    setBindingIndex(tView.bindingStartIndex);
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 2, context2);
    }
    const hooksInitPhaseCompleted = (flags & 3) === 3;
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, null);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
        }
        incrementInitPhaseFlags(
          lView,
          0
          /* InitPhaseState.OnInitHooksToBeRun */
        );
      }
    }
    if (!isInExhaustiveCheckNoChangesPass) {
      markTransplantedViewsForRefresh(lView);
    }
    detectChangesInEmbeddedViews(
      lView,
      0
      /* ChangeDetectionMode.Global */
    );
    if (tView.contentQueries !== null) {
      refreshContentQueries(tView, lView);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const contentCheckHooks = tView.contentCheckHooks;
        if (contentCheckHooks !== null) {
          executeCheckHooks(lView, contentCheckHooks);
        }
      } else {
        const contentHooks = tView.contentHooks;
        if (contentHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            contentHooks,
            1
            /* InitPhaseState.AfterContentInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          1
          /* InitPhaseState.AfterContentInitHooksToBeRun */
        );
      }
    }
    processHostBindingOpCodes(tView, lView);
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        0
        /* ChangeDetectionMode.Global */
      );
    }
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(2, viewQuery, context2);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const viewCheckHooks = tView.viewCheckHooks;
        if (viewCheckHooks !== null) {
          executeCheckHooks(lView, viewCheckHooks);
        }
      } else {
        const viewHooks = tView.viewHooks;
        if (viewHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            viewHooks,
            2
            /* InitPhaseState.AfterViewInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          2
          /* InitPhaseState.AfterViewInitHooksToBeRun */
        );
      }
    }
    if (tView.firstUpdatePass === true) {
      tView.firstUpdatePass = false;
    }
    if (lView[EFFECTS_TO_SCHEDULE]) {
      for (const notifyEffect of lView[EFFECTS_TO_SCHEDULE]) {
        notifyEffect();
      }
      lView[EFFECTS_TO_SCHEDULE] = null;
    }
    if (!isInCheckNoChangesPass) {
      lView[FLAGS] &= ~(64 | 8);
    }
  } catch (e3) {
    if (!isInCheckNoChangesPass) {
      markAncestorsForTraversal(lView);
    }
    throw e3;
  } finally {
    if (currentConsumer !== null) {
      consumerAfterComputation(currentConsumer, prevConsumer);
      maybeReturnReactiveLViewConsumer(currentConsumer);
    }
    leaveView();
  }
}
function viewShouldHaveReactiveConsumer(tView) {
  return tView.type !== 2;
}
function detectChangesInEmbeddedViews(lView, mode) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i3 = CONTAINER_HEADER_OFFSET; i3 < lContainer.length; i3++) {
      const embeddedLView = lContainer[i3];
      detectChangesInViewIfAttached(embeddedLView, mode);
    }
  }
}
function markTransplantedViewsForRefresh(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    if (!(lContainer[FLAGS] & LContainerFlags.HasTransplantedViews))
      continue;
    const movedViews = lContainer[MOVED_VIEWS];
    ngDevMode && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
    for (let i3 = 0; i3 < movedViews.length; i3++) {
      const movedLView = movedViews[i3];
      markViewForRefresh(movedLView);
    }
  }
}
function detectChangesInComponent(hostLView, componentHostIdx, mode) {
  ngDevMode && assertEqual(isCreationMode(hostLView), false, "Should be run in update mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  detectChangesInViewIfAttached(componentView, mode);
}
function detectChangesInViewIfAttached(lView, mode) {
  if (!viewAttachedToChangeDetector(lView)) {
    return;
  }
  detectChangesInView(lView, mode);
}
function detectChangesInView(lView, mode) {
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const tView = lView[TVIEW];
  const flags = lView[FLAGS];
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER];
  let shouldRefreshView = !!(mode === 0 && flags & 16);
  shouldRefreshView ||= !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass);
  shouldRefreshView ||= !!(flags & 1024);
  shouldRefreshView ||= !!(consumer?.dirty && consumerPollProducersForChange(consumer));
  shouldRefreshView ||= !!(ngDevMode && isExhaustiveCheckNoChanges());
  if (consumer) {
    consumer.dirty = false;
  }
  lView[FLAGS] &= ~(8192 | 1024);
  if (shouldRefreshView) {
    refreshView(tView, lView, tView.template, lView[CONTEXT]);
  } else if (flags & 8192) {
    detectChangesInEmbeddedViews(
      lView,
      1
      /* ChangeDetectionMode.Targeted */
    );
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  }
}
function detectChangesInChildComponents(hostLView, components, mode) {
  for (let i3 = 0; i3 < components.length; i3++) {
    detectChangesInComponent(hostLView, components[i3], mode);
  }
}
function markViewDirty(lView, source) {
  const dirtyBitsToUse = isRefreshingViews() ? (
    // When we are actively refreshing views, we only use the `Dirty` bit to mark a view
    64
  ) : (
    // When we are not actively refreshing a view tree, it is absolutely
    // valid to update state and mark views dirty. We use the `RefreshView` flag in this
    // case to allow synchronously rerunning change detection. This applies today to
    // afterRender hooks as well as animation listeners which execute after detecting
    // changes in a view when the render factory flushes.
    1024 | 64
  );
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(source);
  while (lView) {
    lView[FLAGS] |= dirtyBitsToUse;
    const parent2 = getLViewParent(lView);
    if (isRootView(lView) && !parent2) {
      return lView;
    }
    lView = parent2;
  }
  return null;
}
var ViewRef$1 = class {
  get rootNodes() {
    const lView = this._lView;
    const tView = lView[TVIEW];
    return collectNativeNodes(tView, lView, tView.firstChild, []);
  }
  constructor(_lView, _cdRefInjectingView, notifyErrorHandler = true) {
    this._lView = _lView;
    this._cdRefInjectingView = _cdRefInjectingView;
    this.notifyErrorHandler = notifyErrorHandler;
    this._appRef = null;
    this._attachedToViewContainer = false;
  }
  get context() {
    return this._lView[CONTEXT];
  }
  /**
   * @deprecated Replacing the full context object is not supported. Modify the context
   *   directly, or consider using a `Proxy` if you need to replace the full object.
   * // TODO(devversion): Remove this.
   */
  set context(value) {
    if (ngDevMode) {
      console.warn("Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.");
    }
    this._lView[CONTEXT] = value;
  }
  get destroyed() {
    return (this._lView[FLAGS] & 256) === 256;
  }
  destroy() {
    if (this._appRef) {
      this._appRef.detachView(this);
    } else if (this._attachedToViewContainer) {
      const parent2 = this._lView[PARENT];
      if (isLContainer(parent2)) {
        const viewRefs = parent2[VIEW_REFS];
        const index3 = viewRefs ? viewRefs.indexOf(this) : -1;
        if (index3 > -1) {
          ngDevMode && assertEqual(index3, parent2.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
          detachView(parent2, index3);
          removeFromArray(viewRefs, index3);
        }
      }
      this._attachedToViewContainer = false;
    }
    destroyLView(this._lView[TVIEW], this._lView);
  }
  onDestroy(callback) {
    storeLViewOnDestroy(this._lView, callback);
  }
  /**
   * Marks a view and all of its ancestors dirty.
   *
   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is
   * checked when it needs to be re-rendered but the two normal triggers haven't marked it
   * dirty (i.e. inputs haven't changed and events haven't fired in the view).
   *
   * <!-- TODO: Add a link to a chapter on OnPush components -->
   *
   * @usageNotes
   * ### Example
   *
   * ```typescript
   * @Component({
   *   selector: 'app-root',
   *   template: `Number of ticks: {{numberOfTicks}}`
   *   changeDetection: ChangeDetectionStrategy.OnPush,
   * })
   * class AppComponent {
   *   numberOfTicks = 0;
   *
   *   constructor(private ref: ChangeDetectorRef) {
   *     setInterval(() => {
   *       this.numberOfTicks++;
   *       // the following is required, otherwise the view will not be updated
   *       this.ref.markForCheck();
   *     }, 1000);
   *   }
   * }
   * ```
   */
  markForCheck() {
    markViewDirty(
      this._cdRefInjectingView || this._lView,
      4
      /* NotificationSource.MarkForCheck */
    );
  }
  /**
   * Detaches the view from the change detection tree.
   *
   * Detached views will not be checked during change detection runs until they are
   * re-attached, even if they are dirty. `detach` can be used in combination with
   * {@link ChangeDetectorRef#detectChanges} to implement local change
   * detection checks.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example defines a component with a large list of readonly data.
   * Imagine the data changes constantly, many times per second. For performance reasons,
   * we want to check and update the list every five seconds. We can do that by detaching
   * the component's change detector and doing a local check every five seconds.
   *
   * ```typescript
   * class DataProvider {
   *   // in a real application the returned data will be different every time
   *   get data() {
   *     return [1,2,3,4,5];
   *   }
   * }
   *
   * @Component({
   *   selector: 'giant-list',
   *   template: `
   *     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
   *   `,
   * })
   * class GiantList {
   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
   *     ref.detach();
   *     setInterval(() => {
   *       this.ref.detectChanges();
   *     }, 5000);
   *   }
   * }
   *
   * @Component({
   *   selector: 'app',
   *   providers: [DataProvider],
   *   template: `
   *     <giant-list><giant-list>
   *   `,
   * })
   * class App {
   * }
   * ```
   */
  detach() {
    this._lView[FLAGS] &= ~128;
  }
  /**
   * Re-attaches a view to the change detection tree.
   *
   * This can be used to re-attach views that were previously detached from the tree
   * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example creates a component displaying `live` data. The component will detach
   * its change detector from the main change detector tree when the component's live property
   * is set to false.
   *
   * ```typescript
   * class DataProvider {
   *   data = 1;
   *
   *   constructor() {
   *     setInterval(() => {
   *       this.data = this.data * 2;
   *     }, 500);
   *   }
   * }
   *
   * @Component({
   *   selector: 'live-data',
   *   inputs: ['live'],
   *   template: 'Data: {{dataProvider.data}}'
   * })
   * class LiveData {
   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
   *
   *   set live(value) {
   *     if (value) {
   *       this.ref.reattach();
   *     } else {
   *       this.ref.detach();
   *     }
   *   }
   * }
   *
   * @Component({
   *   selector: 'app-root',
   *   providers: [DataProvider],
   *   template: `
   *     Live Update: <input type="checkbox" [(ngModel)]="live">
   *     <live-data [live]="live"><live-data>
   *   `,
   * })
   * class AppComponent {
   *   live = true;
   * }
   * ```
   */
  reattach() {
    updateAncestorTraversalFlagsOnAttach(this._lView);
    this._lView[FLAGS] |= 128;
  }
  /**
   * Checks the view and its children.
   *
   * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement
   * local change detection checks.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example defines a component with a large list of readonly data.
   * Imagine, the data changes constantly, many times per second. For performance reasons,
   * we want to check and update the list every five seconds.
   *
   * We can do that by detaching the component's change detector and doing a local change detection
   * check every five seconds.
   *
   * See {@link ChangeDetectorRef#detach} for more information.
   */
  detectChanges() {
    this._lView[FLAGS] |= 1024;
    detectChangesInternal(this._lView, this.notifyErrorHandler);
  }
  /**
   * Checks the change detector and its children, and throws if any changes are detected.
   *
   * This is used in development mode to verify that running change detection doesn't
   * introduce other changes.
   */
  checkNoChanges() {
    if (ngDevMode) {
      checkNoChangesInternal(this._lView, CheckNoChangesMode.OnlyDirtyViews, this.notifyErrorHandler);
    }
  }
  attachToViewContainerRef() {
    if (this._appRef) {
      throw new RuntimeError(902, ngDevMode && "This view is already attached directly to the ApplicationRef!");
    }
    this._attachedToViewContainer = true;
  }
  detachFromAppRef() {
    this._appRef = null;
    const isRoot = isRootView(this._lView);
    const declarationContainer = this._lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      detachMovedView(declarationContainer, this._lView);
    }
    detachViewFromDOM(this._lView[TVIEW], this._lView);
  }
  attachToAppRef(appRef) {
    if (this._attachedToViewContainer) {
      throw new RuntimeError(902, ngDevMode && "This view is already attached to a ViewContainer!");
    }
    this._appRef = appRef;
    const isRoot = isRootView(this._lView);
    const declarationContainer = this._lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      trackMovedView(declarationContainer, this._lView);
    }
    updateAncestorTraversalFlagsOnAttach(this._lView);
  }
};
var _TemplateRef = class _TemplateRef {
};
_TemplateRef.__NG_ELEMENT_ID__ = injectTemplateRef;
var TemplateRef = _TemplateRef;
var ViewEngineTemplateRef = TemplateRef;
var R3TemplateRef = class TemplateRef2 extends ViewEngineTemplateRef {
  constructor(_declarationLView, _declarationTContainer, elementRef) {
    super();
    this._declarationLView = _declarationLView;
    this._declarationTContainer = _declarationTContainer;
    this.elementRef = elementRef;
  }
  /**
   * Returns an `ssrId` associated with a TView, which was used to
   * create this instance of the `TemplateRef`.
   *
   * @internal
   */
  get ssrId() {
    return this._declarationTContainer.tView?.ssrId || null;
  }
  createEmbeddedView(context2, injector) {
    return this.createEmbeddedViewImpl(context2, injector);
  }
  /**
   * @internal
   */
  createEmbeddedViewImpl(context2, injector, dehydratedView) {
    const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context2, { embeddedViewInjector: injector, dehydratedView });
    return new ViewRef$1(embeddedLView);
  }
};
function injectTemplateRef() {
  return createTemplateRef(getCurrentTNode(), getLView());
}
function createTemplateRef(hostTNode, hostLView) {
  if (hostTNode.type & 4) {
    ngDevMode && assertDefined(hostTNode.tView, "TView must be allocated");
    return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
  }
  return null;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
  if (insertBeforeIndex === null) {
    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
  } else {
    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
    return unwrapRNode(lView[insertBeforeIndex]);
  }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
  if (Array.isArray(tNodeInsertBeforeIndex)) {
    ngDevMode && assertDomNode(childRNode);
    let i18nParent = childRNode;
    let anchorRNode = null;
    if (!(childTNode.type & 3)) {
      anchorRNode = i18nParent;
      i18nParent = parentRElement;
    }
    if (i18nParent !== null && childTNode.componentOffset === -1) {
      for (let i3 = 1; i3 < tNodeInsertBeforeIndex.length; i3++) {
        const i18nChild = lView[tNodeInsertBeforeIndex[i3]];
        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
      }
    }
  }
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
  ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
  previousTNodes.push(newTNode);
  if (previousTNodes.length > 1) {
    for (let i3 = previousTNodes.length - 2; i3 >= 0; i3--) {
      const existingTNode = previousTNodes[i3];
      if (!isI18nText(existingTNode)) {
        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
          setInsertBeforeIndex(existingTNode, newTNode.index);
        }
      }
    }
  }
}
function isI18nText(tNode) {
  return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
  const index3 = tNode.insertBeforeIndex;
  return Array.isArray(index3) ? index3[0] : index3;
}
function setInsertBeforeIndex(tNode, value) {
  const index3 = tNode.insertBeforeIndex;
  if (Array.isArray(index3)) {
    index3[0] = value;
  } else {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    tNode.insertBeforeIndex = value;
  }
}
function getTIcu(tView, index3) {
  const value = tView.data[index3];
  if (value === null || typeof value === "string")
    return null;
  if (ngDevMode && !(value.hasOwnProperty("tView") || value.hasOwnProperty("currentCaseLViewIndex"))) {
    throwError2("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
  }
  const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
  ngDevMode && assertTIcu(tIcu);
  return tIcu;
}
function setTIcu(tView, index3, tIcu) {
  const tNode = tView.data[index3];
  ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty("tView"), true, "We expect to get 'null'|'TIcuContainer'");
  if (tNode === null) {
    tView.data[index3] = tIcu;
  } else {
    ngDevMode && assertTNodeType(
      tNode,
      32
      /* TNodeType.Icu */
    );
    tNode.value = tIcu;
  }
}
function setTNodeInsertBeforeIndex(tNode, index3) {
  ngDevMode && assertTNode(tNode);
  let insertBeforeIndex = tNode.insertBeforeIndex;
  if (insertBeforeIndex === null) {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    insertBeforeIndex = tNode.insertBeforeIndex = [
      null,
      index3
    ];
  } else {
    assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
    insertBeforeIndex.push(index3);
  }
}
function createTNodePlaceholder(tView, previousTNodes, index3) {
  const tNode = createTNodeAtIndex(tView, index3, 64, null, null);
  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
  return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
  const currentCase = lView[tIcu.currentCaseLViewIndex];
  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
  return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
  return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
  return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, "Missing parent index");
  ngDevMode && assertGreaterThan(refIdx, 0, "Missing ref index");
  return opCode | parentIdx << 17 | refIdx << 1;
}
function isRootTemplateMessage(subTemplateIndex) {
  return subTemplateIndex === -1;
}
var REF_EXTRACTOR_REGEXP = new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
var _prepareI18nBlockForHydrationImpl = () => {
};
function prepareI18nBlockForHydration(lView, index3, parentTNode, subTemplateIndex) {
  _prepareI18nBlockForHydrationImpl(lView, index3, parentTNode, subTemplateIndex);
}
var _claimDehydratedIcuCaseImpl = () => {
};
function claimDehydratedIcuCase(lView, icuIndex, caseIndex) {
  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);
}
var _findMatchingDehydratedViewImpl = () => null;
function findMatchingDehydratedView(lContainer, template) {
  return _findMatchingDehydratedViewImpl(lContainer, template);
}
var ChangeDetectionScheduler = class {
};
var ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless enabled" : "", { providedIn: "root", factory: () => false });
var PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless provided" : "", { providedIn: "root", factory: () => false });
var ZONELESS_SCHEDULER_DISABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "scheduler disabled" : "");
var ComponentRef$1 = class {
};
var ComponentFactory$1 = class {
};
function noComponentFactoryError(component) {
  const error = Error(`No component factory found for ${stringify(component)}.`);
  error[ERROR_COMPONENT] = component;
  return error;
}
var ERROR_COMPONENT = "ngComponent";
var _NullComponentFactoryResolver = class {
  resolveComponentFactory(component) {
    throw noComponentFactoryError(component);
  }
};
var _ComponentFactoryResolver$1 = class _ComponentFactoryResolver$1 {
};
_ComponentFactoryResolver$1.NULL = new _NullComponentFactoryResolver();
var ComponentFactoryResolver$1 = _ComponentFactoryResolver$1;
var RendererFactory2 = class {
};
var _Renderer2 = class _Renderer2 {
  constructor() {
    this.destroyNode = null;
  }
};
_Renderer2.__NG_ELEMENT_ID__ = () => injectRenderer2();
var Renderer2 = _Renderer2;
function injectRenderer2() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];
}
var _Sanitizer = class _Sanitizer {
};
_Sanitizer.\u0275prov = \u0275\u0275defineInjectable({
  token: _Sanitizer,
  providedIn: "root",
  factory: () => null
});
var Sanitizer = _Sanitizer;
var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
var markedFeatures = /* @__PURE__ */ new Set();
function performanceMarkFeature(feature) {
  if (markedFeatures.has(feature)) {
    return;
  }
  markedFeatures.add(feature);
  performance?.mark?.("mark_feature_usage", { detail: { feature } });
}
function scheduleCallbackWithRafRace(callback) {
  let executeCallback = true;
  setTimeout(() => {
    if (!executeCallback) {
      return;
    }
    executeCallback = false;
    callback();
  });
  if (typeof _global["requestAnimationFrame"] === "function") {
    _global["requestAnimationFrame"](() => {
      if (!executeCallback) {
        return;
      }
      executeCallback = false;
      callback();
    });
  }
  return () => {
    executeCallback = false;
  };
}
function scheduleCallbackWithMicrotask(callback) {
  let executeCallback = true;
  queueMicrotask(() => {
    if (executeCallback) {
      callback();
    }
  });
  return () => {
    executeCallback = false;
  };
}
function noop2(...args) {
}
var AsyncStackTaggingZoneSpec = class {
  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
    this.name = "asyncStackTagging for " + namePrefix;
    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);
  }
  onScheduleTask(delegate, _current, target, task) {
    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
    return delegate.scheduleTask(target, task);
  }
  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
    let ret;
    if (task.consoleTask) {
      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
    } else {
      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
    }
    return ret;
  }
};
var NgZone = class _NgZone {
  constructor({ enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false, shouldCoalesceRunChangeDetection = false }) {
    this.hasPendingMacrotasks = false;
    this.hasPendingMicrotasks = false;
    this.isStable = true;
    this.onUnstable = new EventEmitter(false);
    this.onMicrotaskEmpty = new EventEmitter(false);
    this.onStable = new EventEmitter(false);
    this.onError = new EventEmitter(false);
    if (typeof Zone == "undefined") {
      throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
    }
    Zone.assertZonePatched();
    const self2 = this;
    self2._nesting = 0;
    self2._outer = self2._inner = Zone.current;
    if (ngDevMode) {
      self2._inner = self2._inner.fork(new AsyncStackTaggingZoneSpec("Angular"));
    }
    if (Zone["TaskTrackingZoneSpec"]) {
      self2._inner = self2._inner.fork(new Zone["TaskTrackingZoneSpec"]());
    }
    if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
      self2._inner = self2._inner.fork(Zone["longStackTraceZoneSpec"]);
    }
    self2.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
    self2.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
    self2.callbackScheduled = false;
    forkInnerZoneWithAngularBehavior(self2);
  }
  /**
    This method checks whether the method call happens within an Angular Zone instance.
  */
  static isInAngularZone() {
    return typeof Zone !== "undefined" && Zone.current.get("isAngularZone") === true;
  }
  /**
    Assures that the method is called within the Angular Zone, otherwise throws an error.
  */
  static assertInAngularZone() {
    if (!_NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && "Expected to be in Angular Zone, but it is not!");
    }
  }
  /**
    Assures that the method is called outside of the Angular Zone, otherwise throws an error.
  */
  static assertNotInAngularZone() {
    if (_NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && "Expected to not be in Angular Zone, but it is!");
    }
  }
  /**
   * Executes the `fn` function synchronously within the Angular zone and returns value returned by
   * the function.
   *
   * Running functions via `run` allows you to reenter Angular zone from a task that was executed
   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * within the Angular zone.
   *
   * If a synchronous error happens it will be rethrown and not reported via `onError`.
   */
  run(fn, applyThis, applyArgs) {
    return this._inner.run(fn, applyThis, applyArgs);
  }
  /**
   * Executes the `fn` function synchronously within the Angular zone as a task and returns value
   * returned by the function.
   *
   * Running functions via `run` allows you to reenter Angular zone from a task that was executed
   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * within the Angular zone.
   *
   * If a synchronous error happens it will be rethrown and not reported via `onError`.
   */
  runTask(fn, applyThis, applyArgs, name) {
    const zone = this._inner;
    const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop2, noop2);
    try {
      return zone.runTask(task, applyThis, applyArgs);
    } finally {
      zone.cancelTask(task);
    }
  }
  /**
   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
   * rethrown.
   */
  runGuarded(fn, applyThis, applyArgs) {
    return this._inner.runGuarded(fn, applyThis, applyArgs);
  }
  /**
   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
   * the function.
   *
   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
   * work that
   * doesn't trigger Angular change-detection or is subject to Angular's error handling.
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * outside of the Angular zone.
   *
   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
   */
  runOutsideAngular(fn) {
    return this._outer.run(fn);
  }
};
var EMPTY_PAYLOAD = {};
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.callbackScheduled) {
    return;
  }
  zone.callbackScheduled = true;
  Zone.root.run(() => {
    scheduleCallbackWithRafRace(() => {
      zone.callbackScheduled = false;
      updateMicroTaskStatus(zone);
      zone.isCheckStableRunning = true;
      checkStable(zone);
      zone.isCheckStableRunning = false;
    });
  });
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  zone._inner = zone._inner.fork({
    name: "angular",
    properties: { "isAngularZone": true },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      if (shouldBeIgnoredByZone(applyArgs)) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection && // Do not delay change detection when the task is the scheduler's tick.
        // We need to synchronously trigger the stability logic so that the
        // zone-based scheduler can prevent a duplicate ApplicationRef.tick
        // by first checking if the scheduler tick is running. This does seem a bit roundabout,
        // but we _do_ still want to trigger all the correct events when we exit the zone.run
        // (`onMicrotaskEmpty` and `onStable` _should_ emit; developers can have code which
        // relies on these events happening after change detection runs).
        // Note: `zone.callbackScheduled` is already in delayChangeDetectionForEventsDelegate
        // but is added here as well to prevent reads of applyArgs when not necessary
        !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == "microTask") {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == "macroTask") {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error) => {
      delegate.handleError(target, error);
      zone.runOutsideAngular(() => zone.onError.emit(error));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
var NoopNgZone = class {
  constructor() {
    this.hasPendingMicrotasks = false;
    this.hasPendingMacrotasks = false;
    this.isStable = true;
    this.onUnstable = new EventEmitter();
    this.onMicrotaskEmpty = new EventEmitter();
    this.onStable = new EventEmitter();
    this.onError = new EventEmitter();
  }
  run(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runGuarded(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return fn();
  }
  runTask(fn, applyThis, applyArgs, name) {
    return fn.apply(applyThis, applyArgs);
  }
};
function shouldBeIgnoredByZone(applyArgs) {
  return hasApplyArgsData(applyArgs, "__ignore_ng_zone__");
}
function isSchedulerTick(applyArgs) {
  return hasApplyArgsData(applyArgs, "__scheduler_tick__");
}
function hasApplyArgsData(applyArgs, key) {
  if (!Array.isArray(applyArgs)) {
    return false;
  }
  if (applyArgs.length !== 1) {
    return false;
  }
  return applyArgs[0]?.data?.[key] === true;
}
function getNgZone(ngZoneToUse = "zone.js", options) {
  if (ngZoneToUse === "noop") {
    return new NoopNgZone();
  }
  if (ngZoneToUse === "zone.js") {
    return new NgZone(options);
  }
  return ngZoneToUse;
}
var AfterRenderPhase;
(function(AfterRenderPhase2) {
  AfterRenderPhase2[AfterRenderPhase2["EarlyRead"] = 0] = "EarlyRead";
  AfterRenderPhase2[AfterRenderPhase2["Write"] = 1] = "Write";
  AfterRenderPhase2[AfterRenderPhase2["MixedReadWrite"] = 2] = "MixedReadWrite";
  AfterRenderPhase2[AfterRenderPhase2["Read"] = 3] = "Read";
})(AfterRenderPhase || (AfterRenderPhase = {}));
var NOOP_AFTER_RENDER_REF = {
  destroy() {
  }
};
function internalAfterNextRender(callback, options) {
  const injector = options?.injector ?? inject(Injector);
  if (!options?.runOnServer && !isPlatformBrowser(injector))
    return;
  const afterRenderEventManager = injector.get(AfterRenderEventManager);
  afterRenderEventManager.internalCallbacks.push(callback);
}
function afterNextRender(callback, options) {
  !options && assertInInjectionContext(afterNextRender);
  const injector = options?.injector ?? inject(Injector);
  if (!isPlatformBrowser(injector)) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature("NgAfterNextRender");
  const afterRenderEventManager = injector.get(AfterRenderEventManager);
  const callbackHandler = afterRenderEventManager.handler ??= new AfterRenderCallbackHandlerImpl();
  const phase = options?.phase ?? AfterRenderPhase.MixedReadWrite;
  const destroy = () => {
    callbackHandler.unregister(instance);
    unregisterFn();
  };
  const unregisterFn = injector.get(DestroyRef).onDestroy(destroy);
  const instance = runInInjectionContext(injector, () => new AfterRenderCallback(phase, () => {
    destroy();
    callback();
  }));
  callbackHandler.register(instance);
  return { destroy };
}
var AfterRenderCallback = class {
  constructor(phase, callbackFn) {
    this.phase = phase;
    this.callbackFn = callbackFn;
    this.zone = inject(NgZone);
    this.errorHandler = inject(ErrorHandler, { optional: true });
    inject(ChangeDetectionScheduler, { optional: true })?.notify(
      6
      /* NotificationSource.NewRenderHook */
    );
  }
  invoke() {
    try {
      this.zone.runOutsideAngular(this.callbackFn);
    } catch (err) {
      this.errorHandler?.handleError(err);
    }
  }
};
var AfterRenderCallbackHandlerImpl = class {
  constructor() {
    this.executingCallbacks = false;
    this.buckets = {
      // Note: the order of these keys controls the order the phases are run.
      [AfterRenderPhase.EarlyRead]: /* @__PURE__ */ new Set(),
      [AfterRenderPhase.Write]: /* @__PURE__ */ new Set(),
      [AfterRenderPhase.MixedReadWrite]: /* @__PURE__ */ new Set(),
      [AfterRenderPhase.Read]: /* @__PURE__ */ new Set()
    };
    this.deferredCallbacks = /* @__PURE__ */ new Set();
  }
  register(callback) {
    const target = this.executingCallbacks ? this.deferredCallbacks : this.buckets[callback.phase];
    target.add(callback);
  }
  unregister(callback) {
    this.buckets[callback.phase].delete(callback);
    this.deferredCallbacks.delete(callback);
  }
  execute() {
    this.executingCallbacks = true;
    for (const bucket of Object.values(this.buckets)) {
      for (const callback of bucket) {
        callback.invoke();
      }
    }
    this.executingCallbacks = false;
    for (const callback of this.deferredCallbacks) {
      this.buckets[callback.phase].add(callback);
    }
    this.deferredCallbacks.clear();
  }
  destroy() {
    for (const bucket of Object.values(this.buckets)) {
      bucket.clear();
    }
    this.deferredCallbacks.clear();
  }
};
var _AfterRenderEventManager = class _AfterRenderEventManager {
  constructor() {
    this.handler = null;
    this.internalCallbacks = [];
  }
  /**
   * Executes internal and user-provided callbacks.
   */
  execute() {
    this.executeInternalCallbacks();
    this.handler?.execute();
  }
  executeInternalCallbacks() {
    const callbacks = [...this.internalCallbacks];
    this.internalCallbacks.length = 0;
    for (const callback of callbacks) {
      callback();
    }
  }
  ngOnDestroy() {
    this.handler?.destroy();
    this.handler = null;
    this.internalCallbacks.length = 0;
  }
};
_AfterRenderEventManager.\u0275prov = \u0275\u0275defineInjectable({
  token: _AfterRenderEventManager,
  providedIn: "root",
  factory: () => new _AfterRenderEventManager()
});
var AfterRenderEventManager = _AfterRenderEventManager;
function isModuleWithProviders(value) {
  return value.ngModule !== void 0;
}
function isNgModule(value) {
  return !!getNgModuleDef(value);
}
function isPipe(value) {
  return !!getPipeDef$1(value);
}
function isDirective(value) {
  return !!getDirectiveDef(value);
}
function isComponent(value) {
  return !!getComponentDef(value);
}
function getDependencyTypeForError(type) {
  if (getComponentDef(type))
    return "component";
  if (getDirectiveDef(type))
    return "directive";
  if (getPipeDef$1(type))
    return "pipe";
  return "type";
}
function verifyStandaloneImport(depType, importingType) {
  if (isForwardRef(depType)) {
    depType = resolveForwardRef(depType);
    if (!depType) {
      throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType) || depType}".`);
    }
  }
  if (getNgModuleDef(depType) == null) {
    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef$1(depType);
    if (def != null) {
      if (!def.standalone) {
        throw new Error(`The "${stringifyForError(depType)}" ${getDependencyTypeForError(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
      }
    } else {
      if (isModuleWithProviders(depType)) {
        throw new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`);
      } else {
        throw new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
      }
    }
  }
}
var USE_RUNTIME_DEPS_TRACKER_FOR_JIT = true;
var DepsTracker = class {
  constructor() {
    this.ownerNgModule = /* @__PURE__ */ new Map();
    this.ngModulesWithSomeUnresolvedDecls = /* @__PURE__ */ new Set();
    this.ngModulesScopeCache = /* @__PURE__ */ new Map();
    this.standaloneComponentsScopeCache = /* @__PURE__ */ new Map();
  }
  /**
   * Attempts to resolve ng module's forward ref declarations as much as possible and add them to
   * the `ownerNgModule` map. This method normally should be called after the initial parsing when
   * all the forward refs are resolved (e.g., when trying to render a component)
   */
  resolveNgModulesDecls() {
    if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {
      return;
    }
    for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {
      const def = getNgModuleDef(moduleType);
      if (def?.declarations) {
        for (const decl of maybeUnwrapFn(def.declarations)) {
          if (isComponent(decl)) {
            this.ownerNgModule.set(decl, moduleType);
          }
        }
      }
    }
    this.ngModulesWithSomeUnresolvedDecls.clear();
  }
  /** @override */
  getComponentDependencies(type, rawImports) {
    this.resolveNgModulesDecls();
    const def = getComponentDef(type);
    if (def === null) {
      throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);
    }
    if (def.standalone) {
      const scope = this.getStandaloneComponentScope(type, rawImports);
      if (scope.compilation.isPoisoned) {
        return { dependencies: [] };
      }
      return {
        dependencies: [
          ...scope.compilation.directives,
          ...scope.compilation.pipes,
          ...scope.compilation.ngModules
        ]
      };
    } else {
      if (!this.ownerNgModule.has(type)) {
        return { dependencies: [] };
      }
      const scope = this.getNgModuleScope(this.ownerNgModule.get(type));
      if (scope.compilation.isPoisoned) {
        return { dependencies: [] };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes]
      };
    }
  }
  /**
   * @override
   * This implementation does not make use of param scopeInfo since it assumes the scope info is
   * already added to the type itself through methods like {@link setNgModuleScope}
   */
  registerNgModule(type, scopeInfo) {
    if (!isNgModule(type)) {
      throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);
    }
    this.ngModulesWithSomeUnresolvedDecls.add(type);
  }
  /** @override */
  clearScopeCacheFor(type) {
    this.ngModulesScopeCache.delete(type);
    this.standaloneComponentsScopeCache.delete(type);
  }
  /** @override */
  getNgModuleScope(type) {
    if (this.ngModulesScopeCache.has(type)) {
      return this.ngModulesScopeCache.get(type);
    }
    const scope = this.computeNgModuleScope(type);
    this.ngModulesScopeCache.set(type, scope);
    return scope;
  }
  /** Compute NgModule scope afresh. */
  computeNgModuleScope(type) {
    const def = getNgModuleDef(type, true);
    const scope = {
      exported: { directives: /* @__PURE__ */ new Set(), pipes: /* @__PURE__ */ new Set() },
      compilation: { directives: /* @__PURE__ */ new Set(), pipes: /* @__PURE__ */ new Set() }
    };
    for (const imported of maybeUnwrapFn(def.imports)) {
      if (isNgModule(imported)) {
        const importedScope = this.getNgModuleScope(imported);
        addSet(importedScope.exported.directives, scope.compilation.directives);
        addSet(importedScope.exported.pipes, scope.compilation.pipes);
      } else if (isStandalone(imported)) {
        if (isDirective(imported) || isComponent(imported)) {
          scope.compilation.directives.add(imported);
        } else if (isPipe(imported)) {
          scope.compilation.pipes.add(imported);
        } else {
          throw new RuntimeError(1e3, "The standalone imported type is neither a component nor a directive nor a pipe");
        }
      } else {
        scope.compilation.isPoisoned = true;
        break;
      }
    }
    if (!scope.compilation.isPoisoned) {
      for (const decl of maybeUnwrapFn(def.declarations)) {
        if (isNgModule(decl) || isStandalone(decl)) {
          scope.compilation.isPoisoned = true;
          break;
        }
        if (isPipe(decl)) {
          scope.compilation.pipes.add(decl);
        } else {
          scope.compilation.directives.add(decl);
        }
      }
    }
    for (const exported of maybeUnwrapFn(def.exports)) {
      if (isNgModule(exported)) {
        const exportedScope = this.getNgModuleScope(exported);
        addSet(exportedScope.exported.directives, scope.exported.directives);
        addSet(exportedScope.exported.pipes, scope.exported.pipes);
        addSet(exportedScope.exported.directives, scope.compilation.directives);
        addSet(exportedScope.exported.pipes, scope.compilation.pipes);
      } else if (isPipe(exported)) {
        scope.exported.pipes.add(exported);
      } else {
        scope.exported.directives.add(exported);
      }
    }
    return scope;
  }
  /** @override */
  getStandaloneComponentScope(type, rawImports) {
    if (this.standaloneComponentsScopeCache.has(type)) {
      return this.standaloneComponentsScopeCache.get(type);
    }
    const ans = this.computeStandaloneComponentScope(type, rawImports);
    this.standaloneComponentsScopeCache.set(type, ans);
    return ans;
  }
  computeStandaloneComponentScope(type, rawImports) {
    const ans = {
      compilation: {
        // Standalone components are always able to self-reference.
        directives: /* @__PURE__ */ new Set([type]),
        pipes: /* @__PURE__ */ new Set(),
        ngModules: /* @__PURE__ */ new Set()
      }
    };
    for (const rawImport of flatten(rawImports ?? [])) {
      const imported = resolveForwardRef(rawImport);
      try {
        verifyStandaloneImport(imported, type);
      } catch (e3) {
        ans.compilation.isPoisoned = true;
        return ans;
      }
      if (isNgModule(imported)) {
        ans.compilation.ngModules.add(imported);
        const importedScope = this.getNgModuleScope(imported);
        if (importedScope.exported.isPoisoned) {
          ans.compilation.isPoisoned = true;
          return ans;
        }
        addSet(importedScope.exported.directives, ans.compilation.directives);
        addSet(importedScope.exported.pipes, ans.compilation.pipes);
      } else if (isPipe(imported)) {
        ans.compilation.pipes.add(imported);
      } else if (isDirective(imported) || isComponent(imported)) {
        ans.compilation.directives.add(imported);
      } else {
        ans.compilation.isPoisoned = true;
        return ans;
      }
    }
    return ans;
  }
  /** @override */
  isOrphanComponent(cmp) {
    const def = getComponentDef(cmp);
    if (!def || def.standalone) {
      return false;
    }
    this.resolveNgModulesDecls();
    return !this.ownerNgModule.has(cmp);
  }
};
function addSet(sourceSet, targetSet) {
  for (const m3 of sourceSet) {
    targetSet.add(m3);
  }
}
var depsTracker = new DepsTracker();
function computeStaticStyling(tNode, attrs, writeToHost) {
  ngDevMode && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
  let styles = writeToHost ? tNode.styles : null;
  let classes = writeToHost ? tNode.classes : null;
  let mode = 0;
  if (attrs !== null) {
    for (let i3 = 0; i3 < attrs.length; i3++) {
      const value = attrs[i3];
      if (typeof value === "number") {
        mode = value;
      } else if (mode == 1) {
        classes = concatStringsWithSpace(classes, value);
      } else if (mode == 2) {
        const style = value;
        const styleValue = attrs[++i3];
        styles = concatStringsWithSpace(styles, style + ": " + styleValue + ";");
      }
    }
  }
  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
var ComponentFactoryResolver = class extends ComponentFactoryResolver$1 {
  /**
   * @param ngModule The NgModuleRef to which all resolved factories are bound.
   */
  constructor(ngModule) {
    super();
    this.ngModule = ngModule;
  }
  resolveComponentFactory(component) {
    ngDevMode && assertComponentType(component);
    const componentDef = getComponentDef(component);
    return new ComponentFactory(componentDef, this.ngModule);
  }
};
function toRefArray(map2) {
  const array = [];
  for (const publicName in map2) {
    if (!map2.hasOwnProperty(publicName)) {
      continue;
    }
    const value = map2[publicName];
    if (value === void 0) {
      continue;
    }
    array.push({
      propName: Array.isArray(value) ? value[0] : value,
      templateName: publicName
    });
  }
  return array;
}
function getNamespace(elementName) {
  const name = elementName.toLowerCase();
  return name === "svg" ? SVG_NAMESPACE : name === "math" ? MATH_ML_NAMESPACE : null;
}
var ChainedInjector = class {
  constructor(injector, parentInjector) {
    this.injector = injector;
    this.parentInjector = parentInjector;
  }
  get(token, notFoundValue, flags) {
    flags = convertToBitFlags(flags);
    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
      return value;
    }
    return this.parentInjector.get(token, notFoundValue, flags);
  }
};
var ComponentFactory = class extends ComponentFactory$1 {
  get inputs() {
    const componentDef = this.componentDef;
    const inputTransforms = componentDef.inputTransforms;
    const refArray = toRefArray(componentDef.inputs);
    if (inputTransforms !== null) {
      for (const input2 of refArray) {
        if (inputTransforms.hasOwnProperty(input2.propName)) {
          input2.transform = inputTransforms[input2.propName];
        }
      }
    }
    return refArray;
  }
  get outputs() {
    return toRefArray(this.componentDef.outputs);
  }
  /**
   * @param componentDef The component definition.
   * @param ngModule The NgModuleRef to which the factory is bound.
   */
  constructor(componentDef, ngModule) {
    super();
    this.componentDef = componentDef;
    this.ngModule = ngModule;
    this.componentType = componentDef.type;
    this.selector = stringifyCSSSelectorList(componentDef.selectors);
    this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
    this.isBoundToModule = !!ngModule;
  }
  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (ngDevMode && false) {
        if (depsTracker.isOrphanComponent(this.componentType)) {
          throw new RuntimeError(1001, `Orphan component found! Trying to render the component ${debugStringifyTypeForError(this.componentType)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);
        }
      }
      environmentInjector = environmentInjector || this.ngModule;
      let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;
      if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {
        realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
      }
      const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
      const rendererFactory = rootViewInjector.get(RendererFactory2, null);
      if (rendererFactory === null) {
        throw new RuntimeError(407, ngDevMode && "Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");
      }
      const sanitizer = rootViewInjector.get(Sanitizer, null);
      const afterRenderEventManager = rootViewInjector.get(AfterRenderEventManager, null);
      const changeDetectionScheduler = rootViewInjector.get(ChangeDetectionScheduler, null);
      const environment2 = {
        rendererFactory,
        sanitizer,
        // We don't use inline effects (yet).
        inlineEffectRunner: null,
        afterRenderEventManager,
        changeDetectionScheduler
      };
      const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
      const elementName = this.componentDef.selectors[0][0] || "div";
      const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation, rootViewInjector) : createElementNode(hostRenderer, elementName, getNamespace(elementName));
      let rootFlags = 512;
      if (this.componentDef.signals) {
        rootFlags |= 4096;
      } else if (!this.componentDef.onPush) {
        rootFlags |= 16;
      }
      let hydrationInfo = null;
      if (hostRNode !== null) {
        hydrationInfo = retrieveHydrationInfo(
          hostRNode,
          rootViewInjector,
          true
          /* isRootView */
        );
      }
      const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null, null);
      const rootLView = createLView(null, rootTView, null, rootFlags, null, null, environment2, hostRenderer, rootViewInjector, null, hydrationInfo);
      enterView(rootLView);
      let component;
      let tElementNode;
      try {
        const rootComponentDef = this.componentDef;
        let rootDirectives;
        let hostDirectiveDefs = null;
        if (rootComponentDef.findHostDirectiveDefs) {
          rootDirectives = [];
          hostDirectiveDefs = /* @__PURE__ */ new Map();
          rootComponentDef.findHostDirectiveDefs(rootComponentDef, rootDirectives, hostDirectiveDefs);
          rootDirectives.push(rootComponentDef);
          ngDevMode && assertNoDuplicateDirectives(rootDirectives);
        } else {
          rootDirectives = [rootComponentDef];
        }
        const hostTNode = createRootComponentTNode(rootLView, hostRNode);
        const componentView = createRootComponentView(hostTNode, hostRNode, rootComponentDef, rootDirectives, rootLView, environment2, hostRenderer);
        tElementNode = getTNode(rootTView, HEADER_OFFSET);
        if (hostRNode) {
          setRootNodeAttributes(hostRenderer, rootComponentDef, hostRNode, rootSelectorOrNode);
        }
        if (projectableNodes !== void 0) {
          projectNodes(tElementNode, this.ngContentSelectors, projectableNodes);
        }
        component = createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, [LifecycleHooksFeature]);
        renderView(rootTView, rootLView, null);
      } finally {
        leaveView();
      }
      return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
};
var ComponentRef = class extends ComponentRef$1 {
  constructor(componentType, instance, location2, _rootLView, _tNode) {
    super();
    this.location = location2;
    this._rootLView = _rootLView;
    this._tNode = _tNode;
    this.previousInputValues = null;
    this.instance = instance;
    this.hostView = this.changeDetectorRef = new ViewRef$1(
      _rootLView,
      void 0,
      false
      /* notifyErrorHandler */
    );
    this.componentType = componentType;
  }
  setInput(name, value) {
    const inputData = this._tNode.inputs;
    let dataValue;
    if (inputData !== null && (dataValue = inputData[name])) {
      this.previousInputValues ??= /* @__PURE__ */ new Map();
      if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {
        return;
      }
      const lView = this._rootLView;
      setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);
      this.previousInputValues.set(name, value);
      const childComponentLView = getComponentLViewByIndex(this._tNode.index, lView);
      markViewDirty(
        childComponentLView,
        1
        /* NotificationSource.SetInput */
      );
    } else {
      if (ngDevMode) {
        const cmpNameForError = stringifyForError(this.componentType);
        let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
        message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;
        reportUnknownPropertyError(message);
      }
    }
  }
  get injector() {
    return new NodeInjector(this._tNode, this._rootLView);
  }
  destroy() {
    this.hostView.destroy();
  }
  onDestroy(callback) {
    this.hostView.onDestroy(callback);
  }
};
function createRootComponentTNode(lView, rNode) {
  const tView = lView[TVIEW];
  const index3 = HEADER_OFFSET;
  ngDevMode && assertIndexInRange(lView, index3);
  lView[index3] = rNode;
  return getOrCreateTNode(tView, index3, 2, "#host", null);
}
function createRootComponentView(tNode, hostRNode, rootComponentDef, rootDirectives, rootView, environment2, hostRenderer) {
  const tView = rootView[TVIEW];
  applyRootComponentStyling(rootDirectives, tNode, hostRNode, hostRenderer);
  let hydrationInfo = null;
  if (hostRNode !== null) {
    hydrationInfo = retrieveHydrationInfo(hostRNode, rootView[INJECTOR]);
  }
  const viewRenderer = environment2.rendererFactory.createRenderer(hostRNode, rootComponentDef);
  let lViewFlags = 16;
  if (rootComponentDef.signals) {
    lViewFlags = 4096;
  } else if (rootComponentDef.onPush) {
    lViewFlags = 64;
  }
  const componentView = createLView(rootView, getOrCreateComponentTView(rootComponentDef), null, lViewFlags, rootView[tNode.index], tNode, environment2, viewRenderer, null, null, hydrationInfo);
  if (tView.firstCreatePass) {
    markAsComponentHost(tView, tNode, rootDirectives.length - 1);
  }
  addToViewTree(rootView, componentView);
  return rootView[tNode.index] = componentView;
}
function applyRootComponentStyling(rootDirectives, tNode, rNode, hostRenderer) {
  for (const def of rootDirectives) {
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
    if (rNode !== null) {
      setupStaticAttributes(hostRenderer, rNode, tNode);
    }
  }
}
function createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, hostFeatures) {
  const rootTNode = getCurrentTNode();
  ngDevMode && assertDefined(rootTNode, "tNode should have been already created");
  const tView = rootLView[TVIEW];
  const native = getNativeByTNode(rootTNode, rootLView);
  initializeDirectives(tView, rootLView, rootTNode, rootDirectives, null, hostDirectiveDefs);
  for (let i3 = 0; i3 < rootDirectives.length; i3++) {
    const directiveIndex = rootTNode.directiveStart + i3;
    const directiveInstance = getNodeInjectable(rootLView, tView, directiveIndex, rootTNode);
    attachPatchData(directiveInstance, rootLView);
  }
  invokeDirectivesHostBindings(tView, rootLView, rootTNode);
  if (native) {
    attachPatchData(native, rootLView);
  }
  ngDevMode && assertGreaterThan(rootTNode.componentOffset, -1, "componentOffset must be great than -1");
  const component = getNodeInjectable(rootLView, tView, rootTNode.directiveStart + rootTNode.componentOffset, rootTNode);
  componentView[CONTEXT] = rootLView[CONTEXT] = component;
  if (hostFeatures !== null) {
    for (const feature of hostFeatures) {
      feature(component, rootComponentDef);
    }
  }
  executeContentQueries(tView, rootTNode, rootLView);
  return component;
}
function setRootNodeAttributes(hostRenderer, componentDef, hostRNode, rootSelectorOrNode) {
  if (rootSelectorOrNode) {
    setUpAttributes(hostRenderer, hostRNode, ["ng-version", "18.0.1"]);
  } else {
    const { attrs, classes } = extractAttrsAndClassesFromSelector(componentDef.selectors[0]);
    if (attrs) {
      setUpAttributes(hostRenderer, hostRNode, attrs);
    }
    if (classes && classes.length > 0) {
      writeDirectClass(hostRenderer, hostRNode, classes.join(" "));
    }
  }
}
function projectNodes(tNode, ngContentSelectors, projectableNodes) {
  const projection = tNode.projection = [];
  for (let i3 = 0; i3 < ngContentSelectors.length; i3++) {
    const nodesforSlot = projectableNodes[i3];
    projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
  }
}
function LifecycleHooksFeature() {
  const tNode = getCurrentTNode();
  ngDevMode && assertDefined(tNode, "TNode is required");
  registerPostOrderHooks(getLView()[TVIEW], tNode);
}
var _ViewContainerRef = class _ViewContainerRef {
};
_ViewContainerRef.__NG_ELEMENT_ID__ = injectViewContainerRef;
var ViewContainerRef = _ViewContainerRef;
function injectViewContainerRef() {
  const previousTNode = getCurrentTNode();
  return createContainerRef(previousTNode, getLView());
}
var VE_ViewContainerRef = ViewContainerRef;
var R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
  constructor(_lContainer, _hostTNode, _hostLView) {
    super();
    this._lContainer = _lContainer;
    this._hostTNode = _hostTNode;
    this._hostLView = _hostLView;
  }
  get element() {
    return createElementRef(this._hostTNode, this._hostLView);
  }
  get injector() {
    return new NodeInjector(this._hostTNode, this._hostLView);
  }
  /** @deprecated No replacement */
  get parentInjector() {
    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
    if (hasParentInjector(parentLocation)) {
      const parentView = getParentInjectorView(parentLocation, this._hostLView);
      const injectorIndex = getParentInjectorIndex(parentLocation);
      ngDevMode && assertNodeInjector(parentView, injectorIndex);
      const parentTNode = parentView[TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ];
      return new NodeInjector(parentTNode, parentView);
    } else {
      return new NodeInjector(null, this._hostLView);
    }
  }
  clear() {
    while (this.length > 0) {
      this.remove(this.length - 1);
    }
  }
  get(index3) {
    const viewRefs = getViewRefs(this._lContainer);
    return viewRefs !== null && viewRefs[index3] || null;
  }
  get length() {
    return this._lContainer.length - CONTAINER_HEADER_OFFSET;
  }
  createEmbeddedView(templateRef, context2, indexOrOptions) {
    let index3;
    let injector;
    if (typeof indexOrOptions === "number") {
      index3 = indexOrOptions;
    } else if (indexOrOptions != null) {
      index3 = indexOrOptions.index;
      injector = indexOrOptions.injector;
    }
    const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
    const viewRef = templateRef.createEmbeddedViewImpl(context2 || {}, injector, dehydratedView);
    this.insertImpl(viewRef, index3, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return viewRef;
  }
  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {
    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
    let index3;
    if (isComponentFactory) {
      if (ngDevMode) {
        assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
      }
      index3 = indexOrOptions;
    } else {
      if (ngDevMode) {
        assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
        assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
      }
      const options = indexOrOptions || {};
      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {
        throwError2(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
      }
      index3 = options.index;
      injector = options.injector;
      projectableNodes = options.projectableNodes;
      environmentInjector = options.environmentInjector || options.ngModuleRef;
    }
    const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef(componentFactoryOrType));
    const contextInjector = injector || this.parentInjector;
    if (!environmentInjector && componentFactory.ngModule == null) {
      const _injector = isComponentFactory ? contextInjector : this.parentInjector;
      const result = _injector.get(EnvironmentInjector, null);
      if (result) {
        environmentInjector = result;
      }
    }
    const componentDef = getComponentDef(componentFactory.componentType ?? {});
    const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);
    const rNode = dehydratedView?.firstChild ?? null;
    const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector);
    this.insertImpl(componentRef.hostView, index3, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return componentRef;
  }
  insert(viewRef, index3) {
    return this.insertImpl(viewRef, index3, true);
  }
  insertImpl(viewRef, index3, addToDOM) {
    const lView = viewRef._lView;
    if (ngDevMode && viewRef.destroyed) {
      throw new Error("Cannot insert a destroyed View in a ViewContainer!");
    }
    if (viewAttachedToContainer(lView)) {
      const prevIdx = this.indexOf(viewRef);
      if (prevIdx !== -1) {
        this.detach(prevIdx);
      } else {
        const prevLContainer = lView[PARENT];
        ngDevMode && assertEqual(isLContainer(prevLContainer), true, "An attached view should have its PARENT point to a container.");
        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
        prevVCRef.detach(prevVCRef.indexOf(viewRef));
      }
    }
    const adjustedIdx = this._adjustIndex(index3);
    const lContainer = this._lContainer;
    addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);
    viewRef.attachToViewContainerRef();
    addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
    return viewRef;
  }
  move(viewRef, newIndex) {
    if (ngDevMode && viewRef.destroyed) {
      throw new Error("Cannot move a destroyed View in a ViewContainer!");
    }
    return this.insert(viewRef, newIndex);
  }
  indexOf(viewRef) {
    const viewRefsArr = getViewRefs(this._lContainer);
    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
  }
  remove(index3) {
    const adjustedIdx = this._adjustIndex(index3, -1);
    const detachedView = detachView(this._lContainer, adjustedIdx);
    if (detachedView) {
      removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
      destroyLView(detachedView[TVIEW], detachedView);
    }
  }
  detach(index3) {
    const adjustedIdx = this._adjustIndex(index3, -1);
    const view = detachView(this._lContainer, adjustedIdx);
    const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
    return wasDetached ? new ViewRef$1(view) : null;
  }
  _adjustIndex(index3, shift = 0) {
    if (index3 == null) {
      return this.length + shift;
    }
    if (ngDevMode) {
      assertGreaterThan(index3, -1, `ViewRef index must be positive, got ${index3}`);
      assertLessThan(index3, this.length + 1 + shift, "index");
    }
    return index3;
  }
};
function getViewRefs(lContainer) {
  return lContainer[VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
  ngDevMode && assertTNodeType(
    hostTNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  let lContainer;
  const slotValue = hostLView[hostTNode.index];
  if (isLContainer(slotValue)) {
    lContainer = slotValue;
  } else {
    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
    hostLView[hostTNode.index] = lContainer;
    addToViewTree(hostLView, lContainer);
  }
  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function insertAnchorNode(hostLView, hostTNode) {
  const renderer = hostLView[RENDERER];
  ngDevMode && ngDevMode.rendererCreateComment++;
  const commentNode = renderer.createComment(ngDevMode ? "container" : "");
  const hostNative = getNativeByTNode(hostTNode, hostLView);
  const parentOfHostNative = nativeParentNode(renderer, hostNative);
  nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);
  return commentNode;
}
var _locateOrCreateAnchorNode = createAnchorNode;
var _populateDehydratedViewsInLContainer = () => false;
function populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {
  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);
}
function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (lContainer[NATIVE])
    return;
  let commentNode;
  if (hostTNode.type & 8) {
    commentNode = unwrapRNode(slotValue);
  } else {
    commentNode = insertAnchorNode(hostLView, hostTNode);
  }
  lContainer[NATIVE] = commentNode;
}
var LQuery_ = class _LQuery_ {
  constructor(queryList) {
    this.queryList = queryList;
    this.matches = null;
  }
  clone() {
    return new _LQuery_(this.queryList);
  }
  setDirty() {
    this.queryList.setDirty();
  }
};
var LQueries_ = class _LQueries_ {
  constructor(queries = []) {
    this.queries = queries;
  }
  createEmbeddedView(tView) {
    const tQueries = tView.queries;
    if (tQueries !== null) {
      const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
      const viewLQueries = [];
      for (let i3 = 0; i3 < noOfInheritedQueries; i3++) {
        const tQuery = tQueries.getByIndex(i3);
        const parentLQuery = this.queries[tQuery.indexInDeclarationView];
        viewLQueries.push(parentLQuery.clone());
      }
      return new _LQueries_(viewLQueries);
    }
    return null;
  }
  insertView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  detachView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  finishViewCreation(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  dirtyQueriesWithMatches(tView) {
    for (let i3 = 0; i3 < this.queries.length; i3++) {
      if (getTQuery(tView, i3).matches !== null) {
        this.queries[i3].setDirty();
      }
    }
  }
};
var TQueryMetadata_ = class {
  constructor(predicate, flags, read = null) {
    this.flags = flags;
    this.read = read;
    if (typeof predicate === "string") {
      this.predicate = splitQueryMultiSelectors(predicate);
    } else {
      this.predicate = predicate;
    }
  }
};
var TQueries_ = class _TQueries_ {
  constructor(queries = []) {
    this.queries = queries;
  }
  elementStart(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
    for (let i3 = 0; i3 < this.queries.length; i3++) {
      this.queries[i3].elementStart(tView, tNode);
    }
  }
  elementEnd(tNode) {
    for (let i3 = 0; i3 < this.queries.length; i3++) {
      this.queries[i3].elementEnd(tNode);
    }
  }
  embeddedTView(tNode) {
    let queriesForTemplateRef = null;
    for (let i3 = 0; i3 < this.length; i3++) {
      const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
      const tqueryClone = this.getByIndex(i3).embeddedTView(tNode, childQueryIndex);
      if (tqueryClone) {
        tqueryClone.indexInDeclarationView = i3;
        if (queriesForTemplateRef !== null) {
          queriesForTemplateRef.push(tqueryClone);
        } else {
          queriesForTemplateRef = [tqueryClone];
        }
      }
    }
    return queriesForTemplateRef !== null ? new _TQueries_(queriesForTemplateRef) : null;
  }
  template(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
    for (let i3 = 0; i3 < this.queries.length; i3++) {
      this.queries[i3].template(tView, tNode);
    }
  }
  getByIndex(index3) {
    ngDevMode && assertIndexInRange(this.queries, index3);
    return this.queries[index3];
  }
  get length() {
    return this.queries.length;
  }
  track(tquery) {
    this.queries.push(tquery);
  }
};
var TQuery_ = class _TQuery_ {
  constructor(metadata, nodeIndex = -1) {
    this.metadata = metadata;
    this.matches = null;
    this.indexInDeclarationView = -1;
    this.crossesNgTemplate = false;
    this._appliesToNextNode = true;
    this._declarationNodeIndex = nodeIndex;
  }
  elementStart(tView, tNode) {
    if (this.isApplyingToNode(tNode)) {
      this.matchTNode(tView, tNode);
    }
  }
  elementEnd(tNode) {
    if (this._declarationNodeIndex === tNode.index) {
      this._appliesToNextNode = false;
    }
  }
  template(tView, tNode) {
    this.elementStart(tView, tNode);
  }
  embeddedTView(tNode, childQueryIndex) {
    if (this.isApplyingToNode(tNode)) {
      this.crossesNgTemplate = true;
      this.addMatch(-tNode.index, childQueryIndex);
      return new _TQuery_(this.metadata);
    }
    return null;
  }
  isApplyingToNode(tNode) {
    if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
      const declarationNodeIdx = this._declarationNodeIndex;
      let parent2 = tNode.parent;
      while (parent2 !== null && parent2.type & 8 && parent2.index !== declarationNodeIdx) {
        parent2 = parent2.parent;
      }
      return declarationNodeIdx === (parent2 !== null ? parent2.index : -1);
    }
    return this._appliesToNextNode;
  }
  matchTNode(tView, tNode) {
    const predicate = this.metadata.predicate;
    if (Array.isArray(predicate)) {
      for (let i3 = 0; i3 < predicate.length; i3++) {
        const name = predicate[i3];
        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
      }
    } else {
      if (predicate === TemplateRef) {
        if (tNode.type & 4) {
          this.matchTNodeWithReadOption(tView, tNode, -1);
        }
      } else {
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
      }
    }
  }
  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
    if (nodeMatchIdx !== null) {
      const read = this.metadata.read;
      if (read !== null) {
        if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
          this.addMatch(tNode.index, -2);
        } else {
          const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
          if (directiveOrProviderIdx !== null) {
            this.addMatch(tNode.index, directiveOrProviderIdx);
          }
        }
      } else {
        this.addMatch(tNode.index, nodeMatchIdx);
      }
    }
  }
  addMatch(tNodeIdx, matchIdx) {
    if (this.matches === null) {
      this.matches = [tNodeIdx, matchIdx];
    } else {
      this.matches.push(tNodeIdx, matchIdx);
    }
  }
};
function getIdxOfMatchingSelector(tNode, selector) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    for (let i3 = 0; i3 < localNames.length; i3 += 2) {
      if (localNames[i3] === selector) {
        return localNames[i3 + 1];
      }
    }
  }
  return null;
}
function createResultByTNodeType(tNode, currentView) {
  if (tNode.type & (3 | 8)) {
    return createElementRef(tNode, currentView);
  } else if (tNode.type & 4) {
    return createTemplateRef(tNode, currentView);
  }
  return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
  if (matchingIdx === -1) {
    return createResultByTNodeType(tNode, lView);
  } else if (matchingIdx === -2) {
    return createSpecialToken(lView, tNode, read);
  } else {
    return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
  }
}
function createSpecialToken(lView, tNode, read) {
  if (read === ElementRef) {
    return createElementRef(tNode, lView);
  } else if (read === TemplateRef) {
    return createTemplateRef(tNode, lView);
  } else if (read === ViewContainerRef) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12
      /* TNodeType.AnyContainer */
    );
    return createContainerRef(tNode, lView);
  } else {
    ngDevMode && throwError2(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
  }
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
  const lQuery = lView[QUERIES].queries[queryIndex];
  if (lQuery.matches === null) {
    const tViewData = tView.data;
    const tQueryMatches = tQuery.matches;
    const result = [];
    for (let i3 = 0; tQueryMatches !== null && i3 < tQueryMatches.length; i3 += 2) {
      const matchedNodeIdx = tQueryMatches[i3];
      if (matchedNodeIdx < 0) {
        result.push(null);
      } else {
        ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
        const tNode = tViewData[matchedNodeIdx];
        result.push(createResultForNode(lView, tNode, tQueryMatches[i3 + 1], tQuery.metadata.read));
      }
    }
    lQuery.matches = result;
  }
  return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
  const tQuery = tView.queries.getByIndex(queryIndex);
  const tQueryMatches = tQuery.matches;
  if (tQueryMatches !== null) {
    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
    for (let i3 = 0; i3 < tQueryMatches.length; i3 += 2) {
      const tNodeIdx = tQueryMatches[i3];
      if (tNodeIdx > 0) {
        result.push(lViewResults[i3 / 2]);
      } else {
        const childQueryIndex = tQueryMatches[i3 + 1];
        const declarationLContainer = lView[-tNodeIdx];
        ngDevMode && assertLContainer(declarationLContainer);
        for (let i4 = CONTAINER_HEADER_OFFSET; i4 < declarationLContainer.length; i4++) {
          const embeddedLView = declarationLContainer[i4];
          if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
        if (declarationLContainer[MOVED_VIEWS] !== null) {
          const embeddedLViews = declarationLContainer[MOVED_VIEWS];
          for (let i4 = 0; i4 < embeddedLViews.length; i4++) {
            const embeddedLView = embeddedLViews[i4];
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
      }
    }
  }
  return result;
}
function loadQueryInternal(lView, queryIndex) {
  ngDevMode && assertDefined(lView[QUERIES], "LQueries should be defined when trying to load a query");
  ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
  return lView[QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
  const queryList = new QueryList(
    (flags & 4) === 4
    /* QueryFlags.emitDistinctChangesOnly */
  );
  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
  const lQueries = (lView[QUERIES] ??= new LQueries_()).queries;
  return lQueries.push(new LQuery_(queryList)) - 1;
}
function createViewQuery(predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
    if ((flags & 2) === 2) {
      tView.staticViewQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function createContentQuery(directiveIndex, predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    const tNode = getCurrentTNode();
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
    saveContentQueryAndDirectiveIndex(tView, directiveIndex);
    if ((flags & 2) === 2) {
      tView.staticContentQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function splitQueryMultiSelectors(locator) {
  return locator.split(",").map((s3) => s3.trim());
}
function createTQuery(tView, metadata, nodeIndex) {
  if (tView.queries === null)
    tView.queries = new TQueries_();
  tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
  if (directiveIndex !== lastSavedDirectiveIndex) {
    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
  }
}
function getTQuery(tView, index3) {
  ngDevMode && assertDefined(tView.queries, "TQueries must be defined to retrieve a TQuery");
  return tView.queries.getByIndex(index3);
}
function getQueryResults(lView, queryIndex) {
  const tView = lView[TVIEW];
  const tQuery = getTQuery(tView, queryIndex);
  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
}
function isSignal(value) {
  return typeof value === "function" && value[SIGNAL] !== void 0;
}
function signal(initialValue, options) {
  performanceMarkFeature("NgSignals");
  const signalFn = createSignal(initialValue);
  const node = signalFn[SIGNAL];
  if (options?.equal) {
    node.equal = options.equal;
  }
  signalFn.set = (newValue) => signalSetFn(node, newValue);
  signalFn.update = (updateFn) => signalUpdateFn(node, updateFn);
  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);
  if (ngDevMode) {
    signalFn.toString = () => `[Signal: ${signalFn()}]`;
  }
  return signalFn;
}
function signalAsReadonlyFn() {
  const node = this[SIGNAL];
  if (node.readonlyFn === void 0) {
    const readonlyFn = () => this();
    readonlyFn[SIGNAL] = node;
    node.readonlyFn = readonlyFn;
  }
  return node.readonlyFn;
}
function isWritableSignal(value) {
  return isSignal(value) && typeof value.set === "function";
}
function createQuerySignalFn(firstOnly, required) {
  let node;
  const signalFn = createComputed(() => {
    node._dirtyCounter();
    const value = refreshSignalQuery(node, firstOnly);
    if (required && value === void 0) {
      throw new RuntimeError(-951, ngDevMode && "Child query result is required but no value is available.");
    }
    return value;
  });
  node = signalFn[SIGNAL];
  node._dirtyCounter = signal(0);
  node._flatValue = void 0;
  if (ngDevMode) {
    signalFn.toString = () => `[Query Signal]`;
  }
  return signalFn;
}
function createSingleResultOptionalQuerySignalFn() {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    false
  );
}
function createSingleResultRequiredQuerySignalFn() {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    true
  );
}
function createMultiResultQuerySignalFn() {
  return createQuerySignalFn(
    /* firstOnly */
    false,
    /* required */
    false
  );
}
function bindQueryToSignal(target, queryIndex) {
  const node = target[SIGNAL];
  node._lView = getLView();
  node._queryIndex = queryIndex;
  node._queryList = loadQueryInternal(node._lView, queryIndex);
  node._queryList.onDirty(() => node._dirtyCounter.update((v3) => v3 + 1));
}
function refreshSignalQuery(node, firstOnly) {
  const lView = node._lView;
  const queryIndex = node._queryIndex;
  if (lView === void 0 || queryIndex === void 0 || lView[FLAGS] & 4) {
    return firstOnly ? void 0 : EMPTY_ARRAY;
  }
  const queryList = loadQueryInternal(lView, queryIndex);
  const results = getQueryResults(lView, queryIndex);
  queryList.reset(results, unwrapElementRef);
  if (firstOnly) {
    return queryList.first;
  } else {
    const resultChanged = queryList._changesDetected;
    if (resultChanged || node._flatValue === void 0) {
      return node._flatValue = queryList.toArray();
    }
    return node._flatValue;
  }
}
function viewChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultOptionalQuerySignalFn();
}
function viewChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultRequiredQuerySignalFn();
}
var viewChild = (() => {
  viewChildFn.required = viewChildRequiredFn;
  return viewChildFn;
})();
function contentChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChild);
  return createSingleResultOptionalQuerySignalFn();
}
function contentChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChildren);
  return createSingleResultRequiredQuerySignalFn();
}
var contentChild = (() => {
  contentChildFn.required = contentChildRequiredFn;
  return contentChildFn;
})();
function contentChildren(locator, opts) {
  return createMultiResultQuerySignalFn();
}
function createModelSignal(initialValue) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  const emitterRef = new OutputEmitterRef();
  node.value = initialValue;
  function getter() {
    producerAccessed(node);
    assertModelSet(node.value);
    return node.value;
  }
  getter[SIGNAL] = node;
  getter.asReadonly = signalAsReadonlyFn.bind(getter);
  getter.set = (newValue) => {
    if (!node.equal(node.value, newValue)) {
      signalSetFn(node, newValue);
      emitterRef.emit(newValue);
    }
  };
  getter.update = (updateFn) => {
    assertModelSet(node.value);
    getter.set(updateFn(node.value));
  };
  getter.subscribe = emitterRef.subscribe.bind(emitterRef);
  getter.destroyRef = emitterRef.destroyRef;
  if (ngDevMode) {
    getter.toString = () => `[Model Signal: ${getter()}]`;
  }
  return getter;
}
function assertModelSet(value) {
  if (value === REQUIRED_UNSET_VALUE) {
    throw new RuntimeError(-952, ngDevMode && "Model is required but no value is available yet.");
  }
}
function modelFunction(initialValue) {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(initialValue);
}
function modelRequiredFunction() {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(REQUIRED_UNSET_VALUE);
}
var model = (() => {
  modelFunction.required = modelRequiredFunction;
  return modelFunction;
})();
var emitDistinctChangesOnlyDefaultValue = true;
var Query = class {
};
var ContentChildren = makePropDecorator("ContentChildren", (selector, opts = {}) => __spreadValues({
  selector,
  first: false,
  isViewQuery: false,
  descendants: false,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
}, opts), Query);
var ContentChild = makePropDecorator("ContentChild", (selector, opts = {}) => __spreadValues({
  selector,
  first: true,
  isViewQuery: false,
  descendants: true
}, opts), Query);
var ViewChildren = makePropDecorator("ViewChildren", (selector, opts = {}) => __spreadValues({
  selector,
  first: false,
  isViewQuery: true,
  descendants: true,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
}, opts), Query);
var ViewChild = makePropDecorator("ViewChild", (selector, opts) => __spreadValues({
  selector,
  first: true,
  isViewQuery: true,
  descendants: true
}, opts), Query);
function resolveComponentResources(resourceResolver) {
  const componentResolved = [];
  const urlMap = /* @__PURE__ */ new Map();
  function cachedResourceResolve(url) {
    let promise = urlMap.get(url);
    if (!promise) {
      const resp = resourceResolver(url);
      urlMap.set(url, promise = resp.then(unwrapResponse));
    }
    return promise;
  }
  componentResourceResolutionQueue.forEach((component, type) => {
    const promises = [];
    if (component.templateUrl) {
      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
        component.template = template;
      }));
    }
    const styles = typeof component.styles === "string" ? [component.styles] : component.styles || [];
    component.styles = styles;
    if (component.styleUrl && component.styleUrls?.length) {
      throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");
    } else if (component.styleUrls?.length) {
      const styleOffset = component.styles.length;
      const styleUrls = component.styleUrls;
      component.styleUrls.forEach((styleUrl, index3) => {
        styles.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index3] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
    } else if (component.styleUrl) {
      promises.push(cachedResourceResolve(component.styleUrl).then((style) => {
        styles.push(style);
        component.styleUrl = void 0;
      }));
    }
    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
    componentResolved.push(fullyResolved);
  });
  clearResolutionOfComponentResourcesQueue();
  return Promise.all(componentResolved).then(() => void 0);
}
var componentResourceResolutionQueue = /* @__PURE__ */ new Map();
var componentDefPendingResolution = /* @__PURE__ */ new Set();
function maybeQueueResolutionOfComponentResources(type, metadata) {
  if (componentNeedsResolution(metadata)) {
    componentResourceResolutionQueue.set(type, metadata);
    componentDefPendingResolution.add(type);
  }
}
function componentNeedsResolution(component) {
  return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length || component.styleUrl);
}
function clearResolutionOfComponentResourcesQueue() {
  const old = componentResourceResolutionQueue;
  componentResourceResolutionQueue = /* @__PURE__ */ new Map();
  return old;
}
function isComponentResourceResolutionQueueEmpty() {
  return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(response) {
  return typeof response == "string" ? response : response.text();
}
function componentDefResolved(type) {
  componentDefPendingResolution.delete(type);
}
var modules = /* @__PURE__ */ new Map();
var checkForDuplicateNgModules = true;
function assertSameOrNotExisting(id, type, incoming) {
  if (type && type !== incoming && checkForDuplicateNgModules) {
    throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
  }
}
function registerNgModuleType(ngModuleType, id) {
  const existing = modules.get(id) || null;
  assertSameOrNotExisting(id, existing, ngModuleType);
  modules.set(id, ngModuleType);
}
function \u0275\u0275validateIframeAttribute(attrValue, tagName, attrName) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  const element = getNativeByTNode(tNode, lView);
  if (tNode.type === 2 && tagName.toLowerCase() === "iframe") {
    const iframe = element;
    iframe.src = "";
    iframe.srcdoc = trustedHTMLFromString("");
    nativeRemoveNode(lView[RENDERER], iframe);
    const errorMessage = ngDevMode && `Angular has detected that the \`${attrName}\` was applied as a binding to an <iframe>${getTemplateLocationDetails(lView)}. For security reasons, the \`${attrName}\` can be set on an <iframe> as a static attribute only. 
To fix this, switch the \`${attrName}\` binding to a static attribute in a template or in host bindings section.`;
    throw new RuntimeError(-910, errorMessage);
  }
  return attrValue;
}
function getSuperType(type) {
  return Object.getPrototypeOf(type.prototype).constructor;
}
function \u0275\u0275InheritDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let shouldInheritFields = true;
  const inheritanceChain = [definition];
  while (superType) {
    let superDef = void 0;
    if (isComponentDef(definition)) {
      superDef = superType.\u0275cmp || superType.\u0275dir;
    } else {
      if (superType.\u0275cmp) {
        throw new RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);
      }
      superDef = superType.\u0275dir;
    }
    if (superDef) {
      if (shouldInheritFields) {
        inheritanceChain.push(superDef);
        const writeableDef = definition;
        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
        writeableDef.inputTransforms = maybeUnwrapEmpty(definition.inputTransforms);
        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        const superHostBindings = superDef.hostBindings;
        superHostBindings && inheritHostBindings(definition, superHostBindings);
        const superViewQuery = superDef.viewQuery;
        const superContentQueries = superDef.contentQueries;
        superViewQuery && inheritViewQuery(definition, superViewQuery);
        superContentQueries && inheritContentQueries(definition, superContentQueries);
        mergeInputsWithTransforms(definition, superDef);
        fillProperties(definition.outputs, superDef.outputs);
        if (isComponentDef(superDef) && superDef.data.animation) {
          const defData = definition.data;
          defData.animation = (defData.animation || []).concat(superDef.data.animation);
        }
      }
      const features = superDef.features;
      if (features) {
        for (let i3 = 0; i3 < features.length; i3++) {
          const feature = features[i3];
          if (feature && feature.ngInherit) {
            feature(definition);
          }
          if (feature === \u0275\u0275InheritDefinitionFeature) {
            shouldInheritFields = false;
          }
        }
      }
    }
    superType = Object.getPrototypeOf(superType);
  }
  mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeInputsWithTransforms(target, source) {
  for (const key in source.inputs) {
    if (!source.inputs.hasOwnProperty(key)) {
      continue;
    }
    if (target.inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = source.inputs[key];
    if (value === void 0) {
      continue;
    }
    target.inputs[key] = value;
    target.declaredInputs[key] = source.declaredInputs[key];
    if (source.inputTransforms !== null) {
      const minifiedName = Array.isArray(value) ? value[0] : value;
      if (!source.inputTransforms.hasOwnProperty(minifiedName)) {
        continue;
      }
      target.inputTransforms ??= {};
      target.inputTransforms[minifiedName] = source.inputTransforms[minifiedName];
    }
  }
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
  let hostVars = 0;
  let hostAttrs = null;
  for (let i3 = inheritanceChain.length - 1; i3 >= 0; i3--) {
    const def = inheritanceChain[i3];
    def.hostVars = hostVars += def.hostVars;
    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
  }
}
function maybeUnwrapEmpty(value) {
  if (value === EMPTY_OBJ) {
    return {};
  } else if (value === EMPTY_ARRAY) {
    return [];
  } else {
    return value;
  }
}
function inheritViewQuery(definition, superViewQuery) {
  const prevViewQuery = definition.viewQuery;
  if (prevViewQuery) {
    definition.viewQuery = (rf, ctx) => {
      superViewQuery(rf, ctx);
      prevViewQuery(rf, ctx);
    };
  } else {
    definition.viewQuery = superViewQuery;
  }
}
function inheritContentQueries(definition, superContentQueries) {
  const prevContentQueries = definition.contentQueries;
  if (prevContentQueries) {
    definition.contentQueries = (rf, ctx, directiveIndex) => {
      superContentQueries(rf, ctx, directiveIndex);
      prevContentQueries(rf, ctx, directiveIndex);
    };
  } else {
    definition.contentQueries = superContentQueries;
  }
}
function inheritHostBindings(definition, superHostBindings) {
  const prevHostBindings = definition.hostBindings;
  if (prevHostBindings) {
    definition.hostBindings = (rf, ctx) => {
      superHostBindings(rf, ctx);
      prevHostBindings(rf, ctx);
    };
  } else {
    definition.hostBindings = superHostBindings;
  }
}
var COPY_DIRECTIVE_FIELDS = [
  // The child class should use the providers of its parent.
  "providersResolver"
  // Not listed here are any fields which are handled by the `InheritDefinitionFeature`, such
  // as inputs, outputs, and host binding functions.
];
var COPY_COMPONENT_FIELDS = [
  // The child class should use the template function of its parent, including all template
  // semantics.
  "template",
  "decls",
  "consts",
  "vars",
  "onPush",
  "ngContentSelectors",
  // The child class should use the CSS styles of its parent, including all styling semantics.
  "styles",
  "encapsulation",
  // The child class should be checked by the runtime in the same way as its parent.
  "schemas"
];
function \u0275\u0275CopyDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let superDef = void 0;
  if (isComponentDef(definition)) {
    superDef = superType.\u0275cmp;
  } else {
    superDef = superType.\u0275dir;
  }
  const defAny = definition;
  for (const field of COPY_DIRECTIVE_FIELDS) {
    defAny[field] = superDef[field];
  }
  if (isComponentDef(superDef)) {
    for (const field of COPY_COMPONENT_FIELDS) {
      defAny[field] = superDef[field];
    }
  }
}
function \u0275\u0275HostDirectivesFeature(rawHostDirectives) {
  const feature = (definition) => {
    const resolved = (Array.isArray(rawHostDirectives) ? rawHostDirectives : rawHostDirectives()).map((dir) => {
      return typeof dir === "function" ? { directive: resolveForwardRef(dir), inputs: EMPTY_OBJ, outputs: EMPTY_OBJ } : {
        directive: resolveForwardRef(dir.directive),
        inputs: bindingArrayToMap(dir.inputs),
        outputs: bindingArrayToMap(dir.outputs)
      };
    });
    if (definition.hostDirectives === null) {
      definition.findHostDirectiveDefs = findHostDirectiveDefs;
      definition.hostDirectives = resolved;
    } else {
      definition.hostDirectives.unshift(...resolved);
    }
  };
  feature.ngInherit = true;
  return feature;
}
function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
  if (currentDef.hostDirectives !== null) {
    for (const hostDirectiveConfig of currentDef.hostDirectives) {
      const hostDirectiveDef = getDirectiveDef(hostDirectiveConfig.directive);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        validateHostDirective(hostDirectiveConfig, hostDirectiveDef);
      }
      patchDeclaredInputs(hostDirectiveDef.declaredInputs, hostDirectiveConfig.inputs);
      findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
      hostDirectiveDefs.set(hostDirectiveDef, hostDirectiveConfig);
      matchedDefs.push(hostDirectiveDef);
    }
  }
}
function bindingArrayToMap(bindings) {
  if (bindings === void 0 || bindings.length === 0) {
    return EMPTY_OBJ;
  }
  const result = {};
  for (let i3 = 0; i3 < bindings.length; i3 += 2) {
    result[bindings[i3]] = bindings[i3 + 1];
  }
  return result;
}
function patchDeclaredInputs(declaredInputs, exposedInputs) {
  for (const publicName in exposedInputs) {
    if (exposedInputs.hasOwnProperty(publicName)) {
      const remappedPublicName = exposedInputs[publicName];
      const privateName = declaredInputs[publicName];
      if ((typeof ngDevMode === "undefined" || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {
        assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
      }
      declaredInputs[remappedPublicName] = privateName;
    }
  }
}
function validateHostDirective(hostDirectiveConfig, directiveDef) {
  const type = hostDirectiveConfig.directive;
  if (directiveDef === null) {
    if (getComponentDef(type) !== null) {
      throw new RuntimeError(310, `Host directive ${type.name} cannot be a component.`);
    }
    throw new RuntimeError(307, `Could not resolve metadata for host directive ${type.name}. Make sure that the ${type.name} class is annotated with an @Directive decorator.`);
  }
  if (!directiveDef.standalone) {
    throw new RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
  }
  validateMappings("input", directiveDef, hostDirectiveConfig.inputs);
  validateMappings("output", directiveDef, hostDirectiveConfig.outputs);
}
function validateMappings(bindingType, def, hostDirectiveBindings) {
  const className = def.type.name;
  const bindings = bindingType === "input" ? def.inputs : def.outputs;
  for (const publicName in hostDirectiveBindings) {
    if (hostDirectiveBindings.hasOwnProperty(publicName)) {
      if (!bindings.hasOwnProperty(publicName)) {
        throw new RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
      }
      const remappedPublicName = hostDirectiveBindings[publicName];
      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {
        throw new RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
      }
    }
  }
}
function \u0275\u0275InputTransformsFeature(definition) {
  const inputs = definition.inputConfig;
  const inputTransforms = {};
  for (const minifiedKey in inputs) {
    if (inputs.hasOwnProperty(minifiedKey)) {
      const value = inputs[minifiedKey];
      if (Array.isArray(value) && value[3]) {
        inputTransforms[minifiedKey] = value[3];
      }
    }
  }
  definition.inputTransforms = inputTransforms;
}
var NgModuleRef$1 = class {
};
var NgModuleFactory$1 = class {
};
function createNgModule(ngModule, parentInjector) {
  return new NgModuleRef(ngModule, parentInjector ?? null, []);
}
var NgModuleRef = class extends NgModuleRef$1 {
  constructor(ngModuleType, _parent, additionalProviders) {
    super();
    this._parent = _parent;
    this._bootstrapComponents = [];
    this.destroyCbs = [];
    this.componentFactoryResolver = new ComponentFactoryResolver(this);
    const ngModuleDef = getNgModuleDef(ngModuleType);
    ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
    this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
    this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [
      { provide: NgModuleRef$1, useValue: this },
      {
        provide: ComponentFactoryResolver$1,
        useValue: this.componentFactoryResolver
      },
      ...additionalProviders
    ], stringify(ngModuleType), /* @__PURE__ */ new Set(["environment"]));
    this._r3Injector.resolveInjectorInitializers();
    this.instance = this._r3Injector.get(ngModuleType);
  }
  get injector() {
    return this._r3Injector;
  }
  destroy() {
    ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
    const injector = this._r3Injector;
    !injector.destroyed && injector.destroy();
    this.destroyCbs.forEach((fn) => fn());
    this.destroyCbs = null;
  }
  onDestroy(callback) {
    ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
    this.destroyCbs.push(callback);
  }
};
var NgModuleFactory = class extends NgModuleFactory$1 {
  constructor(moduleType) {
    super();
    this.moduleType = moduleType;
  }
  create(parentInjector) {
    return new NgModuleRef(this.moduleType, parentInjector, []);
  }
};
function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
  return new NgModuleRef(moduleType, parentInjector, additionalProviders);
}
var EnvironmentNgModuleRefAdapter = class extends NgModuleRef$1 {
  constructor(config3) {
    super();
    this.componentFactoryResolver = new ComponentFactoryResolver(this);
    this.instance = null;
    const injector = new R3Injector([
      ...config3.providers,
      { provide: NgModuleRef$1, useValue: this },
      { provide: ComponentFactoryResolver$1, useValue: this.componentFactoryResolver }
    ], config3.parent || getNullInjector(), config3.debugName, /* @__PURE__ */ new Set(["environment"]));
    this.injector = injector;
    if (config3.runEnvironmentInitializers) {
      injector.resolveInjectorInitializers();
    }
  }
  destroy() {
    this.injector.destroy();
  }
  onDestroy(callback) {
    this.injector.onDestroy(callback);
  }
};
function createEnvironmentInjector(providers, parent2, debugName = null) {
  const adapter = new EnvironmentNgModuleRefAdapter({
    providers,
    parent: parent2,
    debugName,
    runEnvironmentInitializers: true
  });
  return adapter.injector;
}
var _CachedInjectorService = class _CachedInjectorService {
  constructor() {
    this.cachedInjectors = /* @__PURE__ */ new Map();
  }
  getOrCreateInjector(key, parentInjector, providers, debugName) {
    if (!this.cachedInjectors.has(key)) {
      const injector = providers.length > 0 ? createEnvironmentInjector(providers, parentInjector, debugName) : null;
      this.cachedInjectors.set(key, injector);
    }
    return this.cachedInjectors.get(key);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
};
_CachedInjectorService.\u0275prov = \u0275\u0275defineInjectable({
  token: _CachedInjectorService,
  providedIn: "environment",
  factory: () => new _CachedInjectorService()
});
var CachedInjectorService = _CachedInjectorService;
function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
  return noSideEffects(() => {
    const clazz = type;
    if (decorators !== null) {
      if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
        clazz.decorators.push(...decorators);
      } else {
        clazz.decorators = decorators;
      }
    }
    if (ctorParameters !== null) {
      clazz.ctorParameters = ctorParameters;
    }
    if (propDecorators !== null) {
      if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
        clazz.propDecorators = __spreadValues(__spreadValues({}, clazz.propDecorators), propDecorators);
      } else {
        clazz.propDecorators = propDecorators;
      }
    }
  });
}
var _PendingTasks = class _PendingTasks {
  constructor() {
    this.taskId = 0;
    this.pendingTasks = /* @__PURE__ */ new Set();
    this.hasPendingTasks = new BehaviorSubject(false);
  }
  get _hasPendingTasks() {
    return this.hasPendingTasks.value;
  }
  add() {
    if (!this._hasPendingTasks) {
      this.hasPendingTasks.next(true);
    }
    const taskId = this.taskId++;
    this.pendingTasks.add(taskId);
    return taskId;
  }
  remove(taskId) {
    this.pendingTasks.delete(taskId);
    if (this.pendingTasks.size === 0 && this._hasPendingTasks) {
      this.hasPendingTasks.next(false);
    }
  }
  ngOnDestroy() {
    this.pendingTasks.clear();
    if (this._hasPendingTasks) {
      this.hasPendingTasks.next(false);
    }
  }
};
_PendingTasks.\u0275fac = function PendingTasks_Factory(t3) {
  return new (t3 || _PendingTasks)();
};
_PendingTasks.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PendingTasks, factory: _PendingTasks.\u0275fac, providedIn: "root" });
var PendingTasks = _PendingTasks;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PendingTasks, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _ExperimentalPendingTasks = class _ExperimentalPendingTasks {
  constructor() {
    this.internalPendingTasks = inject(PendingTasks);
  }
  /**
   * Adds a new task that should block application's stability.
   * @returns A cleanup function that removes a task when called.
   */
  add() {
    const taskId = this.internalPendingTasks.add();
    return () => this.internalPendingTasks.remove(taskId);
  }
};
_ExperimentalPendingTasks.\u0275fac = function ExperimentalPendingTasks_Factory(t3) {
  return new (t3 || _ExperimentalPendingTasks)();
};
_ExperimentalPendingTasks.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ExperimentalPendingTasks, factory: _ExperimentalPendingTasks.\u0275fac, providedIn: "root" });
var ExperimentalPendingTasks = _ExperimentalPendingTasks;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExperimentalPendingTasks, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function isListLikeIterable(obj) {
  if (!isJsObject(obj))
    return false;
  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
  Symbol.iterator in obj;
}
function areIterablesEqual(a3, b3, comparator) {
  const iterator1 = a3[Symbol.iterator]();
  const iterator2 = b3[Symbol.iterator]();
  while (true) {
    const item1 = iterator1.next();
    const item2 = iterator2.next();
    if (item1.done && item2.done)
      return true;
    if (item1.done || item2.done)
      return false;
    if (!comparator(item1.value, item2.value))
      return false;
  }
}
function iterateListLike(obj, fn) {
  if (Array.isArray(obj)) {
    for (let i3 = 0; i3 < obj.length; i3++) {
      fn(obj[i3]);
    }
  } else {
    const iterator2 = obj[Symbol.iterator]();
    let item;
    while (!(item = iterator2.next()).done) {
      fn(item.value);
    }
  }
}
function isJsObject(o2) {
  return o2 !== null && (typeof o2 === "function" || typeof o2 === "object");
}
function devModeEqual(a3, b3) {
  const isListLikeIterableA = isListLikeIterable(a3);
  const isListLikeIterableB = isListLikeIterable(b3);
  if (isListLikeIterableA && isListLikeIterableB) {
    return areIterablesEqual(a3, b3, devModeEqual);
  } else {
    const isAObject = a3 && (typeof a3 === "object" || typeof a3 === "function");
    const isBObject = b3 && (typeof b3 === "object" || typeof b3 === "function");
    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
      return true;
    } else {
      return Object.is(a3, b3);
    }
  }
}
function updateBinding(lView, bindingIndex, value) {
  return lView[bindingIndex] = value;
}
function getBinding(lView, bindingIndex) {
  ngDevMode && assertIndexInRange(lView, bindingIndex);
  ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
  return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value) {
  ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
  const oldValue = lView[bindingIndex];
  if (Object.is(oldValue, value)) {
    return false;
  } else {
    if (ngDevMode && isInCheckNoChangesMode()) {
      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
      if (!devModeEqual(oldValueToCompare, value)) {
        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);
      }
      return false;
    }
    lView[bindingIndex] = value;
    return true;
  }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
  const different = bindingUpdated(lView, bindingIndex, exp1);
  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
function isDetachedByI18n(tNode) {
  return (tNode.flags & 32) === 32;
}
function templateFirstCreatePass(index3, tView, lView, templateFn, decls, vars, tagName, attrs, localRefsIndex) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const tNode = getOrCreateTNode(tView, index3, 4, tagName || null, attrs || null);
  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
  registerPostOrderHooks(tView, tNode);
  const embeddedTView = tNode.tView = createTView(
    2,
    tNode,
    templateFn,
    decls,
    vars,
    tView.directiveRegistry,
    tView.pipeRegistry,
    null,
    tView.schemas,
    tViewConsts,
    null
    /* ssrId */
  );
  if (tView.queries !== null) {
    tView.queries.template(tView, tNode);
    embeddedTView.queries = tView.queries.embeddedTView(tNode);
  }
  return tNode;
}
function declareTemplate(declarationLView, declarationTView, index3, templateFn, decls, vars, tagName, attrs, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index3 + HEADER_OFFSET;
  const tNode = declarationTView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, declarationTView, declarationLView, templateFn, decls, vars, tagName, attrs, localRefsIndex) : declarationTView.data[adjustedIndex];
  setCurrentTNode(tNode, false);
  const comment = _locateOrCreateContainerAnchor(declarationTView, declarationLView, tNode, index3);
  if (wasLastNodeCreated()) {
    appendChild(declarationTView, declarationLView, comment, tNode);
  }
  attachPatchData(comment, declarationLView);
  const lContainer = createLContainer(comment, declarationLView, comment, tNode);
  declarationLView[adjustedIndex] = lContainer;
  addToViewTree(declarationLView, lContainer);
  populateDehydratedViewsInLContainer(lContainer, tNode, declarationLView);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(declarationTView, declarationLView, tNode);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function \u0275\u0275template(index3, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareTemplate(lView, tView, index3, templateFn, decls, vars, tagName, attrs, localRefsIndex, localRefExtractor);
  return \u0275\u0275template;
}
var _locateOrCreateContainerAnchor = createContainerAnchorImpl;
function createContainerAnchorImpl(tView, lView, tNode, index3) {
  lastNodeWasCreated(true);
  return lView[RENDERER].createComment(ngDevMode ? "container" : "");
}
var DeferDependenciesLoadingState;
(function(DeferDependenciesLoadingState2) {
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["NOT_STARTED"] = 0] = "NOT_STARTED";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["IN_PROGRESS"] = 1] = "IN_PROGRESS";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["COMPLETE"] = 2] = "COMPLETE";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["FAILED"] = 3] = "FAILED";
})(DeferDependenciesLoadingState || (DeferDependenciesLoadingState = {}));
var MINIMUM_SLOT = 0;
var LOADING_AFTER_SLOT = 1;
var DeferBlockState;
(function(DeferBlockState2) {
  DeferBlockState2[DeferBlockState2["Placeholder"] = 0] = "Placeholder";
  DeferBlockState2[DeferBlockState2["Loading"] = 1] = "Loading";
  DeferBlockState2[DeferBlockState2["Complete"] = 2] = "Complete";
  DeferBlockState2[DeferBlockState2["Error"] = 3] = "Error";
})(DeferBlockState || (DeferBlockState = {}));
var DeferBlockInternalState;
(function(DeferBlockInternalState2) {
  DeferBlockInternalState2[DeferBlockInternalState2["Initial"] = -1] = "Initial";
})(DeferBlockInternalState || (DeferBlockInternalState = {}));
var NEXT_DEFER_BLOCK_STATE = 0;
var DEFER_BLOCK_STATE = 1;
var STATE_IS_FROZEN_UNTIL = 2;
var LOADING_AFTER_CLEANUP_FN = 3;
var TRIGGER_CLEANUP_FNS = 4;
var PREFETCH_TRIGGER_CLEANUP_FNS = 5;
var DeferBlockBehavior;
(function(DeferBlockBehavior2) {
  DeferBlockBehavior2[DeferBlockBehavior2["Manual"] = 0] = "Manual";
  DeferBlockBehavior2[DeferBlockBehavior2["Playthrough"] = 1] = "Playthrough";
})(DeferBlockBehavior || (DeferBlockBehavior = {}));
function storeTriggerCleanupFn(type, lDetails, cleanupFn) {
  const key = type === 1 ? PREFETCH_TRIGGER_CLEANUP_FNS : TRIGGER_CLEANUP_FNS;
  if (lDetails[key] === null) {
    lDetails[key] = [];
  }
  lDetails[key].push(cleanupFn);
}
function invokeTriggerCleanupFns(type, lDetails) {
  const key = type === 1 ? PREFETCH_TRIGGER_CLEANUP_FNS : TRIGGER_CLEANUP_FNS;
  const cleanupFns = lDetails[key];
  if (cleanupFns !== null) {
    for (const cleanupFn of cleanupFns) {
      cleanupFn();
    }
    lDetails[key] = null;
  }
}
function invokeAllTriggerCleanupFns(lDetails) {
  invokeTriggerCleanupFns(1, lDetails);
  invokeTriggerCleanupFns(0, lDetails);
}
function getDeferBlockDataIndex(deferBlockIndex) {
  return deferBlockIndex + 1;
}
function getLDeferBlockDetails(lView, tNode) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return lView[slotIndex];
}
function setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  lView[slotIndex] = lDetails;
}
function getTDeferBlockDetails(tView, tNode) {
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return tView.data[slotIndex];
}
function setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  tView.data[slotIndex] = deferBlockConfig;
}
function getTemplateIndexForState(newState, hostLView, tNode) {
  const tView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  switch (newState) {
    case DeferBlockState.Complete:
      return tDetails.primaryTmplIndex;
    case DeferBlockState.Loading:
      return tDetails.loadingTmplIndex;
    case DeferBlockState.Error:
      return tDetails.errorTmplIndex;
    case DeferBlockState.Placeholder:
      return tDetails.placeholderTmplIndex;
    default:
      ngDevMode && throwError2(`Unexpected defer block state: ${newState}`);
      return null;
  }
}
function getMinimumDurationForState(tDetails, currentState) {
  if (currentState === DeferBlockState.Placeholder) {
    return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;
  } else if (currentState === DeferBlockState.Loading) {
    return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;
  }
  return null;
}
function getLoadingBlockAfter(tDetails) {
  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;
}
function addDepsToRegistry(currentDeps, newDeps) {
  if (!currentDeps || currentDeps.length === 0) {
    return newDeps;
  }
  const currentDepSet = new Set(currentDeps);
  for (const dep of newDeps) {
    currentDepSet.add(dep);
  }
  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);
}
function getPrimaryBlockTNode(tView, tDetails) {
  const adjustedIndex = tDetails.primaryTmplIndex + HEADER_OFFSET;
  return getTNode(tView, adjustedIndex);
}
function assertDeferredDependenciesLoaded(tDetails) {
  assertEqual(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, "Expecting all deferred dependencies to be loaded.");
}
var eventListenerOptions = {
  passive: true,
  capture: true
};
var hoverTriggers = /* @__PURE__ */ new WeakMap();
var interactionTriggers = /* @__PURE__ */ new WeakMap();
var viewportTriggers = /* @__PURE__ */ new WeakMap();
var interactionEventNames = ["click", "keydown"];
var hoverEventNames = ["mouseenter", "focusin"];
var intersectionObserver = null;
var observedViewportElements = 0;
var DeferEventEntry = class {
  constructor() {
    this.callbacks = /* @__PURE__ */ new Set();
    this.listener = () => {
      for (const callback of this.callbacks) {
        callback();
      }
    };
  }
};
function onInteraction(trigger, callback) {
  let entry = interactionTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    interactionTriggers.set(trigger, entry);
    for (const name of interactionEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const { callbacks, listener } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      interactionTriggers.delete(trigger);
      for (const name of interactionEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
    }
  };
}
function onHover(trigger, callback) {
  let entry = hoverTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    hoverTriggers.set(trigger, entry);
    for (const name of hoverEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const { callbacks, listener } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      for (const name of hoverEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
      hoverTriggers.delete(trigger);
    }
  };
}
function onViewport(trigger, callback, injector) {
  const ngZone = injector.get(NgZone);
  let entry = viewportTriggers.get(trigger);
  intersectionObserver = intersectionObserver || ngZone.runOutsideAngular(() => {
    return new IntersectionObserver((entries) => {
      for (const current of entries) {
        if (current.isIntersecting && viewportTriggers.has(current.target)) {
          ngZone.run(viewportTriggers.get(current.target).listener);
        }
      }
    });
  });
  if (!entry) {
    entry = new DeferEventEntry();
    ngZone.runOutsideAngular(() => intersectionObserver.observe(trigger));
    viewportTriggers.set(trigger, entry);
    observedViewportElements++;
  }
  entry.callbacks.add(callback);
  return () => {
    if (!viewportTriggers.has(trigger)) {
      return;
    }
    entry.callbacks.delete(callback);
    if (entry.callbacks.size === 0) {
      intersectionObserver?.unobserve(trigger);
      viewportTriggers.delete(trigger);
      observedViewportElements--;
    }
    if (observedViewportElements === 0) {
      intersectionObserver?.disconnect();
      intersectionObserver = null;
    }
  };
}
function getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {
  if (walkUpTimes == null) {
    return deferredHostLView;
  }
  if (walkUpTimes >= 0) {
    return walkUpViews(walkUpTimes, deferredHostLView);
  }
  const deferredContainer = deferredHostLView[deferredTNode.index];
  ngDevMode && assertLContainer(deferredContainer);
  const triggerLView = deferredContainer[CONTAINER_HEADER_OFFSET] ?? null;
  if (ngDevMode && triggerLView !== null) {
    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    assertEqual(renderedState, DeferBlockState.Placeholder, "Expected a placeholder to be rendered in this defer block.");
    assertLView(triggerLView);
  }
  return triggerLView;
}
function getTriggerElement(triggerLView, triggerIndex) {
  const element = getNativeByIndex(HEADER_OFFSET + triggerIndex, triggerLView);
  ngDevMode && assertElement(element);
  return element;
}
function registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type) {
  const injector = initialLView[INJECTOR];
  function pollDomTrigger() {
    if (isDestroyed(initialLView)) {
      return;
    }
    const lDetails = getLDeferBlockDetails(initialLView, tNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {
      return;
    }
    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);
    if (!triggerLView) {
      internalAfterNextRender(pollDomTrigger, { injector });
      return;
    }
    if (isDestroyed(triggerLView)) {
      return;
    }
    const element = getTriggerElement(triggerLView, triggerIndex);
    const cleanup = registerFn(element, () => {
      if (initialLView !== triggerLView) {
        removeLViewOnDestroy(triggerLView, cleanup);
      }
      callback();
    }, injector);
    if (initialLView !== triggerLView) {
      storeLViewOnDestroy(triggerLView, cleanup);
    }
    storeTriggerCleanupFn(type, lDetails, cleanup);
  }
  internalAfterNextRender(pollDomTrigger, { injector });
}
function onIdle(callback, lView) {
  const injector = lView[INJECTOR];
  const scheduler = injector.get(IdleScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(callback);
  return cleanupFn;
}
var _requestIdleCallback = () => typeof requestIdleCallback !== "undefined" ? requestIdleCallback : setTimeout;
var _cancelIdleCallback = () => typeof requestIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
var _IdleScheduler = class _IdleScheduler {
  constructor() {
    this.executingCallbacks = false;
    this.idleId = null;
    this.current = /* @__PURE__ */ new Set();
    this.deferred = /* @__PURE__ */ new Set();
    this.ngZone = inject(NgZone);
    this.requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);
    this.cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);
  }
  add(callback) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    target.add(callback);
    if (this.idleId === null) {
      this.scheduleIdleCallback();
    }
  }
  remove(callback) {
    const { current, deferred } = this;
    current.delete(callback);
    deferred.delete(callback);
    if (current.size === 0 && deferred.size === 0) {
      this.cancelIdleCallback();
    }
  }
  scheduleIdleCallback() {
    const callback = () => {
      this.cancelIdleCallback();
      this.executingCallbacks = true;
      for (const callback2 of this.current) {
        callback2();
      }
      this.current.clear();
      this.executingCallbacks = false;
      if (this.deferred.size > 0) {
        for (const callback2 of this.deferred) {
          this.current.add(callback2);
        }
        this.deferred.clear();
        this.scheduleIdleCallback();
      }
    };
    this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));
  }
  cancelIdleCallback() {
    if (this.idleId !== null) {
      this.cancelIdleCallbackFn(this.idleId);
      this.idleId = null;
    }
  }
  ngOnDestroy() {
    this.cancelIdleCallback();
    this.current.clear();
    this.deferred.clear();
  }
};
_IdleScheduler.\u0275prov = \u0275\u0275defineInjectable({
  token: _IdleScheduler,
  providedIn: "root",
  factory: () => new _IdleScheduler()
});
var IdleScheduler = _IdleScheduler;
function onTimer(delay) {
  return (callback, lView) => scheduleTimerTrigger(delay, callback, lView);
}
function scheduleTimerTrigger(delay, callback, lView) {
  const injector = lView[INJECTOR];
  const scheduler = injector.get(TimerScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(delay, callback);
  return cleanupFn;
}
var _TimerScheduler = class _TimerScheduler {
  constructor() {
    this.executingCallbacks = false;
    this.timeoutId = null;
    this.invokeTimerAt = null;
    this.current = [];
    this.deferred = [];
  }
  add(delay, callback) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    this.addToQueue(target, Date.now() + delay, callback);
    this.scheduleTimer();
  }
  remove(callback) {
    const { current, deferred } = this;
    const callbackIndex = this.removeFromQueue(current, callback);
    if (callbackIndex === -1) {
      this.removeFromQueue(deferred, callback);
    }
    if (current.length === 0 && deferred.length === 0) {
      this.clearTimeout();
    }
  }
  addToQueue(target, invokeAt, callback) {
    let insertAtIndex = target.length;
    for (let i3 = 0; i3 < target.length; i3 += 2) {
      const invokeQueuedCallbackAt = target[i3];
      if (invokeQueuedCallbackAt > invokeAt) {
        insertAtIndex = i3;
        break;
      }
    }
    arrayInsert2(target, insertAtIndex, invokeAt, callback);
  }
  removeFromQueue(target, callback) {
    let index3 = -1;
    for (let i3 = 0; i3 < target.length; i3 += 2) {
      const queuedCallback = target[i3 + 1];
      if (queuedCallback === callback) {
        index3 = i3;
        break;
      }
    }
    if (index3 > -1) {
      arraySplice(target, index3, 2);
    }
    return index3;
  }
  scheduleTimer() {
    const callback = () => {
      this.clearTimeout();
      this.executingCallbacks = true;
      const current = [...this.current];
      const now = Date.now();
      for (let i3 = 0; i3 < current.length; i3 += 2) {
        const invokeAt = current[i3];
        const callback2 = current[i3 + 1];
        if (invokeAt <= now) {
          callback2();
        } else {
          break;
        }
      }
      let lastCallbackIndex = -1;
      for (let i3 = 0; i3 < this.current.length; i3 += 2) {
        const invokeAt = this.current[i3];
        if (invokeAt <= now) {
          lastCallbackIndex = i3 + 1;
        } else {
          break;
        }
      }
      if (lastCallbackIndex >= 0) {
        arraySplice(this.current, 0, lastCallbackIndex + 1);
      }
      this.executingCallbacks = false;
      if (this.deferred.length > 0) {
        for (let i3 = 0; i3 < this.deferred.length; i3 += 2) {
          const invokeAt = this.deferred[i3];
          const callback2 = this.deferred[i3 + 1];
          this.addToQueue(this.current, invokeAt, callback2);
        }
        this.deferred.length = 0;
      }
      this.scheduleTimer();
    };
    const FRAME_DURATION_MS = 16;
    if (this.current.length > 0) {
      const now = Date.now();
      const invokeAt = this.current[0];
      if (this.timeoutId === null || // Reschedule a timer in case a queue contains an item with
      // an earlier timestamp and the delta is more than an average
      // frame duration.
      this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {
        this.clearTimeout();
        const timeout = Math.max(invokeAt - now, FRAME_DURATION_MS);
        this.invokeTimerAt = invokeAt;
        this.timeoutId = setTimeout(callback, timeout);
      }
    }
  }
  clearTimeout() {
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  ngOnDestroy() {
    this.clearTimeout();
    this.current.length = 0;
    this.deferred.length = 0;
  }
};
_TimerScheduler.\u0275prov = \u0275\u0275defineInjectable({
  token: _TimerScheduler,
  providedIn: "root",
  factory: () => new _TimerScheduler()
});
var TimerScheduler = _TimerScheduler;
var DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = new InjectionToken("DEFER_BLOCK_DEPENDENCY_INTERCEPTOR");
var DEFER_BLOCK_CONFIG = new InjectionToken(ngDevMode ? "DEFER_BLOCK_CONFIG" : "");
function shouldTriggerDeferBlock(injector) {
  const config3 = injector.get(DEFER_BLOCK_CONFIG, null, { optional: true });
  if (config3?.behavior === DeferBlockBehavior.Manual) {
    return false;
  }
  return isPlatformBrowser(injector);
}
var applyDeferBlockStateWithSchedulingImpl = null;
function \u0275\u0275deferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {
  const tViewConsts = tView.consts;
  if (placeholderConfigIndex != null) {
    tDetails.placeholderBlockConfig = getConstant(tViewConsts, placeholderConfigIndex);
  }
  if (loadingConfigIndex != null) {
    tDetails.loadingBlockConfig = getConstant(tViewConsts, loadingConfigIndex);
  }
  if (applyDeferBlockStateWithSchedulingImpl === null) {
    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;
  }
}
function \u0275\u0275defer(index3, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index3 + HEADER_OFFSET;
  const tNode = declareTemplate(lView, tView, index3, null, 0, 0);
  if (tView.firstCreatePass) {
    performanceMarkFeature("NgDefer");
    const tDetails = {
      primaryTmplIndex,
      loadingTmplIndex: loadingTmplIndex ?? null,
      placeholderTmplIndex: placeholderTmplIndex ?? null,
      errorTmplIndex: errorTmplIndex ?? null,
      placeholderBlockConfig: null,
      loadingBlockConfig: null,
      dependencyResolverFn: dependencyResolverFn ?? null,
      loadingState: DeferDependenciesLoadingState.NOT_STARTED,
      loadingPromise: null,
      providers: null
    };
    enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);
    setTDeferBlockDetails(tView, adjustedIndex, tDetails);
  }
  const lContainer = lView[adjustedIndex];
  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
  const lDetails = [
    null,
    // NEXT_DEFER_BLOCK_STATE
    DeferBlockInternalState.Initial,
    // DEFER_BLOCK_STATE
    null,
    // STATE_IS_FROZEN_UNTIL
    null,
    // LOADING_AFTER_CLEANUP_FN
    null,
    // TRIGGER_CLEANUP_FNS
    null
    // PREFETCH_TRIGGER_CLEANUP_FNS
  ];
  setLDeferBlockDetails(lView, adjustedIndex, lDetails);
  const cleanupTriggersFn = () => invokeAllTriggerCleanupFns(lDetails);
  storeTriggerCleanupFn(0, lDetails, () => removeLViewOnDestroy(lView, cleanupTriggersFn));
  storeLViewOnDestroy(lView, cleanupTriggersFn);
}
function \u0275\u0275deferWhen(rawValue) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value = Boolean(rawValue);
      const tNode = getSelectedTNode();
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const renderedState = lDetails[DEFER_BLOCK_STATE];
      if (value === false && renderedState === DeferBlockInternalState.Initial) {
        renderPlaceholder(lView, tNode);
      } else if (value === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder)) {
        triggerDeferBlock(lView, tNode);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function \u0275\u0275deferPrefetchWhen(rawValue) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value = Boolean(rawValue);
      const tView = lView[TVIEW];
      const tNode = getSelectedTNode();
      const tDetails = getTDeferBlockDetails(tView, tNode);
      if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
        triggerPrefetching(tDetails, lView, tNode);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function \u0275\u0275deferOnIdle() {
  scheduleDelayedTrigger(onIdle);
}
function \u0275\u0275deferPrefetchOnIdle() {
  scheduleDelayedPrefetching(onIdle);
}
function \u0275\u0275deferOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const injector = lView[INJECTOR];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (!shouldTriggerDeferBlock(injector) || tDetails.loadingTmplIndex === null) {
    renderPlaceholder(lView, tNode);
  }
  triggerDeferBlock(lView, tNode);
}
function \u0275\u0275deferPrefetchOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function \u0275\u0275deferOnTimer(delay) {
  scheduleDelayedTrigger(onTimer(delay));
}
function \u0275\u0275deferPrefetchOnTimer(delay) {
  scheduleDelayedPrefetching(onTimer(delay));
}
function \u0275\u0275deferOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  registerDomTrigger(
    lView,
    tNode,
    triggerIndex,
    walkUpTimes,
    onHover,
    () => triggerDeferBlock(lView, tNode),
    0
    /* TriggerType.Regular */
  );
}
function \u0275\u0275deferPrefetchOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  registerDomTrigger(
    lView,
    tNode,
    triggerIndex,
    walkUpTimes,
    onInteraction,
    () => triggerDeferBlock(lView, tNode),
    0
    /* TriggerType.Regular */
  );
}
function \u0275\u0275deferPrefetchOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  registerDomTrigger(
    lView,
    tNode,
    triggerIndex,
    walkUpTimes,
    onViewport,
    () => triggerDeferBlock(lView, tNode),
    0
    /* TriggerType.Regular */
  );
}
function \u0275\u0275deferPrefetchOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewport,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function scheduleDelayedTrigger(scheduleFn) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  renderPlaceholder(lView, tNode);
  if (isPlatformBrowser(lView[INJECTOR])) {
    const cleanupFn = scheduleFn(() => triggerDeferBlock(lView, tNode), lView);
    const lDetails = getLDeferBlockDetails(lView, tNode);
    storeTriggerCleanupFn(0, lDetails, cleanupFn);
  }
}
function scheduleDelayedPrefetching(scheduleFn) {
  const lView = getLView();
  if (isPlatformBrowser(lView[INJECTOR])) {
    const tNode = getCurrentTNode();
    const tView = lView[TVIEW];
    const tDetails = getTDeferBlockDetails(tView, tNode);
    if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const prefetch = () => triggerPrefetching(tDetails, lView, tNode);
      const cleanupFn = scheduleFn(prefetch, lView);
      storeTriggerCleanupFn(1, lDetails, cleanupFn);
    }
  }
}
function renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {
  const hostLView = lContainer[PARENT];
  const hostTView = hostLView[TVIEW];
  if (isDestroyed(hostLView))
    return;
  ngDevMode && assertTNodeForLView(tNode, hostLView);
  const lDetails = getLDeferBlockDetails(hostLView, tNode);
  ngDevMode && assertDefined(lDetails, "Expected a defer block state defined");
  const currentState = lDetails[DEFER_BLOCK_STATE];
  if (isValidStateChange(currentState, newState) && isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {
    const injector = hostLView[INJECTOR];
    const tDetails = getTDeferBlockDetails(hostTView, tNode);
    const needsScheduling = !skipTimerScheduling && isPlatformBrowser(injector) && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));
    if (ngDevMode && needsScheduling) {
      assertDefined(applyDeferBlockStateWithSchedulingImpl, "Expected scheduling function to be defined");
    }
    const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;
    try {
      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);
    } catch (error) {
      handleError(hostLView, error);
    }
  }
}
function isRouterOutletInjector(currentInjector) {
  return currentInjector instanceof ChainedInjector && typeof currentInjector.injector.__ngOutletInjector === "function";
}
function createRouterOutletInjector(parentOutletInjector, parentInjector) {
  const outletInjector = parentOutletInjector.injector;
  return outletInjector.__ngOutletInjector(parentInjector);
}
function applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {
  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);
  if (stateTmplIndex !== null) {
    lDetails[DEFER_BLOCK_STATE] = newState;
    const hostTView = hostLView[TVIEW];
    const adjustedIndex = stateTmplIndex + HEADER_OFFSET;
    const activeBlockTNode = getTNode(hostTView, adjustedIndex);
    const viewIndex = 0;
    removeLViewFromLContainer(lContainer, viewIndex);
    let injector;
    if (newState === DeferBlockState.Complete) {
      const tDetails = getTDeferBlockDetails(hostTView, tNode);
      const providers = tDetails.providers;
      if (providers && providers.length > 0) {
        const parentInjector = hostLView[INJECTOR];
        const isParentOutletInjector = isRouterOutletInjector(parentInjector);
        const parentEnvInjector = isParentOutletInjector ? parentInjector : parentInjector.get(EnvironmentInjector);
        injector = parentEnvInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentEnvInjector, providers, ngDevMode ? "DeferBlock Injector" : "");
        if (isParentOutletInjector) {
          injector = createRouterOutletInjector(parentInjector, injector);
        }
      }
    }
    const dehydratedView = findMatchingDehydratedView(lContainer, activeBlockTNode.tView.ssrId);
    const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, {
      dehydratedView,
      injector
    });
    addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));
    markViewDirty(
      embeddedLView,
      2
      /* NotificationSource.DeferBlockStateUpdate */
    );
  }
}
function applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {
  const now = Date.now();
  const hostTView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(hostTView, tNode);
  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now) {
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    const loadingAfter = getLoadingBlockAfter(tDetails);
    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;
    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {
      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
      const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);
      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;
    } else {
      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {
        lDetails[LOADING_AFTER_CLEANUP_FN]();
        lDetails[LOADING_AFTER_CLEANUP_FN] = null;
        lDetails[NEXT_DEFER_BLOCK_STATE] = null;
      }
      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);
      const duration = getMinimumDurationForState(tDetails, newState);
      if (duration !== null) {
        lDetails[STATE_IS_FROZEN_UNTIL] = now + duration;
        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);
      }
    }
  } else {
    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
  }
}
function scheduleDeferBlockUpdate(timeout, lDetails, tNode, lContainer, hostLView) {
  const callback = () => {
    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    lDetails[NEXT_DEFER_BLOCK_STATE] = null;
    if (nextState !== null) {
      renderDeferBlockState(nextState, tNode, lContainer);
    }
  };
  return scheduleTimerTrigger(timeout, callback, hostLView);
}
function isValidStateChange(currentState, newState) {
  return currentState < newState;
}
function triggerPrefetching(tDetails, lView, tNode) {
  if (lView[INJECTOR] && shouldTriggerDeferBlock(lView[INJECTOR])) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function triggerResourceLoading(tDetails, lView, tNode) {
  const injector = lView[INJECTOR];
  const tView = lView[TVIEW];
  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {
    return tDetails.loadingPromise ?? Promise.resolve();
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);
  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;
  invokeTriggerCleanupFns(1, lDetails);
  let dependenciesFn = tDetails.dependencyResolverFn;
  if (ngDevMode) {
    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {
      optional: true
    });
    if (deferDependencyInterceptor) {
      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);
    }
  }
  const pendingTasks = injector.get(PendingTasks);
  const taskId = pendingTasks.add();
  if (!dependenciesFn) {
    tDetails.loadingPromise = Promise.resolve().then(() => {
      tDetails.loadingPromise = null;
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      pendingTasks.remove(taskId);
    });
    return tDetails.loadingPromise;
  }
  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then((results) => {
    let failed = false;
    const directiveDefs = [];
    const pipeDefs = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        const dependency = result.value;
        const directiveDef = getComponentDef(dependency) || getDirectiveDef(dependency);
        if (directiveDef) {
          directiveDefs.push(directiveDef);
        } else {
          const pipeDef = getPipeDef$1(dependency);
          if (pipeDef) {
            pipeDefs.push(pipeDef);
          }
        }
      } else {
        failed = true;
        break;
      }
    }
    tDetails.loadingPromise = null;
    pendingTasks.remove(taskId);
    if (failed) {
      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;
      if (tDetails.errorTmplIndex === null) {
        const templateLocation = getTemplateLocationDetails(lView);
        const error = new RuntimeError(750, ngDevMode && `Loading dependencies for \`@defer\` block failed, but no \`@error\` block was configured${templateLocation}. Consider using the \`@error\` block to render an error state.`);
        handleError(lView, error);
      }
    } else {
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      const primaryBlockTView = primaryBlockTNode.tView;
      if (directiveDefs.length > 0) {
        primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);
        const directiveTypes = directiveDefs.map((def) => def.type);
        const providers = internalImportProvidersFrom(false, ...directiveTypes);
        tDetails.providers = providers;
      }
      if (pipeDefs.length > 0) {
        primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);
      }
    }
  });
  return tDetails.loadingPromise;
}
function renderPlaceholder(lView, tNode) {
  const lContainer = lView[tNode.index];
  ngDevMode && assertLContainer(lContainer);
  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);
}
function renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {
  ngDevMode && assertDefined(tDetails.loadingPromise, "Expected loading Promise to exist on this defer block");
  tDetails.loadingPromise.then(() => {
    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
    }
  });
}
function triggerDeferBlock(lView, tNode) {
  const tView = lView[TVIEW];
  const lContainer = lView[tNode.index];
  const injector = lView[INJECTOR];
  ngDevMode && assertLContainer(lContainer);
  if (!shouldTriggerDeferBlock(injector))
    return;
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(tView, tNode);
  invokeAllTriggerCleanupFns(lDetails);
  switch (tDetails.loadingState) {
    case DeferDependenciesLoadingState.NOT_STARTED:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      triggerResourceLoading(tDetails, lView, tNode);
      if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {
        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      }
      break;
    case DeferDependenciesLoadingState.IN_PROGRESS:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.COMPLETE:
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.FAILED:
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
      break;
    default:
      if (ngDevMode) {
        throwError2("Unknown defer block state");
      }
  }
}
function \u0275\u0275attribute(name, value, sanitizer, namespace) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, "attr." + name, bindingIndex);
  }
  return \u0275\u0275attribute;
}
function interpolationV(lView, values) {
  ngDevMode && assertLessThan(2, values.length, "should have at least 3 values");
  ngDevMode && assertEqual(values.length % 2, 1, "should have an odd number of values");
  let isBindingUpdated = false;
  let bindingIndex = getBindingIndex();
  for (let i3 = 1; i3 < values.length; i3 += 2) {
    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i3]) || isBindingUpdated;
  }
  setBindingIndex(bindingIndex);
  if (!isBindingUpdated) {
    return NO_CHANGE;
  }
  let content = values[0];
  for (let i3 = 1; i3 < values.length; i3 += 2) {
    content += renderStringify(values[i3]) + values[i3 + 1];
  }
  return content;
}
function interpolation1(lView, prefix, v0, suffix) {
  const different = bindingUpdated(lView, nextBindingIndex(), v0);
  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
  incrementBindingIndex(2);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v22, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v22);
  incrementBindingIndex(3);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v22) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v22, i22, v3, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v22, v3);
  incrementBindingIndex(4);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v22) + i22 + renderStringify(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v22, v3);
  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
  incrementBindingIndex(5);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v22) + i22 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v22, v3);
  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
  incrementBindingIndex(6);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v22) + i22 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v22, v3);
  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
  incrementBindingIndex(7);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v22) + i22 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v22, v3);
  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
  incrementBindingIndex(8);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v22) + i22 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
}
function \u0275\u0275attributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 1, prefix, suffix);
  }
  return \u0275\u0275attributeInterpolate1;
}
function \u0275\u0275attributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 2, prefix, i0, suffix);
  }
  return \u0275\u0275attributeInterpolate2;
}
function \u0275\u0275attributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v22, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v22, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);
  }
  return \u0275\u0275attributeInterpolate3;
}
function \u0275\u0275attributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v22, i22, v3, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v22, i22, v3, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 4, prefix, i0, i1, i22, suffix);
  }
  return \u0275\u0275attributeInterpolate4;
}
function \u0275\u0275attributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 5, prefix, i0, i1, i22, i3, suffix);
  }
  return \u0275\u0275attributeInterpolate5;
}
function \u0275\u0275attributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 6, prefix, i0, i1, i22, i3, i4, suffix);
  }
  return \u0275\u0275attributeInterpolate6;
}
function \u0275\u0275attributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 7, prefix, i0, i1, i22, i3, i4, i5, suffix);
  }
  return \u0275\u0275attributeInterpolate7;
}
function \u0275\u0275attributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 8, prefix, i0, i1, i22, i3, i4, i5, i6, suffix);
  }
  return \u0275\u0275attributeInterpolate8;
}
function \u0275\u0275attributeInterpolateV(attrName, values, sanitizer, namespace) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);
    if (ngDevMode) {
      const interpolationInBetween = [values[0]];
      for (let i3 = 2; i3 < values.length; i3 += 2) {
        interpolationInBetween.push(values[i3]);
      }
      storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
    }
  }
  return \u0275\u0275attributeInterpolateV;
}
function toTStylingRange(prev, next) {
  ngDevMode && assertNumberInRange(
    prev,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    previous,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~4294836224 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~131068 | //
  next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 1;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index3, isHostBinding, isClassBinding) {
  ngDevMode && assertFirstUpdatePass(getTView());
  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
  let tmplHead = getTStylingRangePrev(tBindings);
  let tmplTail = getTStylingRangeNext(tBindings);
  tData[index3] = tStylingKeyWithStatic;
  let isKeyDuplicateOfStatic = false;
  let tStylingKey;
  if (Array.isArray(tStylingKeyWithStatic)) {
    const staticKeyValueArray = tStylingKeyWithStatic;
    tStylingKey = staticKeyValueArray[1];
    if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
      isKeyDuplicateOfStatic = true;
    }
  } else {
    tStylingKey = tStylingKeyWithStatic;
  }
  if (isHostBinding) {
    const hasTemplateBindings = tmplTail !== 0;
    if (hasTemplateBindings) {
      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
      tData[index3 + 1] = toTStylingRange(previousNode, tmplHead);
      if (previousNode !== 0) {
        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index3);
      }
      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index3);
    } else {
      tData[index3 + 1] = toTStylingRange(tmplHead, 0);
      if (tmplHead !== 0) {
        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index3);
      }
      tmplHead = index3;
    }
  } else {
    tData[index3 + 1] = toTStylingRange(tmplTail, 0);
    ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
    if (tmplHead === 0) {
      tmplHead = index3;
    } else {
      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index3);
    }
    tmplTail = index3;
  }
  if (isKeyDuplicateOfStatic) {
    tData[index3 + 1] = setTStylingRangePrevDuplicate(tData[index3 + 1]);
  }
  markDuplicates(tData, tStylingKey, index3, true);
  markDuplicates(tData, tStylingKey, index3, false);
  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index3, isClassBinding);
  tBindings = toTStylingRange(tmplHead, tmplTail);
  if (isClassBinding) {
    tNode.classBindings = tBindings;
  } else {
    tNode.styleBindings = tBindings;
  }
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index3, isClassBinding) {
  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
  if (residual != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
    tData[index3 + 1] = setTStylingRangeNextDuplicate(tData[index3 + 1]);
  }
}
function markDuplicates(tData, tStylingKey, index3, isPrevDir) {
  const tStylingAtIndex = tData[index3 + 1];
  const isMap = tStylingKey === null;
  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
  let foundDuplicate = false;
  while (cursor !== 0 && (foundDuplicate === false || isMap)) {
    ngDevMode && assertIndexInRange(tData, cursor);
    const tStylingValueAtCursor = tData[cursor];
    const tStyleRangeAtCursor = tData[cursor + 1];
    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
      foundDuplicate = true;
      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
    }
    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
  }
  if (foundDuplicate) {
    tData[index3 + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
  }
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
  ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
  if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that
  // location so we must assume that we have a match.
  tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it
  // contains a match.
  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
    return true;
  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
  }
  return false;
}
var parserState = {
  textEnd: 0,
  key: 0,
  keyEnd: 0,
  value: 0,
  valueEnd: 0
};
function getLastParsedKey(text) {
  return text.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text) {
  return text.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text) {
  resetParserState(text);
  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseClassNameNext(text, index3) {
  const end = parserState.textEnd;
  if (end === index3) {
    return -1;
  }
  index3 = parserState.keyEnd = consumeClassToken(text, parserState.key = index3, end);
  return consumeWhitespace(text, index3, end);
}
function parseStyle(text) {
  resetParserState(text);
  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseStyleNext(text, startIndex) {
  const end = parserState.textEnd;
  let index3 = parserState.key = consumeWhitespace(text, startIndex, end);
  if (end === index3) {
    return -1;
  }
  index3 = parserState.keyEnd = consumeStyleKey(text, index3, end);
  index3 = consumeSeparator(
    text,
    index3,
    end,
    58
    /* CharCode.COLON */
  );
  index3 = parserState.value = consumeWhitespace(text, index3, end);
  index3 = parserState.valueEnd = consumeStyleValue(text, index3, end);
  return consumeSeparator(
    text,
    index3,
    end,
    59
    /* CharCode.SEMI_COLON */
  );
}
function resetParserState(text) {
  parserState.key = 0;
  parserState.keyEnd = 0;
  parserState.value = 0;
  parserState.valueEnd = 0;
  parserState.textEnd = text.length;
}
function consumeWhitespace(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeClassToken(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeStyleKey(text, startIndex, endIndex) {
  let ch;
  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
    startIndex++;
  }
  return startIndex;
}
function consumeSeparator(text, startIndex, endIndex, separator) {
  startIndex = consumeWhitespace(text, startIndex, endIndex);
  if (startIndex < endIndex) {
    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
      malformedStyleError(text, String.fromCharCode(separator), startIndex);
    }
    startIndex++;
  }
  return startIndex;
}
function consumeStyleValue(text, startIndex, endIndex) {
  let ch1 = -1;
  let ch2 = -1;
  let ch3 = -1;
  let i3 = startIndex;
  let lastChIndex = i3;
  while (i3 < endIndex) {
    const ch = text.charCodeAt(i3++);
    if (ch === 59) {
      return lastChIndex;
    } else if (ch === 34 || ch === 39) {
      lastChIndex = i3 = consumeQuotedText(text, ch, i3, endIndex);
    } else if (startIndex === i3 - 4 && // We have seen only 4 characters so far "URL(" (Ignore "foo_URL()")
    ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
      lastChIndex = i3 = consumeQuotedText(text, 41, i3, endIndex);
    } else if (ch > 32) {
      lastChIndex = i3;
    }
    ch3 = ch2;
    ch2 = ch1;
    ch1 = ch & -33;
  }
  return lastChIndex;
}
function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
  let ch1 = -1;
  let index3 = startIndex;
  while (index3 < endIndex) {
    const ch = text.charCodeAt(index3++);
    if (ch == quoteCharCode && ch1 !== 92) {
      return index3;
    }
    if (ch == 92 && ch1 === 92) {
      ch1 = 0;
    } else {
      ch1 = ch;
    }
  }
  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text, expecting, index3) {
  ngDevMode && assertEqual(typeof text === "string", true, "String expected here");
  throw throwError2(`Malformed style at location ${index3} in string '` + text.substring(0, index3) + "[>>" + text.substring(index3, index3 + 1) + "<<]" + text.slice(index3 + 1) + `'. Expecting '${expecting}'.`);
}
function \u0275\u0275property(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275property;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
  const inputs = tNode.inputs;
  const property = isClassBased ? "class" : "style";
  setInputsForProperty(tView, lView, inputs[property], property, value);
}
function \u0275\u0275styleProp(prop, value, suffix) {
  checkStylingProperty(prop, value, suffix, false);
  return \u0275\u0275styleProp;
}
function \u0275\u0275classProp(className, value) {
  checkStylingProperty(className, value, null, true);
  return \u0275\u0275classProp;
}
function \u0275\u0275styleMap(styles) {
  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
}
function styleStringParser(keyValueArray, text) {
  for (let i3 = parseStyle(text); i3 >= 0; i3 = parseStyleNext(text, i3)) {
    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
  }
}
function \u0275\u0275classMap(classes) {
  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text) {
  for (let i3 = parseClassName(text); i3 >= 0; i3 = parseClassNameNext(text, i3)) {
    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
  }
}
function checkStylingProperty(prop, value, suffix, isClassBased) {
  const lView = getLView();
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
  }
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
  }
}
function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
  }
  const lView = getLView();
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
      if (ngDevMode) {
        const tStylingKey = tView.data[bindingIndex];
        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
      }
      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
      ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
      if (staticPrefix !== null) {
        value = concatStringsWithSpace(staticPrefix, value ? value : "");
      }
      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
    } else {
      updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
    }
  }
}
function isInHostBindings(tView, bindingIndex) {
  return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
  ngDevMode && assertFirstUpdatePass(tView);
  const tData = tView.data;
  if (tData[bindingIndex + 1] === null) {
    const tNode = tData[getSelectedIndex()];
    ngDevMode && assertDefined(tNode, "TNode expected");
    const isHostBindings = isInHostBindings(tView, bindingIndex);
    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
      tStylingKey = false;
    }
    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
  }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
  const hostDirectiveDef = getCurrentDirectiveDef(tData);
  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
  if (hostDirectiveDef === null) {
    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
    if (isFirstStylingInstructionInTemplate) {
      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
      residual = null;
    }
  } else {
    const directiveStylingLast = tNode.directiveStylingLast;
    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
    if (isFirstStylingInstructionInHostBinding) {
      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
      if (residual === null) {
        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
        if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
        }
      } else {
        residual = collectResidual(tData, tNode, isClassBased);
      }
    }
  }
  if (residual !== void 0) {
    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
  }
  return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  if (getTStylingRangeNext(bindings) === 0) {
    return void 0;
  }
  return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
  tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
  let residual = void 0;
  const directiveEnd = tNode.directiveEnd;
  ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
  for (let i3 = 1 + tNode.directiveStylingLast; i3 < directiveEnd; i3++) {
    const attrs = tData[i3].hostAttrs;
    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
  }
  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
  let currentDirective = null;
  const directiveEnd = tNode.directiveEnd;
  let directiveStylingLast = tNode.directiveStylingLast;
  if (directiveStylingLast === -1) {
    directiveStylingLast = tNode.directiveStart;
  } else {
    directiveStylingLast++;
  }
  while (directiveStylingLast < directiveEnd) {
    currentDirective = tData[directiveStylingLast];
    ngDevMode && assertDefined(currentDirective, "expected to be defined");
    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
    if (currentDirective === hostDirectiveDef)
      break;
    directiveStylingLast++;
  }
  if (hostDirectiveDef !== null) {
    tNode.directiveStylingLast = directiveStylingLast;
  }
  return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
  const desiredMarker = isClassBased ? 1 : 2;
  let currentMarker = -1;
  if (attrs !== null) {
    for (let i3 = 0; i3 < attrs.length; i3++) {
      const item = attrs[i3];
      if (typeof item === "number") {
        currentMarker = item;
      } else {
        if (currentMarker === desiredMarker) {
          if (!Array.isArray(stylingKey)) {
            stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
          }
          keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i3]);
        }
      }
    }
  }
  return stylingKey === void 0 ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
  if (value == null || value === "")
    return EMPTY_ARRAY;
  const styleKeyValueArray = [];
  const unwrappedValue = unwrapSafeValue(value);
  if (Array.isArray(unwrappedValue)) {
    for (let i3 = 0; i3 < unwrappedValue.length; i3++) {
      keyValueArraySet2(styleKeyValueArray, unwrappedValue[i3], true);
    }
  } else if (typeof unwrappedValue === "object") {
    for (const key in unwrappedValue) {
      if (unwrappedValue.hasOwnProperty(key)) {
        keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
      }
    }
  } else if (typeof unwrappedValue === "string") {
    stringParser(styleKeyValueArray, unwrappedValue);
  } else {
    ngDevMode && throwError2("Unsupported styling type " + typeof unwrappedValue + ": " + unwrappedValue);
  }
  return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value) {
  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
}
function classKeyValueArraySet(keyValueArray, key, value) {
  const stringKey = String(key);
  if (stringKey !== "" && !stringKey.includes(" ")) {
    keyValueArraySet(keyValueArray, stringKey, value);
  }
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
  if (oldKeyValueArray === NO_CHANGE) {
    oldKeyValueArray = EMPTY_ARRAY;
  }
  let oldIndex = 0;
  let newIndex = 0;
  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
  while (oldKey !== null || newKey !== null) {
    ngDevMode && assertLessThan(oldIndex, 999, "Are we stuck in infinite loop?");
    ngDevMode && assertLessThan(newIndex, 999, "Are we stuck in infinite loop?");
    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
    let setKey = null;
    let setValue = void 0;
    if (oldKey === newKey) {
      oldIndex += 2;
      newIndex += 2;
      if (oldValue !== newValue) {
        setKey = newKey;
        setValue = newValue;
      }
    } else if (newKey === null || oldKey !== null && oldKey < newKey) {
      oldIndex += 2;
      setKey = oldKey;
    } else {
      ngDevMode && assertDefined(newKey, "Expecting to have a valid key");
      newIndex += 2;
      setKey = newKey;
      setValue = newValue;
    }
    if (setKey !== null) {
      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
    }
    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
  }
}
function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
  if (!(tNode.type & 3)) {
    return;
  }
  const tData = tView.data;
  const tRange = tData[bindingIndex + 1];
  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
  if (!isStylingValuePresent(higherPriorityValue)) {
    if (!isStylingValuePresent(value)) {
      if (getTStylingRangePrevDuplicate(tRange)) {
        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
      }
    }
    const rNode = getNativeByIndex(getSelectedIndex(), lView);
    applyStyling(renderer, isClassBased, rNode, prop, value);
  }
}
function findStylingValue(tData, tNode, lView, prop, index3, isClassBased) {
  const isPrevDirection = tNode === null;
  let value = void 0;
  while (index3 > 0) {
    const rawKey = tData[index3];
    const containsStatics = Array.isArray(rawKey);
    const key = containsStatics ? rawKey[1] : rawKey;
    const isStylingMap = key === null;
    let valueAtLViewIndex = lView[index3 + 1];
    if (valueAtLViewIndex === NO_CHANGE) {
      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
    }
    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
    if (containsStatics && !isStylingValuePresent(currentValue)) {
      currentValue = keyValueArrayGet(rawKey, prop);
    }
    if (isStylingValuePresent(currentValue)) {
      value = currentValue;
      if (isPrevDirection) {
        return value;
      }
    }
    const tRange = tData[index3 + 1];
    index3 = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
  }
  if (tNode !== null) {
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null) {
      value = keyValueArrayGet(residual, prop);
    }
  }
  return value;
}
function isStylingValuePresent(value) {
  return value !== void 0;
}
function normalizeSuffix(value, suffix) {
  if (value == null || value === "") {
  } else if (typeof suffix === "string") {
    value = value + suffix;
  } else if (typeof value === "object") {
    value = stringify(unwrapSafeValue(value));
  }
  return value;
}
function hasStylingInputShadow(tNode, isClassBased) {
  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
}
function \u0275\u0275classMapInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate3(prefix, v0, i0, v1, i1, v22, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v22, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate4(prefix, v0, i0, v1, i1, v22, i22, v3, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v22, i22, v3, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate5(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate6(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate7(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate8(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolateV(values) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275componentInstance() {
  const instance = getLView()[DECLARATION_COMPONENT_VIEW][CONTEXT];
  ngDevMode && assertDefined(instance, "Expected component instance to be defined");
  return instance;
}
var LiveCollection = class {
  destroy(item) {
  }
  updateValue(index3, value) {
  }
  // operations below could be implemented on top of the operations defined so far, but having
  // them explicitly allow clear expression of intent and potentially more performant
  // implementations
  swap(index1, index22) {
    const startIdx = Math.min(index1, index22);
    const endIdx = Math.max(index1, index22);
    const endItem = this.detach(endIdx);
    if (endIdx - startIdx > 1) {
      const startItem = this.detach(startIdx);
      this.attach(startIdx, endItem);
      this.attach(endIdx, startItem);
    } else {
      this.attach(startIdx, endItem);
    }
  }
  move(prevIndex, newIdx) {
    this.attach(newIdx, this.detach(prevIndex));
  }
};
function valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {
  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {
    return 1;
  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {
    return -1;
  }
  return 0;
}
function recordDuplicateKeys(keyToIdx, key, idx) {
  const idxSoFar = keyToIdx.get(key);
  if (idxSoFar !== void 0) {
    idxSoFar.add(idx);
  } else {
    keyToIdx.set(key, /* @__PURE__ */ new Set([idx]));
  }
}
function reconcile(liveCollection, newCollection, trackByFn) {
  let detachedItems = void 0;
  let liveKeysInTheFuture = void 0;
  let liveStartIdx = 0;
  let liveEndIdx = liveCollection.length - 1;
  const duplicateKeys = ngDevMode ? /* @__PURE__ */ new Map() : void 0;
  if (Array.isArray(newCollection)) {
    let newEndIdx = newCollection.length - 1;
    while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {
      const liveStartValue = liveCollection.at(liveStartIdx);
      const newStartValue = newCollection[liveStartIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newStartValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newStartValue);
        }
        liveStartIdx++;
        continue;
      }
      const liveEndValue = liveCollection.at(liveEndIdx);
      const newEndValue = newCollection[newEndIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(newEndIdx, newEndValue), newEndIdx);
      }
      const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);
      if (isEndMatching !== 0) {
        if (isEndMatching < 0) {
          liveCollection.updateValue(liveEndIdx, newEndValue);
        }
        liveEndIdx--;
        newEndIdx--;
        continue;
      }
      const liveStartKey = trackByFn(liveStartIdx, liveStartValue);
      const liveEndKey = trackByFn(liveEndIdx, liveEndValue);
      const newStartKey = trackByFn(liveStartIdx, newStartValue);
      if (Object.is(newStartKey, liveEndKey)) {
        const newEndKey = trackByFn(newEndIdx, newEndValue);
        if (Object.is(newEndKey, liveStartKey)) {
          liveCollection.swap(liveStartIdx, liveEndIdx);
          liveCollection.updateValue(liveEndIdx, newEndValue);
          newEndIdx--;
          liveEndIdx--;
        } else {
          liveCollection.move(liveEndIdx, liveStartIdx);
        }
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        continue;
      }
      detachedItems ??= new UniqueValueMultiKeyMap();
      liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
      if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        liveEndIdx++;
      } else if (!liveKeysInTheFuture.has(newStartKey)) {
        const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);
        liveCollection.attach(liveStartIdx, newItem);
        liveStartIdx++;
        liveEndIdx++;
      } else {
        detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));
        liveEndIdx--;
      }
    }
    while (liveStartIdx <= newEndIdx) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);
      liveStartIdx++;
    }
  } else if (newCollection != null) {
    const newCollectionIterator = newCollection[Symbol.iterator]();
    let newIterationResult = newCollectionIterator.next();
    while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {
      const liveValue = liveCollection.at(liveStartIdx);
      const newValue = newIterationResult.value;
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newValue);
        }
        liveStartIdx++;
        newIterationResult = newCollectionIterator.next();
      } else {
        detachedItems ??= new UniqueValueMultiKeyMap();
        liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
        const newKey = trackByFn(liveStartIdx, newValue);
        if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {
          liveCollection.updateValue(liveStartIdx, newValue);
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else if (!liveKeysInTheFuture.has(newKey)) {
          liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else {
          const liveKey = trackByFn(liveStartIdx, liveValue);
          detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));
          liveEndIdx--;
        }
      }
    }
    while (!newIterationResult.done) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);
      newIterationResult = newCollectionIterator.next();
    }
  }
  while (liveStartIdx <= liveEndIdx) {
    liveCollection.destroy(liveCollection.detach(liveEndIdx--));
  }
  detachedItems?.forEach((item) => {
    liveCollection.destroy(item);
  });
  if (ngDevMode) {
    let duplicatedKeysMsg = [];
    for (const [key, idxSet] of duplicateKeys) {
      if (idxSet.size > 1) {
        const idx = [...idxSet].sort((a3, b3) => a3 - b3);
        for (let i3 = 1; i3 < idx.length; i3++) {
          duplicatedKeysMsg.push(`key "${stringifyForError(key)}" at index "${idx[i3 - 1]}" and "${idx[i3]}"`);
        }
      }
    }
    if (duplicatedKeysMsg.length > 0) {
      const message = formatRuntimeError(-955, "The provided track expression resulted in duplicated keys for a given collection. Adjust the tracking expression such that it uniquely identifies all the items in the collection. Duplicated keys were: \n" + duplicatedKeysMsg.join(", \n") + ".");
      console.warn(message);
    }
  }
}
function attachPreviouslyDetached(prevCollection, detachedItems, index3, key) {
  if (detachedItems !== void 0 && detachedItems.has(key)) {
    prevCollection.attach(index3, detachedItems.get(key));
    detachedItems.delete(key);
    return true;
  }
  return false;
}
function createOrAttach(liveCollection, detachedItems, trackByFn, index3, value) {
  if (!attachPreviouslyDetached(liveCollection, detachedItems, index3, trackByFn(index3, value))) {
    const newItem = liveCollection.create(index3, value);
    liveCollection.attach(index3, newItem);
  } else {
    liveCollection.updateValue(index3, value);
  }
}
function initLiveItemsInTheFuture(liveCollection, start, end, trackByFn) {
  const keys = /* @__PURE__ */ new Set();
  for (let i3 = start; i3 <= end; i3++) {
    keys.add(trackByFn(i3, liveCollection.at(i3)));
  }
  return keys;
}
var UniqueValueMultiKeyMap = class {
  constructor() {
    this.kvMap = /* @__PURE__ */ new Map();
    this._vMap = void 0;
  }
  has(key) {
    return this.kvMap.has(key);
  }
  delete(key) {
    if (!this.has(key))
      return false;
    const value = this.kvMap.get(key);
    if (this._vMap !== void 0 && this._vMap.has(value)) {
      this.kvMap.set(key, this._vMap.get(value));
      this._vMap.delete(value);
    } else {
      this.kvMap.delete(key);
    }
    return true;
  }
  get(key) {
    return this.kvMap.get(key);
  }
  set(key, value) {
    if (this.kvMap.has(key)) {
      let prevValue = this.kvMap.get(key);
      ngDevMode && assertNotSame(prevValue, value, `Detected a duplicated value ${value} for the key ${key}`);
      if (this._vMap === void 0) {
        this._vMap = /* @__PURE__ */ new Map();
      }
      const vMap = this._vMap;
      while (vMap.has(prevValue)) {
        prevValue = vMap.get(prevValue);
      }
      vMap.set(prevValue, value);
    } else {
      this.kvMap.set(key, value);
    }
  }
  forEach(cb) {
    for (let [key, value] of this.kvMap) {
      cb(value, key);
      if (this._vMap !== void 0) {
        const vMap = this._vMap;
        while (vMap.has(value)) {
          value = vMap.get(value);
          cb(value, key);
        }
      }
    }
  }
};
function \u0275\u0275conditional(matchingTemplateIndex, contextValue) {
  performanceMarkFeature("NgControlFlow");
  const hostLView = getLView();
  const bindingIndex = nextBindingIndex();
  const prevMatchingTemplateIndex = hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;
  const prevContainer = prevMatchingTemplateIndex !== -1 ? getLContainer(hostLView, HEADER_OFFSET + prevMatchingTemplateIndex) : void 0;
  const viewInContainerIdx = 0;
  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (prevContainer !== void 0) {
        removeLViewFromLContainer(prevContainer, viewInContainerIdx);
      }
      if (matchingTemplateIndex !== -1) {
        const nextLContainerIndex = HEADER_OFFSET + matchingTemplateIndex;
        const nextContainer = getLContainer(hostLView, nextLContainerIndex);
        const templateTNode = getExistingTNode(hostLView[TVIEW], nextLContainerIndex);
        const dehydratedView = findMatchingDehydratedView(nextContainer, templateTNode.tView.ssrId);
        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {
          dehydratedView
        });
        addLViewToLContainer(nextContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  } else if (prevContainer !== void 0) {
    const lView = getLViewFromLContainer(prevContainer, viewInContainerIdx);
    if (lView !== void 0) {
      lView[CONTEXT] = contextValue;
    }
  }
}
var RepeaterContext = class {
  constructor(lContainer, $implicit, $index) {
    this.lContainer = lContainer;
    this.$implicit = $implicit;
    this.$index = $index;
  }
  get $count() {
    return this.lContainer.length - CONTAINER_HEADER_OFFSET;
  }
};
function \u0275\u0275repeaterTrackByIndex(index3) {
  return index3;
}
function \u0275\u0275repeaterTrackByIdentity(_3, value) {
  return value;
}
var RepeaterMetadata = class {
  constructor(hasEmptyBlock, trackByFn, liveCollection) {
    this.hasEmptyBlock = hasEmptyBlock;
    this.trackByFn = trackByFn;
    this.liveCollection = liveCollection;
  }
};
function \u0275\u0275repeaterCreate(index3, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {
  performanceMarkFeature("NgControlFlow");
  ngDevMode && assertFunction(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);
  const lView = getLView();
  const tView = getTView();
  const hasEmptyBlock = emptyTemplateFn !== void 0;
  const hostLView = getLView();
  const boundTrackBy = trackByUsesComponentInstance ? (
    // We only want to bind when necessary, because it produces a
    // new function. For pure functions it's not necessary.
    trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT])
  ) : trackByFn;
  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);
  hostLView[HEADER_OFFSET + index3] = metadata;
  declareTemplate(lView, tView, index3 + 1, templateFn, decls, vars, tagName, getConstant(tView.consts, attrsIndex));
  if (hasEmptyBlock) {
    ngDevMode && assertDefined(emptyDecls, "Missing number of declarations for the empty repeater block.");
    ngDevMode && assertDefined(emptyVars, "Missing number of bindings for the empty repeater block.");
    declareTemplate(lView, tView, index3 + 2, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, getConstant(tView.consts, emptyAttrsIndex));
  }
}
function isViewExpensiveToRecreate(lView) {
  return lView.length - HEADER_OFFSET > 2;
}
var OperationsCounter = class {
  constructor() {
    this.created = 0;
    this.destroyed = 0;
  }
  reset() {
    this.created = 0;
    this.destroyed = 0;
  }
  recordCreate() {
    this.created++;
  }
  recordDestroy() {
    this.destroyed++;
  }
  /**
   * A method indicating if the entire collection was re-created as part of the reconciliation pass.
   * Used to warn developers about the usage of a tracking function that might result in excessive
   * amount of view creation / destroy operations.
   *
   * @returns boolean value indicating if a live collection was re-created
   */
  wasReCreated(collectionLen) {
    return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;
  }
};
var LiveCollectionLContainerImpl = class extends LiveCollection {
  constructor(lContainer, hostLView, templateTNode) {
    super();
    this.lContainer = lContainer;
    this.hostLView = hostLView;
    this.templateTNode = templateTNode;
    this.operationsCounter = ngDevMode ? new OperationsCounter() : void 0;
    this.needsIndexUpdate = false;
  }
  get length() {
    return this.lContainer.length - CONTAINER_HEADER_OFFSET;
  }
  at(index3) {
    return this.getLView(index3)[CONTEXT].$implicit;
  }
  attach(index3, lView) {
    const dehydratedView = lView[HYDRATION];
    this.needsIndexUpdate ||= index3 !== this.length;
    addLViewToLContainer(this.lContainer, lView, index3, shouldAddViewToDom(this.templateTNode, dehydratedView));
  }
  detach(index3) {
    this.needsIndexUpdate ||= index3 !== this.length - 1;
    return detachExistingView(this.lContainer, index3);
  }
  create(index3, value) {
    const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);
    const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value, index3), { dehydratedView });
    this.operationsCounter?.recordCreate();
    return embeddedLView;
  }
  destroy(lView) {
    destroyLView(lView[TVIEW], lView);
    this.operationsCounter?.recordDestroy();
  }
  updateValue(index3, value) {
    this.getLView(index3)[CONTEXT].$implicit = value;
  }
  reset() {
    this.needsIndexUpdate = false;
    this.operationsCounter?.reset();
  }
  updateIndexes() {
    if (this.needsIndexUpdate) {
      for (let i3 = 0; i3 < this.length; i3++) {
        this.getLView(i3)[CONTEXT].$index = i3;
      }
    }
  }
  getLView(index3) {
    return getExistingLViewFromLContainer(this.lContainer, index3);
  }
};
function \u0275\u0275repeater(collection) {
  const prevConsumer = setActiveConsumer(null);
  const metadataSlotIdx = getSelectedIndex();
  try {
    const hostLView = getLView();
    const hostTView = hostLView[TVIEW];
    const metadata = hostLView[metadataSlotIdx];
    const containerIndex = metadataSlotIdx + 1;
    const lContainer = getLContainer(hostLView, containerIndex);
    if (metadata.liveCollection === void 0) {
      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
      metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);
    } else {
      metadata.liveCollection.reset();
    }
    const liveCollection = metadata.liveCollection;
    reconcile(liveCollection, collection, metadata.trackByFn);
    if (ngDevMode && metadata.trackByFn === \u0275\u0275repeaterTrackByIdentity && liveCollection.operationsCounter?.wasReCreated(liveCollection.length) && isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))) {
      const message = formatRuntimeError(-956, `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. Please review the "track expression" and make sure that it uniquely identifies items in a collection.`);
      console.warn(message);
    }
    liveCollection.updateIndexes();
    if (metadata.hasEmptyBlock) {
      const bindingIndex = nextBindingIndex();
      const isCollectionEmpty = liveCollection.length === 0;
      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {
        const emptyTemplateIndex = metadataSlotIdx + 2;
        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);
        if (isCollectionEmpty) {
          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
          const dehydratedView = findMatchingDehydratedView(lContainerForEmpty, emptyTemplateTNode.tView.ssrId);
          const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, void 0, { dehydratedView });
          addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
        } else {
          removeLViewFromLContainer(lContainerForEmpty, 0);
        }
      }
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function getLContainer(lView, index3) {
  const lContainer = lView[index3];
  ngDevMode && assertLContainer(lContainer);
  return lContainer;
}
function detachExistingView(lContainer, index3) {
  const existingLView = detachView(lContainer, index3);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index3) {
  const existingLView = getLViewFromLContainer(lContainer, index3);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingTNode(tView, index3) {
  const tNode = getTNode(tView, index3);
  ngDevMode && assertTNode(tNode);
  return tNode;
}
function elementStartFirstCreatePass(index3, tView, lView, name, attrsIndex, localRefsIndex) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index3, 2, name, attrs);
  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function \u0275\u0275elementStart(index3, name, attrsIndex, localRefsIndex) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = HEADER_OFFSET + index3;
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "elements should be created before any bindings");
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  const renderer = lView[RENDERER];
  const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  const native = _locateOrCreateElementNode(tView, lView, tNode, renderer, name, index3);
  lView[adjustedIndex] = native;
  const hasDirectives = isDirectiveHost(tNode);
  if (ngDevMode && tView.firstCreatePass) {
    validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);
  }
  setCurrentTNode(tNode, true);
  setupStaticAttributes(renderer, native, tNode);
  if (!isDetachedByI18n(tNode) && wasLastNodeCreated()) {
    appendChild(tView, lView, native, tNode);
  }
  if (getElementDepthCount() === 0) {
    attachPatchData(native, lView);
  }
  increaseElementDepthCount();
  if (hasDirectives) {
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex !== null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275elementStart;
}
function \u0275\u0275elementEnd() {
  let currentTNode = getCurrentTNode();
  ngDevMode && assertDefined(currentTNode, "No parent node to close.");
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    ngDevMode && assertHasParent(getCurrentTNode());
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  const tNode = currentTNode;
  ngDevMode && assertTNodeType(
    tNode,
    3
    /* TNodeType.AnyRNode */
  );
  if (isSkipHydrationRootTNode(tNode)) {
    leaveSkipHydrationBlock();
  }
  decreaseElementDepthCount();
  const tView = getTView();
  if (tView.firstCreatePass) {
    registerPostOrderHooks(tView, currentTNode);
    if (isContentQueryHost(currentTNode)) {
      tView.queries.elementEnd(currentTNode);
    }
  }
  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);
  }
  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);
  }
  return \u0275\u0275elementEnd;
}
function \u0275\u0275element(index3, name, attrsIndex, localRefsIndex) {
  \u0275\u0275elementStart(index3, name, attrsIndex, localRefsIndex);
  \u0275\u0275elementEnd();
  return \u0275\u0275element;
}
var _locateOrCreateElementNode = (tView, lView, tNode, renderer, name, index3) => {
  lastNodeWasCreated(true);
  return createElementNode(renderer, name, getNamespace$1());
};
function elementContainerStartFirstCreatePass(index3, tView, lView, attrsIndex, localRefsIndex) {
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index3, 8, "ng-container", attrs);
  if (attrs !== null) {
    computeStaticStyling(tNode, attrs, true);
  }
  const localRefs = getConstant(tViewConsts, localRefsIndex);
  resolveDirectives(tView, lView, tNode, localRefs);
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function \u0275\u0275elementContainerStart(index3, attrsIndex, localRefsIndex) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index3 + HEADER_OFFSET;
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "element containers should be created before any bindings");
  const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  setCurrentTNode(tNode, true);
  const comment = _locateOrCreateElementContainerNode(tView, lView, tNode, index3);
  lView[adjustedIndex] = comment;
  if (wasLastNodeCreated()) {
    appendChild(tView, lView, comment, tNode);
  }
  attachPatchData(comment, lView);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275elementContainerStart;
}
function \u0275\u0275elementContainerEnd() {
  let currentTNode = getCurrentTNode();
  const tView = getTView();
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    ngDevMode && assertHasParent(currentTNode);
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  ngDevMode && assertTNodeType(
    currentTNode,
    8
    /* TNodeType.ElementContainer */
  );
  if (tView.firstCreatePass) {
    registerPostOrderHooks(tView, currentTNode);
    if (isContentQueryHost(currentTNode)) {
      tView.queries.elementEnd(currentTNode);
    }
  }
  return \u0275\u0275elementContainerEnd;
}
function \u0275\u0275elementContainer(index3, attrsIndex, localRefsIndex) {
  \u0275\u0275elementContainerStart(index3, attrsIndex, localRefsIndex);
  \u0275\u0275elementContainerEnd();
  return \u0275\u0275elementContainer;
}
var _locateOrCreateElementContainerNode = (tView, lView, tNode, index3) => {
  lastNodeWasCreated(true);
  return createCommentNode(lView[RENDERER], ngDevMode ? "ng-container" : "");
};
function \u0275\u0275getCurrentView() {
  return getLView();
}
function \u0275\u0275hostProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275hostProperty;
}
function \u0275\u0275syntheticHostProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275syntheticHostProperty;
}
if (false) {
  (function() {
    _global["ngI18nClosureMode"] = // TODO(FW-1250): validate that this actually, you know, works.
    // tslint:disable-next-line:no-toplevel-property-access
    typeof goog !== "undefined" && typeof goog.getMsg === "function";
  })();
}
var u = void 0;
function plural(val) {
  const n2 = val, i3 = Math.floor(Math.abs(val)), v3 = val.toString().replace(/^[^.]*\.?/, "").length;
  if (i3 === 1 && v3 === 0)
    return 1;
  return 5;
}
var localeEn = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
var LOCALE_DATA = {};
function findLocaleData(locale) {
  const normalizedLocale = normalizeLocale(locale);
  let match2 = getLocaleData(normalizedLocale);
  if (match2) {
    return match2;
  }
  const parentLocale = normalizedLocale.split("-")[0];
  match2 = getLocaleData(parentLocale);
  if (match2) {
    return match2;
  }
  if (parentLocale === "en") {
    return localeEn;
  }
  throw new RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale}".`);
}
function getLocalePluralCase(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
  if (!(normalizedLocale in LOCALE_DATA)) {
    LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
  }
  return LOCALE_DATA[normalizedLocale];
}
var LocaleDataIndex;
(function(LocaleDataIndex2) {
  LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
  LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
  LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
  LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
  LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
  LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
  LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
  LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
  LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
  LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
  LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
  LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
  LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
  LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
  LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
  LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
  LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
  LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
  LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
  LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
})(LocaleDataIndex || (LocaleDataIndex = {}));
function normalizeLocale(locale) {
  return locale.toLowerCase().replace(/_/g, "-");
}
var pluralMapping = ["zero", "one", "two", "few", "many"];
function getPluralCase(value, locale) {
  const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
  const result = pluralMapping[plural2];
  return result !== void 0 ? result : "other";
}
var DEFAULT_LOCALE_ID = "en-US";
var USD_CURRENCY_CODE = "USD";
var ELEMENT_MARKER = {
  marker: "element"
};
var ICU_MARKER = {
  marker: "ICU"
};
var I18nCreateOpCode;
(function(I18nCreateOpCode2) {
  I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
  I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
  I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
})(I18nCreateOpCode || (I18nCreateOpCode = {}));
var LOCALE_ID$1 = DEFAULT_LOCALE_ID;
function setLocaleId(localeId) {
  ngDevMode && assertDefined(localeId, `Expected localeId to be defined`);
  if (typeof localeId === "string") {
    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
  }
}
function getLocaleId() {
  return LOCALE_ID$1;
}
var changeMask = 0;
var changeMaskCounter = 0;
function setMaskBit(hasChange) {
  if (hasChange) {
    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
  }
  changeMaskCounter++;
}
function applyI18n(tView, lView, index3) {
  if (changeMaskCounter > 0) {
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const tI18n = tView.data[index3];
    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
  }
  changeMask = 0;
  changeMaskCounter = 0;
}
function createNodeWithoutHydration(lView, textOrName, nodeType) {
  const renderer = lView[RENDERER];
  switch (nodeType) {
    case Node.COMMENT_NODE:
      return createCommentNode(renderer, textOrName);
    case Node.TEXT_NODE:
      return createTextNode(renderer, textOrName);
    case Node.ELEMENT_NODE:
      return createElementNode(renderer, textOrName, null);
  }
}
var _locateOrCreateNode = (lView, index3, textOrName, nodeType) => {
  lastNodeWasCreated(true);
  return createNodeWithoutHydration(lView, textOrName, nodeType);
};
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
  const renderer = lView[RENDERER];
  for (let i3 = 0; i3 < createOpCodes.length; i3++) {
    const opCode = createOpCodes[i3++];
    const text = createOpCodes[i3];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index3 = opCode >>> I18nCreateOpCode.SHIFT;
    let rNode = lView[index3];
    let lastNodeWasCreated2 = false;
    if (rNode === null) {
      rNode = lView[index3] = _locateOrCreateNode(lView, index3, text, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);
      lastNodeWasCreated2 = wasLastNodeCreated();
    }
    if (appendNow && parentRNode !== null && lastNodeWasCreated2) {
      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
  }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
  ngDevMode && assertDomNode(anchorRNode);
  const renderer = lView[RENDERER];
  let rootIdx = null;
  let rootRNode;
  for (let i3 = 0; i3 < mutableOpCodes.length; i3++) {
    const opCode = mutableOpCodes[i3];
    if (typeof opCode == "string") {
      const textNodeIndex = mutableOpCodes[++i3];
      if (lView[textNodeIndex] === null) {
        ngDevMode && ngDevMode.rendererCreateTextNode++;
        ngDevMode && assertIndexInRange(lView, textNodeIndex);
        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);
      }
    } else if (typeof opCode == "number") {
      switch (opCode & 1) {
        case 0:
          const parentIdx = getParentFromIcuCreateOpCode(opCode);
          if (rootIdx === null) {
            rootIdx = parentIdx;
            rootRNode = nativeParentNode(renderer, anchorRNode);
          }
          let insertInFrontOf;
          let parentRNode;
          if (parentIdx === rootIdx) {
            insertInFrontOf = anchorRNode;
            parentRNode = rootRNode;
          } else {
            insertInFrontOf = null;
            parentRNode = unwrapRNode(lView[parentIdx]);
          }
          if (parentRNode !== null) {
            ngDevMode && assertDomNode(parentRNode);
            const refIdx = getRefFromIcuCreateOpCode(opCode);
            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, "Missing ref");
            const child = lView[refIdx];
            ngDevMode && assertDomNode(child);
            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
            const tIcu = getTIcu(tView, refIdx);
            if (tIcu !== null && typeof tIcu === "object") {
              ngDevMode && assertTIcu(tIcu);
              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
              if (caseIndex !== null) {
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
              }
            }
          }
          break;
        case 1:
          const elementNodeIndex = opCode >>> 1;
          const attrName = mutableOpCodes[++i3];
          const attrValue = mutableOpCodes[++i3];
          setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
          break;
        default:
          if (ngDevMode) {
            throw new RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
          }
      }
    } else {
      switch (opCode) {
        case ICU_MARKER:
          const commentValue = mutableOpCodes[++i3];
          const commentNodeIndex = mutableOpCodes[++i3];
          if (lView[commentNodeIndex] === null) {
            ngDevMode && assertEqual(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
            ngDevMode && ngDevMode.rendererCreateComment++;
            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
            const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);
            attachPatchData(commentRNode, lView);
          }
          break;
        case ELEMENT_MARKER:
          const tagName = mutableOpCodes[++i3];
          const elementNodeIndex = mutableOpCodes[++i3];
          if (lView[elementNodeIndex] === null) {
            ngDevMode && assertEqual(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
            ngDevMode && ngDevMode.rendererCreateElement++;
            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);
            const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);
            attachPatchData(elementRNode, lView);
          }
          break;
        default:
          ngDevMode && throwError2(`Unable to determine the type of mutate operation for "${opCode}"`);
      }
    }
  }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
  for (let i3 = 0; i3 < updateOpCodes.length; i3++) {
    const checkBit = updateOpCodes[i3];
    const skipCodes = updateOpCodes[++i3];
    if (checkBit & changeMask2) {
      let value = "";
      for (let j4 = i3 + 1; j4 <= i3 + skipCodes; j4++) {
        const opCode = updateOpCodes[j4];
        if (typeof opCode == "string") {
          value += opCode;
        } else if (typeof opCode == "number") {
          if (opCode < 0) {
            value += renderStringify(lView[bindingsStartIndex - opCode]);
          } else {
            const nodeIndex = opCode >>> 2;
            switch (opCode & 3) {
              case 1:
                const propName = updateOpCodes[++j4];
                const sanitizeFn = updateOpCodes[++j4];
                const tNodeOrTagName = tView.data[nodeIndex];
                ngDevMode && assertDefined(tNodeOrTagName, "Experting TNode or string");
                if (typeof tNodeOrTagName === "string") {
                  setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                } else {
                  elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);
                }
                break;
              case 0:
                const rText = lView[nodeIndex];
                rText !== null && updateTextNode(lView[RENDERER], rText, value);
                break;
              case 2:
                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                break;
              case 3:
                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                break;
            }
          }
        }
      }
    } else {
      const opCode = updateOpCodes[i3 + 1];
      if (opCode > 0 && (opCode & 3) === 3) {
        const nodeIndex = opCode >>> 2;
        const tIcu = getTIcu(tView, nodeIndex);
        const currentIndex = lView[tIcu.currentCaseLViewIndex];
        if (currentIndex < 0) {
          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
        }
      }
    }
    i3 += skipCodes;
  }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
  if (activeCaseIndex !== null) {
    let mask = changeMask;
    if (activeCaseIndex < 0) {
      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
      mask = -1;
    }
    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
  }
}
function applyIcuSwitchCase(tView, tIcu, lView, value) {
  const caseIndex = getCaseIndex(tIcu, value);
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== caseIndex) {
    applyIcuSwitchCaseRemove(tView, tIcu, lView);
    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
    if (caseIndex !== null) {
      const anchorRNode = lView[tIcu.anchorIdx];
      if (anchorRNode) {
        ngDevMode && assertDomNode(anchorRNode);
        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
      }
      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);
    }
  }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== null) {
    const removeCodes = tIcu.remove[activeCaseIndex];
    for (let i3 = 0; i3 < removeCodes.length; i3++) {
      const nodeOrIcuIndex = removeCodes[i3];
      if (nodeOrIcuIndex > 0) {
        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
      } else {
        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
      }
    }
  }
}
function getCaseIndex(icuExpression, bindingValue) {
  let index3 = icuExpression.cases.indexOf(bindingValue);
  if (index3 === -1) {
    switch (icuExpression.type) {
      case 1: {
        const resolvedCase = getPluralCase(bindingValue, getLocaleId());
        index3 = icuExpression.cases.indexOf(resolvedCase);
        if (index3 === -1 && resolvedCase !== "other") {
          index3 = icuExpression.cases.indexOf("other");
        }
        break;
      }
      case 0: {
        index3 = icuExpression.cases.indexOf("other");
        break;
      }
    }
  }
  return index3 === -1 ? null : index3;
}
function loadIcuContainerVisitor() {
  const _stack = [];
  let _index = -1;
  let _lView;
  let _removes;
  function icuContainerIteratorStart(tIcuContainerNode, lView) {
    _lView = lView;
    while (_stack.length)
      _stack.pop();
    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
    enterIcu(tIcuContainerNode.value, lView);
    return icuContainerIteratorNext;
  }
  function enterIcu(tIcu, lView) {
    _index = 0;
    const currentCase = getCurrentICUCaseIndex(tIcu, lView);
    if (currentCase !== null) {
      ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
      _removes = tIcu.remove[currentCase];
    } else {
      _removes = EMPTY_ARRAY;
    }
  }
  function icuContainerIteratorNext() {
    if (_index < _removes.length) {
      const removeOpCode = _removes[_index++];
      ngDevMode && assertNumber(removeOpCode, "Expecting OpCode number");
      if (removeOpCode > 0) {
        const rNode = _lView[removeOpCode];
        ngDevMode && assertDomNode(rNode);
        return rNode;
      } else {
        _stack.push(_index, _removes);
        const tIcuIndex = ~removeOpCode;
        const tIcu = _lView[TVIEW].data[tIcuIndex];
        ngDevMode && assertTIcu(tIcu);
        enterIcu(tIcu, _lView);
        return icuContainerIteratorNext();
      }
    } else {
      if (_stack.length === 0) {
        return null;
      } else {
        _removes = _stack.pop();
        _index = _stack.pop();
        return icuContainerIteratorNext();
      }
    }
  }
  return icuContainerIteratorStart;
}
function i18nCreateOpCodesToString(opcodes) {
  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i3 = 0; i3 < createOpCodes.length; i3++) {
    const opCode = createOpCodes[i3++];
    const text = createOpCodes[i3];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index3 = opCode >>> I18nCreateOpCode.SHIFT;
    lines.push(`lView[${index3}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
    if (appendNow) {
      lines.push(`parent.appendChild(lView[${index3}]);`);
    }
  }
  return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(value) {
    const ref = value >>> 2;
    const opCode = value & 3;
    switch (opCode) {
      case 0:
        return `(lView[${ref}] as Text).textContent = $$$`;
      case 1:
        const attrName = parser.consumeString();
        const sanitizationFn = parser.consumeFunction();
        const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
      case 2:
        return `icuSwitchCase(${ref}, $$$)`;
      case 3:
        return `icuUpdateCase(${ref})`;
    }
    throw new Error("unexpected OpCode");
  }
  while (parser.hasMore()) {
    let mask = parser.consumeNumber();
    let size = parser.consumeNumber();
    const end = parser.i + size;
    const statements = [];
    let statement = "";
    while (parser.i < end) {
      let value = parser.consumeNumberOrString();
      if (typeof value === "string") {
        statement += value;
      } else if (value < 0) {
        statement += "${lView[i" + value + "]}";
      } else {
        const opCodeText = consumeOpCode(value);
        statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
        statement = "";
      }
    }
    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
  }
  return lines;
}
function icuCreateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(opCode) {
    const parent2 = getParentFromIcuCreateOpCode(opCode);
    const ref = getRefFromIcuCreateOpCode(opCode);
    switch (getInstructionFromIcuCreateOpCode(opCode)) {
      case 0:
        return `(lView[${parent2}] as Element).appendChild(lView[${lastRef}])`;
      case 1:
        return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
    }
    throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
  }
  let lastRef = -1;
  while (parser.hasMore()) {
    let value = parser.consumeNumberStringOrMarker();
    if (value === ICU_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
    } else if (value === ELEMENT_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
    } else if (typeof value === "string") {
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
    } else if (typeof value === "number") {
      const line = consumeOpCode(value);
      line && lines.push(line);
    } else {
      throw new Error("Unexpected value");
    }
  }
  return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i3 = 0; i3 < removeCodes.length; i3++) {
    const nodeOrIcuIndex = removeCodes[i3];
    if (nodeOrIcuIndex > 0) {
      lines.push(`remove(lView[${nodeOrIcuIndex}])`);
    } else {
      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
  }
  return lines;
}
var OpCodeParser = class {
  constructor(codes) {
    this.i = 0;
    this.codes = codes;
  }
  hasMore() {
    return this.i < this.codes.length;
  }
  consumeNumber() {
    let value = this.codes[this.i++];
    assertNumber(value, "expecting number in OpCode");
    return value;
  }
  consumeString() {
    let value = this.codes[this.i++];
    assertString(value, "expecting string in OpCode");
    return value;
  }
  consumeFunction() {
    let value = this.codes[this.i++];
    if (value === null || typeof value === "function") {
      return value;
    }
    throw new Error("expecting function in OpCode");
  }
  consumeNumberOrString() {
    let value = this.codes[this.i++];
    if (typeof value === "string") {
      return value;
    }
    assertNumber(value, "expecting number or string in OpCode");
    return value;
  }
  consumeNumberStringOrMarker() {
    let value = this.codes[this.i++];
    if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
      return value;
    }
    assertNumber(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
    return value;
  }
};
var BINDING_REGEXP = /(\d+):?\d*/gi;
var ICU_REGEXP = /({\s*\d+:?\d*\s*,\s*\S{6}\s*,[\s\S]*})/gi;
var NESTED_ICU = /(\d+)/;
var ICU_BLOCK_REGEXP = /^\s*(\d+:?\d*)\s*,\s*(select|plural)\s*,/;
var MARKER = `\uFFFD`;
var SUBTEMPLATE_REGEXP = /\/?\*(\d+:\d+)/gi;
var PH_REGEXP = /(\/?[#*]\d+):?\d*/gi;
var NGSP_UNICODE_REGEXP = /\uE500/g;
function replaceNgsp(value) {
  return value.replace(NGSP_UNICODE_REGEXP, " ");
}
function attachDebugGetter(obj, debugGetter) {
  if (ngDevMode) {
    Object.defineProperty(obj, "debug", { get: debugGetter, enumerable: false });
  } else {
    throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
  }
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index3, message, subTemplateIndex) {
  const rootTNode = getCurrentParentTNode();
  const createOpCodes = [];
  const updateOpCodes = [];
  const existingTNodeStack = [[]];
  const astStack = [[]];
  if (ngDevMode) {
    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  message = getTranslationForTemplate(message, subTemplateIndex);
  const msgParts = replaceNgsp(message).split(PH_REGEXP);
  for (let i3 = 0; i3 < msgParts.length; i3++) {
    let value = msgParts[i3];
    if ((i3 & 1) === 0) {
      const parts = i18nParseTextIntoPartsAndICU(value);
      for (let j4 = 0; j4 < parts.length; j4++) {
        let part = parts[j4];
        if ((j4 & 1) === 0) {
          const text = part;
          ngDevMode && assertString(text, "Parsed ICU part should be string");
          if (text !== "") {
            i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
          }
        } else {
          const icuExpression = part;
          if (typeof icuExpression !== "object") {
            throw new Error(`Unable to parse ICU expression in "${message}" message.`);
          }
          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index3}:${icuExpression.mainBinding}` : "", true);
          const icuNodeIndex = icuContainerTNode.index;
          ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, "Index must be in absolute LView offset");
          icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
        }
      }
    } else {
      const isClosing = value.charCodeAt(0) === 47;
      const type = value.charCodeAt(isClosing ? 1 : 0);
      ngDevMode && assertOneOf(
        type,
        42,
        35
        /* CharCode.HASH */
      );
      const index4 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
      if (isClosing) {
        existingTNodeStack.shift();
        astStack.shift();
        setCurrentTNode(getCurrentParentTNode(), false);
      } else {
        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index4);
        existingTNodeStack.unshift([]);
        setCurrentTNode(tNode, true);
        const placeholderNode = {
          kind: 2,
          index: index4,
          children: [],
          type: type === 35 ? 0 : 1
        };
        astStack[0].push(placeholderNode);
        astStack.unshift(placeholderNode.children);
      }
    }
  }
  tView.data[index3] = {
    create: createOpCodes,
    update: updateOpCodes,
    ast: astStack[0]
  };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
  let parentTNode = getCurrentParentTNode();
  if (rootTNode === parentTNode) {
    parentTNode = null;
  }
  if (parentTNode === null) {
    opCode |= I18nCreateOpCode.APPEND_EAGERLY;
  }
  if (isICU) {
    opCode |= I18nCreateOpCode.COMMENT;
    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
  }
  createOpCodes.push(opCode, text === null ? "" : text);
  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? "{{?}}" : "" : text, null);
  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
  const tNodeIdx = tNode.index;
  setCurrentTNode(
    tNode,
    false
    /* Text nodes are self closing */
  );
  if (parentTNode !== null && rootTNode !== parentTNode) {
    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
  }
  return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
  const hasBinding = text.match(BINDING_REGEXP);
  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
  const index3 = tNode.index;
  if (hasBinding) {
    generateBindingUpdateOpCodes(updateOpCodes, text, index3, null, 0, null);
  }
  ast.push({ kind: 0, index: index3 });
}
function i18nAttributesFirstPass(tView, index3, values) {
  const previousElement = getCurrentTNode();
  const previousElementIndex = previousElement.index;
  const updateOpCodes = [];
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  if (tView.firstCreatePass && tView.data[index3] === null) {
    for (let i3 = 0; i3 < values.length; i3 += 2) {
      const attrName = values[i3];
      const message = values[i3 + 1];
      if (message !== "") {
        if (ICU_REGEXP.test(message)) {
          throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
        }
        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
      }
    }
    tView.data[index3] = updateOpCodes;
  }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
  ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, "Index must be in absolute LView offset");
  const maskIndex = updateOpCodes.length;
  const sizeIndex = maskIndex + 1;
  updateOpCodes.push(null, null);
  const startIndex = maskIndex + 2;
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  const textParts = str.split(BINDING_REGEXP);
  let mask = 0;
  for (let j4 = 0; j4 < textParts.length; j4++) {
    const textValue = textParts[j4];
    if (j4 & 1) {
      const bindingIndex = bindingStart + parseInt(textValue, 10);
      updateOpCodes.push(-1 - bindingIndex);
      mask = mask | toMaskBit(bindingIndex);
    } else if (textValue !== "") {
      updateOpCodes.push(textValue);
    }
  }
  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
  if (attrName) {
    updateOpCodes.push(attrName, sanitizeFn);
  }
  updateOpCodes[maskIndex] = mask;
  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
  return mask;
}
function countBindings(opCodes) {
  let count = 0;
  for (let i3 = 0; i3 < opCodes.length; i3++) {
    const opCode = opCodes[i3];
    if (typeof opCode === "number" && opCode < 0) {
      count++;
    }
  }
  return count;
}
function toMaskBit(bindingIndex) {
  return 1 << Math.min(bindingIndex, 31);
}
function removeInnerTemplateTranslation(message) {
  let match2;
  let res = "";
  let index3 = 0;
  let inTemplate = false;
  let tagMatched;
  while ((match2 = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
    if (!inTemplate) {
      res += message.substring(index3, match2.index + match2[0].length);
      tagMatched = match2[1];
      inTemplate = true;
    } else {
      if (match2[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
        index3 = match2.index;
        inTemplate = false;
      }
    }
  }
  ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
  res += message.slice(index3);
  return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
  if (isRootTemplateMessage(subTemplateIndex)) {
    return removeInnerTemplateTranslation(message);
  } else {
    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
    const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
    return removeInnerTemplateTranslation(message.substring(start, end));
  }
}
function icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
  ngDevMode && assertDefined(icuExpression, "ICU expression must be defined");
  let bindingMask = 0;
  const tIcu = {
    type: icuExpression.type,
    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
    anchorIdx,
    cases: [],
    create: [],
    remove: [],
    update: []
  };
  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
  setTIcu(tView, anchorIdx, tIcu);
  const values = icuExpression.values;
  const cases = [];
  for (let i3 = 0; i3 < values.length; i3++) {
    const valueArr = values[i3];
    const nestedIcus = [];
    for (let j4 = 0; j4 < valueArr.length; j4++) {
      const value = valueArr[j4];
      if (typeof value !== "string") {
        const icuIndex = nestedIcus.push(value) - 1;
        valueArr[j4] = `<!--\uFFFD${icuIndex}\uFFFD-->`;
      }
    }
    const caseAst = [];
    cases.push(caseAst);
    bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i3], valueArr.join(""), nestedIcus) | bindingMask;
  }
  if (bindingMask) {
    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
  }
  ast.push({
    kind: 3,
    index: anchorIdx,
    cases,
    currentCaseLViewIndex: tIcu.currentCaseLViewIndex
  });
}
function parseICUBlock(pattern) {
  const cases = [];
  const values = [];
  let icuType = 1;
  let mainBinding = 0;
  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
    if (type === "select") {
      icuType = 0;
    } else {
      icuType = 1;
    }
    mainBinding = parseInt(binding.slice(1), 10);
    return "";
  });
  const parts = i18nParseTextIntoPartsAndICU(pattern);
  for (let pos = 0; pos < parts.length; ) {
    let key = parts[pos++].trim();
    if (icuType === 1) {
      key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
    }
    if (key.length) {
      cases.push(key);
    }
    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
    if (cases.length > values.length) {
      values.push(blocks);
    }
  }
  return { type: icuType, mainBinding, cases, values };
}
function i18nParseTextIntoPartsAndICU(pattern) {
  if (!pattern) {
    return [];
  }
  let prevPos = 0;
  const braceStack = [];
  const results = [];
  const braces = /[{}]/g;
  braces.lastIndex = 0;
  let match2;
  while (match2 = braces.exec(pattern)) {
    const pos = match2.index;
    if (match2[0] == "}") {
      braceStack.pop();
      if (braceStack.length == 0) {
        const block = pattern.substring(prevPos, pos);
        if (ICU_BLOCK_REGEXP.test(block)) {
          results.push(parseICUBlock(block));
        } else {
          results.push(block);
        }
        prevPos = pos + 1;
      }
    } else {
      if (braceStack.length == 0) {
        const substring2 = pattern.substring(prevPos, pos);
        results.push(substring2);
        prevPos = pos + 1;
      }
      braceStack.push("{");
    }
  }
  const substring = pattern.substring(prevPos);
  results.push(substring);
  return results;
}
function parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
  const create = [];
  const remove2 = [];
  const update = [];
  if (ngDevMode) {
    attachDebugGetter(create, icuCreateOpCodesToString);
    attachDebugGetter(remove2, i18nRemoveOpCodesToString);
    attachDebugGetter(update, i18nUpdateOpCodesToString);
  }
  tIcu.cases.push(caseName);
  tIcu.create.push(create);
  tIcu.remove.push(remove2);
  tIcu.update.push(update);
  const inertBodyHelper2 = getInertBodyHelper(getDocument());
  const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
  ngDevMode && assertDefined(inertBodyElement, "Unable to generate inert body element");
  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
  if (inertRootNode) {
    return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx, nestedIcus, 0);
  } else {
    return 0;
  }
}
function walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx, nestedIcus, depth) {
  let bindingMask = 0;
  let currentNode = parentNode.firstChild;
  while (currentNode) {
    const newIndex = allocExpando(tView, lView, 1, null);
    switch (currentNode.nodeType) {
      case Node.ELEMENT_NODE:
        const element = currentNode;
        const tagName = element.tagName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
          tView.data[newIndex] = tagName;
          const elAttrs = element.attributes;
          for (let i3 = 0; i3 < elAttrs.length; i3++) {
            const attr = elAttrs.item(i3);
            const lowerAttrName = attr.name.toLowerCase();
            const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
            if (hasBinding2) {
              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                if (URI_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                } else {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                }
              } else {
                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${XSS_SECURITY_URL})`);
              }
            } else {
              addCreateAttribute(create, newIndex, attr);
            }
          }
          const elementNode = {
            kind: 1,
            index: newIndex,
            children: []
          };
          ast.push(elementNode);
          bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
          addRemoveNode(remove2, newIndex, depth);
        }
        break;
      case Node.TEXT_NODE:
        const value = currentNode.textContent || "";
        const hasBinding = value.match(BINDING_REGEXP);
        addCreateNodeAndAppend(create, null, hasBinding ? "" : value, parentIdx, newIndex);
        addRemoveNode(remove2, newIndex, depth);
        if (hasBinding) {
          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
        }
        ast.push({
          kind: 0,
          index: newIndex
        });
        break;
      case Node.COMMENT_NODE:
        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
        if (isNestedIcu) {
          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
          const icuExpression = nestedIcus[nestedIcuIndex];
          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
          addRemoveNestedIcu(remove2, newIndex, depth);
        }
        break;
    }
    currentNode = currentNode.nextSibling;
  }
  return bindingMask;
}
function addRemoveNode(remove2, index3, depth) {
  if (depth === 0) {
    remove2.push(index3);
  }
}
function addRemoveNestedIcu(remove2, index3, depth) {
  if (depth === 0) {
    remove2.push(~index3);
    remove2.push(index3);
  }
}
function addUpdateIcuSwitch(update, icuExpression, index3) {
  update.push(
    toMaskBit(icuExpression.mainBinding),
    2,
    -1 - icuExpression.mainBinding,
    index3 << 2 | 2
    /* I18nUpdateOpCode.IcuSwitch */
  );
}
function addUpdateIcuUpdate(update, bindingMask, index3) {
  update.push(
    bindingMask,
    1,
    index3 << 2 | 3
    /* I18nUpdateOpCode.IcuUpdate */
  );
}
function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
  if (marker !== null) {
    create.push(marker);
  }
  create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
}
function addCreateAttribute(create, newIndex, attr) {
  create.push(newIndex << 1 | 1, attr.name, attr.value);
}
var ROOT_TEMPLATE_ID = 0;
var PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(.+??)\]/;
var PP_PLACEHOLDERS_REGEXP = /\[(.+??)\]|(\/?\*\d+:\d+)/g;
var PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
var PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
var PP_ICUS_REGEXP = /I18N_EXP_(ICU(_\d+)?)/g;
var PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
var PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
function i18nPostprocess(message, replacements = {}) {
  let result = message;
  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
    const matches = {};
    const templateIdsStack = [ROOT_TEMPLATE_ID];
    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m3, phs, tmpl) => {
      const content = phs || tmpl;
      const placeholders = matches[content] || [];
      if (!placeholders.length) {
        content.split("|").forEach((placeholder2) => {
          const match2 = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
          const templateId2 = match2 ? parseInt(match2[1], 10) : ROOT_TEMPLATE_ID;
          const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
          placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
        });
        matches[content] = placeholders;
      }
      if (!placeholders.length) {
        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
      }
      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
      let idx = 0;
      for (let i3 = 0; i3 < placeholders.length; i3++) {
        if (placeholders[i3][0] === currentTemplateId) {
          idx = i3;
          break;
        }
      }
      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
      if (isCloseTemplateTag) {
        templateIdsStack.pop();
      } else if (currentTemplateId !== templateId) {
        templateIdsStack.push(templateId);
      }
      placeholders.splice(idx, 1);
      return placeholder;
    });
  }
  if (!Object.keys(replacements).length) {
    return result;
  }
  result = result.replace(PP_ICU_VARS_REGEXP, (match2, start, key, _type, _idx, end) => {
    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match2;
  });
  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match2, key) => {
    return replacements.hasOwnProperty(key) ? replacements[key] : match2;
  });
  result = result.replace(PP_ICUS_REGEXP, (match2, key) => {
    if (replacements.hasOwnProperty(key)) {
      const list = replacements[key];
      if (!list.length) {
        throw new Error(`i18n postprocess: unmatched ICU - ${match2} with key: ${key}`);
      }
      return list.shift();
    }
    return match2;
  });
  return result;
}
function \u0275\u0275i18nStart(index3, messageIndex, subTemplateIndex = -1) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = HEADER_OFFSET + index3;
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const message = getConstant(tView.consts, messageIndex);
  const parentTNode = getCurrentParentTNode();
  if (tView.firstCreatePass) {
    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
  }
  if (tView.type === 2) {
    const componentLView = lView[DECLARATION_COMPONENT_VIEW];
    componentLView[FLAGS] |= 32;
  } else {
    lView[FLAGS] |= 32;
  }
  const tI18n = tView.data[adjustedIndex];
  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
  prepareI18nBlockForHydration(lView, adjustedIndex, parentTNode, subTemplateIndex);
  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
  setInI18nBlock(true);
}
function \u0275\u0275i18nEnd() {
  setInI18nBlock(false);
}
function \u0275\u0275i18n(index3, messageIndex, subTemplateIndex) {
  \u0275\u0275i18nStart(index3, messageIndex, subTemplateIndex);
  \u0275\u0275i18nEnd();
}
function \u0275\u0275i18nAttributes(index3, attrsIndex) {
  const tView = getTView();
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const attrs = getConstant(tView.consts, attrsIndex);
  i18nAttributesFirstPass(tView, index3 + HEADER_OFFSET, attrs);
}
function \u0275\u0275i18nExp(value) {
  const lView = getLView();
  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
  return \u0275\u0275i18nExp;
}
function \u0275\u0275i18nApply(index3) {
  applyI18n(getTView(), getLView(), index3 + HEADER_OFFSET);
}
function \u0275\u0275i18nPostprocess(message, replacements = {}) {
  return i18nPostprocess(message, replacements);
}
var disableEventReplayFn = (el, eventName, listenerFn) => {
};
function \u0275\u0275listener(eventName, listenerFn, useCapture, eventTargetResolver) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
  return \u0275\u0275listener;
}
function \u0275\u0275syntheticHostListener(eventName, listenerFn) {
  const tNode = getCurrentTNode();
  const lView = getLView();
  const tView = getTView();
  const currentDef = getCurrentDirectiveDef(tView.data);
  const renderer = loadComponentRenderer(currentDef, tNode, lView);
  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
  return \u0275\u0275syntheticHostListener;
}
function findExistingListener(tView, lView, eventName, tNodeIdx) {
  const tCleanup = tView.cleanup;
  if (tCleanup != null) {
    for (let i3 = 0; i3 < tCleanup.length - 1; i3 += 2) {
      const cleanupEventName = tCleanup[i3];
      if (cleanupEventName === eventName && tCleanup[i3 + 1] === tNodeIdx) {
        const lCleanup = lView[CLEANUP];
        const listenerIdxInLCleanup = tCleanup[i3 + 2];
        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
      }
      if (typeof cleanupEventName === "string") {
        i3 += 2;
      }
    }
  }
  return null;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
  const isTNodeDirectiveHost = isDirectiveHost(tNode);
  const firstCreatePass = tView.firstCreatePass;
  const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
  const context2 = lView[CONTEXT];
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  let processOutputs = true;
  if (tNode.type & 3 || eventTargetResolver) {
    const native = getNativeByTNode(tNode, lView);
    const target = eventTargetResolver ? eventTargetResolver(native) : native;
    const lCleanupIndex = lCleanup.length;
    const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
    disableEventReplayFn(native, eventName, listenerFn);
    let existingListener = null;
    if (!eventTargetResolver && isTNodeDirectiveHost) {
      existingListener = findExistingListener(tView, lView, eventName, tNode.index);
    }
    if (existingListener !== null) {
      const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
      lastListenerFn.__ngNextListenerFn__ = listenerFn;
      existingListener.__ngLastListenerFn__ = listenerFn;
      processOutputs = false;
    } else {
      listenerFn = wrapListener(tNode, lView, context2, listenerFn);
      const cleanupFn = renderer.listen(target, eventName, listenerFn);
      ngDevMode && ngDevMode.rendererAddEventListener++;
      lCleanup.push(listenerFn, cleanupFn);
      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
    }
  } else {
    listenerFn = wrapListener(tNode, lView, context2, listenerFn);
  }
  const outputs = tNode.outputs;
  let props;
  if (processOutputs && outputs !== null && (props = outputs[eventName])) {
    const propsLength = props.length;
    if (propsLength) {
      for (let i3 = 0; i3 < propsLength; i3 += 2) {
        const index3 = props[i3];
        ngDevMode && assertIndexInRange(lView, index3);
        const minifiedName = props[i3 + 1];
        const directiveInstance = lView[index3];
        const output = directiveInstance[minifiedName];
        if (ngDevMode && !isOutputSubscribable(output)) {
          throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);
        }
        const subscription = output.subscribe(listenerFn);
        const idx = lCleanup.length;
        lCleanup.push(listenerFn, subscription);
        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
      }
    }
  }
}
function executeListenerWithErrorHandling(lView, context2, listenerFn, e3) {
  const prevConsumer = setActiveConsumer(null);
  try {
    profiler(6, context2, listenerFn);
    return listenerFn(e3) !== false;
  } catch (error) {
    handleError(lView, error);
    return false;
  } finally {
    profiler(7, context2, listenerFn);
    setActiveConsumer(prevConsumer);
  }
}
function wrapListener(tNode, lView, context2, listenerFn) {
  return function wrapListenerIn_markDirtyAndPreventDefault(e3) {
    if (e3 === Function) {
      return listenerFn;
    }
    const startView = tNode.componentOffset > -1 ? getComponentLViewByIndex(tNode.index, lView) : lView;
    markViewDirty(
      startView,
      5
      /* NotificationSource.Listener */
    );
    let result = executeListenerWithErrorHandling(lView, context2, listenerFn, e3);
    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
    while (nextListenerFn) {
      result = executeListenerWithErrorHandling(lView, context2, nextListenerFn, e3) && result;
      nextListenerFn = nextListenerFn.__ngNextListenerFn__;
    }
    return result;
  };
}
function isOutputSubscribable(value) {
  return value != null && typeof value.subscribe === "function";
}
function \u0275\u0275nextContext(level = 1) {
  return nextContextImpl(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
  let wildcardNgContentIndex = null;
  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
  for (let i3 = 0; i3 < projectionSlots.length; i3++) {
    const slotValue = projectionSlots[i3];
    if (slotValue === "*") {
      wildcardNgContentIndex = i3;
      continue;
    }
    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(
      tNode,
      slotValue,
      /* isProjectionMode */
      true
    ) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
      return i3;
    }
  }
  return wildcardNgContentIndex;
}
function \u0275\u0275projectionDef(projectionSlots) {
  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
  if (!componentNode.projection) {
    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
    const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
    const tails = projectionHeads.slice();
    let componentChild = componentNode.child;
    while (componentChild !== null) {
      const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
      if (slotIndex !== null) {
        if (tails[slotIndex]) {
          tails[slotIndex].projectionNext = componentChild;
        } else {
          projectionHeads[slotIndex] = componentChild;
        }
        tails[slotIndex] = componentChild;
      }
      componentChild = componentChild.next;
    }
  }
}
function \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs, fallbackTemplateFn, fallbackDecls, fallbackVars) {
  const lView = getLView();
  const tView = getTView();
  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;
  if (fallbackIndex !== null) {
    declareTemplate(lView, tView, fallbackIndex, fallbackTemplateFn, fallbackDecls, fallbackVars, null, attrs);
  }
  const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
  if (tProjectionNode.projection === null) {
    tProjectionNode.projection = selectorIndex;
  }
  setCurrentTNodeAsNotParent();
  const hydrationInfo = lView[HYDRATION];
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();
  const componentHostNode = lView[DECLARATION_COMPONENT_VIEW][T_HOST];
  const isEmpty = componentHostNode.projection[tProjectionNode.projection] === null;
  if (isEmpty && fallbackIndex !== null) {
    insertFallbackContent(lView, tView, fallbackIndex);
  } else if (isNodeCreationMode && (tProjectionNode.flags & 32) !== 32) {
    applyProjection(tView, lView, tProjectionNode);
  }
}
function insertFallbackContent(lView, tView, fallbackIndex) {
  const adjustedIndex = HEADER_OFFSET + fallbackIndex;
  const fallbackTNode = tView.data[adjustedIndex];
  const fallbackLContainer = lView[adjustedIndex];
  ngDevMode && assertTNode(fallbackTNode);
  ngDevMode && assertLContainer(fallbackLContainer);
  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView.ssrId);
  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, void 0, {
    dehydratedView
  });
  addLViewToLContainer(fallbackLContainer, fallbackLView, 0, shouldAddViewToDom(fallbackTNode, dehydratedView));
}
function \u0275\u0275propertyInterpolate(propName, v0, sanitizer) {
  \u0275\u0275propertyInterpolate1(propName, "", v0, "", sanitizer);
  return \u0275\u0275propertyInterpolate;
}
function \u0275\u0275propertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);
  }
  return \u0275\u0275propertyInterpolate1;
}
function \u0275\u0275propertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);
  }
  return \u0275\u0275propertyInterpolate2;
}
function \u0275\u0275propertyInterpolate3(propName, prefix, v0, i0, v1, i1, v22, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v22, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);
  }
  return \u0275\u0275propertyInterpolate3;
}
function \u0275\u0275propertyInterpolate4(propName, prefix, v0, i0, v1, i1, v22, i22, v3, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v22, i22, v3, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i22, suffix);
  }
  return \u0275\u0275propertyInterpolate4;
}
function \u0275\u0275propertyInterpolate5(propName, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i22, i3, suffix);
  }
  return \u0275\u0275propertyInterpolate5;
}
function \u0275\u0275propertyInterpolate6(propName, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i22, i3, i4, suffix);
  }
  return \u0275\u0275propertyInterpolate6;
}
function \u0275\u0275propertyInterpolate7(propName, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i22, i3, i4, i5, suffix);
  }
  return \u0275\u0275propertyInterpolate7;
}
function \u0275\u0275propertyInterpolate8(propName, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i22, i3, i4, i5, i6, suffix);
  }
  return \u0275\u0275propertyInterpolate8;
}
function \u0275\u0275propertyInterpolateV(propName, values, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    if (ngDevMode) {
      const interpolationInBetween = [values[0]];
      for (let i3 = 2; i3 < values.length; i3 += 2) {
        interpolationInBetween.push(values[i3]);
      }
      storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
    }
  }
  return \u0275\u0275propertyInterpolateV;
}
function \u0275\u0275contentQuery(directiveIndex, predicate, flags, read) {
  createContentQuery(directiveIndex, predicate, flags, read);
}
function \u0275\u0275viewQuery(predicate, flags, read) {
  createViewQuery(predicate, flags, read);
}
function \u0275\u0275queryRefresh(queryList) {
  const lView = getLView();
  const tView = getTView();
  const queryIndex = getCurrentQueryIndex();
  setCurrentQueryIndex(queryIndex + 1);
  const tQuery = getTQuery(tView, queryIndex);
  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
    if (tQuery.matches === null) {
      queryList.reset([]);
    } else {
      const result = getQueryResults(lView, queryIndex);
      queryList.reset(result, unwrapElementRef);
      queryList.notifyOnChanges();
    }
    return true;
  }
  return false;
}
function \u0275\u0275loadQuery() {
  return loadQueryInternal(getLView(), getCurrentQueryIndex());
}
function \u0275\u0275contentQuerySignal(directiveIndex, target, predicate, flags, read) {
  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));
}
function \u0275\u0275viewQuerySignal(target, predicate, flags, read) {
  bindQueryToSignal(target, createViewQuery(predicate, flags, read));
}
function \u0275\u0275queryAdvance(indexOffset = 1) {
  setCurrentQueryIndex(getCurrentQueryIndex() + indexOffset);
}
function store(tView, lView, index3, value) {
  if (index3 >= tView.data.length) {
    tView.data[index3] = null;
    tView.blueprint[index3] = null;
  }
  lView[index3] = value;
}
function \u0275\u0275reference(index3) {
  const contextLView = getContextLView();
  return load(contextLView, HEADER_OFFSET + index3);
}
function \u0275\u0275styleMapInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate3(prefix, v0, i0, v1, i1, v22, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v22, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate4(prefix, v0, i0, v1, i1, v22, i22, v3, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v22, i22, v3, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate5(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate6(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate7(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate8(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolateV(values) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275stylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate1;
}
function \u0275\u0275stylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate2;
}
function \u0275\u0275stylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v22, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v22, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate3;
}
function \u0275\u0275stylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v22, i22, v3, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v22, i22, v3, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate4;
}
function \u0275\u0275stylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate5;
}
function \u0275\u0275stylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate6;
}
function \u0275\u0275stylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate7;
}
function \u0275\u0275stylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate8;
}
function \u0275\u0275stylePropInterpolateV(prop, values, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolateV;
}
function \u0275\u0275text(index3, value = "") {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index3 + HEADER_OFFSET;
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "text nodes should be created before any bindings");
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index3);
  lView[adjustedIndex] = textNative;
  if (wasLastNodeCreated()) {
    appendChild(tView, lView, textNative, tNode);
  }
  setCurrentTNode(tNode, false);
}
var _locateOrCreateTextNode = (tView, lView, tNode, value, index3) => {
  lastNodeWasCreated(true);
  return createTextNode(lView[RENDERER], value);
};
function \u0275\u0275textInterpolate(v0) {
  \u0275\u0275textInterpolate1("", v0, "");
  return \u0275\u0275textInterpolate;
}
function \u0275\u0275textInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolated = interpolation1(lView, prefix, v0, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate1;
}
function \u0275\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate2;
}
function \u0275\u0275textInterpolate3(prefix, v0, i0, v1, i1, v22, suffix) {
  const lView = getLView();
  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v22, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate3;
}
function \u0275\u0275textInterpolate4(prefix, v0, i0, v1, i1, v22, i22, v3, suffix) {
  const lView = getLView();
  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v22, i22, v3, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate4;
}
function \u0275\u0275textInterpolate5(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate5;
}
function \u0275\u0275textInterpolate6(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate6;
}
function \u0275\u0275textInterpolate7(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate7;
}
function \u0275\u0275textInterpolate8(prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v22, i22, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate8;
}
function \u0275\u0275textInterpolateV(values) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolateV;
}
function \u0275\u0275twoWayProperty(propName, value, sanitizer) {
  if (isWritableSignal(value)) {
    value = value();
  }
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275twoWayProperty;
}
function \u0275\u0275twoWayBindingSet(target, value) {
  const canWrite = isWritableSignal(target);
  canWrite && target.set(value);
  return canWrite;
}
function \u0275\u0275twoWayListener(eventName, listenerFn) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn);
  return \u0275\u0275twoWayListener;
}
function providersResolver(def, providers, viewProviders) {
  const tView = getTView();
  if (tView.firstCreatePass) {
    const isComponent2 = isComponentDef(def);
    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent2, true);
    resolveProvider(providers, tView.data, tView.blueprint, isComponent2, false);
  }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider) {
  provider = resolveForwardRef(provider);
  if (Array.isArray(provider)) {
    for (let i3 = 0; i3 < provider.length; i3++) {
      resolveProvider(provider[i3], tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider);
    }
  } else {
    const tView = getTView();
    const lView = getLView();
    const tNode = getCurrentTNode();
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
    const providerFactory = providerToFactory(provider);
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      runInInjectorProfilerContext(injector, token, () => {
        emitProviderConfiguredEvent(provider, isViewProvider);
      });
    }
    const beginIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveStart;
    const cptViewProvidersCount = tNode.providerIndexes >> 20;
    if (isTypeProvider(provider) || !provider.multi) {
      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject);
      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
      if (existingFactoryIndex === -1) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        lInjectablesBlueprint[existingFactoryIndex] = factory;
        lView[existingFactoryIndex] = factory;
      }
    } else {
      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent2, providerFactory);
        if (!isViewProvider && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
        }
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent2);
        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
      }
      if (!isViewProvider && isComponent2 && doesViewProvidersFactoryExist) {
        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
      }
    }
  }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
  const providerIsTypeProvider = isTypeProvider(provider);
  const providerIsClassProvider = isClassProvider(provider);
  if (providerIsTypeProvider || providerIsClassProvider) {
    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
    const prototype = classToken.prototype;
    const ngOnDestroy = prototype.ngOnDestroy;
    if (ngOnDestroy) {
      const hooks = tView.destroyHooks || (tView.destroyHooks = []);
      if (!providerIsTypeProvider && provider.multi) {
        ngDevMode && assertDefined(indexInFactory, "indexInFactory when registering multi factory destroy hook");
        const existingCallbacksIndex = hooks.indexOf(contextIndex);
        if (existingCallbacksIndex === -1) {
          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
        } else {
          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
        }
      } else {
        hooks.push(contextIndex, ngOnDestroy);
      }
    }
  }
}
function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
  if (isComponentProvider) {
    multiFactory2.componentProviders++;
  }
  return multiFactory2.multi.push(factory) - 1;
}
function indexOf(item, arr, begin, end) {
  for (let i3 = begin; i3 < end; i3++) {
    if (arr[i3] === item)
      return i3;
  }
  return -1;
}
function multiProvidersFactoryResolver(_3, tData, lData, tNode) {
  return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_3, tData, lView, tNode) {
  const factories = this.multi;
  let result;
  if (this.providerFactory) {
    const componentCount = this.providerFactory.componentProviders;
    const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
    result = multiProviders.slice(0, componentCount);
    multiResolve(factories, result);
    for (let i3 = componentCount; i3 < multiProviders.length; i3++) {
      result.push(multiProviders[i3]);
    }
  } else {
    result = [];
    multiResolve(factories, result);
  }
  return result;
}
function multiResolve(factories, result) {
  for (let i3 = 0; i3 < factories.length; i3++) {
    const factory = factories[i3];
    result.push(factory());
  }
  return result;
}
function multiFactory(factoryFn, index3, isViewProvider, isComponent2, f3) {
  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject);
  factory.multi = [];
  factory.index = index3;
  factory.componentProviders = 0;
  multiFactoryAdd(factory, f3, isComponent2 && !isViewProvider);
  return factory;
}
function \u0275\u0275ProvidersFeature(providers, viewProviders = []) {
  return (definition) => {
    definition.providersResolver = (def, processProvidersFn) => {
      return providersResolver(
        def,
        //
        processProvidersFn ? processProvidersFn(providers) : providers,
        //
        viewProviders
      );
    };
  };
}
var _StandaloneService = class _StandaloneService {
  constructor(_injector) {
    this._injector = _injector;
    this.cachedInjectors = /* @__PURE__ */ new Map();
  }
  getOrCreateStandaloneInjector(componentDef) {
    if (!componentDef.standalone) {
      return null;
    }
    if (!this.cachedInjectors.has(componentDef)) {
      const providers = internalImportProvidersFrom(false, componentDef.type);
      const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;
      this.cachedInjectors.set(componentDef, standaloneInjector);
    }
    return this.cachedInjectors.get(componentDef);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
};
_StandaloneService.\u0275prov = \u0275\u0275defineInjectable({
  token: _StandaloneService,
  providedIn: "environment",
  factory: () => new _StandaloneService(\u0275\u0275inject(EnvironmentInjector))
});
var StandaloneService = _StandaloneService;
function \u0275\u0275StandaloneFeature(definition) {
  performanceMarkFeature("NgStandalone");
  definition.getStandaloneInjector = (parentInjector) => {
    return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);
  };
}
function \u0275\u0275setComponentScope(type, directives, pipes) {
  const def = type.\u0275cmp;
  def.directiveDefs = extractDefListOrFactory(
    directives,
    /* pipeDef */
    false
  );
  def.pipeDefs = extractDefListOrFactory(
    pipes,
    /* pipeDef */
    true
  );
}
function \u0275\u0275setNgModuleScope(type, scope) {
  return noSideEffects(() => {
    const ngModuleDef = getNgModuleDef(type, true);
    ngModuleDef.declarations = convertToTypeArray(scope.declarations || EMPTY_ARRAY);
    ngModuleDef.imports = convertToTypeArray(scope.imports || EMPTY_ARRAY);
    ngModuleDef.exports = convertToTypeArray(scope.exports || EMPTY_ARRAY);
    if (scope.bootstrap) {
      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);
    }
    depsTracker.registerNgModule(type, scope);
  });
}
function convertToTypeArray(values) {
  if (typeof values === "function") {
    return values;
  }
  const flattenValues = flatten(values);
  if (flattenValues.some(isForwardRef)) {
    return () => flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders);
  } else {
    return flattenValues.map(maybeUnwrapModuleWithProviders);
  }
}
function maybeUnwrapModuleWithProviders(value) {
  return isModuleWithProviders(value) ? value.ngModule : value;
}
function \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
}
function \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {
  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
}
function \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
}
function \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
}
function \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
}
function \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function \u0275\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function \u0275\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function \u0275\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {
  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
  ngDevMode && assertIndexInRange(lView, returnValueIndex);
  const lastReturnValue = lView[returnValueIndex];
  return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
  let bindingIndex = bindingRoot + slotOffset;
  let different = false;
  for (let i3 = 0; i3 < exps.length; i3++) {
    bindingUpdated(lView, bindingIndex++, exps[i3]) && (different = true);
  }
  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function \u0275\u0275pipe(index3, pipeName) {
  const tView = getTView();
  let pipeDef;
  const adjustedIndex = index3 + HEADER_OFFSET;
  if (tView.firstCreatePass) {
    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
    tView.data[adjustedIndex] = pipeDef;
    if (pipeDef.onDestroy) {
      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);
    }
  } else {
    pipeDef = tView.data[adjustedIndex];
  }
  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
  let previousInjectorProfilerContext;
  if (ngDevMode) {
    previousInjectorProfilerContext = setInjectorProfilerContext({
      injector: new NodeInjector(getCurrentTNode(), getLView()),
      token: pipeDef.type
    });
  }
  const previousInjectImplementation = setInjectImplementation(\u0275\u0275directiveInject);
  try {
    const previousIncludeViewProviders = setIncludeViewProviders(false);
    const pipeInstance = pipeFactory();
    setIncludeViewProviders(previousIncludeViewProviders);
    store(tView, getLView(), adjustedIndex, pipeInstance);
    return pipeInstance;
  } finally {
    setInjectImplementation(previousInjectImplementation);
    ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext);
  }
}
function getPipeDef(name, registry) {
  if (registry) {
    if (ngDevMode) {
      const pipes = registry.filter((pipe2) => pipe2.name === name);
      if (pipes.length > 1) {
        console.warn(formatRuntimeError(313, getMultipleMatchingPipesMessage(name)));
      }
    }
    for (let i3 = registry.length - 1; i3 >= 0; i3--) {
      const pipeDef = registry[i3];
      if (name === pipeDef.name) {
        return pipeDef;
      }
    }
  }
  if (ngDevMode) {
    throw new RuntimeError(-302, getPipeNotFoundErrorMessage(name));
  }
  return;
}
function getMultipleMatchingPipesMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
  const verifyMessage = `check ${hostIsStandalone ? "'@Component.imports' of this component" : "the imports of this module"}`;
  const errorMessage = `Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function getPipeNotFoundErrorMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : "declared or imported in this module"}`;
  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function \u0275\u0275pipeBind1(index3, offset, v1) {
  const adjustedIndex = index3 + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), offset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function \u0275\u0275pipeBind2(index3, slotOffset, v1, v22) {
  const adjustedIndex = index3 + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v22, pipeInstance) : pipeInstance.transform(v1, v22);
}
function \u0275\u0275pipeBind3(index3, slotOffset, v1, v22, v3) {
  const adjustedIndex = index3 + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v22, v3, pipeInstance) : pipeInstance.transform(v1, v22, v3);
}
function \u0275\u0275pipeBind4(index3, slotOffset, v1, v22, v3, v4) {
  const adjustedIndex = index3 + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v22, v3, v4, pipeInstance) : pipeInstance.transform(v1, v22, v3, v4);
}
function \u0275\u0275pipeBindV(index3, slotOffset, values) {
  const adjustedIndex = index3 + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
}
function isPure(lView, index3) {
  return lView[TVIEW].data[index3].pure;
}
function \u0275\u0275templateRefExtractor(tNode, lView) {
  return createTemplateRef(tNode, lView);
}
function \u0275\u0275getComponentDepsFactory(type, rawImports) {
  return () => {
    try {
      return depsTracker.getComponentDependencies(type, rawImports).dependencies;
    } catch (e3) {
      console.error(`Computing dependencies in local compilation mode for the component "${type.name}" failed with the exception:`, e3);
      throw e3;
    }
  };
}
function \u0275setClassDebugInfo(type, debugInfo) {
  const def = getComponentDef(type);
  if (def !== null) {
    def.debugInfo = debugInfo;
  }
}
var angularCoreEnv = /* @__PURE__ */ (() => ({
  "\u0275\u0275attribute": \u0275\u0275attribute,
  "\u0275\u0275attributeInterpolate1": \u0275\u0275attributeInterpolate1,
  "\u0275\u0275attributeInterpolate2": \u0275\u0275attributeInterpolate2,
  "\u0275\u0275attributeInterpolate3": \u0275\u0275attributeInterpolate3,
  "\u0275\u0275attributeInterpolate4": \u0275\u0275attributeInterpolate4,
  "\u0275\u0275attributeInterpolate5": \u0275\u0275attributeInterpolate5,
  "\u0275\u0275attributeInterpolate6": \u0275\u0275attributeInterpolate6,
  "\u0275\u0275attributeInterpolate7": \u0275\u0275attributeInterpolate7,
  "\u0275\u0275attributeInterpolate8": \u0275\u0275attributeInterpolate8,
  "\u0275\u0275attributeInterpolateV": \u0275\u0275attributeInterpolateV,
  "\u0275\u0275defineComponent": \u0275\u0275defineComponent,
  "\u0275\u0275defineDirective": \u0275\u0275defineDirective,
  "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
  "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
  "\u0275\u0275defineNgModule": \u0275\u0275defineNgModule,
  "\u0275\u0275definePipe": \u0275\u0275definePipe,
  "\u0275\u0275directiveInject": \u0275\u0275directiveInject,
  "\u0275\u0275getInheritedFactory": \u0275\u0275getInheritedFactory,
  "\u0275\u0275inject": \u0275\u0275inject,
  "\u0275\u0275injectAttribute": \u0275\u0275injectAttribute,
  "\u0275\u0275invalidFactory": \u0275\u0275invalidFactory,
  "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
  "\u0275\u0275templateRefExtractor": \u0275\u0275templateRefExtractor,
  "\u0275\u0275resetView": \u0275\u0275resetView,
  "\u0275\u0275HostDirectivesFeature": \u0275\u0275HostDirectivesFeature,
  "\u0275\u0275NgOnChangesFeature": \u0275\u0275NgOnChangesFeature,
  "\u0275\u0275ProvidersFeature": \u0275\u0275ProvidersFeature,
  "\u0275\u0275CopyDefinitionFeature": \u0275\u0275CopyDefinitionFeature,
  "\u0275\u0275InheritDefinitionFeature": \u0275\u0275InheritDefinitionFeature,
  "\u0275\u0275InputTransformsFeature": \u0275\u0275InputTransformsFeature,
  "\u0275\u0275StandaloneFeature": \u0275\u0275StandaloneFeature,
  "\u0275\u0275nextContext": \u0275\u0275nextContext,
  "\u0275\u0275namespaceHTML": \u0275\u0275namespaceHTML,
  "\u0275\u0275namespaceMathML": \u0275\u0275namespaceMathML,
  "\u0275\u0275namespaceSVG": \u0275\u0275namespaceSVG,
  "\u0275\u0275enableBindings": \u0275\u0275enableBindings,
  "\u0275\u0275disableBindings": \u0275\u0275disableBindings,
  "\u0275\u0275elementStart": \u0275\u0275elementStart,
  "\u0275\u0275elementEnd": \u0275\u0275elementEnd,
  "\u0275\u0275element": \u0275\u0275element,
  "\u0275\u0275elementContainerStart": \u0275\u0275elementContainerStart,
  "\u0275\u0275elementContainerEnd": \u0275\u0275elementContainerEnd,
  "\u0275\u0275elementContainer": \u0275\u0275elementContainer,
  "\u0275\u0275pureFunction0": \u0275\u0275pureFunction0,
  "\u0275\u0275pureFunction1": \u0275\u0275pureFunction1,
  "\u0275\u0275pureFunction2": \u0275\u0275pureFunction2,
  "\u0275\u0275pureFunction3": \u0275\u0275pureFunction3,
  "\u0275\u0275pureFunction4": \u0275\u0275pureFunction4,
  "\u0275\u0275pureFunction5": \u0275\u0275pureFunction5,
  "\u0275\u0275pureFunction6": \u0275\u0275pureFunction6,
  "\u0275\u0275pureFunction7": \u0275\u0275pureFunction7,
  "\u0275\u0275pureFunction8": \u0275\u0275pureFunction8,
  "\u0275\u0275pureFunctionV": \u0275\u0275pureFunctionV,
  "\u0275\u0275getCurrentView": \u0275\u0275getCurrentView,
  "\u0275\u0275restoreView": \u0275\u0275restoreView,
  "\u0275\u0275listener": \u0275\u0275listener,
  "\u0275\u0275projection": \u0275\u0275projection,
  "\u0275\u0275syntheticHostProperty": \u0275\u0275syntheticHostProperty,
  "\u0275\u0275syntheticHostListener": \u0275\u0275syntheticHostListener,
  "\u0275\u0275pipeBind1": \u0275\u0275pipeBind1,
  "\u0275\u0275pipeBind2": \u0275\u0275pipeBind2,
  "\u0275\u0275pipeBind3": \u0275\u0275pipeBind3,
  "\u0275\u0275pipeBind4": \u0275\u0275pipeBind4,
  "\u0275\u0275pipeBindV": \u0275\u0275pipeBindV,
  "\u0275\u0275projectionDef": \u0275\u0275projectionDef,
  "\u0275\u0275hostProperty": \u0275\u0275hostProperty,
  "\u0275\u0275property": \u0275\u0275property,
  "\u0275\u0275propertyInterpolate": \u0275\u0275propertyInterpolate,
  "\u0275\u0275propertyInterpolate1": \u0275\u0275propertyInterpolate1,
  "\u0275\u0275propertyInterpolate2": \u0275\u0275propertyInterpolate2,
  "\u0275\u0275propertyInterpolate3": \u0275\u0275propertyInterpolate3,
  "\u0275\u0275propertyInterpolate4": \u0275\u0275propertyInterpolate4,
  "\u0275\u0275propertyInterpolate5": \u0275\u0275propertyInterpolate5,
  "\u0275\u0275propertyInterpolate6": \u0275\u0275propertyInterpolate6,
  "\u0275\u0275propertyInterpolate7": \u0275\u0275propertyInterpolate7,
  "\u0275\u0275propertyInterpolate8": \u0275\u0275propertyInterpolate8,
  "\u0275\u0275propertyInterpolateV": \u0275\u0275propertyInterpolateV,
  "\u0275\u0275pipe": \u0275\u0275pipe,
  "\u0275\u0275queryRefresh": \u0275\u0275queryRefresh,
  "\u0275\u0275queryAdvance": \u0275\u0275queryAdvance,
  "\u0275\u0275viewQuery": \u0275\u0275viewQuery,
  "\u0275\u0275viewQuerySignal": \u0275\u0275viewQuerySignal,
  "\u0275\u0275loadQuery": \u0275\u0275loadQuery,
  "\u0275\u0275contentQuery": \u0275\u0275contentQuery,
  "\u0275\u0275contentQuerySignal": \u0275\u0275contentQuerySignal,
  "\u0275\u0275reference": \u0275\u0275reference,
  "\u0275\u0275classMap": \u0275\u0275classMap,
  "\u0275\u0275classMapInterpolate1": \u0275\u0275classMapInterpolate1,
  "\u0275\u0275classMapInterpolate2": \u0275\u0275classMapInterpolate2,
  "\u0275\u0275classMapInterpolate3": \u0275\u0275classMapInterpolate3,
  "\u0275\u0275classMapInterpolate4": \u0275\u0275classMapInterpolate4,
  "\u0275\u0275classMapInterpolate5": \u0275\u0275classMapInterpolate5,
  "\u0275\u0275classMapInterpolate6": \u0275\u0275classMapInterpolate6,
  "\u0275\u0275classMapInterpolate7": \u0275\u0275classMapInterpolate7,
  "\u0275\u0275classMapInterpolate8": \u0275\u0275classMapInterpolate8,
  "\u0275\u0275classMapInterpolateV": \u0275\u0275classMapInterpolateV,
  "\u0275\u0275styleMap": \u0275\u0275styleMap,
  "\u0275\u0275styleMapInterpolate1": \u0275\u0275styleMapInterpolate1,
  "\u0275\u0275styleMapInterpolate2": \u0275\u0275styleMapInterpolate2,
  "\u0275\u0275styleMapInterpolate3": \u0275\u0275styleMapInterpolate3,
  "\u0275\u0275styleMapInterpolate4": \u0275\u0275styleMapInterpolate4,
  "\u0275\u0275styleMapInterpolate5": \u0275\u0275styleMapInterpolate5,
  "\u0275\u0275styleMapInterpolate6": \u0275\u0275styleMapInterpolate6,
  "\u0275\u0275styleMapInterpolate7": \u0275\u0275styleMapInterpolate7,
  "\u0275\u0275styleMapInterpolate8": \u0275\u0275styleMapInterpolate8,
  "\u0275\u0275styleMapInterpolateV": \u0275\u0275styleMapInterpolateV,
  "\u0275\u0275styleProp": \u0275\u0275styleProp,
  "\u0275\u0275stylePropInterpolate1": \u0275\u0275stylePropInterpolate1,
  "\u0275\u0275stylePropInterpolate2": \u0275\u0275stylePropInterpolate2,
  "\u0275\u0275stylePropInterpolate3": \u0275\u0275stylePropInterpolate3,
  "\u0275\u0275stylePropInterpolate4": \u0275\u0275stylePropInterpolate4,
  "\u0275\u0275stylePropInterpolate5": \u0275\u0275stylePropInterpolate5,
  "\u0275\u0275stylePropInterpolate6": \u0275\u0275stylePropInterpolate6,
  "\u0275\u0275stylePropInterpolate7": \u0275\u0275stylePropInterpolate7,
  "\u0275\u0275stylePropInterpolate8": \u0275\u0275stylePropInterpolate8,
  "\u0275\u0275stylePropInterpolateV": \u0275\u0275stylePropInterpolateV,
  "\u0275\u0275classProp": \u0275\u0275classProp,
  "\u0275\u0275advance": \u0275\u0275advance,
  "\u0275\u0275template": \u0275\u0275template,
  "\u0275\u0275conditional": \u0275\u0275conditional,
  "\u0275\u0275defer": \u0275\u0275defer,
  "\u0275\u0275deferWhen": \u0275\u0275deferWhen,
  "\u0275\u0275deferOnIdle": \u0275\u0275deferOnIdle,
  "\u0275\u0275deferOnImmediate": \u0275\u0275deferOnImmediate,
  "\u0275\u0275deferOnTimer": \u0275\u0275deferOnTimer,
  "\u0275\u0275deferOnHover": \u0275\u0275deferOnHover,
  "\u0275\u0275deferOnInteraction": \u0275\u0275deferOnInteraction,
  "\u0275\u0275deferOnViewport": \u0275\u0275deferOnViewport,
  "\u0275\u0275deferPrefetchWhen": \u0275\u0275deferPrefetchWhen,
  "\u0275\u0275deferPrefetchOnIdle": \u0275\u0275deferPrefetchOnIdle,
  "\u0275\u0275deferPrefetchOnImmediate": \u0275\u0275deferPrefetchOnImmediate,
  "\u0275\u0275deferPrefetchOnTimer": \u0275\u0275deferPrefetchOnTimer,
  "\u0275\u0275deferPrefetchOnHover": \u0275\u0275deferPrefetchOnHover,
  "\u0275\u0275deferPrefetchOnInteraction": \u0275\u0275deferPrefetchOnInteraction,
  "\u0275\u0275deferPrefetchOnViewport": \u0275\u0275deferPrefetchOnViewport,
  "\u0275\u0275deferEnableTimerScheduling": \u0275\u0275deferEnableTimerScheduling,
  "\u0275\u0275repeater": \u0275\u0275repeater,
  "\u0275\u0275repeaterCreate": \u0275\u0275repeaterCreate,
  "\u0275\u0275repeaterTrackByIndex": \u0275\u0275repeaterTrackByIndex,
  "\u0275\u0275repeaterTrackByIdentity": \u0275\u0275repeaterTrackByIdentity,
  "\u0275\u0275componentInstance": \u0275\u0275componentInstance,
  "\u0275\u0275text": \u0275\u0275text,
  "\u0275\u0275textInterpolate": \u0275\u0275textInterpolate,
  "\u0275\u0275textInterpolate1": \u0275\u0275textInterpolate1,
  "\u0275\u0275textInterpolate2": \u0275\u0275textInterpolate2,
  "\u0275\u0275textInterpolate3": \u0275\u0275textInterpolate3,
  "\u0275\u0275textInterpolate4": \u0275\u0275textInterpolate4,
  "\u0275\u0275textInterpolate5": \u0275\u0275textInterpolate5,
  "\u0275\u0275textInterpolate6": \u0275\u0275textInterpolate6,
  "\u0275\u0275textInterpolate7": \u0275\u0275textInterpolate7,
  "\u0275\u0275textInterpolate8": \u0275\u0275textInterpolate8,
  "\u0275\u0275textInterpolateV": \u0275\u0275textInterpolateV,
  "\u0275\u0275i18n": \u0275\u0275i18n,
  "\u0275\u0275i18nAttributes": \u0275\u0275i18nAttributes,
  "\u0275\u0275i18nExp": \u0275\u0275i18nExp,
  "\u0275\u0275i18nStart": \u0275\u0275i18nStart,
  "\u0275\u0275i18nEnd": \u0275\u0275i18nEnd,
  "\u0275\u0275i18nApply": \u0275\u0275i18nApply,
  "\u0275\u0275i18nPostprocess": \u0275\u0275i18nPostprocess,
  "\u0275\u0275resolveWindow": \u0275\u0275resolveWindow,
  "\u0275\u0275resolveDocument": \u0275\u0275resolveDocument,
  "\u0275\u0275resolveBody": \u0275\u0275resolveBody,
  "\u0275\u0275setComponentScope": \u0275\u0275setComponentScope,
  "\u0275\u0275setNgModuleScope": \u0275\u0275setNgModuleScope,
  "\u0275\u0275registerNgModuleType": registerNgModuleType,
  "\u0275\u0275getComponentDepsFactory": \u0275\u0275getComponentDepsFactory,
  "\u0275setClassDebugInfo": \u0275setClassDebugInfo,
  "\u0275\u0275sanitizeHtml": \u0275\u0275sanitizeHtml,
  "\u0275\u0275sanitizeStyle": \u0275\u0275sanitizeStyle,
  "\u0275\u0275sanitizeResourceUrl": \u0275\u0275sanitizeResourceUrl,
  "\u0275\u0275sanitizeScript": \u0275\u0275sanitizeScript,
  "\u0275\u0275sanitizeUrl": \u0275\u0275sanitizeUrl,
  "\u0275\u0275sanitizeUrlOrResourceUrl": \u0275\u0275sanitizeUrlOrResourceUrl,
  "\u0275\u0275trustConstantHtml": \u0275\u0275trustConstantHtml,
  "\u0275\u0275trustConstantResourceUrl": \u0275\u0275trustConstantResourceUrl,
  "\u0275\u0275validateIframeAttribute": \u0275\u0275validateIframeAttribute,
  "forwardRef": forwardRef,
  "resolveForwardRef": resolveForwardRef,
  "\u0275\u0275twoWayProperty": \u0275\u0275twoWayProperty,
  "\u0275\u0275twoWayBindingSet": \u0275\u0275twoWayBindingSet,
  "\u0275\u0275twoWayListener": \u0275\u0275twoWayListener
}))();
var jitOptions = null;
function setJitOptions(options) {
  if (jitOptions !== null) {
    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
      ngDevMode && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
      return;
    }
    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
      ngDevMode && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
      return;
    }
  }
  jitOptions = options;
}
function getJitOptions() {
  return jitOptions;
}
function patchModuleCompilation() {
}
var moduleQueue = [];
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
  moduleQueue.push({ moduleType, ngModule });
}
var flushingModuleQueue = false;
function flushModuleScopingQueueAsMuchAsPossible() {
  if (!flushingModuleQueue) {
    flushingModuleQueue = true;
    try {
      for (let i3 = moduleQueue.length - 1; i3 >= 0; i3--) {
        const { moduleType, ngModule } = moduleQueue[i3];
        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
          moduleQueue.splice(i3, 1);
          setScopeOnDeclaredComponents(moduleType, ngModule);
        }
      }
    } finally {
      flushingModuleQueue = false;
    }
  }
}
function isResolvedDeclaration(declaration) {
  if (Array.isArray(declaration)) {
    return declaration.every(isResolvedDeclaration);
  }
  return !!resolveForwardRef(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
  patchModuleCompilation();
  compileNgModuleDefs(moduleType, ngModule);
  if (ngModule.id !== void 0) {
    registerNgModuleType(moduleType, ngModule.id);
  }
  enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
  ngDevMode && assertDefined(moduleType, "Required value moduleType");
  ngDevMode && assertDefined(ngModule, "Required value ngModule");
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  let ngModuleDef = null;
  Object.defineProperty(moduleType, NG_MOD_DEF, {
    configurable: true,
    get: () => {
      if (ngModuleDef === null) {
        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
        }
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {
          type: moduleType,
          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
          declarations: declarations.map(resolveForwardRef),
          imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
          id: ngModule.id || null
        });
        if (!ngModuleDef.schemas) {
          ngModuleDef.schemas = [];
        }
      }
      return ngModuleDef;
    }
  });
  let ngFactoryDef = null;
  Object.defineProperty(moduleType, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\u0275fac.js`, {
          name: moduleType.name,
          type: moduleType,
          deps: reflectDependencies(moduleType),
          target: compiler.FactoryTarget.NgModule,
          typeArgumentCount: 0
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  let ngInjectorDef = null;
  Object.defineProperty(moduleType, NG_INJ_DEF, {
    get: () => {
      if (ngInjectorDef === null) {
        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
        const meta = {
          name: moduleType.name,
          type: moduleType,
          providers: ngModule.providers || EMPTY_ARRAY,
          imports: [
            (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),
            (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)
          ]
        };
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta);
      }
      return ngInjectorDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function generateStandaloneInDeclarationsError(type, location2) {
  const prefix = `Unexpected "${stringifyForError(type)}" found in the "declarations" array of the`;
  const suffix = `"${stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`;
  return `${prefix} ${location2}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
  if (verifiedNgModule.get(moduleType))
    return;
  if (isStandalone(moduleType))
    return;
  verifiedNgModule.set(moduleType, true);
  moduleType = resolveForwardRef(moduleType);
  let ngModuleDef;
  if (importingModule) {
    ngModuleDef = getNgModuleDef(moduleType);
    if (!ngModuleDef) {
      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  } else {
    ngModuleDef = getNgModuleDef(moduleType, true);
  }
  const errors = [];
  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
  const imports = maybeUnwrapFn(ngModuleDef.imports);
  flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt) => {
    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
  });
  const exports = maybeUnwrapFn(ngModuleDef.exports);
  declarations.forEach(verifyDeclarationsHaveDefinitions);
  declarations.forEach(verifyDirectivesHaveSelector);
  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));
  const combinedDeclarations = [
    ...declarations.map(resolveForwardRef),
    ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)
  ];
  exports.forEach(verifyExportsAreDeclaredOrReExported);
  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
  const ngModule = getAnnotation(moduleType, "NgModule");
  if (ngModule) {
    ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
  }
  if (errors.length) {
    throw new Error(errors.join("\n"));
  }
  function verifyDeclarationsHaveDefinitions(type) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
    if (!def) {
      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
  }
  function verifyDirectivesHaveSelector(type) {
    type = resolveForwardRef(type);
    const def = getDirectiveDef(type);
    if (!getComponentDef(type) && def && def.selectors.length == 0) {
      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
    }
  }
  function verifyNotStandalone(type, moduleType2) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
    if (def?.standalone) {
      const location2 = `"${stringifyForError(moduleType2)}" NgModule`;
      errors.push(generateStandaloneInDeclarationsError(type, location2));
    }
  }
  function verifyExportsAreDeclaredOrReExported(type) {
    type = resolveForwardRef(type);
    const kind = getComponentDef(type) && "component" || getDirectiveDef(type) && "directive" || getPipeDef$1(type) && "pipe";
    if (kind) {
      if (combinedDeclarations.lastIndexOf(type) === -1) {
        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
      }
    }
  }
  function verifyDeclarationIsUnique(type, suppressErrors) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (existingModule && existingModule !== moduleType) {
      if (!suppressErrors) {
        const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
        errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
      }
    } else {
      ownerNgModule.set(type, moduleType);
    }
  }
  function verifyComponentIsPartOfNgModule(type) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (!existingModule && !isStandalone(type)) {
      errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);
    }
  }
  function verifyCorrectBootstrapType(type) {
    type = resolveForwardRef(type);
    if (!getComponentDef(type)) {
      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
    }
    if (isStandalone(type)) {
      errors.push(`The \`${stringifyForError(type)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`);
    }
  }
  function verifySemanticsOfNgModuleImport(type, importingModule2) {
    type = resolveForwardRef(type);
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null && !directiveDef.standalone) {
      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
    const pipeDef = getPipeDef$1(type);
    if (pipeDef !== null && !pipeDef.standalone) {
      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
  }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
  return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type, name) {
  let annotation = null;
  collect(type.__annotations__);
  collect(type.decorators);
  return annotation;
  function collect(annotations) {
    if (annotations) {
      annotations.forEach(readAnnotation);
    }
  }
  function readAnnotation(decorator) {
    if (!annotation) {
      const proto = Object.getPrototypeOf(decorator);
      if (proto.ngMetadataName == name) {
        annotation = decorator;
      } else if (decorator.type) {
        const proto2 = Object.getPrototypeOf(decorator.type);
        if (proto2.ngMetadataName == name) {
          annotation = decorator.args[0];
        }
      }
    }
  }
}
var ownerNgModule = /* @__PURE__ */ new WeakMap();
var verifiedNgModule = /* @__PURE__ */ new WeakMap();
function computeCombinedExports(type) {
  type = resolveForwardRef(type);
  const ngModuleDef = getNgModuleDef(type);
  if (ngModuleDef === null) {
    return [type];
  }
  return flatten(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {
    const ngModuleDef2 = getNgModuleDef(type2);
    if (ngModuleDef2) {
      verifySemanticsOfNgModuleDef(type2, false);
      return computeCombinedExports(type2);
    } else {
      return type2;
    }
  }));
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  const transitiveScopes = transitiveScopesFor(moduleType);
  declarations.forEach((declaration) => {
    declaration = resolveForwardRef(declaration);
    if (declaration.hasOwnProperty(NG_COMP_DEF)) {
      const component = declaration;
      const componentDef = getComponentDef(component);
      patchComponentDefWithScope(componentDef, transitiveScopes);
    } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
      declaration.ngSelectorScope = moduleType;
    }
  });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);
  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe2) => getPipeDef$1(pipe2));
  componentDef.schemas = transitiveScopes.schemas;
  componentDef.tView = null;
}
function transitiveScopesFor(type) {
  if (isNgModule(type)) {
    if (USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      const scope = depsTracker.getNgModuleScope(type);
      const def = getNgModuleDef(type, true);
      return __spreadValues({
        schemas: def.schemas || null
      }, scope);
    } else {
      return transitiveScopesForNgModule(type);
    }
  } else if (isStandalone(type)) {
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set([type]),
          pipes: /* @__PURE__ */ new Set()
        }
      };
    }
    const pipeDef = getPipeDef$1(type);
    if (pipeDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set([type])
        }
      };
    }
  }
  throw new Error(`${type.name} does not have a module def (\u0275mod property)`);
}
function transitiveScopesForNgModule(moduleType) {
  const def = getNgModuleDef(moduleType, true);
  if (def.transitiveCompileScopes !== null) {
    return def.transitiveCompileScopes;
  }
  const scopes = {
    schemas: def.schemas || null,
    compilation: {
      directives: /* @__PURE__ */ new Set(),
      pipes: /* @__PURE__ */ new Set()
    },
    exported: {
      directives: /* @__PURE__ */ new Set(),
      pipes: /* @__PURE__ */ new Set()
    }
  };
  maybeUnwrapFn(def.imports).forEach((imported) => {
    const importedScope = transitiveScopesFor(imported);
    importedScope.exported.directives.forEach((entry) => scopes.compilation.directives.add(entry));
    importedScope.exported.pipes.forEach((entry) => scopes.compilation.pipes.add(entry));
  });
  maybeUnwrapFn(def.declarations).forEach((declared) => {
    const declaredWithDefs = declared;
    if (getPipeDef$1(declaredWithDefs)) {
      scopes.compilation.pipes.add(declared);
    } else {
      scopes.compilation.directives.add(declared);
    }
  });
  maybeUnwrapFn(def.exports).forEach((exported) => {
    const exportedType = exported;
    if (isNgModule(exportedType)) {
      const exportedScope = transitiveScopesFor(exportedType);
      exportedScope.exported.directives.forEach((entry) => {
        scopes.compilation.directives.add(entry);
        scopes.exported.directives.add(entry);
      });
      exportedScope.exported.pipes.forEach((entry) => {
        scopes.compilation.pipes.add(entry);
        scopes.exported.pipes.add(entry);
      });
    } else if (getPipeDef$1(exportedType)) {
      scopes.exported.pipes.add(exportedType);
    } else {
      scopes.exported.directives.add(exportedType);
    }
  });
  def.transitiveCompileScopes = scopes;
  return scopes;
}
function expandModuleWithProviders(value) {
  if (isModuleWithProviders(value)) {
    return value.ngModule;
  }
  return value;
}
var compilationDepth = 0;
function compileComponent(type, metadata) {
  (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
  let ngComponentDef = null;
  maybeQueueResolutionOfComponentResources(type, metadata);
  addDirectiveFactoryDef(type, metadata);
  Object.defineProperty(type, NG_COMP_DEF, {
    get: () => {
      if (ngComponentDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "component",
          type
        });
        if (componentNeedsResolution(metadata)) {
          const error = [`Component '${type.name}' is not resolved:`];
          if (metadata.templateUrl) {
            error.push(` - templateUrl: ${metadata.templateUrl}`);
          }
          if (metadata.styleUrls && metadata.styleUrls.length) {
            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
          }
          if (metadata.styleUrl) {
            error.push(` - styleUrl: ${metadata.styleUrl}`);
          }
          error.push(`Did you run and wait for 'resolveComponentResources()'?`);
          throw new Error(error.join("\n"));
        }
        const options = getJitOptions();
        let preserveWhitespaces = metadata.preserveWhitespaces;
        if (preserveWhitespaces === void 0) {
          if (options !== null && options.preserveWhitespaces !== void 0) {
            preserveWhitespaces = options.preserveWhitespaces;
          } else {
            preserveWhitespaces = false;
          }
        }
        let encapsulation = metadata.encapsulation;
        if (encapsulation === void 0) {
          if (options !== null && options.defaultEncapsulation !== void 0) {
            encapsulation = options.defaultEncapsulation;
          } else {
            encapsulation = ViewEncapsulation$1.Emulated;
          }
        }
        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
        const meta = __spreadProps(__spreadValues({}, directiveMetadata(type, metadata)), {
          typeSourceSpan: compiler.createParseSourceSpan("Component", type.name, templateUrl),
          template: metadata.template || "",
          preserveWhitespaces,
          styles: typeof metadata.styles === "string" ? [metadata.styles] : metadata.styles || EMPTY_ARRAY,
          animations: metadata.animations,
          // JIT components are always compiled against an empty set of `declarations`. Instead, the
          // `directiveDefs` and `pipeDefs` are updated at a later point:
          //  * for NgModule-based components, they're set when the NgModule which declares the
          //    component resolves in the module scoping queue
          //  * for standalone components, they're set just below, after `compileComponent`.
          declarations: [],
          changeDetection: metadata.changeDetection,
          encapsulation,
          interpolation: metadata.interpolation,
          viewProviders: metadata.viewProviders || null
        });
        compilationDepth++;
        try {
          if (meta.usesInheritance) {
            addDirectiveDefToUndecoratedParents(type);
          }
          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          if (metadata.standalone) {
            const imports = flatten(metadata.imports || EMPTY_ARRAY);
            const { directiveDefs, pipeDefs } = getStandaloneDefFunctions(type, imports);
            ngComponentDef.directiveDefs = directiveDefs;
            ngComponentDef.pipeDefs = pipeDefs;
            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);
          }
        } finally {
          compilationDepth--;
        }
        if (compilationDepth === 0) {
          flushModuleScopingQueueAsMuchAsPossible();
        }
        if (hasSelectorScope(type)) {
          const scopes = transitiveScopesFor(type.ngSelectorScope);
          patchComponentDefWithScope(ngComponentDef, scopes);
        }
        if (metadata.schemas) {
          if (metadata.standalone) {
            ngComponentDef.schemas = metadata.schemas;
          } else {
            throw new Error(`The 'schemas' was specified for the ${stringifyForError(type)} but is only valid on a component that is standalone.`);
          }
        } else if (metadata.standalone) {
          ngComponentDef.schemas = [];
        }
      }
      return ngComponentDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getStandaloneDefFunctions(type, imports) {
  let cachedDirectiveDefs = null;
  let cachedPipeDefs = null;
  const directiveDefs = () => {
    if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      if (cachedDirectiveDefs === null) {
        cachedDirectiveDefs = [getComponentDef(type)];
        const seen = /* @__PURE__ */ new Set([type]);
        for (const rawDep of imports) {
          ngDevMode && verifyStandaloneImport(rawDep, type);
          const dep = resolveForwardRef(rawDep);
          if (seen.has(dep)) {
            continue;
          }
          seen.add(dep);
          if (!!getNgModuleDef(dep)) {
            const scope = transitiveScopesFor(dep);
            for (const dir of scope.exported.directives) {
              const def = getComponentDef(dir) || getDirectiveDef(dir);
              if (def && !seen.has(dir)) {
                seen.add(dir);
                cachedDirectiveDefs.push(def);
              }
            }
          } else {
            const def = getComponentDef(dep) || getDirectiveDef(dep);
            if (def) {
              cachedDirectiveDefs.push(def);
            }
          }
        }
      }
      return cachedDirectiveDefs;
    } else {
      if (ngDevMode) {
        for (const rawDep of imports) {
          verifyStandaloneImport(rawDep, type);
        }
      }
      if (!isComponent(type)) {
        return [];
      }
      const scope = depsTracker.getStandaloneComponentScope(type, imports);
      return [...scope.compilation.directives].map((p3) => getComponentDef(p3) || getDirectiveDef(p3)).filter((d2) => d2 !== null);
    }
  };
  const pipeDefs = () => {
    if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      if (cachedPipeDefs === null) {
        cachedPipeDefs = [];
        const seen = /* @__PURE__ */ new Set();
        for (const rawDep of imports) {
          const dep = resolveForwardRef(rawDep);
          if (seen.has(dep)) {
            continue;
          }
          seen.add(dep);
          if (!!getNgModuleDef(dep)) {
            const scope = transitiveScopesFor(dep);
            for (const pipe2 of scope.exported.pipes) {
              const def = getPipeDef$1(pipe2);
              if (def && !seen.has(pipe2)) {
                seen.add(pipe2);
                cachedPipeDefs.push(def);
              }
            }
          } else {
            const def = getPipeDef$1(dep);
            if (def) {
              cachedPipeDefs.push(def);
            }
          }
        }
      }
      return cachedPipeDefs;
    } else {
      if (ngDevMode) {
        for (const rawDep of imports) {
          verifyStandaloneImport(rawDep, type);
        }
      }
      if (!isComponent(type)) {
        return [];
      }
      const scope = depsTracker.getStandaloneComponentScope(type, imports);
      return [...scope.compilation.pipes].map((p3) => getPipeDef$1(p3)).filter((d2) => d2 !== null);
    }
  };
  return {
    directiveDefs,
    pipeDefs
  };
}
function hasSelectorScope(component) {
  return component.ngSelectorScope !== void 0;
}
function compileDirective(type, directive) {
  let ngDirectiveDef = null;
  addDirectiveFactoryDef(type, directive || {});
  Object.defineProperty(type, NG_DIR_DEF, {
    get: () => {
      if (ngDirectiveDef === null) {
        const meta = getDirectiveMetadata(type, directive || {});
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
      }
      return ngDirectiveDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getDirectiveMetadata(type, metadata) {
  const name = type && type.name;
  const sourceMapUrl = `ng:///${name}/\u0275dir.js`;
  const compiler = getCompilerFacade({ usage: 0, kind: "directive", type });
  const facade = directiveMetadata(type, metadata);
  facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
  if (facade.usesInheritance) {
    addDirectiveDefToUndecoratedParents(type);
  }
  return { metadata: facade, sourceMapUrl };
}
function addDirectiveFactoryDef(type, metadata) {
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const meta = getDirectiveMetadata(type, metadata);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/\u0275fac.js`, {
          name: meta.metadata.name,
          type: meta.metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Directive
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function extendsDirectlyFromObject(type) {
  return Object.getPrototypeOf(type.prototype) === Object.prototype;
}
function directiveMetadata(type, metadata) {
  const reflect = getReflect();
  const propMetadata = reflect.ownPropMetadata(type);
  return {
    name: type.name,
    type,
    selector: metadata.selector !== void 0 ? metadata.selector : null,
    host: metadata.host || EMPTY_OBJ,
    propMetadata,
    inputs: metadata.inputs || EMPTY_ARRAY,
    outputs: metadata.outputs || EMPTY_ARRAY,
    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
    lifecycle: { usesOnChanges: reflect.hasLifecycleHook(type, "ngOnChanges") },
    typeSourceSpan: null,
    usesInheritance: !extendsDirectlyFromObject(type),
    exportAs: extractExportAs(metadata.exportAs),
    providers: metadata.providers || null,
    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
    isStandalone: !!metadata.standalone,
    isSignal: !!metadata.signals,
    hostDirectives: metadata.hostDirectives?.map((directive) => typeof directive === "function" ? { directive } : directive) || null
  };
}
function addDirectiveDefToUndecoratedParents(type) {
  const objPrototype = Object.prototype;
  let parent2 = Object.getPrototypeOf(type.prototype).constructor;
  while (parent2 && parent2 !== objPrototype) {
    if (!getDirectiveDef(parent2) && !getComponentDef(parent2) && shouldAddAbstractDirective(parent2)) {
      compileDirective(parent2, null);
    }
    parent2 = Object.getPrototypeOf(parent2);
  }
}
function convertToR3QueryPredicate(selector) {
  return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
}
function convertToR3QueryMetadata(propertyName, ann) {
  return {
    propertyName,
    predicate: convertToR3QueryPredicate(ann.selector),
    descendants: ann.descendants,
    first: ann.first,
    read: ann.read ? ann.read : null,
    static: !!ann.static,
    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,
    isSignal: !!ann.isSignal
  };
}
function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
  const queriesMeta = [];
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      const annotations = propMetadata[field];
      annotations.forEach((ann) => {
        if (isQueryAnn(ann)) {
          if (!ann.selector) {
            throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type)}" since the query selector wasn't defined.`);
          }
          if (annotations.some(isInputAnnotation)) {
            throw new Error(`Cannot combine @Input decorators with query decorators`);
          }
          queriesMeta.push(convertToR3QueryMetadata(field, ann));
        }
      });
    }
  }
  return queriesMeta;
}
function extractExportAs(exportAs) {
  return exportAs === void 0 ? null : splitByComma(exportAs);
}
function isContentQuery(value) {
  const name = value.ngMetadataName;
  return name === "ContentChild" || name === "ContentChildren";
}
function isViewQuery(value) {
  const name = value.ngMetadataName;
  return name === "ViewChild" || name === "ViewChildren";
}
function isInputAnnotation(value) {
  return value.ngMetadataName === "Input";
}
function splitByComma(value) {
  return value.split(",").map((piece) => piece.trim());
}
var LIFECYCLE_HOOKS = [
  "ngOnChanges",
  "ngOnInit",
  "ngOnDestroy",
  "ngDoCheck",
  "ngAfterViewInit",
  "ngAfterViewChecked",
  "ngAfterContentInit",
  "ngAfterContentChecked"
];
function shouldAddAbstractDirective(type) {
  const reflect = getReflect();
  if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {
    return true;
  }
  const propMetadata = reflect.propMetadata(type);
  for (const field in propMetadata) {
    const annotations = propMetadata[field];
    for (let i3 = 0; i3 < annotations.length; i3++) {
      const current = annotations[i3];
      const metadataName = current.ngMetadataName;
      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
        return true;
      }
    }
  }
  return false;
}
function compilePipe(type, meta) {
  let ngPipeDef = null;
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/\u0275fac.js`, {
          name: metadata.name,
          type: metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Pipe
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  Object.defineProperty(type, NG_PIPE_DEF, {
    get: () => {
      if (ngPipeDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/\u0275pipe.js`, metadata);
      }
      return ngPipeDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getPipeMetadata(type, meta) {
  return {
    type,
    name: type.name,
    pipeName: meta.name,
    pure: meta.pure !== void 0 ? meta.pure : true,
    isStandalone: !!meta.standalone
  };
}
var Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type, meta) => compileDirective(type, meta));
var Component = makeDecorator("Component", (c3 = {}) => __spreadValues({ changeDetection: ChangeDetectionStrategy.Default }, c3), Directive, void 0, (type, meta) => compileComponent(type, meta));
var Pipe = makeDecorator("Pipe", (p3) => __spreadValues({ pure: true }, p3), void 0, void 0, (type, meta) => compilePipe(type, meta));
var Input = makePropDecorator("Input", (arg) => {
  if (!arg) {
    return {};
  }
  return typeof arg === "string" ? { alias: arg } : arg;
});
var Output = makePropDecorator("Output", (alias) => ({ alias }));
var HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({ hostPropertyName }));
var HostListener = makePropDecorator("HostListener", (eventName, args) => ({ eventName, args }));
var NgModule = makeDecorator(
  "NgModule",
  (ngModule) => ngModule,
  void 0,
  void 0,
  /**
   * Decorator that marks the following class as an NgModule, and supplies
   * configuration metadata for it.
   *
   * * The `declarations` option configures the compiler
   * with information about what belongs to the NgModule.
   * * The `providers` options configures the NgModule's injector to provide
   * dependencies the NgModule members.
   * * The `imports` and `exports` options bring in members from other modules, and make
   * this module's members available to others.
   */
  (type, meta) => compileNgModule(type, meta)
);
var Version = class {
  constructor(full) {
    this.full = full;
    const parts = full.split(".");
    this.major = parts[0];
    this.minor = parts[1];
    this.patch = parts.slice(2).join(".");
  }
};
var VERSION = new Version("18.0.1");
var _Console = class _Console {
  log(message) {
    console.log(message);
  }
  // Note: for reporting errors use `DOM.logError()` as it is platform specific
  warn(message) {
    console.warn(message);
  }
};
_Console.\u0275fac = function Console_Factory(t3) {
  return new (t3 || _Console)();
};
_Console.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Console, factory: _Console.\u0275fac, providedIn: "platform" });
var Console = _Console;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
    type: Injectable,
    args: [{ providedIn: "platform" }]
  }], null, null);
})();
var DIDebugData = class {
  constructor() {
    this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
    this.resolverToProviders = /* @__PURE__ */ new WeakMap();
    this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
  }
  reset() {
    this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
    this.resolverToProviders = /* @__PURE__ */ new WeakMap();
    this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
  }
};
var frameworkDIDebugData = new DIDebugData();
function getFrameworkDIDebugData() {
  return frameworkDIDebugData;
}
function setupFrameworkInjectorProfiler() {
  frameworkDIDebugData.reset();
  setInjectorProfiler((injectorProfilerEvent) => handleInjectorProfilerEvent(injectorProfilerEvent));
}
function handleInjectorProfilerEvent(injectorProfilerEvent) {
  const { context: context2, type } = injectorProfilerEvent;
  if (type === 0) {
    handleInjectEvent(context2, injectorProfilerEvent.service);
  } else if (type === 1) {
    handleInstanceCreatedByInjectorEvent(context2, injectorProfilerEvent.instance);
  } else if (type === 2) {
    handleProviderConfiguredEvent(context2, injectorProfilerEvent.providerRecord);
  }
}
function handleInjectEvent(context2, data) {
  const diResolver = getDIResolver(context2.injector);
  if (diResolver === null) {
    throwError2("An Inject event must be run within an injection context.");
  }
  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
  if (!diResolverToInstantiatedToken.has(diResolver)) {
    diResolverToInstantiatedToken.set(diResolver, /* @__PURE__ */ new WeakMap());
  }
  if (!canBeHeldWeakly(context2.token)) {
    return;
  }
  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
  if (!instantiatedTokenToDependencies.has(context2.token)) {
    instantiatedTokenToDependencies.set(context2.token, []);
  }
  const { token, value, flags } = data;
  assertDefined(context2.token, "Injector profiler context token is undefined.");
  const dependencies = instantiatedTokenToDependencies.get(context2.token);
  assertDefined(dependencies, "Could not resolve dependencies for token.");
  if (context2.injector instanceof NodeInjector) {
    dependencies.push({ token, value, flags, injectedIn: getNodeInjectorContext(context2.injector) });
  } else {
    dependencies.push({ token, value, flags });
  }
}
function getNodeInjectorContext(injector) {
  if (!(injector instanceof NodeInjector)) {
    throwError2("getNodeInjectorContext must be called with a NodeInjector");
  }
  const lView = getNodeInjectorLView(injector);
  const tNode = getNodeInjectorTNode(injector);
  if (tNode === null) {
    return;
  }
  assertTNodeForLView(tNode, lView);
  return { lView, tNode };
}
function handleInstanceCreatedByInjectorEvent(context2, data) {
  const { value } = data;
  if (getDIResolver(context2.injector) === null) {
    throwError2("An InjectorCreatedInstance event must be run within an injection context.");
  }
  let standaloneComponent = void 0;
  if (typeof value === "object") {
    standaloneComponent = value?.constructor;
  }
  if (standaloneComponent === void 0 || !isStandaloneComponent(standaloneComponent)) {
    return;
  }
  const environmentInjector = context2.injector.get(EnvironmentInjector, null, { optional: true });
  if (environmentInjector === null) {
    return;
  }
  const { standaloneInjectorToComponent } = frameworkDIDebugData;
  if (standaloneInjectorToComponent.has(environmentInjector)) {
    return;
  }
  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
}
function isStandaloneComponent(value) {
  const def = getComponentDef(value);
  return !!def?.standalone;
}
function handleProviderConfiguredEvent(context2, data) {
  const { resolverToProviders } = frameworkDIDebugData;
  let diResolver;
  if (context2?.injector instanceof NodeInjector) {
    diResolver = getNodeInjectorTNode(context2.injector);
  } else {
    diResolver = context2.injector;
  }
  if (diResolver === null) {
    throwError2("A ProviderConfigured event must be run within an injection context.");
  }
  if (!resolverToProviders.has(diResolver)) {
    resolverToProviders.set(diResolver, []);
  }
  resolverToProviders.get(diResolver).push(data);
}
function getDIResolver(injector) {
  let diResolver = null;
  if (injector === void 0) {
    return diResolver;
  }
  if (injector instanceof NodeInjector) {
    diResolver = getNodeInjectorLView(injector);
  } else {
    diResolver = injector;
  }
  return diResolver;
}
function canBeHeldWeakly(value) {
  return value !== null && (typeof value === "object" || typeof value === "function" || typeof value === "symbol");
}
function applyChanges(component) {
  ngDevMode && assertDefined(component, "component");
  markViewDirty(
    getComponentViewByInstance(component),
    3
    /* NotificationSource.DebugApplyChanges */
  );
  getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
}
function detectChanges(component) {
  const view = getComponentViewByInstance(component);
  view[FLAGS] |= 1024;
  detectChangesInternal(view);
}
function getDependenciesFromInjectable(injector, token) {
  const instance = injector.get(token, null, { self: true, optional: true });
  if (instance === null) {
    throw new Error(`Unable to determine instance of ${token} in given injector`);
  }
  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);
  const resolutionPath = getInjectorResolutionPath(injector);
  const dependencies = unformattedDependencies.map((dep) => {
    const formattedDependency = {
      value: dep.value
    };
    const flags = dep.flags;
    formattedDependency.flags = {
      optional: (8 & flags) === 8,
      host: (1 & flags) === 1,
      self: (2 & flags) === 2,
      skipSelf: (4 & flags) === 4
    };
    for (let i3 = 0; i3 < resolutionPath.length; i3++) {
      const injectorToCheck = resolutionPath[i3];
      if (i3 === 0 && formattedDependency.flags.skipSelf) {
        continue;
      }
      if (formattedDependency.flags.host && injectorToCheck instanceof EnvironmentInjector) {
        break;
      }
      const instance2 = injectorToCheck.get(dep.token, null, {
        self: true,
        optional: true
      });
      if (instance2 !== null) {
        if (formattedDependency.flags.host) {
          const firstInjector = resolutionPath[0];
          const lookupFromFirstInjector = firstInjector.get(dep.token, null, __spreadProps(__spreadValues({}, formattedDependency.flags), {
            optional: true
          }));
          if (lookupFromFirstInjector !== null) {
            formattedDependency.providedIn = injectorToCheck;
          }
          break;
        }
        formattedDependency.providedIn = injectorToCheck;
        break;
      }
      if (i3 === 0 && formattedDependency.flags.self) {
        break;
      }
    }
    if (dep.token)
      formattedDependency.token = dep.token;
    return formattedDependency;
  });
  return { instance, dependencies };
}
function getDependenciesForTokenInInjector(token, injector) {
  const { resolverToTokenToDependencies } = getFrameworkDIDebugData();
  if (!(injector instanceof NodeInjector)) {
    return resolverToTokenToDependencies.get(injector)?.get?.(token) ?? [];
  }
  const lView = getNodeInjectorLView(injector);
  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);
  const dependencies = tokenDependencyMap?.get(token) ?? [];
  return dependencies.filter((dependency) => {
    const dependencyNode = dependency.injectedIn?.tNode;
    if (dependencyNode === void 0) {
      return false;
    }
    const instanceNode = getNodeInjectorTNode(injector);
    assertTNode(dependencyNode);
    assertTNode(instanceNode);
    return dependencyNode === instanceNode;
  });
}
function getProviderImportsContainer(injector) {
  const { standaloneInjectorToComponent } = getFrameworkDIDebugData();
  if (standaloneInjectorToComponent.has(injector)) {
    return standaloneInjectorToComponent.get(injector);
  }
  const defTypeRef = injector.get(NgModuleRef$1, null, { self: true, optional: true });
  if (defTypeRef === null) {
    return null;
  }
  if (defTypeRef.instance === null) {
    return null;
  }
  return defTypeRef.instance.constructor;
}
function getNodeInjectorProviders(injector) {
  const diResolver = getNodeInjectorTNode(injector);
  const { resolverToProviders } = getFrameworkDIDebugData();
  return resolverToProviders.get(diResolver) ?? [];
}
function getProviderImportPaths(providerImportsContainer) {
  const providerToPath = /* @__PURE__ */ new Map();
  const visitedContainers = /* @__PURE__ */ new Set();
  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);
  walkProviderTree(providerImportsContainer, visitor, [], /* @__PURE__ */ new Set());
  return providerToPath;
}
function walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {
  return (provider, container) => {
    if (!providerToPath.has(provider)) {
      providerToPath.set(provider, [container]);
    }
    if (!visitedContainers.has(container)) {
      for (const prov of providerToPath.keys()) {
        const existingImportPath = providerToPath.get(prov);
        let containerDef = getInjectorDef(container);
        if (!containerDef) {
          const ngModule = container.ngModule;
          containerDef = getInjectorDef(ngModule);
        }
        if (!containerDef) {
          return;
        }
        const lastContainerAddedToPath = existingImportPath[0];
        let isNextStepInPath = false;
        deepForEach(containerDef.imports, (moduleImport) => {
          if (isNextStepInPath) {
            return;
          }
          isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;
          if (isNextStepInPath) {
            providerToPath.get(prov)?.unshift(container);
          }
        });
      }
    }
    visitedContainers.add(container);
  };
}
function getEnvironmentInjectorProviders(injector) {
  const providerRecordsWithoutImportPaths = getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];
  if (isPlatformInjector(injector)) {
    return providerRecordsWithoutImportPaths;
  }
  const providerImportsContainer = getProviderImportsContainer(injector);
  if (providerImportsContainer === null) {
    return providerRecordsWithoutImportPaths;
  }
  const providerToPath = getProviderImportPaths(providerImportsContainer);
  const providerRecords = [];
  for (const providerRecord of providerRecordsWithoutImportPaths) {
    const provider = providerRecord.provider;
    const token = provider.provide;
    if (token === ENVIRONMENT_INITIALIZER || token === INJECTOR_DEF_TYPES) {
      continue;
    }
    let importPath = providerToPath.get(provider) ?? [];
    const def = getComponentDef(providerImportsContainer);
    const isStandaloneComponent2 = !!def?.standalone;
    if (isStandaloneComponent2) {
      importPath = [providerImportsContainer, ...importPath];
    }
    providerRecords.push(__spreadProps(__spreadValues({}, providerRecord), { importPath }));
  }
  return providerRecords;
}
function isPlatformInjector(injector) {
  return injector instanceof R3Injector && injector.scopes.has("platform");
}
function getInjectorProviders(injector) {
  if (injector instanceof NodeInjector) {
    return getNodeInjectorProviders(injector);
  } else if (injector instanceof EnvironmentInjector) {
    return getEnvironmentInjectorProviders(injector);
  }
  throwError2("getInjectorProviders only supports NodeInjector and EnvironmentInjector");
}
function getInjectorMetadata(injector) {
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    const tNode = getNodeInjectorTNode(injector);
    assertTNodeForLView(tNode, lView);
    return { type: "element", source: getNativeByTNode(tNode, lView) };
  }
  if (injector instanceof R3Injector) {
    return { type: "environment", source: injector.source ?? null };
  }
  if (injector instanceof NullInjector) {
    return { type: "null", source: null };
  }
  return null;
}
function getInjectorResolutionPath(injector) {
  const resolutionPath = [injector];
  getInjectorResolutionPathHelper(injector, resolutionPath);
  return resolutionPath;
}
function getInjectorResolutionPathHelper(injector, resolutionPath) {
  const parent2 = getInjectorParent(injector);
  if (parent2 === null) {
    if (injector instanceof NodeInjector) {
      const firstInjector = resolutionPath[0];
      if (firstInjector instanceof NodeInjector) {
        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);
        if (moduleInjector === null) {
          throwError2("NodeInjector must have some connection to the module injector tree");
        }
        resolutionPath.push(moduleInjector);
        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);
      }
      return resolutionPath;
    }
  } else {
    resolutionPath.push(parent2);
    getInjectorResolutionPathHelper(parent2, resolutionPath);
  }
  return resolutionPath;
}
function getInjectorParent(injector) {
  if (injector instanceof R3Injector) {
    return injector.parent;
  }
  let tNode;
  let lView;
  if (injector instanceof NodeInjector) {
    tNode = getNodeInjectorTNode(injector);
    lView = getNodeInjectorLView(injector);
  } else if (injector instanceof NullInjector) {
    return null;
  } else if (injector instanceof ChainedInjector) {
    return injector.parentInjector;
  } else {
    throwError2("getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector, ChainedInjector");
  }
  const parentLocation = getParentInjectorLocation(tNode, lView);
  if (hasParentInjector(parentLocation)) {
    const parentInjectorIndex = getParentInjectorIndex(parentLocation);
    const parentLView = getParentInjectorView(parentLocation, lView);
    const parentTView = parentLView[TVIEW];
    const parentTNode = parentTView.data[
      parentInjectorIndex + 8
      /* NodeInjectorOffset.TNODE */
    ];
    return new NodeInjector(parentTNode, parentLView);
  } else {
    const chainedInjector = lView[INJECTOR];
    const injectorParent = chainedInjector.injector?.parent;
    if (injectorParent instanceof NodeInjector) {
      return injectorParent;
    }
  }
  return null;
}
function getModuleInjectorOfNodeInjector(injector) {
  let lView;
  if (injector instanceof NodeInjector) {
    lView = getNodeInjectorLView(injector);
  } else {
    throwError2("getModuleInjectorOfNodeInjector must be called with a NodeInjector");
  }
  const inj = lView[INJECTOR];
  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;
  if (!moduleInjector) {
    throwError2("NodeInjector must have some connection to the module injector tree");
  }
  return moduleInjector;
}
var GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
var globalUtilsFunctions = {
  /**
   * Warning: functions that start with `` are considered *INTERNAL* and should not be relied upon
   * in application's code. The contract of those functions might be changed in any release and/or a
   * function can be removed completely.
   */
  "\u0275getDependenciesFromInjectable": getDependenciesFromInjectable,
  "\u0275getInjectorProviders": getInjectorProviders,
  "\u0275getInjectorResolutionPath": getInjectorResolutionPath,
  "\u0275getInjectorMetadata": getInjectorMetadata,
  "\u0275setProfiler": setProfiler,
  "getDirectiveMetadata": getDirectiveMetadata$1,
  "getComponent": getComponent$1,
  "getContext": getContext,
  "getListeners": getListeners,
  "getOwningComponent": getOwningComponent,
  "getHostElement": getHostElement,
  "getInjector": getInjector,
  "getRootComponents": getRootComponents,
  "getDirectives": getDirectives,
  "applyChanges": applyChanges,
  "isSignal": isSignal
};
var _published = false;
function publishDefaultGlobalUtils$1() {
  if (!_published) {
    _published = true;
    if (typeof window !== "undefined") {
      setupFrameworkInjectorProfiler();
    }
    for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {
      publishGlobalUtil(methodName, method);
    }
  }
}
function publishGlobalUtil(name, fn) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const w4 = _global;
    ngDevMode && assertDefined(fn, "function not defined");
    w4[GLOBAL_PUBLISH_EXPANDO_KEY] ??= {};
    w4[GLOBAL_PUBLISH_EXPANDO_KEY][name] = fn;
  }
}
var TESTABILITY = new InjectionToken("");
var TESTABILITY_GETTER = new InjectionToken("");
var _Testability = class _Testability {
  constructor(_ngZone, registry, testabilityGetter) {
    this._ngZone = _ngZone;
    this.registry = registry;
    this._isZoneStable = true;
    this._callbacks = [];
    this.taskTrackingZone = null;
    if (!_testabilityGetter) {
      setTestabilityGetter(testabilityGetter);
      testabilityGetter.addToWindow(registry);
    }
    this._watchAngularEvents();
    _ngZone.run(() => {
      this.taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
    });
  }
  _watchAngularEvents() {
    this._ngZone.onUnstable.subscribe({
      next: () => {
        this._isZoneStable = false;
      }
    });
    this._ngZone.runOutsideAngular(() => {
      this._ngZone.onStable.subscribe({
        next: () => {
          NgZone.assertNotInAngularZone();
          queueMicrotask(() => {
            this._isZoneStable = true;
            this._runCallbacksIfReady();
          });
        }
      });
    });
  }
  /**
   * Whether an associated application is stable
   */
  isStable() {
    return this._isZoneStable && !this._ngZone.hasPendingMacrotasks;
  }
  _runCallbacksIfReady() {
    if (this.isStable()) {
      queueMicrotask(() => {
        while (this._callbacks.length !== 0) {
          let cb = this._callbacks.pop();
          clearTimeout(cb.timeoutId);
          cb.doneCb();
        }
      });
    } else {
      let pending = this.getPendingTasks();
      this._callbacks = this._callbacks.filter((cb) => {
        if (cb.updateCb && cb.updateCb(pending)) {
          clearTimeout(cb.timeoutId);
          return false;
        }
        return true;
      });
    }
  }
  getPendingTasks() {
    if (!this.taskTrackingZone) {
      return [];
    }
    return this.taskTrackingZone.macroTasks.map((t3) => {
      return {
        source: t3.source,
        // From TaskTrackingZone:
        // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
        creationLocation: t3.creationLocation,
        data: t3.data
      };
    });
  }
  addCallback(cb, timeout, updateCb) {
    let timeoutId = -1;
    if (timeout && timeout > 0) {
      timeoutId = setTimeout(() => {
        this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
        cb();
      }, timeout);
    }
    this._callbacks.push({ doneCb: cb, timeoutId, updateCb });
  }
  /**
   * Wait for the application to be stable with a timeout. If the timeout is reached before that
   * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
   *
   * @param doneCb The callback to invoke when Angular is stable or the timeout expires
   *    whichever comes first.
   * @param timeout Optional. The maximum time to wait for Angular to become stable. If not
   *    specified, whenStable() will wait forever.
   * @param updateCb Optional. If specified, this callback will be invoked whenever the set of
   *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
   *    and no further updates will be issued.
   */
  whenStable(doneCb, timeout, updateCb) {
    if (updateCb && !this.taskTrackingZone) {
      throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
    }
    this.addCallback(doneCb, timeout, updateCb);
    this._runCallbacksIfReady();
  }
  /**
   * Registers an application with a testability hook so that it can be tracked.
   * @param token token of application, root element
   *
   * @internal
   */
  registerApplication(token) {
    this.registry.registerApplication(token, this);
  }
  /**
   * Unregisters an application.
   * @param token token of application, root element
   *
   * @internal
   */
  unregisterApplication(token) {
    this.registry.unregisterApplication(token);
  }
  /**
   * Find providers by name
   * @param using The root element to search from
   * @param provider The name of binding variable
   * @param exactMatch Whether using exactMatch
   */
  findProviders(using, provider, exactMatch) {
    return [];
  }
};
_Testability.\u0275fac = function Testability_Factory(t3) {
  return new (t3 || _Testability)(\u0275\u0275inject(NgZone), \u0275\u0275inject(TestabilityRegistry), \u0275\u0275inject(TESTABILITY_GETTER));
};
_Testability.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Testability, factory: _Testability.\u0275fac });
var Testability = _Testability;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
    type: Injectable
  }], () => [{ type: NgZone }, { type: TestabilityRegistry }, { type: void 0, decorators: [{
    type: Inject,
    args: [TESTABILITY_GETTER]
  }] }], null);
})();
var _TestabilityRegistry = class _TestabilityRegistry {
  constructor() {
    this._applications = /* @__PURE__ */ new Map();
  }
  /**
   * Registers an application with a testability hook so that it can be tracked
   * @param token token of application, root element
   * @param testability Testability hook
   */
  registerApplication(token, testability) {
    this._applications.set(token, testability);
  }
  /**
   * Unregisters an application.
   * @param token token of application, root element
   */
  unregisterApplication(token) {
    this._applications.delete(token);
  }
  /**
   * Unregisters all applications
   */
  unregisterAllApplications() {
    this._applications.clear();
  }
  /**
   * Get a testability hook associated with the application
   * @param elem root element
   */
  getTestability(elem) {
    return this._applications.get(elem) || null;
  }
  /**
   * Get all registered testabilities
   */
  getAllTestabilities() {
    return Array.from(this._applications.values());
  }
  /**
   * Get all registered applications(root elements)
   */
  getAllRootElements() {
    return Array.from(this._applications.keys());
  }
  /**
   * Find testability of a node in the Tree
   * @param elem node
   * @param findInAncestors whether finding testability in ancestors if testability was not found in
   * current node
   */
  findTestabilityInTree(elem, findInAncestors = true) {
    return _testabilityGetter?.findTestabilityInTree(this, elem, findInAncestors) ?? null;
  }
};
_TestabilityRegistry.\u0275fac = function TestabilityRegistry_Factory(t3) {
  return new (t3 || _TestabilityRegistry)();
};
_TestabilityRegistry.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _TestabilityRegistry, factory: _TestabilityRegistry.\u0275fac, providedIn: "platform" });
var TestabilityRegistry = _TestabilityRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
    type: Injectable,
    args: [{ providedIn: "platform" }]
  }], null, null);
})();
function setTestabilityGetter(getter) {
  _testabilityGetter = getter;
}
var _testabilityGetter;
function isPromise2(obj) {
  return !!obj && typeof obj.then === "function";
}
function isSubscribable(obj) {
  return !!obj && typeof obj.subscribe === "function";
}
var APP_INITIALIZER = new InjectionToken(ngDevMode ? "Application Initializer" : "");
var _ApplicationInitStatus = class _ApplicationInitStatus {
  constructor() {
    this.initialized = false;
    this.done = false;
    this.donePromise = new Promise((res, rej) => {
      this.resolve = res;
      this.reject = rej;
    });
    this.appInits = inject(APP_INITIALIZER, { optional: true }) ?? [];
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !Array.isArray(this.appInits)) {
      throw new RuntimeError(-209, `Unexpected type of the \`APP_INITIALIZER\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \`APP_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
    }
  }
  /** @internal */
  runInitializers() {
    if (this.initialized) {
      return;
    }
    const asyncInitPromises = [];
    for (const appInits of this.appInits) {
      const initResult = appInits();
      if (isPromise2(initResult)) {
        asyncInitPromises.push(initResult);
      } else if (isSubscribable(initResult)) {
        const observableAsPromise = new Promise((resolve, reject) => {
          initResult.subscribe({ complete: resolve, error: reject });
        });
        asyncInitPromises.push(observableAsPromise);
      }
    }
    const complete = () => {
      this.done = true;
      this.resolve();
    };
    Promise.all(asyncInitPromises).then(() => {
      complete();
    }).catch((e3) => {
      this.reject(e3);
    });
    if (asyncInitPromises.length === 0) {
      complete();
    }
    this.initialized = true;
  }
};
_ApplicationInitStatus.\u0275fac = function ApplicationInitStatus_Factory(t3) {
  return new (t3 || _ApplicationInitStatus)();
};
_ApplicationInitStatus.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ApplicationInitStatus, factory: _ApplicationInitStatus.\u0275fac, providedIn: "root" });
var ApplicationInitStatus = _ApplicationInitStatus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], () => [], null);
})();
var APP_BOOTSTRAP_LISTENER = new InjectionToken(ngDevMode ? "appBootstrapListener" : "");
function publishDefaultGlobalUtils() {
  ngDevMode && publishDefaultGlobalUtils$1();
}
function publishSignalConfiguration() {
  setThrowInvalidWriteToSignalError(() => {
    throw new RuntimeError(600, ngDevMode && "Writing to signals is not allowed in a `computed` or an `effect` by default. Use `allowSignalWrites` in the `CreateEffectOptions` to enable this inside effects.");
  });
}
function isBoundToModule(cf) {
  return cf.isBoundToModule;
}
var MAXIMUM_REFRESH_RERUNS = 10;
function _callAndReportToErrorHandler(errorHandler2, ngZone, callback) {
  try {
    const result = callback();
    if (isPromise2(result)) {
      return result.catch((e3) => {
        ngZone.runOutsideAngular(() => errorHandler2.handleError(e3));
        throw e3;
      });
    }
    return result;
  } catch (e3) {
    ngZone.runOutsideAngular(() => errorHandler2.handleError(e3));
    throw e3;
  }
}
function optionsReducer(dst, objs) {
  if (Array.isArray(objs)) {
    return objs.reduce(optionsReducer, dst);
  }
  return __spreadValues(__spreadValues({}, dst), objs);
}
var _ApplicationRef = class _ApplicationRef {
  constructor() {
    this._bootstrapListeners = [];
    this._runningTick = false;
    this._destroyed = false;
    this._destroyListeners = [];
    this._views = [];
    this.internalErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
    this.afterRenderEffectManager = inject(AfterRenderEventManager);
    this.zonelessEnabled = inject(ZONELESS_ENABLED);
    this.externalTestViews = /* @__PURE__ */ new Set();
    this.beforeRender = new Subject();
    this.afterTick = new Subject();
    this.componentTypes = [];
    this.components = [];
    this.isStable = inject(PendingTasks).hasPendingTasks.pipe(map((pending) => !pending));
    this._injector = inject(EnvironmentInjector);
  }
  /** @internal */
  get allViews() {
    return [...this.externalTestViews.keys(), ...this._views];
  }
  /**
   * Indicates whether this instance was destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  /**
   * The `EnvironmentInjector` used to create this application.
   */
  get injector() {
    return this._injector;
  }
  /**
   * Bootstrap a component onto the element identified by its selector or, optionally, to a
   * specified element.
   *
   * @usageNotes
   * ### Bootstrap process
   *
   * When bootstrapping a component, Angular mounts it onto a target DOM element
   * and kicks off automatic change detection. The target DOM element can be
   * provided using the `rootSelectorOrNode` argument.
   *
   * If the target DOM element is not provided, Angular tries to find one on a page
   * using the `selector` of the component that is being bootstrapped
   * (first matched element is used).
   *
   * ### Example
   *
   * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,
   * but it requires us to know the component while writing the application code.
   *
   * Imagine a situation where we have to wait for an API call to decide about the component to
   * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to
   * dynamically bootstrap a component.
   *
   * {@example core/ts/platform/platform.ts region='componentSelector'}
   *
   * Optionally, a component can be mounted onto a DOM element that does not match the
   * selector of the bootstrapped component.
   *
   * In the following example, we are providing a CSS selector to match the target element.
   *
   * {@example core/ts/platform/platform.ts region='cssSelector'}
   *
   * While in this example, we are providing reference to a DOM node.
   *
   * {@example core/ts/platform/platform.ts region='domNode'}
   */
  bootstrap(componentOrFactory, rootSelectorOrNode) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
    const initStatus = this._injector.get(ApplicationInitStatus);
    if (!initStatus.done) {
      const standalone = !isComponentFactory && isStandalone(componentOrFactory);
      const errorMessage = (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot bootstrap as there are still asynchronous initializers running." + (standalone ? "" : " Bootstrap components in the `ngDoBootstrap` method of the root module.");
      throw new RuntimeError(405, errorMessage);
    }
    let componentFactory;
    if (isComponentFactory) {
      componentFactory = componentOrFactory;
    } else {
      const resolver = this._injector.get(ComponentFactoryResolver$1);
      componentFactory = resolver.resolveComponentFactory(componentOrFactory);
    }
    this.componentTypes.push(componentFactory.componentType);
    const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
    const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
    const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
    const nativeElement = compRef.location.nativeElement;
    const testability = compRef.injector.get(TESTABILITY, null);
    testability?.registerApplication(nativeElement);
    compRef.onDestroy(() => {
      this.detachView(compRef.hostView);
      remove(this.components, compRef);
      testability?.unregisterApplication(nativeElement);
    });
    this._loadComponent(compRef);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const _console = this._injector.get(Console);
      _console.log(`Angular is running in development mode.`);
    }
    return compRef;
  }
  /**
   * Invoke this method to explicitly process change detection and its side-effects.
   *
   * In development mode, `tick()` also performs a second change detection cycle to ensure that no
   * further changes are detected. If additional changes are picked up during this second cycle,
   * bindings in the app have side-effects that cannot be resolved in a single change detection
   * pass.
   * In this case, Angular throws an error, since an Angular application can only have one change
   * detection pass during which all change detection must complete.
   */
  tick() {
    this._tick(true);
  }
  /** @internal */
  _tick(refreshViews) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    if (this._runningTick) {
      throw new RuntimeError(101, ngDevMode && "ApplicationRef.tick is called recursively");
    }
    const prevConsumer = setActiveConsumer(null);
    try {
      this._runningTick = true;
      this.detectChangesInAttachedViews(refreshViews);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        for (let view of this._views) {
          view.checkNoChanges();
        }
      }
    } catch (e3) {
      this.internalErrorHandler(e3);
    } finally {
      this._runningTick = false;
      setActiveConsumer(prevConsumer);
      this.afterTick.next();
    }
  }
  detectChangesInAttachedViews(refreshViews) {
    let rendererFactory = null;
    if (!this._injector.destroyed) {
      rendererFactory = this._injector.get(RendererFactory2, null, { optional: true });
    }
    let runs = 0;
    const afterRenderEffectManager = this.afterRenderEffectManager;
    while (runs < MAXIMUM_REFRESH_RERUNS) {
      const isFirstPass = runs === 0;
      if (refreshViews || !isFirstPass) {
        this.beforeRender.next(isFirstPass);
        for (let { _lView, notifyErrorHandler } of this._views) {
          detectChangesInViewIfRequired(_lView, notifyErrorHandler, isFirstPass, this.zonelessEnabled);
        }
      } else {
        rendererFactory?.begin?.();
        rendererFactory?.end?.();
      }
      runs++;
      afterRenderEffectManager.executeInternalCallbacks();
      if (this.allViews.some(({ _lView }) => requiresRefreshOrTraversal(_lView))) {
        continue;
      }
      afterRenderEffectManager.execute();
      if (!this.allViews.some(({ _lView }) => requiresRefreshOrTraversal(_lView))) {
        break;
      }
    }
    if ((typeof ngDevMode === "undefined" || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {
      throw new RuntimeError(103, ngDevMode && "Infinite change detection while refreshing application views. Ensure views are not calling `markForCheck` on every template execution or that afterRender hooks always mark views for check.");
    }
  }
  /**
   * Attaches a view so that it will be dirty checked.
   * The view will be automatically detached when it is destroyed.
   * This will throw if the view is already attached to a ViewContainer.
   */
  attachView(viewRef) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const view = viewRef;
    this._views.push(view);
    view.attachToAppRef(this);
  }
  /**
   * Detaches a view from dirty checking again.
   */
  detachView(viewRef) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const view = viewRef;
    remove(this._views, view);
    view.detachFromAppRef();
  }
  _loadComponent(componentRef) {
    this.attachView(componentRef.hostView);
    this.tick();
    this.components.push(componentRef);
    const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
    if (ngDevMode && !Array.isArray(listeners)) {
      throw new RuntimeError(-209, `Unexpected type of the \`APP_BOOTSTRAP_LISTENER\` token value (expected an array, but got ${typeof listeners}). Please check that the \`APP_BOOTSTRAP_LISTENER\` token is configured as a \`multi: true\` provider.`);
    }
    [...this._bootstrapListeners, ...listeners].forEach((listener) => listener(componentRef));
  }
  /** @internal */
  ngOnDestroy() {
    if (this._destroyed)
      return;
    try {
      this._destroyListeners.forEach((listener) => listener());
      this._views.slice().forEach((view) => view.destroy());
    } finally {
      this._destroyed = true;
      this._views = [];
      this._bootstrapListeners = [];
      this._destroyListeners = [];
    }
  }
  /**
   * Registers a listener to be called when an instance is destroyed.
   *
   * @param callback A callback function to add as a listener.
   * @returns A function which unregisters a listener.
   */
  onDestroy(callback) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    this._destroyListeners.push(callback);
    return () => remove(this._destroyListeners, callback);
  }
  /**
   * Destroys an Angular application represented by this `ApplicationRef`. Calling this function
   * will destroy the associated environment injectors as well as all the bootstrapped components
   * with their views.
   */
  destroy() {
    if (this._destroyed) {
      throw new RuntimeError(406, ngDevMode && "This instance of the `ApplicationRef` has already been destroyed.");
    }
    const injector = this._injector;
    if (injector.destroy && !injector.destroyed) {
      injector.destroy();
    }
  }
  /**
   * Returns the number of attached views.
   */
  get viewCount() {
    return this._views.length;
  }
  warnIfDestroyed() {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && this._destroyed) {
      console.warn(formatRuntimeError(406, "This instance of the `ApplicationRef` has already been destroyed."));
    }
  }
};
_ApplicationRef.\u0275fac = function ApplicationRef_Factory(t3) {
  return new (t3 || _ApplicationRef)();
};
_ApplicationRef.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ApplicationRef, factory: _ApplicationRef.\u0275fac, providedIn: "root" });
var ApplicationRef = _ApplicationRef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();
function remove(list, el) {
  const index3 = list.indexOf(el);
  if (index3 > -1) {
    list.splice(index3, 1);
  }
}
function detectChangesInViewIfRequired(lView, notifyErrorHandler, isFirstPass, zonelessEnabled) {
  if (!isFirstPass && !requiresRefreshOrTraversal(lView)) {
    return;
  }
  const mode = isFirstPass && !zonelessEnabled ? (
    // The first pass is always in Global mode, which includes `CheckAlways` views.
    0
  ) : (
    // Only refresh views with the `RefreshView` flag or views is a changed signal
    1
  );
  detectChangesInternal(lView, notifyErrorHandler, mode);
}
var ModuleWithComponentFactories = class {
  constructor(ngModuleFactory, componentFactories) {
    this.ngModuleFactory = ngModuleFactory;
    this.componentFactories = componentFactories;
  }
};
var _Compiler = class _Compiler {
  /**
   * Compiles the given NgModule and all of its components. All templates of the components
   * have to be inlined.
   */
  compileModuleSync(moduleType) {
    return new NgModuleFactory(moduleType);
  }
  /**
   * Compiles the given NgModule and all of its components
   */
  compileModuleAsync(moduleType) {
    return Promise.resolve(this.compileModuleSync(moduleType));
  }
  /**
   * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.
   */
  compileModuleAndAllComponentsSync(moduleType) {
    const ngModuleFactory = this.compileModuleSync(moduleType);
    const moduleDef = getNgModuleDef(moduleType);
    const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
      const componentDef = getComponentDef(declaration);
      componentDef && factories.push(new ComponentFactory(componentDef));
      return factories;
    }, []);
    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
  }
  /**
   * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.
   */
  compileModuleAndAllComponentsAsync(moduleType) {
    return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
  }
  /**
   * Clears all caches.
   */
  clearCache() {
  }
  /**
   * Clears the cache for the given component/ngModule.
   */
  clearCacheFor(type) {
  }
  /**
   * Returns the id for a given NgModule, if one is defined and known to the compiler.
   */
  getModuleId(moduleType) {
    return void 0;
  }
};
_Compiler.\u0275fac = function Compiler_Factory(t3) {
  return new (t3 || _Compiler)();
};
_Compiler.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _Compiler, factory: _Compiler.\u0275fac, providedIn: "root" });
var Compiler = _Compiler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();
var COMPILER_OPTIONS = new InjectionToken(ngDevMode ? "compilerOptions" : "");
function compileNgModuleFactory(injector, options, moduleType) {
  ngDevMode && assertNgModuleType(moduleType);
  const moduleFactory = new NgModuleFactory(moduleType);
  if (true) {
    return Promise.resolve(moduleFactory);
  }
  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
  setJitOptions({
    defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
    preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
  });
  if (isComponentResourceResolutionQueueEmpty()) {
    return Promise.resolve(moduleFactory);
  }
  const compilerProviders = compilerOptions.flatMap((option) => option.providers ?? []);
  if (compilerProviders.length === 0) {
    return Promise.resolve(moduleFactory);
  }
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "NgModule",
    type: moduleType
  });
  const compilerInjector = Injector.create({ providers: compilerProviders });
  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
  return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
}
function _lastDefined(args) {
  for (let i3 = args.length - 1; i3 >= 0; i3--) {
    if (args[i3] !== void 0) {
      return args[i3];
    }
  }
  return void 0;
}
var _NgZoneChangeDetectionScheduler = class _NgZoneChangeDetectionScheduler {
  constructor() {
    this.zone = inject(NgZone);
    this.changeDetectionScheduler = inject(ChangeDetectionScheduler);
    this.applicationRef = inject(ApplicationRef);
  }
  initialize() {
    if (this._onMicrotaskEmptySubscription) {
      return;
    }
    this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
      next: () => {
        if (this.changeDetectionScheduler.runningTick) {
          return;
        }
        this.zone.run(() => {
          this.applicationRef.tick();
        });
      }
    });
  }
  ngOnDestroy() {
    this._onMicrotaskEmptySubscription?.unsubscribe();
  }
};
_NgZoneChangeDetectionScheduler.\u0275fac = function NgZoneChangeDetectionScheduler_Factory(t3) {
  return new (t3 || _NgZoneChangeDetectionScheduler)();
};
_NgZoneChangeDetectionScheduler.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _NgZoneChangeDetectionScheduler, factory: _NgZoneChangeDetectionScheduler.\u0275fac, providedIn: "root" });
var NgZoneChangeDetectionScheduler = _NgZoneChangeDetectionScheduler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgZoneChangeDetectionScheduler, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();
var PROVIDED_NG_ZONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "provideZoneChangeDetection token" : "", { factory: () => false });
function internalProvideZoneChangeDetection({ ngZoneFactory, ignoreChangesOutsideZone }) {
  ngZoneFactory ??= () => new NgZone(getNgZoneOptions());
  return [
    { provide: NgZone, useFactory: ngZoneFactory },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const ngZoneChangeDetectionScheduler = inject(NgZoneChangeDetectionScheduler, {
          optional: true
        });
        if ((typeof ngDevMode === "undefined" || ngDevMode) && ngZoneChangeDetectionScheduler === null) {
          throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the \`BrowserModule\` is imported.`);
        }
        return () => ngZoneChangeDetectionScheduler.initialize();
      }
    },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const service = inject(ZoneStablePendingTask);
        return () => {
          service.initialize();
        };
      }
    },
    { provide: INTERNAL_APPLICATION_ERROR_HANDLER, useFactory: ngZoneApplicationErrorHandlerFactory },
    // Always disable scheduler whenever explicitly disabled, even if another place called
    // `provideZoneChangeDetection` without the 'ignore' option.
    ignoreChangesOutsideZone === true ? { provide: ZONELESS_SCHEDULER_DISABLED, useValue: true } : []
  ];
}
function ngZoneApplicationErrorHandlerFactory() {
  const zone = inject(NgZone);
  const userErrorHandler = inject(ErrorHandler);
  return (e3) => zone.runOutsideAngular(() => userErrorHandler.handleError(e3));
}
function getNgZoneOptions(options) {
  return {
    enableLongStackTrace: typeof ngDevMode === "undefined" ? false : !!ngDevMode,
    shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,
    shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false
  };
}
var _ZoneStablePendingTask = class _ZoneStablePendingTask {
  constructor() {
    this.subscription = new Subscription();
    this.initialized = false;
    this.zone = inject(NgZone);
    this.pendingTasks = inject(PendingTasks);
  }
  initialize() {
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    let task = null;
    if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
      task = this.pendingTasks.add();
    }
    this.zone.runOutsideAngular(() => {
      this.subscription.add(this.zone.onStable.subscribe(() => {
        NgZone.assertNotInAngularZone();
        queueMicrotask(() => {
          if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
            this.pendingTasks.remove(task);
            task = null;
          }
        });
      }));
    });
    this.subscription.add(this.zone.onUnstable.subscribe(() => {
      NgZone.assertInAngularZone();
      task ??= this.pendingTasks.add();
    }));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
_ZoneStablePendingTask.\u0275fac = function ZoneStablePendingTask_Factory(t3) {
  return new (t3 || _ZoneStablePendingTask)();
};
_ZoneStablePendingTask.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ZoneStablePendingTask, factory: _ZoneStablePendingTask.\u0275fac, providedIn: "root" });
var ZoneStablePendingTask = _ZoneStablePendingTask;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoneStablePendingTask, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();
var CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;
var consecutiveMicrotaskNotifications = 0;
var stackFromLastFewNotifications = [];
function trackMicrotaskNotificationForDebugging() {
  consecutiveMicrotaskNotifications++;
  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {
    const stack = new Error().stack;
    if (stack) {
      stackFromLastFewNotifications.push(stack);
    }
  }
  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {
    throw new RuntimeError(103, "Angular could not stabilize because there were endless change notifications within the browser event loop. The stack from the last several notifications: \n" + stackFromLastFewNotifications.join("\n"));
  }
}
var _ChangeDetectionSchedulerImpl = class _ChangeDetectionSchedulerImpl {
  constructor() {
    this.appRef = inject(ApplicationRef);
    this.taskService = inject(PendingTasks);
    this.ngZone = inject(NgZone);
    this.zonelessEnabled = inject(ZONELESS_ENABLED);
    this.disableScheduling = inject(ZONELESS_SCHEDULER_DISABLED, { optional: true }) ?? false;
    this.zoneIsDefined = typeof Zone !== "undefined" && !!Zone.root.run;
    this.schedulerTickApplyArgs = [{ data: { "__scheduler_tick__": true } }];
    this.subscriptions = new Subscription();
    this.cancelScheduledCallback = null;
    this.shouldRefreshViews = false;
    this.useMicrotaskScheduler = false;
    this.runningTick = false;
    this.pendingRenderTaskId = null;
    this.subscriptions.add(this.appRef.afterTick.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.disableScheduling ||= !this.zonelessEnabled && // NoopNgZone without enabling zoneless means no scheduling whatsoever
    (this.ngZone instanceof NoopNgZone || // The same goes for the lack of Zone without enabling zoneless scheduling
    !this.zoneIsDefined);
  }
  notify(source) {
    if (!this.zonelessEnabled && source === 5) {
      return;
    }
    switch (source) {
      case 3:
      case 2:
      case 0:
      case 4:
      case 5:
      case 1: {
        this.shouldRefreshViews = true;
        break;
      }
      case 8:
      case 7:
      case 6:
      case 9:
      default: {
      }
    }
    if (!this.shouldScheduleTick()) {
      return;
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (this.useMicrotaskScheduler) {
        trackMicrotaskNotificationForDebugging();
      } else {
        consecutiveMicrotaskNotifications = 0;
        stackFromLastFewNotifications.length = 0;
      }
    }
    const scheduleCallback = this.useMicrotaskScheduler ? scheduleCallbackWithMicrotask : scheduleCallbackWithRafRace;
    this.pendingRenderTaskId = this.taskService.add();
    if (this.zoneIsDefined) {
      Zone.root.run(() => {
        this.cancelScheduledCallback = scheduleCallback(() => {
          this.tick(this.shouldRefreshViews);
        });
      });
    } else {
      this.cancelScheduledCallback = scheduleCallback(() => {
        this.tick(this.shouldRefreshViews);
      });
    }
  }
  shouldScheduleTick() {
    if (this.disableScheduling) {
      return false;
    }
    if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {
      return false;
    }
    if (!this.zonelessEnabled && this.zoneIsDefined && NgZone.isInAngularZone()) {
      return false;
    }
    return true;
  }
  /**
   * Calls ApplicationRef._tick inside the `NgZone`.
   *
   * Calling `tick` directly runs change detection and cancels any change detection that had been
   * scheduled previously.
   *
   * @param shouldRefreshViews Passed directly to `ApplicationRef._tick` and skips straight to
   *     render hooks when `false`.
   */
  tick(shouldRefreshViews) {
    if (this.runningTick || this.appRef.destroyed) {
      return;
    }
    const task = this.taskService.add();
    try {
      this.ngZone.run(() => {
        this.runningTick = true;
        this.appRef._tick(shouldRefreshViews);
      }, void 0, this.schedulerTickApplyArgs);
    } catch (e3) {
      this.taskService.remove(task);
      throw e3;
    } finally {
      this.cleanup();
    }
    this.useMicrotaskScheduler = true;
    scheduleCallbackWithMicrotask(() => {
      this.useMicrotaskScheduler = false;
      this.taskService.remove(task);
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.cleanup();
  }
  cleanup() {
    this.shouldRefreshViews = false;
    this.runningTick = false;
    this.cancelScheduledCallback?.();
    this.cancelScheduledCallback = null;
    if (this.pendingRenderTaskId !== null) {
      const taskId = this.pendingRenderTaskId;
      this.pendingRenderTaskId = null;
      this.taskService.remove(taskId);
    }
  }
};
_ChangeDetectionSchedulerImpl.\u0275fac = function ChangeDetectionSchedulerImpl_Factory(t3) {
  return new (t3 || _ChangeDetectionSchedulerImpl)();
};
_ChangeDetectionSchedulerImpl.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ChangeDetectionSchedulerImpl, factory: _ChangeDetectionSchedulerImpl.\u0275fac, providedIn: "root" });
var ChangeDetectionSchedulerImpl = _ChangeDetectionSchedulerImpl;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], () => [], null);
})();
function getGlobalLocale() {
  if (false) {
    return goog.LOCALE;
  } else {
    return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
  }
}
var LOCALE_ID = new InjectionToken(ngDevMode ? "LocaleId" : "", {
  providedIn: "root",
  factory: () => inject(LOCALE_ID, InjectFlags.Optional | InjectFlags.SkipSelf) || getGlobalLocale()
});
var DEFAULT_CURRENCY_CODE = new InjectionToken(ngDevMode ? "DefaultCurrencyCode" : "", {
  providedIn: "root",
  factory: () => USD_CURRENCY_CODE
});
var TRANSLATIONS = new InjectionToken(ngDevMode ? "Translations" : "");
var TRANSLATIONS_FORMAT = new InjectionToken(ngDevMode ? "TranslationsFormat" : "");
var MissingTranslationStrategy;
(function(MissingTranslationStrategy2) {
  MissingTranslationStrategy2[MissingTranslationStrategy2["Error"] = 0] = "Error";
  MissingTranslationStrategy2[MissingTranslationStrategy2["Warning"] = 1] = "Warning";
  MissingTranslationStrategy2[MissingTranslationStrategy2["Ignore"] = 2] = "Ignore";
})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
var PLATFORM_DESTROY_LISTENERS = new InjectionToken(ngDevMode ? "PlatformDestroyListeners" : "");
var _PlatformRef = class _PlatformRef {
  /** @internal */
  constructor(_injector) {
    this._injector = _injector;
    this._modules = [];
    this._destroyListeners = [];
    this._destroyed = false;
  }
  /**
   * Creates an instance of an `@NgModule` for the given platform.
   *
   * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function
   *     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.
   */
  bootstrapModuleFactory(moduleFactory, options) {
    const ngZone = getNgZone(options?.ngZone, getNgZoneOptions({
      eventCoalescing: options?.ngZoneEventCoalescing,
      runCoalescing: options?.ngZoneRunCoalescing
    }));
    return ngZone.run(() => {
      const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;
      const moduleRef = createNgModuleRefWithProviders(moduleFactory.moduleType, this.injector, [
        ...internalProvideZoneChangeDetection({
          ngZoneFactory: () => ngZone,
          ignoreChangesOutsideZone
        }),
        { provide: ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl }
      ]);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        if (moduleRef.injector.get(PROVIDED_NG_ZONE)) {
          throw new RuntimeError(207, "`bootstrapModule` does not support `provideZoneChangeDetection`. Use `BootstrapOptions` instead.");
        }
        if (moduleRef.injector.get(ZONELESS_ENABLED) && options?.ngZone !== "noop") {
          throw new RuntimeError(408, "Invalid change detection configuration: `ngZone: 'noop'` must be set in `BootstrapOptions` with provideExperimentalZonelessChangeDetection.");
        }
      }
      const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
      if ((typeof ngDevMode === "undefined" || ngDevMode) && exceptionHandler === null) {
        throw new RuntimeError(402, "No ErrorHandler. Is platform module (BrowserModule) included?");
      }
      ngZone.runOutsideAngular(() => {
        const subscription = ngZone.onError.subscribe({
          next: (error) => {
            exceptionHandler.handleError(error);
          }
        });
        moduleRef.onDestroy(() => {
          remove(this._modules, moduleRef);
          subscription.unsubscribe();
        });
      });
      return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
        const initStatus = moduleRef.injector.get(ApplicationInitStatus);
        initStatus.runInitializers();
        return initStatus.donePromise.then(() => {
          const localeId = moduleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
          setLocaleId(localeId || DEFAULT_LOCALE_ID);
          this._moduleDoBootstrap(moduleRef);
          return moduleRef;
        });
      });
    });
  }
  /**
   * Creates an instance of an `@NgModule` for a given platform.
   *
   * @usageNotes
   * ### Simple Example
   *
   * ```typescript
   * @NgModule({
   *   imports: [BrowserModule]
   * })
   * class MyModule {}
   *
   * let moduleRef = platformBrowser().bootstrapModule(MyModule);
   * ```
   *
   */
  bootstrapModule(moduleType, compilerOptions = []) {
    const options = optionsReducer({}, compilerOptions);
    return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
  }
  _moduleDoBootstrap(moduleRef) {
    const appRef = moduleRef.injector.get(ApplicationRef);
    if (moduleRef._bootstrapComponents.length > 0) {
      moduleRef._bootstrapComponents.forEach((f3) => appRef.bootstrap(f3));
    } else if (moduleRef.instance.ngDoBootstrap) {
      moduleRef.instance.ngDoBootstrap(appRef);
    } else {
      throw new RuntimeError(-403, ngDevMode && `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
    }
    this._modules.push(moduleRef);
  }
  /**
   * Registers a listener to be called when the platform is destroyed.
   */
  onDestroy(callback) {
    this._destroyListeners.push(callback);
  }
  /**
   * Retrieves the platform {@link Injector}, which is the parent injector for
   * every Angular application on the page and provides singleton providers.
   */
  get injector() {
    return this._injector;
  }
  /**
   * Destroys the current Angular platform and all Angular applications on the page.
   * Destroys all modules and listeners registered with the platform.
   */
  destroy() {
    if (this._destroyed) {
      throw new RuntimeError(404, ngDevMode && "The platform has already been destroyed!");
    }
    this._modules.slice().forEach((module) => module.destroy());
    this._destroyListeners.forEach((listener) => listener());
    const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
    if (destroyListeners) {
      destroyListeners.forEach((listener) => listener());
      destroyListeners.clear();
    }
    this._destroyed = true;
  }
  /**
   * Indicates whether this instance was destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
};
_PlatformRef.\u0275fac = function PlatformRef_Factory(t3) {
  return new (t3 || _PlatformRef)(\u0275\u0275inject(Injector));
};
_PlatformRef.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PlatformRef, factory: _PlatformRef.\u0275fac, providedIn: "platform" });
var PlatformRef = _PlatformRef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformRef, [{
    type: Injectable,
    args: [{ providedIn: "platform" }]
  }], () => [{ type: Injector }], null);
})();
var _platformInjector = null;
var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken(ngDevMode ? "AllowMultipleToken" : "");
function createPlatform(injector) {
  if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
    throw new RuntimeError(400, ngDevMode && "There can be only one platform. Destroy the previous one to create a new one.");
  }
  publishDefaultGlobalUtils();
  publishSignalConfiguration();
  _platformInjector = injector;
  const platform = injector.get(PlatformRef);
  runPlatformInitializers(injector);
  return platform;
}
function createPlatformFactory(parentPlatformFactory, name, providers = []) {
  const desc = `Platform: ${name}`;
  const marker = new InjectionToken(desc);
  return (extraProviders = []) => {
    let platform = getPlatform();
    if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      const platformProviders = [
        ...providers,
        ...extraProviders,
        { provide: marker, useValue: true }
      ];
      if (parentPlatformFactory) {
        parentPlatformFactory(platformProviders);
      } else {
        createPlatform(createPlatformInjector(platformProviders, desc));
      }
    }
    return assertPlatform(marker);
  };
}
function createPlatformInjector(providers = [], name) {
  return Injector.create({
    name,
    providers: [
      { provide: INJECTOR_SCOPE, useValue: "platform" },
      { provide: PLATFORM_DESTROY_LISTENERS, useValue: /* @__PURE__ */ new Set([() => _platformInjector = null]) },
      ...providers
    ]
  });
}
function assertPlatform(requiredToken) {
  const platform = getPlatform();
  if (!platform) {
    throw new RuntimeError(401, ngDevMode && "No platform exists!");
  }
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !platform.injector.get(requiredToken, null)) {
    throw new RuntimeError(400, "A platform with a different configuration has been created. Please destroy it first.");
  }
  return platform;
}
function getPlatform() {
  return _platformInjector?.get(PlatformRef) ?? null;
}
function createOrReusePlatformInjector(providers = []) {
  if (_platformInjector)
    return _platformInjector;
  publishDefaultGlobalUtils();
  const injector = createPlatformInjector(providers);
  _platformInjector = injector;
  publishSignalConfiguration();
  runPlatformInitializers(injector);
  return injector;
}
function runPlatformInitializers(injector) {
  const inits = injector.get(PLATFORM_INITIALIZER, null);
  inits?.forEach((init) => init());
}
var _ChangeDetectorRef = class _ChangeDetectorRef {
};
_ChangeDetectorRef.__NG_ELEMENT_ID__ = injectChangeDetectorRef;
var ChangeDetectorRef = _ChangeDetectorRef;
function injectChangeDetectorRef(flags) {
  return createViewRef(
    getCurrentTNode(),
    getLView(),
    (flags & 16) === 16
    /* InternalInjectFlags.ForPipe */
  );
}
function createViewRef(tNode, lView, isPipe2) {
  if (isComponentHost(tNode) && !isPipe2) {
    const componentView = getComponentLViewByIndex(tNode.index, lView);
    return new ViewRef$1(componentView, componentView);
  } else if (tNode.type & (3 | 12 | 32)) {
    const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
    return new ViewRef$1(hostComponentView, lView);
  }
  return null;
}
var DefaultIterableDifferFactory = class {
  constructor() {
  }
  supports(obj) {
    return isListLikeIterable(obj);
  }
  create(trackByFn) {
    return new DefaultIterableDiffer(trackByFn);
  }
};
var trackByIdentity = (index3, item) => item;
var DefaultIterableDiffer = class {
  constructor(trackByFn) {
    this.length = 0;
    this._linkedRecords = null;
    this._unlinkedRecords = null;
    this._previousItHead = null;
    this._itHead = null;
    this._itTail = null;
    this._additionsHead = null;
    this._additionsTail = null;
    this._movesHead = null;
    this._movesTail = null;
    this._removalsHead = null;
    this._removalsTail = null;
    this._identityChangesHead = null;
    this._identityChangesTail = null;
    this._trackByFn = trackByFn || trackByIdentity;
  }
  forEachItem(fn) {
    let record;
    for (record = this._itHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachOperation(fn) {
    let nextIt = this._itHead;
    let nextRemove = this._removalsHead;
    let addRemoveOffset = 0;
    let moveOffsets = null;
    while (nextIt || nextRemove) {
      const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
      const currentIndex = record.currentIndex;
      if (record === nextRemove) {
        addRemoveOffset--;
        nextRemove = nextRemove._nextRemoved;
      } else {
        nextIt = nextIt._next;
        if (record.previousIndex == null) {
          addRemoveOffset++;
        } else {
          if (!moveOffsets)
            moveOffsets = [];
          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
          const localCurrentIndex = currentIndex - addRemoveOffset;
          if (localMovePreviousIndex != localCurrentIndex) {
            for (let i3 = 0; i3 < localMovePreviousIndex; i3++) {
              const offset = i3 < moveOffsets.length ? moveOffsets[i3] : moveOffsets[i3] = 0;
              const index3 = offset + i3;
              if (localCurrentIndex <= index3 && index3 < localMovePreviousIndex) {
                moveOffsets[i3] = offset + 1;
              }
            }
            const previousIndex = record.previousIndex;
            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
          }
        }
      }
      if (adjPreviousIndex !== currentIndex) {
        fn(record, adjPreviousIndex, currentIndex);
      }
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachMovedItem(fn) {
    let record;
    for (record = this._movesHead; record !== null; record = record._nextMoved) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  forEachIdentityChange(fn) {
    let record;
    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
      fn(record);
    }
  }
  diff(collection) {
    if (collection == null)
      collection = [];
    if (!isListLikeIterable(collection)) {
      throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
    }
    if (this.check(collection)) {
      return this;
    } else {
      return null;
    }
  }
  onDestroy() {
  }
  check(collection) {
    this._reset();
    let record = this._itHead;
    let mayBeDirty = false;
    let index3;
    let item;
    let itemTrackBy;
    if (Array.isArray(collection)) {
      this.length = collection.length;
      for (let index4 = 0; index4 < this.length; index4++) {
        item = collection[index4];
        itemTrackBy = this._trackByFn(index4, item);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item, itemTrackBy, index4);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item, itemTrackBy, index4);
          }
          if (!Object.is(record.item, item))
            this._addIdentityChange(record, item);
        }
        record = record._next;
      }
    } else {
      index3 = 0;
      iterateListLike(collection, (item2) => {
        itemTrackBy = this._trackByFn(index3, item2);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item2, itemTrackBy, index3);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item2, itemTrackBy, index3);
          }
          if (!Object.is(record.item, item2))
            this._addIdentityChange(record, item2);
        }
        record = record._next;
        index3++;
      });
      this.length = index3;
    }
    this._truncate(record);
    this.collection = collection;
    return this.isDirty;
  }
  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
   * changes.
   */
  get isDirty() {
    return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
  }
  /**
   * Reset the state of the change objects to show no changes. This means set previousKey to
   * currentKey, and clear all of the queues (additions, moves, removals).
   * Set the previousIndexes of moved and added items to their currentIndexes
   * Reset the list of additions, moves and removals
   *
   * @internal
   */
  _reset() {
    if (this.isDirty) {
      let record;
      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        record.previousIndex = record.currentIndex;
      }
      this._additionsHead = this._additionsTail = null;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        record.previousIndex = record.currentIndex;
      }
      this._movesHead = this._movesTail = null;
      this._removalsHead = this._removalsTail = null;
      this._identityChangesHead = this._identityChangesTail = null;
    }
  }
  /**
   * This is the core function which handles differences between collections.
   *
   * - `record` is the record which we saw at this position last time. If null then it is a new
   *   item.
   * - `item` is the current item in the collection
   * - `index` is the position of the item in the collection
   *
   * @internal
   */
  _mismatch(record, item, itemTrackBy, index3) {
    let previousRecord;
    if (record === null) {
      previousRecord = this._itTail;
    } else {
      previousRecord = record._prev;
      this._remove(record);
    }
    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (record !== null) {
      if (!Object.is(record.item, item))
        this._addIdentityChange(record, item);
      this._reinsertAfter(record, previousRecord, index3);
    } else {
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index3);
      if (record !== null) {
        if (!Object.is(record.item, item))
          this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index3);
      } else {
        record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index3);
      }
    }
    return record;
  }
  /**
   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
   *
   * Use case: `[a, a]` => `[b, a, a]`
   *
   * If we did not have this check then the insertion of `b` would:
   *   1) evict first `a`
   *   2) insert `b` at `0` index.
   *   3) leave `a` at index `1` as is. <-- this is wrong!
   *   3) reinsert `a` at index 2. <-- this is wrong!
   *
   * The correct behavior is:
   *   1) evict first `a`
   *   2) insert `b` at `0` index.
   *   3) reinsert `a` at index 1.
   *   3) move `a` at from `1` to `2`.
   *
   *
   * Double check that we have not evicted a duplicate item. We need to check if the item type may
   * have already been removed:
   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
   * at the end.
   *
   * @internal
   */
  _verifyReinsertion(record, item, itemTrackBy, index3) {
    let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (reinsertRecord !== null) {
      record = this._reinsertAfter(reinsertRecord, record._prev, index3);
    } else if (record.currentIndex != index3) {
      record.currentIndex = index3;
      this._addToMoves(record, index3);
    }
    return record;
  }
  /**
   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
   *
   * - `record` The first excess {@link IterableChangeRecord_}.
   *
   * @internal
   */
  _truncate(record) {
    while (record !== null) {
      const nextRecord = record._next;
      this._addToRemovals(this._unlink(record));
      record = nextRecord;
    }
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.clear();
    }
    if (this._additionsTail !== null) {
      this._additionsTail._nextAdded = null;
    }
    if (this._movesTail !== null) {
      this._movesTail._nextMoved = null;
    }
    if (this._itTail !== null) {
      this._itTail._next = null;
    }
    if (this._removalsTail !== null) {
      this._removalsTail._nextRemoved = null;
    }
    if (this._identityChangesTail !== null) {
      this._identityChangesTail._nextIdentityChange = null;
    }
  }
  /** @internal */
  _reinsertAfter(record, prevRecord, index3) {
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.remove(record);
    }
    const prev = record._prevRemoved;
    const next = record._nextRemoved;
    if (prev === null) {
      this._removalsHead = next;
    } else {
      prev._nextRemoved = next;
    }
    if (next === null) {
      this._removalsTail = prev;
    } else {
      next._prevRemoved = prev;
    }
    this._insertAfter(record, prevRecord, index3);
    this._addToMoves(record, index3);
    return record;
  }
  /** @internal */
  _moveAfter(record, prevRecord, index3) {
    this._unlink(record);
    this._insertAfter(record, prevRecord, index3);
    this._addToMoves(record, index3);
    return record;
  }
  /** @internal */
  _addAfter(record, prevRecord, index3) {
    this._insertAfter(record, prevRecord, index3);
    if (this._additionsTail === null) {
      this._additionsTail = this._additionsHead = record;
    } else {
      this._additionsTail = this._additionsTail._nextAdded = record;
    }
    return record;
  }
  /** @internal */
  _insertAfter(record, prevRecord, index3) {
    const next = prevRecord === null ? this._itHead : prevRecord._next;
    record._next = next;
    record._prev = prevRecord;
    if (next === null) {
      this._itTail = record;
    } else {
      next._prev = record;
    }
    if (prevRecord === null) {
      this._itHead = record;
    } else {
      prevRecord._next = record;
    }
    if (this._linkedRecords === null) {
      this._linkedRecords = new _DuplicateMap();
    }
    this._linkedRecords.put(record);
    record.currentIndex = index3;
    return record;
  }
  /** @internal */
  _remove(record) {
    return this._addToRemovals(this._unlink(record));
  }
  /** @internal */
  _unlink(record) {
    if (this._linkedRecords !== null) {
      this._linkedRecords.remove(record);
    }
    const prev = record._prev;
    const next = record._next;
    if (prev === null) {
      this._itHead = next;
    } else {
      prev._next = next;
    }
    if (next === null) {
      this._itTail = prev;
    } else {
      next._prev = prev;
    }
    return record;
  }
  /** @internal */
  _addToMoves(record, toIndex) {
    if (record.previousIndex === toIndex) {
      return record;
    }
    if (this._movesTail === null) {
      this._movesTail = this._movesHead = record;
    } else {
      this._movesTail = this._movesTail._nextMoved = record;
    }
    return record;
  }
  _addToRemovals(record) {
    if (this._unlinkedRecords === null) {
      this._unlinkedRecords = new _DuplicateMap();
    }
    this._unlinkedRecords.put(record);
    record.currentIndex = null;
    record._nextRemoved = null;
    if (this._removalsTail === null) {
      this._removalsTail = this._removalsHead = record;
      record._prevRemoved = null;
    } else {
      record._prevRemoved = this._removalsTail;
      this._removalsTail = this._removalsTail._nextRemoved = record;
    }
    return record;
  }
  /** @internal */
  _addIdentityChange(record, item) {
    record.item = item;
    if (this._identityChangesTail === null) {
      this._identityChangesTail = this._identityChangesHead = record;
    } else {
      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
    }
    return record;
  }
};
var IterableChangeRecord_ = class {
  constructor(item, trackById) {
    this.item = item;
    this.trackById = trackById;
    this.currentIndex = null;
    this.previousIndex = null;
    this._nextPrevious = null;
    this._prev = null;
    this._next = null;
    this._prevDup = null;
    this._nextDup = null;
    this._prevRemoved = null;
    this._nextRemoved = null;
    this._nextAdded = null;
    this._nextMoved = null;
    this._nextIdentityChange = null;
  }
};
var _DuplicateItemRecordList = class {
  constructor() {
    this._head = null;
    this._tail = null;
  }
  /**
   * Append the record to the list of duplicates.
   *
   * Note: by design all records in the list of duplicates hold the same value in record.item.
   */
  add(record) {
    if (this._head === null) {
      this._head = this._tail = record;
      record._nextDup = null;
      record._prevDup = null;
    } else {
      this._tail._nextDup = record;
      record._prevDup = this._tail;
      record._nextDup = null;
      this._tail = record;
    }
  }
  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
  // IterableChangeRecord_.currentIndex >= atOrAfterIndex
  get(trackById, atOrAfterIndex) {
    let record;
    for (record = this._head; record !== null; record = record._nextDup) {
      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
        return record;
      }
    }
    return null;
  }
  /**
   * Remove one {@link IterableChangeRecord_} from the list of duplicates.
   *
   * Returns whether the list of duplicates is empty.
   */
  remove(record) {
    const prev = record._prevDup;
    const next = record._nextDup;
    if (prev === null) {
      this._head = next;
    } else {
      prev._nextDup = next;
    }
    if (next === null) {
      this._tail = prev;
    } else {
      next._prevDup = prev;
    }
    return this._head === null;
  }
};
var _DuplicateMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  put(record) {
    const key = record.trackById;
    let duplicates = this.map.get(key);
    if (!duplicates) {
      duplicates = new _DuplicateItemRecordList();
      this.map.set(key, duplicates);
    }
    duplicates.add(record);
  }
  /**
   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
   *
   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
   * have any more `a`s needs to return the second `a`.
   */
  get(trackById, atOrAfterIndex) {
    const key = trackById;
    const recordList = this.map.get(key);
    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
  }
  /**
   * Removes a {@link IterableChangeRecord_} from the list of duplicates.
   *
   * The list of duplicates also is removed from the map if it gets empty.
   */
  remove(record) {
    const key = record.trackById;
    const recordList = this.map.get(key);
    if (recordList.remove(record)) {
      this.map.delete(key);
    }
    return record;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
  clear() {
    this.map.clear();
  }
};
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
  const previousIndex = item.previousIndex;
  if (previousIndex === null)
    return previousIndex;
  let moveOffset = 0;
  if (moveOffsets && previousIndex < moveOffsets.length) {
    moveOffset = moveOffsets[previousIndex];
  }
  return previousIndex + addRemoveOffset + moveOffset;
}
var DefaultKeyValueDifferFactory = class {
  constructor() {
  }
  supports(obj) {
    return obj instanceof Map || isJsObject(obj);
  }
  create() {
    return new DefaultKeyValueDiffer();
  }
};
var DefaultKeyValueDiffer = class {
  constructor() {
    this._records = /* @__PURE__ */ new Map();
    this._mapHead = null;
    this._appendAfter = null;
    this._previousMapHead = null;
    this._changesHead = null;
    this._changesTail = null;
    this._additionsHead = null;
    this._additionsTail = null;
    this._removalsHead = null;
    this._removalsTail = null;
  }
  get isDirty() {
    return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
  }
  forEachItem(fn) {
    let record;
    for (record = this._mapHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachChangedItem(fn) {
    let record;
    for (record = this._changesHead; record !== null; record = record._nextChanged) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  diff(map2) {
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
    } else if (!(map2 instanceof Map || isJsObject(map2))) {
      throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(map2)}'. Only maps and objects are allowed`);
    }
    return this.check(map2) ? this : null;
  }
  onDestroy() {
  }
  /**
   * Check the current state of the map vs the previous.
   * The algorithm is optimised for when the keys do no change.
   */
  check(map2) {
    this._reset();
    let insertBefore = this._mapHead;
    this._appendAfter = null;
    this._forEach(map2, (value, key) => {
      if (insertBefore && insertBefore.key === key) {
        this._maybeAddToChanges(insertBefore, value);
        this._appendAfter = insertBefore;
        insertBefore = insertBefore._next;
      } else {
        const record = this._getOrCreateRecordForKey(key, value);
        insertBefore = this._insertBeforeOrAppend(insertBefore, record);
      }
    });
    if (insertBefore) {
      if (insertBefore._prev) {
        insertBefore._prev._next = null;
      }
      this._removalsHead = insertBefore;
      for (let record = insertBefore; record !== null; record = record._nextRemoved) {
        if (record === this._mapHead) {
          this._mapHead = null;
        }
        this._records.delete(record.key);
        record._nextRemoved = record._next;
        record.previousValue = record.currentValue;
        record.currentValue = null;
        record._prev = null;
        record._next = null;
      }
    }
    if (this._changesTail)
      this._changesTail._nextChanged = null;
    if (this._additionsTail)
      this._additionsTail._nextAdded = null;
    return this.isDirty;
  }
  /**
   * Inserts a record before `before` or append at the end of the list when `before` is null.
   *
   * Notes:
   * - This method appends at `this._appendAfter`,
   * - This method updates `this._appendAfter`,
   * - The return value is the new value for the insertion pointer.
   */
  _insertBeforeOrAppend(before, record) {
    if (before) {
      const prev = before._prev;
      record._next = before;
      record._prev = prev;
      before._prev = record;
      if (prev) {
        prev._next = record;
      }
      if (before === this._mapHead) {
        this._mapHead = record;
      }
      this._appendAfter = before;
      return before;
    }
    if (this._appendAfter) {
      this._appendAfter._next = record;
      record._prev = this._appendAfter;
    } else {
      this._mapHead = record;
    }
    this._appendAfter = record;
    return null;
  }
  _getOrCreateRecordForKey(key, value) {
    if (this._records.has(key)) {
      const record2 = this._records.get(key);
      this._maybeAddToChanges(record2, value);
      const prev = record2._prev;
      const next = record2._next;
      if (prev) {
        prev._next = next;
      }
      if (next) {
        next._prev = prev;
      }
      record2._next = null;
      record2._prev = null;
      return record2;
    }
    const record = new KeyValueChangeRecord_(key);
    this._records.set(key, record);
    record.currentValue = value;
    this._addToAdditions(record);
    return record;
  }
  /** @internal */
  _reset() {
    if (this.isDirty) {
      let record;
      this._previousMapHead = this._mapHead;
      for (record = this._previousMapHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        record.previousValue = record.currentValue;
      }
      for (record = this._additionsHead; record != null; record = record._nextAdded) {
        record.previousValue = record.currentValue;
      }
      this._changesHead = this._changesTail = null;
      this._additionsHead = this._additionsTail = null;
      this._removalsHead = null;
    }
  }
  // Add the record or a given key to the list of changes only when the value has actually changed
  _maybeAddToChanges(record, newValue) {
    if (!Object.is(newValue, record.currentValue)) {
      record.previousValue = record.currentValue;
      record.currentValue = newValue;
      this._addToChanges(record);
    }
  }
  _addToAdditions(record) {
    if (this._additionsHead === null) {
      this._additionsHead = this._additionsTail = record;
    } else {
      this._additionsTail._nextAdded = record;
      this._additionsTail = record;
    }
  }
  _addToChanges(record) {
    if (this._changesHead === null) {
      this._changesHead = this._changesTail = record;
    } else {
      this._changesTail._nextChanged = record;
      this._changesTail = record;
    }
  }
  /** @internal */
  _forEach(obj, fn) {
    if (obj instanceof Map) {
      obj.forEach(fn);
    } else {
      Object.keys(obj).forEach((k3) => fn(obj[k3], k3));
    }
  }
};
var KeyValueChangeRecord_ = class {
  constructor(key) {
    this.key = key;
    this.previousValue = null;
    this.currentValue = null;
    this._nextPrevious = null;
    this._next = null;
    this._prev = null;
    this._nextAdded = null;
    this._nextRemoved = null;
    this._nextChanged = null;
  }
};
function defaultIterableDiffersFactory() {
  return new IterableDiffers([new DefaultIterableDifferFactory()]);
}
var _IterableDiffers = class _IterableDiffers {
  constructor(factories) {
    this.factories = factories;
  }
  static create(factories, parent2) {
    if (parent2 != null) {
      const copied = parent2.factories.slice();
      factories = factories.concat(copied);
    }
    return new _IterableDiffers(factories);
  }
  /**
   * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
   * inherited {@link IterableDiffers} instance with the provided factories and return a new
   * {@link IterableDiffers} instance.
   *
   * @usageNotes
   * ### Example
   *
   * The following example shows how to extend an existing list of factories,
   * which will only be applied to the injector for this component and its children.
   * This step is all that's required to make a new {@link IterableDiffer} available.
   *
   * ```
   * @Component({
   *   viewProviders: [
   *     IterableDiffers.extend([new ImmutableListDiffer()])
   *   ]
   * })
   * ```
   */
  static extend(factories) {
    return {
      provide: _IterableDiffers,
      useFactory: (parent2) => {
        return _IterableDiffers.create(factories, parent2 || defaultIterableDiffersFactory());
      },
      // Dependency technically isn't optional, but we can provide a better error message this way.
      deps: [[_IterableDiffers, new SkipSelf(), new Optional()]]
    };
  }
  find(iterable) {
    const factory = this.factories.find((f3) => f3.supports(iterable));
    if (factory != null) {
      return factory;
    } else {
      throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
    }
  }
};
_IterableDiffers.\u0275prov = \u0275\u0275defineInjectable({
  token: _IterableDiffers,
  providedIn: "root",
  factory: defaultIterableDiffersFactory
});
var IterableDiffers = _IterableDiffers;
function getTypeNameForDebugging(type) {
  return type["name"] || typeof type;
}
function defaultKeyValueDiffersFactory() {
  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
}
var _KeyValueDiffers = class _KeyValueDiffers {
  constructor(factories) {
    this.factories = factories;
  }
  static create(factories, parent2) {
    if (parent2) {
      const copied = parent2.factories.slice();
      factories = factories.concat(copied);
    }
    return new _KeyValueDiffers(factories);
  }
  /**
   * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
   * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
   * {@link KeyValueDiffers} instance.
   *
   * @usageNotes
   * ### Example
   *
   * The following example shows how to extend an existing list of factories,
   * which will only be applied to the injector for this component and its children.
   * This step is all that's required to make a new {@link KeyValueDiffer} available.
   *
   * ```
   * @Component({
   *   viewProviders: [
   *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
   *   ]
   * })
   * ```
   */
  static extend(factories) {
    return {
      provide: _KeyValueDiffers,
      useFactory: (parent2) => {
        return _KeyValueDiffers.create(factories, parent2 || defaultKeyValueDiffersFactory());
      },
      // Dependency technically isn't optional, but we can provide a better error message this way.
      deps: [[_KeyValueDiffers, new SkipSelf(), new Optional()]]
    };
  }
  find(kv) {
    const factory = this.factories.find((f3) => f3.supports(kv));
    if (factory) {
      return factory;
    }
    throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);
  }
};
_KeyValueDiffers.\u0275prov = \u0275\u0275defineInjectable({
  token: _KeyValueDiffers,
  providedIn: "root",
  factory: defaultKeyValueDiffersFactory
});
var KeyValueDiffers = _KeyValueDiffers;
var keyValDiff = [new DefaultKeyValueDifferFactory()];
var iterableDiff = [new DefaultIterableDifferFactory()];
var defaultIterableDiffers = new IterableDiffers(iterableDiff);
var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
var platformCore = createPlatformFactory(null, "core", []);
var _ApplicationModule = class _ApplicationModule {
  // Inject ApplicationRef to make it eager...
  constructor(appRef) {
  }
};
_ApplicationModule.\u0275fac = function ApplicationModule_Factory(t3) {
  return new (t3 || _ApplicationModule)(\u0275\u0275inject(ApplicationRef));
};
_ApplicationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _ApplicationModule });
_ApplicationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var ApplicationModule = _ApplicationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationModule, [{
    type: NgModule
  }], () => [{ type: ApplicationRef }], null);
})();
var SCAN_DELAY = 200;
var OVERSIZED_IMAGE_TOLERANCE = 1200;
var _ImagePerformanceWarning = class _ImagePerformanceWarning {
  constructor() {
    this.window = null;
    this.observer = null;
    this.options = inject(IMAGE_CONFIG);
    this.ngZone = inject(NgZone);
  }
  start() {
    if (typeof PerformanceObserver === "undefined" || this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning) {
      return;
    }
    this.observer = this.initPerformanceObserver();
    const doc = getDocument();
    const win = doc.defaultView;
    if (typeof win !== "undefined") {
      this.window = win;
      const waitToScan = () => {
        setTimeout(this.scanImages.bind(this), SCAN_DELAY);
      };
      this.ngZone.runOutsideAngular(() => {
        if (doc.readyState === "complete") {
          waitToScan();
        } else {
          this.window?.addEventListener("load", waitToScan, { once: true });
        }
      });
    }
  }
  ngOnDestroy() {
    this.observer?.disconnect();
  }
  initPerformanceObserver() {
    if (typeof PerformanceObserver === "undefined") {
      return null;
    }
    const observer = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      if (entries.length === 0)
        return;
      const lcpElement = entries[entries.length - 1];
      const imgSrc = lcpElement.element?.src ?? "";
      if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:"))
        return;
      this.lcpImageUrl = imgSrc;
    });
    observer.observe({ type: "largest-contentful-paint", buffered: true });
    return observer;
  }
  scanImages() {
    const images = getDocument().querySelectorAll("img");
    let lcpElementFound, lcpElementLoadedCorrectly = false;
    images.forEach((image) => {
      if (!this.options?.disableImageSizeWarning) {
        for (const image2 of images) {
          if (!image2.getAttribute("ng-img") && this.isOversized(image2)) {
            logOversizedImageWarning(image2.src);
          }
        }
      }
      if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {
        if (image.src === this.lcpImageUrl) {
          lcpElementFound = true;
          if (image.loading !== "lazy" || image.getAttribute("ng-img")) {
            lcpElementLoadedCorrectly = true;
          }
        }
      }
    });
    if (lcpElementFound && !lcpElementLoadedCorrectly && this.lcpImageUrl && !this.options?.disableImageLazyLoadWarning) {
      logLazyLCPWarning(this.lcpImageUrl);
    }
  }
  isOversized(image) {
    if (!this.window) {
      return false;
    }
    const computedStyle = this.window.getComputedStyle(image);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
    const boxSizing = computedStyle.getPropertyValue("box-sizing");
    const objectFit = computedStyle.getPropertyValue("object-fit");
    if (objectFit === `cover`) {
      return false;
    }
    if (boxSizing === "border-box") {
      const paddingTop = computedStyle.getPropertyValue("padding-top");
      const paddingRight = computedStyle.getPropertyValue("padding-right");
      const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
      const paddingLeft = computedStyle.getPropertyValue("padding-left");
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const intrinsicWidth = image.naturalWidth;
    const intrinsicHeight = image.naturalHeight;
    const recommendedWidth = this.window.devicePixelRatio * renderedWidth;
    const recommendedHeight = this.window.devicePixelRatio * renderedHeight;
    const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
    const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
    return oversizedWidth || oversizedHeight;
  }
};
_ImagePerformanceWarning.\u0275fac = function ImagePerformanceWarning_Factory(t3) {
  return new (t3 || _ImagePerformanceWarning)();
};
_ImagePerformanceWarning.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ImagePerformanceWarning, factory: _ImagePerformanceWarning.\u0275fac, providedIn: "root" });
var ImagePerformanceWarning = _ImagePerformanceWarning;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImagePerformanceWarning, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();
function logLazyLCPWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} is the Largest Contentful Paint (LCP) element but was given a "loading" value of "lazy", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to "eager", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
function logOversizedImageWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
function internalCreateApplication(config3) {
  try {
    const { rootComponent, appProviders, platformProviders } = config3;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && rootComponent !== void 0) {
      assertStandaloneComponentType(rootComponent);
    }
    const platformInjector = createOrReusePlatformInjector(platformProviders);
    const allAppProviders = [
      internalProvideZoneChangeDetection({}),
      { provide: ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl },
      ...appProviders || []
    ];
    const adapter = new EnvironmentNgModuleRefAdapter({
      providers: allAppProviders,
      parent: platformInjector,
      debugName: typeof ngDevMode === "undefined" || ngDevMode ? "Environment Injector" : "",
      // We skip environment initializers because we need to run them inside the NgZone, which
      // happens after we get the NgZone instance from the Injector.
      runEnvironmentInitializers: false
    });
    const envInjector = adapter.injector;
    const ngZone = envInjector.get(NgZone);
    return ngZone.run(() => {
      envInjector.resolveInjectorInitializers();
      const exceptionHandler = envInjector.get(ErrorHandler, null);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        if (!exceptionHandler) {
          throw new RuntimeError(402, "No `ErrorHandler` found in the Dependency Injection tree.");
        }
        if (envInjector.get(PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {
          throw new RuntimeError(408, "Invalid change detection configuration: provideZoneChangeDetection and provideExperimentalZonelessChangeDetection cannot be used together.");
        }
      }
      let onErrorSubscription;
      ngZone.runOutsideAngular(() => {
        onErrorSubscription = ngZone.onError.subscribe({
          next: (error) => {
            exceptionHandler.handleError(error);
          }
        });
      });
      const destroyListener = () => envInjector.destroy();
      const onPlatformDestroyListeners = platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      envInjector.onDestroy(() => {
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
      return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
        const initStatus = envInjector.get(ApplicationInitStatus);
        initStatus.runInitializers();
        return initStatus.donePromise.then(() => {
          const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
          setLocaleId(localeId || DEFAULT_LOCALE_ID);
          const appRef = envInjector.get(ApplicationRef);
          if (rootComponent !== void 0) {
            appRef.bootstrap(rootComponent);
          }
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            const imagePerformanceService = envInjector.get(ImagePerformanceWarning);
            imagePerformanceService.start();
          }
          return appRef;
        });
      });
    });
  } catch (e3) {
    return Promise.reject(e3);
  }
}
function booleanAttribute(value) {
  return typeof value === "boolean" ? value : value != null && value !== "false";
}
function numberAttribute(value, fallbackValue = NaN) {
  const isNumberValue = !isNaN(parseFloat(value)) && !isNaN(Number(value));
  return isNumberValue ? Number(value) : fallbackValue;
}
function untracked(nonReactiveReadsFn) {
  const prevConsumer = setActiveConsumer(null);
  try {
    return nonReactiveReadsFn();
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
var APP_EFFECT_SCHEDULER = new InjectionToken("", {
  providedIn: "root",
  factory: () => inject(EffectScheduler)
});
var _EffectScheduler = class _EffectScheduler {
};
_EffectScheduler.\u0275prov = \u0275\u0275defineInjectable({
  token: _EffectScheduler,
  providedIn: "root",
  factory: () => new ZoneAwareEffectScheduler()
});
var EffectScheduler = _EffectScheduler;
var ZoneAwareEffectScheduler = class {
  constructor() {
    this.queuedEffectCount = 0;
    this.queues = /* @__PURE__ */ new Map();
    this.pendingTasks = inject(PendingTasks);
    this.taskId = null;
  }
  scheduleEffect(handle) {
    this.enqueue(handle);
    if (this.taskId === null) {
      const taskId = this.taskId = this.pendingTasks.add();
      queueMicrotask(() => {
        this.flush();
        this.pendingTasks.remove(taskId);
        this.taskId = null;
      });
    }
  }
  enqueue(handle) {
    const zone = handle.creationZone;
    if (!this.queues.has(zone)) {
      this.queues.set(zone, /* @__PURE__ */ new Set());
    }
    const queue = this.queues.get(zone);
    if (queue.has(handle)) {
      return;
    }
    this.queuedEffectCount++;
    queue.add(handle);
  }
  /**
   * Run all scheduled effects.
   *
   * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no
   * ordering guarantee between effects scheduled in different zones.
   */
  flush() {
    while (this.queuedEffectCount > 0) {
      for (const [zone, queue] of this.queues) {
        if (zone === null) {
          this.flushQueue(queue);
        } else {
          zone.run(() => this.flushQueue(queue));
        }
      }
    }
  }
  flushQueue(queue) {
    for (const handle of queue) {
      queue.delete(handle);
      this.queuedEffectCount--;
      handle.run();
    }
  }
};
function reflectComponentType(component) {
  const componentDef = getComponentDef(component);
  if (!componentDef)
    return null;
  const factory = new ComponentFactory(componentDef);
  return {
    get selector() {
      return factory.selector;
    },
    get type() {
      return factory.componentType;
    },
    get inputs() {
      return factory.inputs;
    },
    get outputs() {
      return factory.outputs;
    },
    get ngContentSelectors() {
      return factory.ngContentSelectors;
    },
    get isStandalone() {
      return componentDef.standalone;
    },
    get isSignal() {
      return componentDef.signals;
    }
  };
}
if (typeof ngDevMode !== "undefined" && ngDevMode) {
  _global.$localize ??= function() {
    throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)");
  };
}

// node_modules/@angular/common/fesm2022/common.mjs
var _DOM = null;
function getDOM() {
  return _DOM;
}
function setRootDomAdapter(adapter) {
  _DOM ??= adapter;
}
var DomAdapter = class {
};
var _PlatformNavigation = class _PlatformNavigation {
};
_PlatformNavigation.\u0275fac = function PlatformNavigation_Factory(t3) {
  return new (t3 || _PlatformNavigation)();
};
_PlatformNavigation.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PlatformNavigation,
  factory: () => (() => window.navigation)(),
  providedIn: "platform"
});
var PlatformNavigation = _PlatformNavigation;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformNavigation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => window.navigation
    }]
  }], null, null);
})();
var DOCUMENT2 = new InjectionToken(ngDevMode ? "DocumentToken" : "");
var _PlatformLocation = class _PlatformLocation {
  historyGo(relativePosition) {
    throw new Error(ngDevMode ? "Not implemented" : "");
  }
};
_PlatformLocation.\u0275fac = function PlatformLocation_Factory(t3) {
  return new (t3 || _PlatformLocation)();
};
_PlatformLocation.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PlatformLocation,
  factory: () => (() => inject(BrowserPlatformLocation))(),
  providedIn: "platform"
});
var PlatformLocation = _PlatformLocation;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformLocation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => inject(BrowserPlatformLocation)
    }]
  }], null, null);
})();
var LOCATION_INITIALIZED = new InjectionToken(ngDevMode ? "Location Initialized" : "");
var _BrowserPlatformLocation = class _BrowserPlatformLocation extends PlatformLocation {
  constructor() {
    super();
    this._doc = inject(DOCUMENT2);
    this._location = window.location;
    this._history = window.history;
  }
  getBaseHrefFromDOM() {
    return getDOM().getBaseHref(this._doc);
  }
  onPopState(fn) {
    const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
    window2.addEventListener("popstate", fn, false);
    return () => window2.removeEventListener("popstate", fn);
  }
  onHashChange(fn) {
    const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
    window2.addEventListener("hashchange", fn, false);
    return () => window2.removeEventListener("hashchange", fn);
  }
  get href() {
    return this._location.href;
  }
  get protocol() {
    return this._location.protocol;
  }
  get hostname() {
    return this._location.hostname;
  }
  get port() {
    return this._location.port;
  }
  get pathname() {
    return this._location.pathname;
  }
  get search() {
    return this._location.search;
  }
  get hash() {
    return this._location.hash;
  }
  set pathname(newPath) {
    this._location.pathname = newPath;
  }
  pushState(state, title, url) {
    this._history.pushState(state, title, url);
  }
  replaceState(state, title, url) {
    this._history.replaceState(state, title, url);
  }
  forward() {
    this._history.forward();
  }
  back() {
    this._history.back();
  }
  historyGo(relativePosition = 0) {
    this._history.go(relativePosition);
  }
  getState() {
    return this._history.state;
  }
};
_BrowserPlatformLocation.\u0275fac = function BrowserPlatformLocation_Factory(t3) {
  return new (t3 || _BrowserPlatformLocation)();
};
_BrowserPlatformLocation.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _BrowserPlatformLocation,
  factory: () => (() => new _BrowserPlatformLocation())(),
  providedIn: "platform"
});
var BrowserPlatformLocation = _BrowserPlatformLocation;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserPlatformLocation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => new BrowserPlatformLocation()
    }]
  }], () => [], null);
})();
function joinWithSlash(start, end) {
  if (start.length == 0) {
    return end;
  }
  if (end.length == 0) {
    return start;
  }
  let slashes = 0;
  if (start.endsWith("/")) {
    slashes++;
  }
  if (end.startsWith("/")) {
    slashes++;
  }
  if (slashes == 2) {
    return start + end.substring(1);
  }
  if (slashes == 1) {
    return start + end;
  }
  return start + "/" + end;
}
function stripTrailingSlash(url) {
  const match2 = url.match(/#|\?|$/);
  const pathEndIdx = match2 && match2.index || url.length;
  const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === "/" ? 1 : 0);
  return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
}
function normalizeQueryParams(params) {
  return params && params[0] !== "?" ? "?" + params : params;
}
var _LocationStrategy = class _LocationStrategy {
  historyGo(relativePosition) {
    throw new Error(ngDevMode ? "Not implemented" : "");
  }
};
_LocationStrategy.\u0275fac = function LocationStrategy_Factory(t3) {
  return new (t3 || _LocationStrategy)();
};
_LocationStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _LocationStrategy,
  factory: () => (() => inject(PathLocationStrategy))(),
  providedIn: "root"
});
var LocationStrategy = _LocationStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocationStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(PathLocationStrategy)
    }]
  }], null, null);
})();
var APP_BASE_HREF = new InjectionToken(ngDevMode ? "appBaseHref" : "");
var _PathLocationStrategy = class _PathLocationStrategy extends LocationStrategy {
  constructor(_platformLocation, href) {
    super();
    this._platformLocation = _platformLocation;
    this._removeListenerFns = [];
    this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? inject(DOCUMENT2).location?.origin ?? "";
  }
  /** @nodoc */
  ngOnDestroy() {
    while (this._removeListenerFns.length) {
      this._removeListenerFns.pop()();
    }
  }
  onPopState(fn) {
    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
  }
  getBaseHref() {
    return this._baseHref;
  }
  prepareExternalUrl(internal) {
    return joinWithSlash(this._baseHref, internal);
  }
  path(includeHash = false) {
    const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
    const hash = this._platformLocation.hash;
    return hash && includeHash ? `${pathname}${hash}` : pathname;
  }
  pushState(state, title, url, queryParams) {
    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
    this._platformLocation.pushState(state, title, externalUrl);
  }
  replaceState(state, title, url, queryParams) {
    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
    this._platformLocation.replaceState(state, title, externalUrl);
  }
  forward() {
    this._platformLocation.forward();
  }
  back() {
    this._platformLocation.back();
  }
  getState() {
    return this._platformLocation.getState();
  }
  historyGo(relativePosition = 0) {
    this._platformLocation.historyGo?.(relativePosition);
  }
};
_PathLocationStrategy.\u0275fac = function PathLocationStrategy_Factory(t3) {
  return new (t3 || _PathLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
};
_PathLocationStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PathLocationStrategy,
  factory: _PathLocationStrategy.\u0275fac,
  providedIn: "root"
});
var PathLocationStrategy = _PathLocationStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PathLocationStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PlatformLocation
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [APP_BASE_HREF]
    }]
  }], null);
})();
var _HashLocationStrategy = class _HashLocationStrategy extends LocationStrategy {
  constructor(_platformLocation, _baseHref) {
    super();
    this._platformLocation = _platformLocation;
    this._baseHref = "";
    this._removeListenerFns = [];
    if (_baseHref != null) {
      this._baseHref = _baseHref;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    while (this._removeListenerFns.length) {
      this._removeListenerFns.pop()();
    }
  }
  onPopState(fn) {
    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
  }
  getBaseHref() {
    return this._baseHref;
  }
  path(includeHash = false) {
    const path = this._platformLocation.hash ?? "#";
    return path.length > 0 ? path.substring(1) : path;
  }
  prepareExternalUrl(internal) {
    const url = joinWithSlash(this._baseHref, internal);
    return url.length > 0 ? "#" + url : url;
  }
  pushState(state, title, path, queryParams) {
    let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
    if (url.length == 0) {
      url = this._platformLocation.pathname;
    }
    this._platformLocation.pushState(state, title, url);
  }
  replaceState(state, title, path, queryParams) {
    let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
    if (url.length == 0) {
      url = this._platformLocation.pathname;
    }
    this._platformLocation.replaceState(state, title, url);
  }
  forward() {
    this._platformLocation.forward();
  }
  back() {
    this._platformLocation.back();
  }
  getState() {
    return this._platformLocation.getState();
  }
  historyGo(relativePosition = 0) {
    this._platformLocation.historyGo?.(relativePosition);
  }
};
_HashLocationStrategy.\u0275fac = function HashLocationStrategy_Factory(t3) {
  return new (t3 || _HashLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
};
_HashLocationStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HashLocationStrategy,
  factory: _HashLocationStrategy.\u0275fac
});
var HashLocationStrategy = _HashLocationStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HashLocationStrategy, [{
    type: Injectable
  }], () => [{
    type: PlatformLocation
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [APP_BASE_HREF]
    }]
  }], null);
})();
var _Location = class _Location {
  constructor(locationStrategy) {
    this._subject = new EventEmitter();
    this._urlChangeListeners = [];
    this._urlChangeSubscription = null;
    this._locationStrategy = locationStrategy;
    const baseHref = this._locationStrategy.getBaseHref();
    this._basePath = _stripOrigin(stripTrailingSlash(_stripIndexHtml(baseHref)));
    this._locationStrategy.onPopState((ev) => {
      this._subject.emit({
        "url": this.path(true),
        "pop": true,
        "state": ev.state,
        "type": ev.type
      });
    });
  }
  /** @nodoc */
  ngOnDestroy() {
    this._urlChangeSubscription?.unsubscribe();
    this._urlChangeListeners = [];
  }
  /**
   * Normalizes the URL path for this location.
   *
   * @param includeHash True to include an anchor fragment in the path.
   *
   * @returns The normalized URL path.
   */
  // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
  // removed.
  path(includeHash = false) {
    return this.normalize(this._locationStrategy.path(includeHash));
  }
  /**
   * Reports the current state of the location history.
   * @returns The current value of the `history.state` object.
   */
  getState() {
    return this._locationStrategy.getState();
  }
  /**
   * Normalizes the given path and compares to the current normalized path.
   *
   * @param path The given URL path.
   * @param query Query parameters.
   *
   * @returns True if the given URL path is equal to the current normalized path, false
   * otherwise.
   */
  isCurrentPathEqualTo(path, query = "") {
    return this.path() == this.normalize(path + normalizeQueryParams(query));
  }
  /**
   * Normalizes a URL path by stripping any trailing slashes.
   *
   * @param url String representing a URL.
   *
   * @returns The normalized URL string.
   */
  normalize(url) {
    return _Location.stripTrailingSlash(_stripBasePath(this._basePath, _stripIndexHtml(url)));
  }
  /**
   * Normalizes an external URL path.
   * If the given URL doesn't begin with a leading slash (`'/'`), adds one
   * before normalizing. Adds a hash if `HashLocationStrategy` is
   * in use, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
   *
   * @param url String representing a URL.
   *
   * @returns  A normalized platform-specific URL.
   */
  prepareExternalUrl(url) {
    if (url && url[0] !== "/") {
      url = "/" + url;
    }
    return this._locationStrategy.prepareExternalUrl(url);
  }
  // TODO: rename this method to pushState
  /**
   * Changes the browser's URL to a normalized version of a given URL, and pushes a
   * new item onto the platform's history.
   *
   * @param path  URL path to normalize.
   * @param query Query parameters.
   * @param state Location history state.
   *
   */
  go(path, query = "", state = null) {
    this._locationStrategy.pushState(state, "", path, query);
    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
  }
  /**
   * Changes the browser's URL to a normalized version of the given URL, and replaces
   * the top item on the platform's history stack.
   *
   * @param path  URL path to normalize.
   * @param query Query parameters.
   * @param state Location history state.
   */
  replaceState(path, query = "", state = null) {
    this._locationStrategy.replaceState(state, "", path, query);
    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
  }
  /**
   * Navigates forward in the platform's history.
   */
  forward() {
    this._locationStrategy.forward();
  }
  /**
   * Navigates back in the platform's history.
   */
  back() {
    this._locationStrategy.back();
  }
  /**
   * Navigate to a specific page from session history, identified by its relative position to the
   * current page.
   *
   * @param relativePosition  Position of the target page in the history relative to the current
   *     page.
   * A negative value moves backwards, a positive value moves forwards, e.g. `location.historyGo(2)`
   * moves forward two pages and `location.historyGo(-2)` moves back two pages. When we try to go
   * beyond what's stored in the history session, we stay in the current page. Same behaviour occurs
   * when `relativePosition` equals 0.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/History_API#Moving_to_a_specific_point_in_history
   */
  historyGo(relativePosition = 0) {
    this._locationStrategy.historyGo?.(relativePosition);
  }
  /**
   * Registers a URL change listener. Use to catch updates performed by the Angular
   * framework that are not detectible through "popstate" or "hashchange" events.
   *
   * @param fn The change handler function, which take a URL and a location history state.
   * @returns A function that, when executed, unregisters a URL change listener.
   */
  onUrlChange(fn) {
    this._urlChangeListeners.push(fn);
    this._urlChangeSubscription ??= this.subscribe((v3) => {
      this._notifyUrlChangeListeners(v3.url, v3.state);
    });
    return () => {
      const fnIndex = this._urlChangeListeners.indexOf(fn);
      this._urlChangeListeners.splice(fnIndex, 1);
      if (this._urlChangeListeners.length === 0) {
        this._urlChangeSubscription?.unsubscribe();
        this._urlChangeSubscription = null;
      }
    };
  }
  /** @internal */
  _notifyUrlChangeListeners(url = "", state) {
    this._urlChangeListeners.forEach((fn) => fn(url, state));
  }
  /**
   * Subscribes to the platform's `popState` events.
   *
   * Note: `Location.go()` does not trigger the `popState` event in the browser. Use
   * `Location.onUrlChange()` to subscribe to URL changes instead.
   *
   * @param value Event that is triggered when the state history changes.
   * @param exception The exception to throw.
   *
   * @see [onpopstate](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate)
   *
   * @returns Subscribed events.
   */
  subscribe(onNext, onThrow, onReturn) {
    return this._subject.subscribe({
      next: onNext,
      error: onThrow,
      complete: onReturn
    });
  }
};
_Location.normalizeQueryParams = normalizeQueryParams;
_Location.joinWithSlash = joinWithSlash;
_Location.stripTrailingSlash = stripTrailingSlash;
_Location.\u0275fac = function Location_Factory(t3) {
  return new (t3 || _Location)(\u0275\u0275inject(LocationStrategy));
};
_Location.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _Location,
  factory: () => createLocation(),
  providedIn: "root"
});
var Location = _Location;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Location, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      // See #23917
      useFactory: createLocation
    }]
  }], () => [{
    type: LocationStrategy
  }], null);
})();
function createLocation() {
  return new Location(\u0275\u0275inject(LocationStrategy));
}
function _stripBasePath(basePath, url) {
  if (!basePath || !url.startsWith(basePath)) {
    return url;
  }
  const strippedUrl = url.substring(basePath.length);
  if (strippedUrl === "" || ["/", ";", "?", "#"].includes(strippedUrl[0])) {
    return strippedUrl;
  }
  return url;
}
function _stripIndexHtml(url) {
  return url.replace(/\/index.html$/, "");
}
function _stripOrigin(baseHref) {
  const isAbsoluteUrl2 = new RegExp("^(https?:)?//").test(baseHref);
  if (isAbsoluteUrl2) {
    const [, pathname] = baseHref.split(/\/\/[^\/]+/);
    return pathname;
  }
  return baseHref;
}
var CURRENCIES_EN = {
  "ADP": [void 0, void 0, 0],
  "AFN": [void 0, "\u060B", 0],
  "ALL": [void 0, void 0, 0],
  "AMD": [void 0, "\u058F", 2],
  "AOA": [void 0, "Kz"],
  "ARS": [void 0, "$"],
  "AUD": ["A$", "$"],
  "AZN": [void 0, "\u20BC"],
  "BAM": [void 0, "KM"],
  "BBD": [void 0, "$"],
  "BDT": [void 0, "\u09F3"],
  "BHD": [void 0, void 0, 3],
  "BIF": [void 0, void 0, 0],
  "BMD": [void 0, "$"],
  "BND": [void 0, "$"],
  "BOB": [void 0, "Bs"],
  "BRL": ["R$"],
  "BSD": [void 0, "$"],
  "BWP": [void 0, "P"],
  "BYN": [void 0, void 0, 2],
  "BYR": [void 0, void 0, 0],
  "BZD": [void 0, "$"],
  "CAD": ["CA$", "$", 2],
  "CHF": [void 0, void 0, 2],
  "CLF": [void 0, void 0, 4],
  "CLP": [void 0, "$", 0],
  "CNY": ["CN\xA5", "\xA5"],
  "COP": [void 0, "$", 2],
  "CRC": [void 0, "\u20A1", 2],
  "CUC": [void 0, "$"],
  "CUP": [void 0, "$"],
  "CZK": [void 0, "K\u010D", 2],
  "DJF": [void 0, void 0, 0],
  "DKK": [void 0, "kr", 2],
  "DOP": [void 0, "$"],
  "EGP": [void 0, "E\xA3"],
  "ESP": [void 0, "\u20A7", 0],
  "EUR": ["\u20AC"],
  "FJD": [void 0, "$"],
  "FKP": [void 0, "\xA3"],
  "GBP": ["\xA3"],
  "GEL": [void 0, "\u20BE"],
  "GHS": [void 0, "GH\u20B5"],
  "GIP": [void 0, "\xA3"],
  "GNF": [void 0, "FG", 0],
  "GTQ": [void 0, "Q"],
  "GYD": [void 0, "$", 2],
  "HKD": ["HK$", "$"],
  "HNL": [void 0, "L"],
  "HRK": [void 0, "kn"],
  "HUF": [void 0, "Ft", 2],
  "IDR": [void 0, "Rp", 2],
  "ILS": ["\u20AA"],
  "INR": ["\u20B9"],
  "IQD": [void 0, void 0, 0],
  "IRR": [void 0, void 0, 0],
  "ISK": [void 0, "kr", 0],
  "ITL": [void 0, void 0, 0],
  "JMD": [void 0, "$"],
  "JOD": [void 0, void 0, 3],
  "JPY": ["\xA5", void 0, 0],
  "KHR": [void 0, "\u17DB"],
  "KMF": [void 0, "CF", 0],
  "KPW": [void 0, "\u20A9", 0],
  "KRW": ["\u20A9", void 0, 0],
  "KWD": [void 0, void 0, 3],
  "KYD": [void 0, "$"],
  "KZT": [void 0, "\u20B8"],
  "LAK": [void 0, "\u20AD", 0],
  "LBP": [void 0, "L\xA3", 0],
  "LKR": [void 0, "Rs"],
  "LRD": [void 0, "$"],
  "LTL": [void 0, "Lt"],
  "LUF": [void 0, void 0, 0],
  "LVL": [void 0, "Ls"],
  "LYD": [void 0, void 0, 3],
  "MGA": [void 0, "Ar", 0],
  "MGF": [void 0, void 0, 0],
  "MMK": [void 0, "K", 0],
  "MNT": [void 0, "\u20AE", 2],
  "MRO": [void 0, void 0, 0],
  "MUR": [void 0, "Rs", 2],
  "MXN": ["MX$", "$"],
  "MYR": [void 0, "RM"],
  "NAD": [void 0, "$"],
  "NGN": [void 0, "\u20A6"],
  "NIO": [void 0, "C$"],
  "NOK": [void 0, "kr", 2],
  "NPR": [void 0, "Rs"],
  "NZD": ["NZ$", "$"],
  "OMR": [void 0, void 0, 3],
  "PHP": ["\u20B1"],
  "PKR": [void 0, "Rs", 2],
  "PLN": [void 0, "z\u0142"],
  "PYG": [void 0, "\u20B2", 0],
  "RON": [void 0, "lei"],
  "RSD": [void 0, void 0, 0],
  "RUB": [void 0, "\u20BD"],
  "RWF": [void 0, "RF", 0],
  "SBD": [void 0, "$"],
  "SEK": [void 0, "kr", 2],
  "SGD": [void 0, "$"],
  "SHP": [void 0, "\xA3"],
  "SLE": [void 0, void 0, 2],
  "SLL": [void 0, void 0, 0],
  "SOS": [void 0, void 0, 0],
  "SRD": [void 0, "$"],
  "SSP": [void 0, "\xA3"],
  "STD": [void 0, void 0, 0],
  "STN": [void 0, "Db"],
  "SYP": [void 0, "\xA3", 0],
  "THB": [void 0, "\u0E3F"],
  "TMM": [void 0, void 0, 0],
  "TND": [void 0, void 0, 3],
  "TOP": [void 0, "T$"],
  "TRL": [void 0, void 0, 0],
  "TRY": [void 0, "\u20BA"],
  "TTD": [void 0, "$"],
  "TWD": ["NT$", "$", 2],
  "TZS": [void 0, void 0, 2],
  "UAH": [void 0, "\u20B4"],
  "UGX": [void 0, void 0, 0],
  "USD": ["$"],
  "UYI": [void 0, void 0, 0],
  "UYU": [void 0, "$"],
  "UYW": [void 0, void 0, 4],
  "UZS": [void 0, void 0, 2],
  "VEF": [void 0, "Bs", 2],
  "VND": ["\u20AB", void 0, 0],
  "VUV": [void 0, void 0, 0],
  "XAF": ["FCFA", void 0, 0],
  "XCD": ["EC$", "$"],
  "XOF": ["F\u202FCFA", void 0, 0],
  "XPF": ["CFPF", void 0, 0],
  "XXX": ["\xA4"],
  "YER": [void 0, void 0, 0],
  "ZAR": [void 0, "R"],
  "ZMK": [void 0, void 0, 0],
  "ZMW": [void 0, "ZK"],
  "ZWD": [void 0, void 0, 0]
};
var NumberFormatStyle;
(function(NumberFormatStyle2) {
  NumberFormatStyle2[NumberFormatStyle2["Decimal"] = 0] = "Decimal";
  NumberFormatStyle2[NumberFormatStyle2["Percent"] = 1] = "Percent";
  NumberFormatStyle2[NumberFormatStyle2["Currency"] = 2] = "Currency";
  NumberFormatStyle2[NumberFormatStyle2["Scientific"] = 3] = "Scientific";
})(NumberFormatStyle || (NumberFormatStyle = {}));
var Plural;
(function(Plural2) {
  Plural2[Plural2["Zero"] = 0] = "Zero";
  Plural2[Plural2["One"] = 1] = "One";
  Plural2[Plural2["Two"] = 2] = "Two";
  Plural2[Plural2["Few"] = 3] = "Few";
  Plural2[Plural2["Many"] = 4] = "Many";
  Plural2[Plural2["Other"] = 5] = "Other";
})(Plural || (Plural = {}));
var FormStyle;
(function(FormStyle2) {
  FormStyle2[FormStyle2["Format"] = 0] = "Format";
  FormStyle2[FormStyle2["Standalone"] = 1] = "Standalone";
})(FormStyle || (FormStyle = {}));
var TranslationWidth;
(function(TranslationWidth2) {
  TranslationWidth2[TranslationWidth2["Narrow"] = 0] = "Narrow";
  TranslationWidth2[TranslationWidth2["Abbreviated"] = 1] = "Abbreviated";
  TranslationWidth2[TranslationWidth2["Wide"] = 2] = "Wide";
  TranslationWidth2[TranslationWidth2["Short"] = 3] = "Short";
})(TranslationWidth || (TranslationWidth = {}));
var FormatWidth;
(function(FormatWidth2) {
  FormatWidth2[FormatWidth2["Short"] = 0] = "Short";
  FormatWidth2[FormatWidth2["Medium"] = 1] = "Medium";
  FormatWidth2[FormatWidth2["Long"] = 2] = "Long";
  FormatWidth2[FormatWidth2["Full"] = 3] = "Full";
})(FormatWidth || (FormatWidth = {}));
var NumberSymbol = {
  /**
   * Decimal separator.
   * For `en-US`, the dot character.
   * Example: 2,345`.`67
   */
  Decimal: 0,
  /**
   * Grouping separator, typically for thousands.
   * For `en-US`, the comma character.
   * Example: 2`,`345.67
   */
  Group: 1,
  /**
   * List-item separator.
   * Example: "one, two, and three"
   */
  List: 2,
  /**
   * Sign for percentage (out of 100).
   * Example: 23.4%
   */
  PercentSign: 3,
  /**
   * Sign for positive numbers.
   * Example: +23
   */
  PlusSign: 4,
  /**
   * Sign for negative numbers.
   * Example: -23
   */
  MinusSign: 5,
  /**
   * Computer notation for exponential value (n times a power of 10).
   * Example: 1.2E3
   */
  Exponential: 6,
  /**
   * Human-readable format of exponential.
   * Example: 1.2x103
   */
  SuperscriptingExponent: 7,
  /**
   * Sign for permille (out of 1000).
   * Example: 23.4
   */
  PerMille: 8,
  /**
   * Infinity, can be used with plus and minus.
   * Example: , +, -
   */
  Infinity: 9,
  /**
   * Not a number.
   * Example: NaN
   */
  NaN: 10,
  /**
   * Symbol used between time units.
   * Example: 10:52
   */
  TimeSeparator: 11,
  /**
   * Decimal separator for currency values (fallback to `Decimal`).
   * Example: $2,345.67
   */
  CurrencyDecimal: 12,
  /**
   * Group separator for currency values (fallback to `Group`).
   * Example: $2,345.67
   */
  CurrencyGroup: 13
};
var WeekDay;
(function(WeekDay2) {
  WeekDay2[WeekDay2["Sunday"] = 0] = "Sunday";
  WeekDay2[WeekDay2["Monday"] = 1] = "Monday";
  WeekDay2[WeekDay2["Tuesday"] = 2] = "Tuesday";
  WeekDay2[WeekDay2["Wednesday"] = 3] = "Wednesday";
  WeekDay2[WeekDay2["Thursday"] = 4] = "Thursday";
  WeekDay2[WeekDay2["Friday"] = 5] = "Friday";
  WeekDay2[WeekDay2["Saturday"] = 6] = "Saturday";
})(WeekDay || (WeekDay = {}));
function getLocaleId2(locale) {
  return findLocaleData(locale)[LocaleDataIndex.LocaleId];
}
function getLocaleDayPeriods(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const amPmData = [data[LocaleDataIndex.DayPeriodsFormat], data[LocaleDataIndex.DayPeriodsStandalone]];
  const amPm = getLastDefinedValue(amPmData, formStyle);
  return getLastDefinedValue(amPm, width);
}
function getLocaleDayNames(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const daysData = [data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone]];
  const days = getLastDefinedValue(daysData, formStyle);
  return getLastDefinedValue(days, width);
}
function getLocaleMonthNames(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const monthsData = [data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone]];
  const months = getLastDefinedValue(monthsData, formStyle);
  return getLastDefinedValue(months, width);
}
function getLocaleEraNames(locale, width) {
  const data = findLocaleData(locale);
  const erasData = data[LocaleDataIndex.Eras];
  return getLastDefinedValue(erasData, width);
}
function getLocaleDateFormat(locale, width) {
  const data = findLocaleData(locale);
  return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);
}
function getLocaleTimeFormat(locale, width) {
  const data = findLocaleData(locale);
  return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);
}
function getLocaleDateTimeFormat(locale, width) {
  const data = findLocaleData(locale);
  const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];
  return getLastDefinedValue(dateTimeFormatData, width);
}
function getLocaleNumberSymbol(locale, symbol) {
  const data = findLocaleData(locale);
  const res = data[LocaleDataIndex.NumberSymbols][symbol];
  if (typeof res === "undefined") {
    if (symbol === NumberSymbol.CurrencyDecimal) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
    } else if (symbol === NumberSymbol.CurrencyGroup) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
    }
  }
  return res;
}
function getLocaleNumberFormat(locale, type) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.NumberFormats][type];
}
function getLocaleCurrencies(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.Currencies];
}
var getLocalePluralCase2 = getLocalePluralCase;
function checkFullData(data) {
  if (!data[LocaleDataIndex.ExtraData]) {
    throw new Error(`Missing extra locale data for the locale "${data[LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
  }
}
function getLocaleExtraDayPeriodRules(locale) {
  const data = findLocaleData(locale);
  checkFullData(data);
  const rules = data[LocaleDataIndex.ExtraData][
    2
    /* ExtraLocaleDataIndex.ExtraDayPeriodsRules */
  ] || [];
  return rules.map((rule) => {
    if (typeof rule === "string") {
      return extractTime(rule);
    }
    return [extractTime(rule[0]), extractTime(rule[1])];
  });
}
function getLocaleExtraDayPeriods(locale, formStyle, width) {
  const data = findLocaleData(locale);
  checkFullData(data);
  const dayPeriodsData = [data[LocaleDataIndex.ExtraData][
    0
    /* ExtraLocaleDataIndex.ExtraDayPeriodFormats */
  ], data[LocaleDataIndex.ExtraData][
    1
    /* ExtraLocaleDataIndex.ExtraDayPeriodStandalone */
  ]];
  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
  return getLastDefinedValue(dayPeriods, width) || [];
}
function getLastDefinedValue(data, index3) {
  for (let i3 = index3; i3 > -1; i3--) {
    if (typeof data[i3] !== "undefined") {
      return data[i3];
    }
  }
  throw new Error("Locale data API: locale data undefined");
}
function extractTime(time) {
  const [h3, m3] = time.split(":");
  return {
    hours: +h3,
    minutes: +m3
  };
}
function getCurrencySymbol(code, format, locale = "en") {
  const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
  const symbolNarrow = currency[
    1
    /* CurrencyIndex.SymbolNarrow */
  ];
  if (format === "narrow" && typeof symbolNarrow === "string") {
    return symbolNarrow;
  }
  return currency[
    0
    /* CurrencyIndex.Symbol */
  ] || code;
}
var DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
function getNumberOfCurrencyDigits(code) {
  let digits;
  const currency = CURRENCIES_EN[code];
  if (currency) {
    digits = currency[
      2
      /* CurrencyIndex.NbOfDigits */
    ];
  }
  return typeof digits === "number" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
}
var ISO8601_DATE_REGEX = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
var NAMED_FORMATS = {};
var DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
var ZoneWidth;
(function(ZoneWidth2) {
  ZoneWidth2[ZoneWidth2["Short"] = 0] = "Short";
  ZoneWidth2[ZoneWidth2["ShortGMT"] = 1] = "ShortGMT";
  ZoneWidth2[ZoneWidth2["Long"] = 2] = "Long";
  ZoneWidth2[ZoneWidth2["Extended"] = 3] = "Extended";
})(ZoneWidth || (ZoneWidth = {}));
var DateType;
(function(DateType2) {
  DateType2[DateType2["FullYear"] = 0] = "FullYear";
  DateType2[DateType2["Month"] = 1] = "Month";
  DateType2[DateType2["Date"] = 2] = "Date";
  DateType2[DateType2["Hours"] = 3] = "Hours";
  DateType2[DateType2["Minutes"] = 4] = "Minutes";
  DateType2[DateType2["Seconds"] = 5] = "Seconds";
  DateType2[DateType2["FractionalSeconds"] = 6] = "FractionalSeconds";
  DateType2[DateType2["Day"] = 7] = "Day";
})(DateType || (DateType = {}));
var TranslationType;
(function(TranslationType2) {
  TranslationType2[TranslationType2["DayPeriods"] = 0] = "DayPeriods";
  TranslationType2[TranslationType2["Days"] = 1] = "Days";
  TranslationType2[TranslationType2["Months"] = 2] = "Months";
  TranslationType2[TranslationType2["Eras"] = 3] = "Eras";
})(TranslationType || (TranslationType = {}));
function formatDate(value, format, locale, timezone) {
  let date = toDate(value);
  const namedFormat = getNamedFormat(locale, format);
  format = namedFormat || format;
  let parts = [];
  let match2;
  while (format) {
    match2 = DATE_FORMATS_SPLIT.exec(format);
    if (match2) {
      parts = parts.concat(match2.slice(1));
      const part = parts.pop();
      if (!part) {
        break;
      }
      format = part;
    } else {
      parts.push(format);
      break;
    }
  }
  let dateTimezoneOffset = date.getTimezoneOffset();
  if (timezone) {
    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    date = convertTimezoneToLocal(date, timezone, true);
  }
  let text = "";
  parts.forEach((value2) => {
    const dateFormatter = getDateFormatter(value2);
    text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : value2 === "''" ? "'" : value2.replace(/(^'|'$)/g, "").replace(/''/g, "'");
  });
  return text;
}
function createDate(year, month, date) {
  const newDate = /* @__PURE__ */ new Date(0);
  newDate.setFullYear(year, month, date);
  newDate.setHours(0, 0, 0);
  return newDate;
}
function getNamedFormat(locale, format) {
  const localeId = getLocaleId2(locale);
  NAMED_FORMATS[localeId] ??= {};
  if (NAMED_FORMATS[localeId][format]) {
    return NAMED_FORMATS[localeId][format];
  }
  let formatValue2 = "";
  switch (format) {
    case "shortDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Short);
      break;
    case "mediumDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Medium);
      break;
    case "longDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Long);
      break;
    case "fullDate":
      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Full);
      break;
    case "shortTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Short);
      break;
    case "mediumTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Medium);
      break;
    case "longTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Long);
      break;
    case "fullTime":
      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Full);
      break;
    case "short":
      const shortTime = getNamedFormat(locale, "shortTime");
      const shortDate = getNamedFormat(locale, "shortDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
      break;
    case "medium":
      const mediumTime = getNamedFormat(locale, "mediumTime");
      const mediumDate = getNamedFormat(locale, "mediumDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
      break;
    case "long":
      const longTime = getNamedFormat(locale, "longTime");
      const longDate = getNamedFormat(locale, "longDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
      break;
    case "full":
      const fullTime = getNamedFormat(locale, "fullTime");
      const fullDate = getNamedFormat(locale, "fullDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);
      break;
  }
  if (formatValue2) {
    NAMED_FORMATS[localeId][format] = formatValue2;
  }
  return formatValue2;
}
function formatDateTime(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{([^}]+)}/g, function(match2, key) {
      return opt_values != null && key in opt_values ? opt_values[key] : match2;
    });
  }
  return str;
}
function padNumber(num, digits, minusSign = "-", trim, negWrap) {
  let neg = "";
  if (num < 0 || negWrap && num <= 0) {
    if (negWrap) {
      num = -num + 1;
    } else {
      num = -num;
      neg = minusSign;
    }
  }
  let strNum = String(num);
  while (strNum.length < digits) {
    strNum = "0" + strNum;
  }
  if (trim) {
    strNum = strNum.slice(strNum.length - digits);
  }
  return neg + strNum;
}
function formatFractionalSeconds(milliseconds, digits) {
  const strMs = padNumber(milliseconds, 3);
  return strMs.substring(0, digits);
}
function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
  return function(date, locale) {
    let part = getDatePart(name, date);
    if (offset > 0 || part > -offset) {
      part += offset;
    }
    if (name === DateType.Hours) {
      if (part === 0 && offset === -12) {
        part = 12;
      }
    } else if (name === DateType.FractionalSeconds) {
      return formatFractionalSeconds(part, size);
    }
    const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    return padNumber(part, size, localeMinus, trim, negWrap);
  };
}
function getDatePart(part, date) {
  switch (part) {
    case DateType.FullYear:
      return date.getFullYear();
    case DateType.Month:
      return date.getMonth();
    case DateType.Date:
      return date.getDate();
    case DateType.Hours:
      return date.getHours();
    case DateType.Minutes:
      return date.getMinutes();
    case DateType.Seconds:
      return date.getSeconds();
    case DateType.FractionalSeconds:
      return date.getMilliseconds();
    case DateType.Day:
      return date.getDay();
    default:
      throw new Error(`Unknown DateType value "${part}".`);
  }
}
function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
  return function(date, locale) {
    return getDateTranslation(date, locale, name, width, form, extended);
  };
}
function getDateTranslation(date, locale, name, width, form, extended) {
  switch (name) {
    case TranslationType.Months:
      return getLocaleMonthNames(locale, form, width)[date.getMonth()];
    case TranslationType.Days:
      return getLocaleDayNames(locale, form, width)[date.getDay()];
    case TranslationType.DayPeriods:
      const currentHours = date.getHours();
      const currentMinutes = date.getMinutes();
      if (extended) {
        const rules = getLocaleExtraDayPeriodRules(locale);
        const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
        const index3 = rules.findIndex((rule) => {
          if (Array.isArray(rule)) {
            const [from2, to] = rule;
            const afterFrom = currentHours >= from2.hours && currentMinutes >= from2.minutes;
            const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
            if (from2.hours < to.hours) {
              if (afterFrom && beforeTo) {
                return true;
              }
            } else if (afterFrom || beforeTo) {
              return true;
            }
          } else {
            if (rule.hours === currentHours && rule.minutes === currentMinutes) {
              return true;
            }
          }
          return false;
        });
        if (index3 !== -1) {
          return dayPeriods[index3];
        }
      }
      return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];
    case TranslationType.Eras:
      return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
    default:
      const unexpected = name;
      throw new Error(`unexpected translation type ${unexpected}`);
  }
}
function timeZoneGetter(width) {
  return function(date, locale, offset) {
    const zone = -1 * offset;
    const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
    switch (width) {
      case ZoneWidth.Short:
        return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
      case ZoneWidth.ShortGMT:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 1, minusSign);
      case ZoneWidth.Long:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
      case ZoneWidth.Extended:
        if (offset === 0) {
          return "Z";
        } else {
          return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
        }
      default:
        throw new Error(`Unknown zone width "${width}"`);
    }
  };
}
var JANUARY = 0;
var THURSDAY = 4;
function getFirstThursdayOfYear(year) {
  const firstDayOfYear = createDate(year, JANUARY, 1).getDay();
  return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
}
function getThursdayThisIsoWeek(datetime) {
  const currentDay = datetime.getDay();
  const deltaToThursday = currentDay === 0 ? -3 : THURSDAY - currentDay;
  return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + deltaToThursday);
}
function weekGetter(size, monthBased = false) {
  return function(date, locale) {
    let result;
    if (monthBased) {
      const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
      const today = date.getDate();
      result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
    } else {
      const thisThurs = getThursdayThisIsoWeek(date);
      const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
      const diff = thisThurs.getTime() - firstThurs.getTime();
      result = 1 + Math.round(diff / 6048e5);
    }
    return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  };
}
function weekNumberingYearGetter(size, trim = false) {
  return function(date, locale) {
    const thisThurs = getThursdayThisIsoWeek(date);
    const weekNumberingYear = thisThurs.getFullYear();
    return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);
  };
}
var DATE_FORMATS = {};
function getDateFormatter(format) {
  if (DATE_FORMATS[format]) {
    return DATE_FORMATS[format];
  }
  let formatter;
  switch (format) {
    case "G":
    case "GG":
    case "GGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
      break;
    case "GGGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
      break;
    case "GGGGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
      break;
    case "y":
      formatter = dateGetter(DateType.FullYear, 1, 0, false, true);
      break;
    case "yy":
      formatter = dateGetter(DateType.FullYear, 2, 0, true, true);
      break;
    case "yyy":
      formatter = dateGetter(DateType.FullYear, 3, 0, false, true);
      break;
    case "yyyy":
      formatter = dateGetter(DateType.FullYear, 4, 0, false, true);
      break;
    case "Y":
      formatter = weekNumberingYearGetter(1);
      break;
    case "YY":
      formatter = weekNumberingYearGetter(2, true);
      break;
    case "YYY":
      formatter = weekNumberingYearGetter(3);
      break;
    case "YYYY":
      formatter = weekNumberingYearGetter(4);
      break;
    case "M":
    case "L":
      formatter = dateGetter(DateType.Month, 1, 1);
      break;
    case "MM":
    case "LL":
      formatter = dateGetter(DateType.Month, 2, 1);
      break;
    case "MMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
      break;
    case "MMMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
      break;
    case "MMMMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
      break;
    case "LLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "LLLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "LLLLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "w":
      formatter = weekGetter(1);
      break;
    case "ww":
      formatter = weekGetter(2);
      break;
    case "W":
      formatter = weekGetter(1, true);
      break;
    case "d":
      formatter = dateGetter(DateType.Date, 1);
      break;
    case "dd":
      formatter = dateGetter(DateType.Date, 2);
      break;
    case "c":
    case "cc":
      formatter = dateGetter(DateType.Day, 1);
      break;
    case "ccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "cccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "ccccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "cccccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short, FormStyle.Standalone);
      break;
    case "E":
    case "EE":
    case "EEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
      break;
    case "EEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
      break;
    case "EEEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
      break;
    case "EEEEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
      break;
    case "a":
    case "aa":
    case "aaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
      break;
    case "aaaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
      break;
    case "aaaaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
      break;
    case "b":
    case "bb":
    case "bbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
      break;
    case "bbbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, true);
      break;
    case "bbbbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, true);
      break;
    case "B":
    case "BB":
    case "BBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, true);
      break;
    case "BBBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, true);
      break;
    case "BBBBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, true);
      break;
    case "h":
      formatter = dateGetter(DateType.Hours, 1, -12);
      break;
    case "hh":
      formatter = dateGetter(DateType.Hours, 2, -12);
      break;
    case "H":
      formatter = dateGetter(DateType.Hours, 1);
      break;
    case "HH":
      formatter = dateGetter(DateType.Hours, 2);
      break;
    case "m":
      formatter = dateGetter(DateType.Minutes, 1);
      break;
    case "mm":
      formatter = dateGetter(DateType.Minutes, 2);
      break;
    case "s":
      formatter = dateGetter(DateType.Seconds, 1);
      break;
    case "ss":
      formatter = dateGetter(DateType.Seconds, 2);
      break;
    case "S":
      formatter = dateGetter(DateType.FractionalSeconds, 1);
      break;
    case "SS":
      formatter = dateGetter(DateType.FractionalSeconds, 2);
      break;
    case "SSS":
      formatter = dateGetter(DateType.FractionalSeconds, 3);
      break;
    case "Z":
    case "ZZ":
    case "ZZZ":
      formatter = timeZoneGetter(ZoneWidth.Short);
      break;
    case "ZZZZZ":
      formatter = timeZoneGetter(ZoneWidth.Extended);
      break;
    case "O":
    case "OO":
    case "OOO":
    case "z":
    case "zz":
    case "zzz":
      formatter = timeZoneGetter(ZoneWidth.ShortGMT);
      break;
    case "OOOO":
    case "ZZZZ":
    case "zzzz":
      formatter = timeZoneGetter(ZoneWidth.Long);
      break;
    default:
      return null;
  }
  DATE_FORMATS[format] = formatter;
  return formatter;
}
function timezoneToOffset(timezone, fallback) {
  timezone = timezone.replace(/:/g, "");
  const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
}
function addDateMinutes(date, minutes) {
  date = new Date(date.getTime());
  date.setMinutes(date.getMinutes() + minutes);
  return date;
}
function convertTimezoneToLocal(date, timezone, reverse) {
  const reverseValue = reverse ? -1 : 1;
  const dateTimezoneOffset = date.getTimezoneOffset();
  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
  return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
}
function toDate(value) {
  if (isDate(value)) {
    return value;
  }
  if (typeof value === "number" && !isNaN(value)) {
    return new Date(value);
  }
  if (typeof value === "string") {
    value = value.trim();
    if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value)) {
      const [y3, m3 = 1, d2 = 1] = value.split("-").map((val) => +val);
      return createDate(y3, m3 - 1, d2);
    }
    const parsedNb = parseFloat(value);
    if (!isNaN(value - parsedNb)) {
      return new Date(parsedNb);
    }
    let match2;
    if (match2 = value.match(ISO8601_DATE_REGEX)) {
      return isoStringToDate(match2);
    }
  }
  const date = new Date(value);
  if (!isDate(date)) {
    throw new Error(`Unable to convert "${value}" into a date`);
  }
  return date;
}
function isoStringToDate(match2) {
  const date = /* @__PURE__ */ new Date(0);
  let tzHour = 0;
  let tzMin = 0;
  const dateSetter = match2[8] ? date.setUTCFullYear : date.setFullYear;
  const timeSetter = match2[8] ? date.setUTCHours : date.setHours;
  if (match2[9]) {
    tzHour = Number(match2[9] + match2[10]);
    tzMin = Number(match2[9] + match2[11]);
  }
  dateSetter.call(date, Number(match2[1]), Number(match2[2]) - 1, Number(match2[3]));
  const h3 = Number(match2[4] || 0) - tzHour;
  const m3 = Number(match2[5] || 0) - tzMin;
  const s3 = Number(match2[6] || 0);
  const ms = Math.floor(parseFloat("0." + (match2[7] || 0)) * 1e3);
  timeSetter.call(date, h3, m3, s3, ms);
  return date;
}
function isDate(value) {
  return value instanceof Date && !isNaN(value.valueOf());
}
var NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
var MAX_DIGITS = 22;
var DECIMAL_SEP = ".";
var ZERO_CHAR = "0";
var PATTERN_SEP = ";";
var GROUP_SEP = ",";
var DIGIT_CHAR = "#";
var CURRENCY_CHAR = "\xA4";
var PERCENT_CHAR = "%";
function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
  let formattedText = "";
  let isZero = false;
  if (!isFinite(value)) {
    formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
  } else {
    let parsedNumber = parseNumber(value);
    if (isPercent) {
      parsedNumber = toPercent(parsedNumber);
    }
    let minInt = pattern.minInt;
    let minFraction = pattern.minFrac;
    let maxFraction = pattern.maxFrac;
    if (digitsInfo) {
      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
      if (parts === null) {
        throw new Error(`${digitsInfo} is not a valid digit info`);
      }
      const minIntPart = parts[1];
      const minFractionPart = parts[3];
      const maxFractionPart = parts[5];
      if (minIntPart != null) {
        minInt = parseIntAutoRadix(minIntPart);
      }
      if (minFractionPart != null) {
        minFraction = parseIntAutoRadix(minFractionPart);
      }
      if (maxFractionPart != null) {
        maxFraction = parseIntAutoRadix(maxFractionPart);
      } else if (minFractionPart != null && minFraction > maxFraction) {
        maxFraction = minFraction;
      }
    }
    roundNumber(parsedNumber, minFraction, maxFraction);
    let digits = parsedNumber.digits;
    let integerLen = parsedNumber.integerLen;
    const exponent = parsedNumber.exponent;
    let decimals = [];
    isZero = digits.every((d2) => !d2);
    for (; integerLen < minInt; integerLen++) {
      digits.unshift(0);
    }
    for (; integerLen < 0; integerLen++) {
      digits.unshift(0);
    }
    if (integerLen > 0) {
      decimals = digits.splice(integerLen, digits.length);
    } else {
      decimals = digits;
      digits = [0];
    }
    const groups = [];
    if (digits.length >= pattern.lgSize) {
      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
    }
    while (digits.length > pattern.gSize) {
      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
    }
    if (digits.length) {
      groups.unshift(digits.join(""));
    }
    formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
    if (decimals.length) {
      formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join("");
    }
    if (exponent) {
      formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + "+" + exponent;
    }
  }
  if (value < 0 && !isZero) {
    formattedText = pattern.negPre + formattedText + pattern.negSuf;
  } else {
    formattedText = pattern.posPre + formattedText + pattern.posSuf;
  }
  return formattedText;
}
function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
  pattern.maxFrac = pattern.minFrac;
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
  return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, "").trim();
}
function formatPercent(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
  return res.replace(new RegExp(PERCENT_CHAR, "g"), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
}
function formatNumber(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
}
function parseNumberFormat(format, minusSign = "-") {
  const p3 = {
    minInt: 1,
    minFrac: 0,
    maxFrac: 0,
    posPre: "",
    posSuf: "",
    negPre: "",
    negSuf: "",
    gSize: 0,
    lgSize: 0
  };
  const patternParts = format.split(PATTERN_SEP);
  const positive = patternParts[0];
  const negative = patternParts[1];
  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)], integer = positiveParts[0], fraction = positiveParts[1] || "";
  p3.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));
  for (let i3 = 0; i3 < fraction.length; i3++) {
    const ch = fraction.charAt(i3);
    if (ch === ZERO_CHAR) {
      p3.minFrac = p3.maxFrac = i3 + 1;
    } else if (ch === DIGIT_CHAR) {
      p3.maxFrac = i3 + 1;
    } else {
      p3.posSuf += ch;
    }
  }
  const groups = integer.split(GROUP_SEP);
  p3.gSize = groups[1] ? groups[1].length : 0;
  p3.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
  if (negative) {
    const trunkLen = positive.length - p3.posPre.length - p3.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);
    p3.negPre = negative.substring(0, pos).replace(/'/g, "");
    p3.negSuf = negative.slice(pos + trunkLen).replace(/'/g, "");
  } else {
    p3.negPre = minusSign + p3.posPre;
    p3.negSuf = p3.posSuf;
  }
  return p3;
}
function toPercent(parsedNumber) {
  if (parsedNumber.digits[0] === 0) {
    return parsedNumber;
  }
  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
  if (parsedNumber.exponent) {
    parsedNumber.exponent += 2;
  } else {
    if (fractionLen === 0) {
      parsedNumber.digits.push(0, 0);
    } else if (fractionLen === 1) {
      parsedNumber.digits.push(0);
    }
    parsedNumber.integerLen += 2;
  }
  return parsedNumber;
}
function parseNumber(num) {
  let numStr = Math.abs(num) + "";
  let exponent = 0, digits, integerLen;
  let i3, j4, zeros;
  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
    numStr = numStr.replace(DECIMAL_SEP, "");
  }
  if ((i3 = numStr.search(/e/i)) > 0) {
    if (integerLen < 0) integerLen = i3;
    integerLen += +numStr.slice(i3 + 1);
    numStr = numStr.substring(0, i3);
  } else if (integerLen < 0) {
    integerLen = numStr.length;
  }
  for (i3 = 0; numStr.charAt(i3) === ZERO_CHAR; i3++) {
  }
  if (i3 === (zeros = numStr.length)) {
    digits = [0];
    integerLen = 1;
  } else {
    zeros--;
    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
    integerLen -= i3;
    digits = [];
    for (j4 = 0; i3 <= zeros; i3++, j4++) {
      digits[j4] = Number(numStr.charAt(i3));
    }
  }
  if (integerLen > MAX_DIGITS) {
    digits = digits.splice(0, MAX_DIGITS - 1);
    exponent = integerLen - 1;
    integerLen = 1;
  }
  return {
    digits,
    exponent,
    integerLen
  };
}
function roundNumber(parsedNumber, minFrac, maxFrac) {
  if (minFrac > maxFrac) {
    throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
  }
  let digits = parsedNumber.digits;
  let fractionLen = digits.length - parsedNumber.integerLen;
  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
  let roundAt = fractionSize + parsedNumber.integerLen;
  let digit = digits[roundAt];
  if (roundAt > 0) {
    digits.splice(Math.max(parsedNumber.integerLen, roundAt));
    for (let j4 = roundAt; j4 < digits.length; j4++) {
      digits[j4] = 0;
    }
  } else {
    fractionLen = Math.max(0, fractionLen);
    parsedNumber.integerLen = 1;
    digits.length = Math.max(1, roundAt = fractionSize + 1);
    digits[0] = 0;
    for (let i3 = 1; i3 < roundAt; i3++) digits[i3] = 0;
  }
  if (digit >= 5) {
    if (roundAt - 1 < 0) {
      for (let k3 = 0; k3 > roundAt; k3--) {
        digits.unshift(0);
        parsedNumber.integerLen++;
      }
      digits.unshift(1);
      parsedNumber.integerLen++;
    } else {
      digits[roundAt - 1]++;
    }
  }
  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
  let dropTrailingZeros = fractionSize !== 0;
  const minLen = minFrac + parsedNumber.integerLen;
  const carry = digits.reduceRight(function(carry2, d2, i3, digits2) {
    d2 = d2 + carry2;
    digits2[i3] = d2 < 10 ? d2 : d2 - 10;
    if (dropTrailingZeros) {
      if (digits2[i3] === 0 && i3 >= minLen) {
        digits2.pop();
      } else {
        dropTrailingZeros = false;
      }
    }
    return d2 >= 10 ? 1 : 0;
  }, 0);
  if (carry) {
    digits.unshift(carry);
    parsedNumber.integerLen++;
  }
}
function parseIntAutoRadix(text) {
  const result = parseInt(text);
  if (isNaN(result)) {
    throw new Error("Invalid integer literal when parsing " + text);
  }
  return result;
}
var _NgLocalization = class _NgLocalization {
};
_NgLocalization.\u0275fac = function NgLocalization_Factory(t3) {
  return new (t3 || _NgLocalization)();
};
_NgLocalization.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NgLocalization,
  factory: function NgLocalization_Factory(t3) {
    let r3 = null;
    if (t3) {
      r3 = new t3();
    } else {
      r3 = ((locale) => new NgLocaleLocalization(locale))(\u0275\u0275inject(LOCALE_ID));
    }
    return r3;
  },
  providedIn: "root"
});
var NgLocalization = _NgLocalization;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocalization, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: (locale) => new NgLocaleLocalization(locale),
      deps: [LOCALE_ID]
    }]
  }], null, null);
})();
function getPluralCategory(value, cases, ngLocalization, locale) {
  let key = `=${value}`;
  if (cases.indexOf(key) > -1) {
    return key;
  }
  key = ngLocalization.getPluralCategory(value, locale);
  if (cases.indexOf(key) > -1) {
    return key;
  }
  if (cases.indexOf("other") > -1) {
    return "other";
  }
  throw new Error(`No plural message found for value "${value}"`);
}
var _NgLocaleLocalization = class _NgLocaleLocalization extends NgLocalization {
  constructor(locale) {
    super();
    this.locale = locale;
  }
  getPluralCategory(value, locale) {
    const plural2 = getLocalePluralCase2(locale || this.locale)(value);
    switch (plural2) {
      case Plural.Zero:
        return "zero";
      case Plural.One:
        return "one";
      case Plural.Two:
        return "two";
      case Plural.Few:
        return "few";
      case Plural.Many:
        return "many";
      default:
        return "other";
    }
  }
};
_NgLocaleLocalization.\u0275fac = function NgLocaleLocalization_Factory(t3) {
  return new (t3 || _NgLocaleLocalization)(\u0275\u0275inject(LOCALE_ID));
};
_NgLocaleLocalization.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NgLocaleLocalization,
  factory: _NgLocaleLocalization.\u0275fac
});
var NgLocaleLocalization = _NgLocaleLocalization;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocaleLocalization, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
function parseCookieValue(cookieStr, name) {
  name = encodeURIComponent(name);
  for (const cookie of cookieStr.split(";")) {
    const eqIndex = cookie.indexOf("=");
    const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, ""] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
    if (cookieName.trim() === name) {
      return decodeURIComponent(cookieValue);
    }
  }
  return null;
}
var WS_REGEXP = /\s+/;
var EMPTY_ARRAY2 = [];
var _NgClass = class _NgClass {
  constructor(_ngEl, _renderer) {
    this._ngEl = _ngEl;
    this._renderer = _renderer;
    this.initialClasses = EMPTY_ARRAY2;
    this.stateMap = /* @__PURE__ */ new Map();
  }
  set klass(value) {
    this.initialClasses = value != null ? value.trim().split(WS_REGEXP) : EMPTY_ARRAY2;
  }
  set ngClass(value) {
    this.rawClass = typeof value === "string" ? value.trim().split(WS_REGEXP) : value;
  }
  /*
  The NgClass directive uses the custom change detection algorithm for its inputs. The custom
  algorithm is necessary since inputs are represented as complex object or arrays that need to be
  deeply-compared.
     This algorithm is perf-sensitive since NgClass is used very frequently and its poor performance
  might negatively impact runtime performance of the entire change detection cycle. The design of
  this algorithm is making sure that:
  - there is no unnecessary DOM manipulation (CSS classes are added / removed from the DOM only when
  needed), even if references to bound objects change;
  - there is no memory allocation if nothing changes (even relatively modest memory allocation
  during the change detection cycle can result in GC pauses for some of the CD cycles).
     The algorithm works by iterating over the set of bound classes, staring with [class] binding and
  then going over [ngClass] binding. For each CSS class name:
  - check if it was seen before (this information is tracked in the state map) and if its value
  changed;
  - mark it as "touched" - names that are not marked are not present in the latest set of binding
  and we can remove such class name from the internal data structures;
     After iteration over all the CSS class names we've got data structure with all the information
  necessary to synchronize changes to the DOM - it is enough to iterate over the state map, flush
  changes to the DOM and reset internal data structures so those are ready for the next change
  detection cycle.
   */
  ngDoCheck() {
    for (const klass of this.initialClasses) {
      this._updateState(klass, true);
    }
    const rawClass = this.rawClass;
    if (Array.isArray(rawClass) || rawClass instanceof Set) {
      for (const klass of rawClass) {
        this._updateState(klass, true);
      }
    } else if (rawClass != null) {
      for (const klass of Object.keys(rawClass)) {
        this._updateState(klass, Boolean(rawClass[klass]));
      }
    }
    this._applyStateDiff();
  }
  _updateState(klass, nextEnabled) {
    const state = this.stateMap.get(klass);
    if (state !== void 0) {
      if (state.enabled !== nextEnabled) {
        state.changed = true;
        state.enabled = nextEnabled;
      }
      state.touched = true;
    } else {
      this.stateMap.set(klass, {
        enabled: nextEnabled,
        changed: true,
        touched: true
      });
    }
  }
  _applyStateDiff() {
    for (const stateEntry of this.stateMap) {
      const klass = stateEntry[0];
      const state = stateEntry[1];
      if (state.changed) {
        this._toggleClass(klass, state.enabled);
        state.changed = false;
      } else if (!state.touched) {
        if (state.enabled) {
          this._toggleClass(klass, false);
        }
        this.stateMap.delete(klass);
      }
      state.touched = false;
    }
  }
  _toggleClass(klass, enabled) {
    if (ngDevMode) {
      if (typeof klass !== "string") {
        throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(klass)}`);
      }
    }
    klass = klass.trim();
    if (klass.length > 0) {
      klass.split(WS_REGEXP).forEach((klass2) => {
        if (enabled) {
          this._renderer.addClass(this._ngEl.nativeElement, klass2);
        } else {
          this._renderer.removeClass(this._ngEl.nativeElement, klass2);
        }
      });
    }
  }
};
_NgClass.\u0275fac = function NgClass_Factory(t3) {
  return new (t3 || _NgClass)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
};
_NgClass.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgClass,
  selectors: [["", "ngClass", ""]],
  inputs: {
    klass: [0, "class", "klass"],
    ngClass: "ngClass"
  },
  standalone: true
});
var NgClass = _NgClass;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgClass, [{
    type: Directive,
    args: [{
      selector: "[ngClass]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    klass: [{
      type: Input,
      args: ["class"]
    }],
    ngClass: [{
      type: Input,
      args: ["ngClass"]
    }]
  });
})();
var _NgComponentOutlet = class _NgComponentOutlet {
  constructor(_viewContainerRef) {
    this._viewContainerRef = _viewContainerRef;
    this.ngComponentOutlet = null;
    this._inputsUsed = /* @__PURE__ */ new Map();
  }
  _needToReCreateNgModuleInstance(changes) {
    return changes["ngComponentOutletNgModule"] !== void 0 || changes["ngComponentOutletNgModuleFactory"] !== void 0;
  }
  _needToReCreateComponentInstance(changes) {
    return changes["ngComponentOutlet"] !== void 0 || changes["ngComponentOutletContent"] !== void 0 || changes["ngComponentOutletInjector"] !== void 0 || this._needToReCreateNgModuleInstance(changes);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._needToReCreateComponentInstance(changes)) {
      this._viewContainerRef.clear();
      this._inputsUsed.clear();
      this._componentRef = void 0;
      if (this.ngComponentOutlet) {
        const injector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
        if (this._needToReCreateNgModuleInstance(changes)) {
          this._moduleRef?.destroy();
          if (this.ngComponentOutletNgModule) {
            this._moduleRef = createNgModule(this.ngComponentOutletNgModule, getParentInjector(injector));
          } else if (this.ngComponentOutletNgModuleFactory) {
            this._moduleRef = this.ngComponentOutletNgModuleFactory.create(getParentInjector(injector));
          } else {
            this._moduleRef = void 0;
          }
        }
        this._componentRef = this._viewContainerRef.createComponent(this.ngComponentOutlet, {
          injector,
          ngModuleRef: this._moduleRef,
          projectableNodes: this.ngComponentOutletContent
        });
      }
    }
  }
  /** @nodoc */
  ngDoCheck() {
    if (this._componentRef) {
      if (this.ngComponentOutletInputs) {
        for (const inputName of Object.keys(this.ngComponentOutletInputs)) {
          this._inputsUsed.set(inputName, true);
        }
      }
      this._applyInputStateDiff(this._componentRef);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this._moduleRef?.destroy();
  }
  _applyInputStateDiff(componentRef) {
    for (const [inputName, touched] of this._inputsUsed) {
      if (!touched) {
        componentRef.setInput(inputName, void 0);
        this._inputsUsed.delete(inputName);
      } else {
        componentRef.setInput(inputName, this.ngComponentOutletInputs[inputName]);
        this._inputsUsed.set(inputName, false);
      }
    }
  }
};
_NgComponentOutlet.\u0275fac = function NgComponentOutlet_Factory(t3) {
  return new (t3 || _NgComponentOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
};
_NgComponentOutlet.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgComponentOutlet,
  selectors: [["", "ngComponentOutlet", ""]],
  inputs: {
    ngComponentOutlet: "ngComponentOutlet",
    ngComponentOutletInputs: "ngComponentOutletInputs",
    ngComponentOutletInjector: "ngComponentOutletInjector",
    ngComponentOutletContent: "ngComponentOutletContent",
    ngComponentOutletNgModule: "ngComponentOutletNgModule",
    ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NgComponentOutlet = _NgComponentOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgComponentOutlet, [{
    type: Directive,
    args: [{
      selector: "[ngComponentOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], {
    ngComponentOutlet: [{
      type: Input
    }],
    ngComponentOutletInputs: [{
      type: Input
    }],
    ngComponentOutletInjector: [{
      type: Input
    }],
    ngComponentOutletContent: [{
      type: Input
    }],
    ngComponentOutletNgModule: [{
      type: Input
    }],
    ngComponentOutletNgModuleFactory: [{
      type: Input
    }]
  });
})();
function getParentInjector(injector) {
  const parentNgModule = injector.get(NgModuleRef$1);
  return parentNgModule.injector;
}
var NgForOfContext = class {
  constructor($implicit, ngForOf, index3, count) {
    this.$implicit = $implicit;
    this.ngForOf = ngForOf;
    this.index = index3;
    this.count = count;
  }
  get first() {
    return this.index === 0;
  }
  get last() {
    return this.index === this.count - 1;
  }
  get even() {
    return this.index % 2 === 0;
  }
  get odd() {
    return !this.even;
  }
};
var _NgForOf = class _NgForOf {
  /**
   * The value of the iterable expression, which can be used as a
   * [template input variable](guide/directives/structural-directives#shorthand).
   */
  set ngForOf(ngForOf) {
    this._ngForOf = ngForOf;
    this._ngForOfDirty = true;
  }
  /**
   * Specifies a custom `TrackByFunction` to compute the identity of items in an iterable.
   *
   * If a custom `TrackByFunction` is not provided, `NgForOf` will use the item's [object
   * identity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)
   * as the key.
   *
   * `NgForOf` uses the computed key to associate items in an iterable with DOM elements
   * it produces for these items.
   *
   * A custom `TrackByFunction` is useful to provide good user experience in cases when items in an
   * iterable rendered using `NgForOf` have a natural identifier (for example, custom ID or a
   * primary key), and this iterable could be updated with new object instances that still
   * represent the same underlying entity (for example, when data is re-fetched from the server,
   * and the iterable is recreated and re-rendered, but most of the data is still the same).
   *
   * @see {@link TrackByFunction}
   */
  set ngForTrackBy(fn) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`);
    }
    this._trackByFn = fn;
  }
  get ngForTrackBy() {
    return this._trackByFn;
  }
  constructor(_viewContainer, _template, _differs) {
    this._viewContainer = _viewContainer;
    this._template = _template;
    this._differs = _differs;
    this._ngForOf = null;
    this._ngForOfDirty = true;
    this._differ = null;
  }
  /**
   * A reference to the template that is stamped out for each item in the iterable.
   * @see [template reference variable](guide/templates/reference-variables)
   */
  set ngForTemplate(value) {
    if (value) {
      this._template = value;
    }
  }
  /**
   * Applies the changes when needed.
   * @nodoc
   */
  ngDoCheck() {
    if (this._ngForOfDirty) {
      this._ngForOfDirty = false;
      const value = this._ngForOf;
      if (!this._differ && value) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          try {
            this._differ = this._differs.find(value).create(this.ngForTrackBy);
          } catch {
            let errorMessage = `Cannot find a differ supporting object '${value}' of type '${getTypeName(value)}'. NgFor only supports binding to Iterables, such as Arrays.`;
            if (typeof value === "object") {
              errorMessage += " Did you mean to use the keyvalue pipe?";
            }
            throw new RuntimeError(-2200, errorMessage);
          }
        } else {
          this._differ = this._differs.find(value).create(this.ngForTrackBy);
        }
      }
    }
    if (this._differ) {
      const changes = this._differ.diff(this._ngForOf);
      if (changes) this._applyChanges(changes);
    }
  }
  _applyChanges(changes) {
    const viewContainer = this._viewContainer;
    changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
      if (item.previousIndex == null) {
        viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);
      } else if (currentIndex == null) {
        viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
      } else if (adjustedPreviousIndex !== null) {
        const view = viewContainer.get(adjustedPreviousIndex);
        viewContainer.move(view, currentIndex);
        applyViewChange(view, item);
      }
    });
    for (let i3 = 0, ilen = viewContainer.length; i3 < ilen; i3++) {
      const viewRef = viewContainer.get(i3);
      const context2 = viewRef.context;
      context2.index = i3;
      context2.count = ilen;
      context2.ngForOf = this._ngForOf;
    }
    changes.forEachIdentityChange((record) => {
      const viewRef = viewContainer.get(record.currentIndex);
      applyViewChange(viewRef, record);
    });
  }
  /**
   * Asserts the correct type of the context for the template that `NgForOf` will render.
   *
   * The presence of this method is a signal to the Ivy template type-check compiler that the
   * `NgForOf` structural directive renders its template with a specific context type.
   */
  static ngTemplateContextGuard(dir, ctx) {
    return true;
  }
};
_NgForOf.\u0275fac = function NgForOf_Factory(t3) {
  return new (t3 || _NgForOf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(IterableDiffers));
};
_NgForOf.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgForOf,
  selectors: [["", "ngFor", "", "ngForOf", ""]],
  inputs: {
    ngForOf: "ngForOf",
    ngForTrackBy: "ngForTrackBy",
    ngForTemplate: "ngForTemplate"
  },
  standalone: true
});
var NgForOf = _NgForOf;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForOf, [{
    type: Directive,
    args: [{
      selector: "[ngFor][ngForOf]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: IterableDiffers
  }], {
    ngForOf: [{
      type: Input
    }],
    ngForTrackBy: [{
      type: Input
    }],
    ngForTemplate: [{
      type: Input
    }]
  });
})();
function applyViewChange(view, record) {
  view.context.$implicit = record.item;
}
function getTypeName(type) {
  return type["name"] || typeof type;
}
var _NgIf = class _NgIf {
  constructor(_viewContainer, templateRef) {
    this._viewContainer = _viewContainer;
    this._context = new NgIfContext();
    this._thenTemplateRef = null;
    this._elseTemplateRef = null;
    this._thenViewRef = null;
    this._elseViewRef = null;
    this._thenTemplateRef = templateRef;
  }
  /**
   * The Boolean expression to evaluate as the condition for showing a template.
   */
  set ngIf(condition) {
    this._context.$implicit = this._context.ngIf = condition;
    this._updateView();
  }
  /**
   * A template to show if the condition expression evaluates to true.
   */
  set ngIfThen(templateRef) {
    assertTemplate("ngIfThen", templateRef);
    this._thenTemplateRef = templateRef;
    this._thenViewRef = null;
    this._updateView();
  }
  /**
   * A template to show if the condition expression evaluates to false.
   */
  set ngIfElse(templateRef) {
    assertTemplate("ngIfElse", templateRef);
    this._elseTemplateRef = templateRef;
    this._elseViewRef = null;
    this._updateView();
  }
  _updateView() {
    if (this._context.$implicit) {
      if (!this._thenViewRef) {
        this._viewContainer.clear();
        this._elseViewRef = null;
        if (this._thenTemplateRef) {
          this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
        }
      }
    } else {
      if (!this._elseViewRef) {
        this._viewContainer.clear();
        this._thenViewRef = null;
        if (this._elseTemplateRef) {
          this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
        }
      }
    }
  }
  /**
   * Asserts the correct type of the context for the template that `NgIf` will render.
   *
   * The presence of this method is a signal to the Ivy template type-check compiler that the
   * `NgIf` structural directive renders its template with a specific context type.
   */
  static ngTemplateContextGuard(dir, ctx) {
    return true;
  }
};
_NgIf.\u0275fac = function NgIf_Factory(t3) {
  return new (t3 || _NgIf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef));
};
_NgIf.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgIf,
  selectors: [["", "ngIf", ""]],
  inputs: {
    ngIf: "ngIf",
    ngIfThen: "ngIfThen",
    ngIfElse: "ngIfElse"
  },
  standalone: true
});
var NgIf = _NgIf;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgIf, [{
    type: Directive,
    args: [{
      selector: "[ngIf]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }], {
    ngIf: [{
      type: Input
    }],
    ngIfThen: [{
      type: Input
    }],
    ngIfElse: [{
      type: Input
    }]
  });
})();
var NgIfContext = class {
  constructor() {
    this.$implicit = null;
    this.ngIf = null;
  }
};
function assertTemplate(property, templateRef) {
  const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
  if (!isTemplateRefOrNull) {
    throw new Error(`${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
  }
}
var NG_SWITCH_USE_STRICT_EQUALS = true;
var SwitchView = class {
  constructor(_viewContainerRef, _templateRef) {
    this._viewContainerRef = _viewContainerRef;
    this._templateRef = _templateRef;
    this._created = false;
  }
  create() {
    this._created = true;
    this._viewContainerRef.createEmbeddedView(this._templateRef);
  }
  destroy() {
    this._created = false;
    this._viewContainerRef.clear();
  }
  enforceState(created) {
    if (created && !this._created) {
      this.create();
    } else if (!created && this._created) {
      this.destroy();
    }
  }
};
var _NgSwitch = class _NgSwitch {
  constructor() {
    this._defaultViews = [];
    this._defaultUsed = false;
    this._caseCount = 0;
    this._lastCaseCheckIndex = 0;
    this._lastCasesMatched = false;
  }
  set ngSwitch(newValue) {
    this._ngSwitch = newValue;
    if (this._caseCount === 0) {
      this._updateDefaultCases(true);
    }
  }
  /** @internal */
  _addCase() {
    return this._caseCount++;
  }
  /** @internal */
  _addDefault(view) {
    this._defaultViews.push(view);
  }
  /** @internal */
  _matchCase(value) {
    const matched = NG_SWITCH_USE_STRICT_EQUALS ? value === this._ngSwitch : value == this._ngSwitch;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && matched !== (value == this._ngSwitch)) {
      console.warn(formatRuntimeError(2001, `As of Angular v17 the NgSwitch directive uses strict equality comparison === instead of == to match different cases. Previously the case value "${stringifyValue(value)}" matched switch expression value "${stringifyValue(this._ngSwitch)}", but this is no longer the case with the stricter equality check. Your comparison results return different results using === vs. == and you should adjust your ngSwitch expression and / or values to conform with the strict equality requirements.`));
    }
    this._lastCasesMatched ||= matched;
    this._lastCaseCheckIndex++;
    if (this._lastCaseCheckIndex === this._caseCount) {
      this._updateDefaultCases(!this._lastCasesMatched);
      this._lastCaseCheckIndex = 0;
      this._lastCasesMatched = false;
    }
    return matched;
  }
  _updateDefaultCases(useDefault) {
    if (this._defaultViews.length > 0 && useDefault !== this._defaultUsed) {
      this._defaultUsed = useDefault;
      for (const defaultView of this._defaultViews) {
        defaultView.enforceState(useDefault);
      }
    }
  }
};
_NgSwitch.\u0275fac = function NgSwitch_Factory(t3) {
  return new (t3 || _NgSwitch)();
};
_NgSwitch.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgSwitch,
  selectors: [["", "ngSwitch", ""]],
  inputs: {
    ngSwitch: "ngSwitch"
  },
  standalone: true
});
var NgSwitch = _NgSwitch;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitch, [{
    type: Directive,
    args: [{
      selector: "[ngSwitch]",
      standalone: true
    }]
  }], null, {
    ngSwitch: [{
      type: Input
    }]
  });
})();
var _NgSwitchCase = class _NgSwitchCase {
  constructor(viewContainer, templateRef, ngSwitch) {
    this.ngSwitch = ngSwitch;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
      throwNgSwitchProviderNotFoundError("ngSwitchCase", "NgSwitchCase");
    }
    ngSwitch._addCase();
    this._view = new SwitchView(viewContainer, templateRef);
  }
  /**
   * Performs case matching. For internal use only.
   * @nodoc
   */
  ngDoCheck() {
    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
  }
};
_NgSwitchCase.\u0275fac = function NgSwitchCase_Factory(t3) {
  return new (t3 || _NgSwitchCase)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
};
_NgSwitchCase.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgSwitchCase,
  selectors: [["", "ngSwitchCase", ""]],
  inputs: {
    ngSwitchCase: "ngSwitchCase"
  },
  standalone: true
});
var NgSwitchCase = _NgSwitchCase;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchCase, [{
    type: Directive,
    args: [{
      selector: "[ngSwitchCase]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: NgSwitch,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngSwitchCase: [{
      type: Input
    }]
  });
})();
var _NgSwitchDefault = class _NgSwitchDefault {
  constructor(viewContainer, templateRef, ngSwitch) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
      throwNgSwitchProviderNotFoundError("ngSwitchDefault", "NgSwitchDefault");
    }
    ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
  }
};
_NgSwitchDefault.\u0275fac = function NgSwitchDefault_Factory(t3) {
  return new (t3 || _NgSwitchDefault)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
};
_NgSwitchDefault.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgSwitchDefault,
  selectors: [["", "ngSwitchDefault", ""]],
  standalone: true
});
var NgSwitchDefault = _NgSwitchDefault;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchDefault, [{
    type: Directive,
    args: [{
      selector: "[ngSwitchDefault]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: NgSwitch,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], null);
})();
function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
  throw new RuntimeError(2e3, `An element with the "${attrName}" attribute (matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute (matching "NgSwitch" directive)`);
}
function stringifyValue(value) {
  return typeof value === "string" ? `'${value}'` : String(value);
}
var _NgPlural = class _NgPlural {
  constructor(_localization) {
    this._localization = _localization;
    this._caseViews = {};
  }
  set ngPlural(value) {
    this._updateView(value);
  }
  addCase(value, switchView) {
    this._caseViews[value] = switchView;
  }
  _updateView(switchValue) {
    this._clearViews();
    const cases = Object.keys(this._caseViews);
    const key = getPluralCategory(switchValue, cases, this._localization);
    this._activateView(this._caseViews[key]);
  }
  _clearViews() {
    if (this._activeView) this._activeView.destroy();
  }
  _activateView(view) {
    if (view) {
      this._activeView = view;
      this._activeView.create();
    }
  }
};
_NgPlural.\u0275fac = function NgPlural_Factory(t3) {
  return new (t3 || _NgPlural)(\u0275\u0275directiveInject(NgLocalization));
};
_NgPlural.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgPlural,
  selectors: [["", "ngPlural", ""]],
  inputs: {
    ngPlural: "ngPlural"
  },
  standalone: true
});
var NgPlural = _NgPlural;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPlural, [{
    type: Directive,
    args: [{
      selector: "[ngPlural]",
      standalone: true
    }]
  }], () => [{
    type: NgLocalization
  }], {
    ngPlural: [{
      type: Input
    }]
  });
})();
var _NgPluralCase = class _NgPluralCase {
  constructor(value, template, viewContainer, ngPlural) {
    this.value = value;
    const isANumber = !isNaN(Number(value));
    ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
  }
};
_NgPluralCase.\u0275fac = function NgPluralCase_Factory(t3) {
  return new (t3 || _NgPluralCase)(\u0275\u0275injectAttribute("ngPluralCase"), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NgPlural, 1));
};
_NgPluralCase.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgPluralCase,
  selectors: [["", "ngPluralCase", ""]],
  standalone: true
});
var NgPluralCase = _NgPluralCase;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPluralCase, [{
    type: Directive,
    args: [{
      selector: "[ngPluralCase]",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["ngPluralCase"]
    }]
  }, {
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: NgPlural,
    decorators: [{
      type: Host
    }]
  }], null);
})();
var _NgStyle = class _NgStyle {
  constructor(_ngEl, _differs, _renderer) {
    this._ngEl = _ngEl;
    this._differs = _differs;
    this._renderer = _renderer;
    this._ngStyle = null;
    this._differ = null;
  }
  set ngStyle(values) {
    this._ngStyle = values;
    if (!this._differ && values) {
      this._differ = this._differs.find(values).create();
    }
  }
  ngDoCheck() {
    if (this._differ) {
      const changes = this._differ.diff(this._ngStyle);
      if (changes) {
        this._applyChanges(changes);
      }
    }
  }
  _setStyle(nameAndUnit, value) {
    const [name, unit] = nameAndUnit.split(".");
    const flags = name.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value != null) {
      this._renderer.setStyle(this._ngEl.nativeElement, name, unit ? `${value}${unit}` : value, flags);
    } else {
      this._renderer.removeStyle(this._ngEl.nativeElement, name, flags);
    }
  }
  _applyChanges(changes) {
    changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
    changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
    changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
  }
};
_NgStyle.\u0275fac = function NgStyle_Factory(t3) {
  return new (t3 || _NgStyle)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(KeyValueDiffers), \u0275\u0275directiveInject(Renderer2));
};
_NgStyle.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgStyle,
  selectors: [["", "ngStyle", ""]],
  inputs: {
    ngStyle: "ngStyle"
  },
  standalone: true
});
var NgStyle = _NgStyle;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgStyle, [{
    type: Directive,
    args: [{
      selector: "[ngStyle]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: KeyValueDiffers
  }, {
    type: Renderer2
  }], {
    ngStyle: [{
      type: Input,
      args: ["ngStyle"]
    }]
  });
})();
var _NgTemplateOutlet = class _NgTemplateOutlet {
  constructor(_viewContainerRef) {
    this._viewContainerRef = _viewContainerRef;
    this._viewRef = null;
    this.ngTemplateOutletContext = null;
    this.ngTemplateOutlet = null;
    this.ngTemplateOutletInjector = null;
  }
  ngOnChanges(changes) {
    if (this._shouldRecreateView(changes)) {
      const viewContainerRef = this._viewContainerRef;
      if (this._viewRef) {
        viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
      }
      if (!this.ngTemplateOutlet) {
        this._viewRef = null;
        return;
      }
      const viewContext = this._createContextForwardProxy();
      this._viewRef = viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, viewContext, {
        injector: this.ngTemplateOutletInjector ?? void 0
      });
    }
  }
  /**
   * We need to re-create existing embedded view if either is true:
   * - the outlet changed.
   * - the injector changed.
   */
  _shouldRecreateView(changes) {
    return !!changes["ngTemplateOutlet"] || !!changes["ngTemplateOutletInjector"];
  }
  /**
   * For a given outlet instance, we create a proxy object that delegates
   * to the user-specified context. This allows changing, or swapping out
   * the context object completely without having to destroy/re-create the view.
   */
  _createContextForwardProxy() {
    return new Proxy({}, {
      set: (_target, prop, newValue) => {
        if (!this.ngTemplateOutletContext) {
          return false;
        }
        return Reflect.set(this.ngTemplateOutletContext, prop, newValue);
      },
      get: (_target, prop, receiver) => {
        if (!this.ngTemplateOutletContext) {
          return void 0;
        }
        return Reflect.get(this.ngTemplateOutletContext, prop, receiver);
      }
    });
  }
};
_NgTemplateOutlet.\u0275fac = function NgTemplateOutlet_Factory(t3) {
  return new (t3 || _NgTemplateOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
};
_NgTemplateOutlet.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgTemplateOutlet,
  selectors: [["", "ngTemplateOutlet", ""]],
  inputs: {
    ngTemplateOutletContext: "ngTemplateOutletContext",
    ngTemplateOutlet: "ngTemplateOutlet",
    ngTemplateOutletInjector: "ngTemplateOutletInjector"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NgTemplateOutlet = _NgTemplateOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgTemplateOutlet, [{
    type: Directive,
    args: [{
      selector: "[ngTemplateOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], {
    ngTemplateOutletContext: [{
      type: Input
    }],
    ngTemplateOutlet: [{
      type: Input
    }],
    ngTemplateOutletInjector: [{
      type: Input
    }]
  });
})();
var COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];
function invalidPipeArgumentError(type, value) {
  return new RuntimeError(2100, ngDevMode && `InvalidPipeArgument: '${value}' for pipe '${stringify(type)}'`);
}
var SubscribableStrategy = class {
  createSubscription(async, updateLatestValue) {
    return untracked(() => async.subscribe({
      next: updateLatestValue,
      error: (e3) => {
        throw e3;
      }
    }));
  }
  dispose(subscription) {
    untracked(() => subscription.unsubscribe());
  }
};
var PromiseStrategy = class {
  createSubscription(async, updateLatestValue) {
    return async.then(updateLatestValue, (e3) => {
      throw e3;
    });
  }
  dispose(subscription) {
  }
};
var _promiseStrategy = new PromiseStrategy();
var _subscribableStrategy = new SubscribableStrategy();
var _AsyncPipe = class _AsyncPipe {
  constructor(ref) {
    this._latestValue = null;
    this.markForCheckOnValueUpdate = true;
    this._subscription = null;
    this._obj = null;
    this._strategy = null;
    this._ref = ref;
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._dispose();
    }
    this._ref = null;
  }
  transform(obj) {
    if (!this._obj) {
      if (obj) {
        try {
          this.markForCheckOnValueUpdate = false;
          this._subscribe(obj);
        } finally {
          this.markForCheckOnValueUpdate = true;
        }
      }
      return this._latestValue;
    }
    if (obj !== this._obj) {
      this._dispose();
      return this.transform(obj);
    }
    return this._latestValue;
  }
  _subscribe(obj) {
    this._obj = obj;
    this._strategy = this._selectStrategy(obj);
    this._subscription = this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value));
  }
  _selectStrategy(obj) {
    if (isPromise2(obj)) {
      return _promiseStrategy;
    }
    if (isSubscribable(obj)) {
      return _subscribableStrategy;
    }
    throw invalidPipeArgumentError(_AsyncPipe, obj);
  }
  _dispose() {
    this._strategy.dispose(this._subscription);
    this._latestValue = null;
    this._subscription = null;
    this._obj = null;
  }
  _updateLatestValue(async, value) {
    if (async === this._obj) {
      this._latestValue = value;
      if (this.markForCheckOnValueUpdate) {
        this._ref?.markForCheck();
      }
    }
  }
};
_AsyncPipe.\u0275fac = function AsyncPipe_Factory(t3) {
  return new (t3 || _AsyncPipe)(\u0275\u0275directiveInject(ChangeDetectorRef, 16));
};
_AsyncPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "async",
  type: _AsyncPipe,
  pure: false,
  standalone: true
});
var AsyncPipe = _AsyncPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AsyncPipe, [{
    type: Pipe,
    args: [{
      name: "async",
      pure: false,
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], null);
})();
var _LowerCasePipe = class _LowerCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== "string") {
      throw invalidPipeArgumentError(_LowerCasePipe, value);
    }
    return value.toLowerCase();
  }
};
_LowerCasePipe.\u0275fac = function LowerCasePipe_Factory(t3) {
  return new (t3 || _LowerCasePipe)();
};
_LowerCasePipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "lowercase",
  type: _LowerCasePipe,
  pure: true,
  standalone: true
});
var LowerCasePipe = _LowerCasePipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LowerCasePipe, [{
    type: Pipe,
    args: [{
      name: "lowercase",
      standalone: true
    }]
  }], null, null);
})();
var unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
var _TitleCasePipe = class _TitleCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== "string") {
      throw invalidPipeArgumentError(_TitleCasePipe, value);
    }
    return value.replace(unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.slice(1).toLowerCase());
  }
};
_TitleCasePipe.\u0275fac = function TitleCasePipe_Factory(t3) {
  return new (t3 || _TitleCasePipe)();
};
_TitleCasePipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "titlecase",
  type: _TitleCasePipe,
  pure: true,
  standalone: true
});
var TitleCasePipe = _TitleCasePipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleCasePipe, [{
    type: Pipe,
    args: [{
      name: "titlecase",
      standalone: true
    }]
  }], null, null);
})();
var _UpperCasePipe = class _UpperCasePipe {
  transform(value) {
    if (value == null) return null;
    if (typeof value !== "string") {
      throw invalidPipeArgumentError(_UpperCasePipe, value);
    }
    return value.toUpperCase();
  }
};
_UpperCasePipe.\u0275fac = function UpperCasePipe_Factory(t3) {
  return new (t3 || _UpperCasePipe)();
};
_UpperCasePipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "uppercase",
  type: _UpperCasePipe,
  pure: true,
  standalone: true
});
var UpperCasePipe = _UpperCasePipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UpperCasePipe, [{
    type: Pipe,
    args: [{
      name: "uppercase",
      standalone: true
    }]
  }], null, null);
})();
var DEFAULT_DATE_FORMAT = "mediumDate";
var DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_TIMEZONE" : "");
var DATE_PIPE_DEFAULT_OPTIONS = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_OPTIONS" : "");
var _DatePipe = class _DatePipe {
  constructor(locale, defaultTimezone, defaultOptions) {
    this.locale = locale;
    this.defaultTimezone = defaultTimezone;
    this.defaultOptions = defaultOptions;
  }
  transform(value, format, timezone, locale) {
    if (value == null || value === "" || value !== value) return null;
    try {
      const _format = format ?? this.defaultOptions?.dateFormat ?? DEFAULT_DATE_FORMAT;
      const _timezone = timezone ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0;
      return formatDate(value, _format, locale || this.locale, _timezone);
    } catch (error) {
      throw invalidPipeArgumentError(_DatePipe, error.message);
    }
  }
};
_DatePipe.\u0275fac = function DatePipe_Factory(t3) {
  return new (t3 || _DatePipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_OPTIONS, 24));
};
_DatePipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "date",
  type: _DatePipe,
  pure: true,
  standalone: true
});
var DatePipe = _DatePipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePipe, [{
    type: Pipe,
    args: [{
      name: "date",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DATE_PIPE_DEFAULT_TIMEZONE]
    }, {
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DATE_PIPE_DEFAULT_OPTIONS]
    }, {
      type: Optional
    }]
  }], null);
})();
var _INTERPOLATION_REGEXP = /#/g;
var _I18nPluralPipe = class _I18nPluralPipe {
  constructor(_localization) {
    this._localization = _localization;
  }
  /**
   * @param value the number to be formatted
   * @param pluralMap an object that mimics the ICU format, see
   * https://unicode-org.github.io/icu/userguide/format_parse/messages/.
   * @param locale a `string` defining the locale to use (uses the current {@link LOCALE_ID} by
   * default).
   */
  transform(value, pluralMap, locale) {
    if (value == null) return "";
    if (typeof pluralMap !== "object" || pluralMap === null) {
      throw invalidPipeArgumentError(_I18nPluralPipe, pluralMap);
    }
    const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);
    return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
  }
};
_I18nPluralPipe.\u0275fac = function I18nPluralPipe_Factory(t3) {
  return new (t3 || _I18nPluralPipe)(\u0275\u0275directiveInject(NgLocalization, 16));
};
_I18nPluralPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "i18nPlural",
  type: _I18nPluralPipe,
  pure: true,
  standalone: true
});
var I18nPluralPipe = _I18nPluralPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nPluralPipe, [{
    type: Pipe,
    args: [{
      name: "i18nPlural",
      standalone: true
    }]
  }], () => [{
    type: NgLocalization
  }], null);
})();
var _I18nSelectPipe = class _I18nSelectPipe {
  /**
   * @param value a string to be internationalized.
   * @param mapping an object that indicates the text that should be displayed
   * for different values of the provided `value`.
   */
  transform(value, mapping) {
    if (value == null) return "";
    if (typeof mapping !== "object" || typeof value !== "string") {
      throw invalidPipeArgumentError(_I18nSelectPipe, mapping);
    }
    if (mapping.hasOwnProperty(value)) {
      return mapping[value];
    }
    if (mapping.hasOwnProperty("other")) {
      return mapping["other"];
    }
    return "";
  }
};
_I18nSelectPipe.\u0275fac = function I18nSelectPipe_Factory(t3) {
  return new (t3 || _I18nSelectPipe)();
};
_I18nSelectPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "i18nSelect",
  type: _I18nSelectPipe,
  pure: true,
  standalone: true
});
var I18nSelectPipe = _I18nSelectPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nSelectPipe, [{
    type: Pipe,
    args: [{
      name: "i18nSelect",
      standalone: true
    }]
  }], null, null);
})();
var _JsonPipe = class _JsonPipe {
  /**
   * @param value A value of any type to convert into a JSON-format string.
   */
  transform(value) {
    return JSON.stringify(value, null, 2);
  }
};
_JsonPipe.\u0275fac = function JsonPipe_Factory(t3) {
  return new (t3 || _JsonPipe)();
};
_JsonPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "json",
  type: _JsonPipe,
  pure: false,
  standalone: true
});
var JsonPipe = _JsonPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonPipe, [{
    type: Pipe,
    args: [{
      name: "json",
      pure: false,
      standalone: true
    }]
  }], null, null);
})();
function makeKeyValuePair(key, value) {
  return {
    key,
    value
  };
}
var _KeyValuePipe = class _KeyValuePipe {
  constructor(differs) {
    this.differs = differs;
    this.keyValues = [];
    this.compareFn = defaultComparator;
  }
  transform(input2, compareFn = defaultComparator) {
    if (!input2 || !(input2 instanceof Map) && typeof input2 !== "object") {
      return null;
    }
    this.differ ??= this.differs.find(input2).create();
    const differChanges = this.differ.diff(input2);
    const compareFnChanged = compareFn !== this.compareFn;
    if (differChanges) {
      this.keyValues = [];
      differChanges.forEachItem((r3) => {
        this.keyValues.push(makeKeyValuePair(r3.key, r3.currentValue));
      });
    }
    if (differChanges || compareFnChanged) {
      this.keyValues.sort(compareFn);
      this.compareFn = compareFn;
    }
    return this.keyValues;
  }
};
_KeyValuePipe.\u0275fac = function KeyValuePipe_Factory(t3) {
  return new (t3 || _KeyValuePipe)(\u0275\u0275directiveInject(KeyValueDiffers, 16));
};
_KeyValuePipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "keyvalue",
  type: _KeyValuePipe,
  pure: false,
  standalone: true
});
var KeyValuePipe = _KeyValuePipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyValuePipe, [{
    type: Pipe,
    args: [{
      name: "keyvalue",
      pure: false,
      standalone: true
    }]
  }], () => [{
    type: KeyValueDiffers
  }], null);
})();
function defaultComparator(keyValueA, keyValueB) {
  const a3 = keyValueA.key;
  const b3 = keyValueB.key;
  if (a3 === b3) return 0;
  if (a3 === void 0) return 1;
  if (b3 === void 0) return -1;
  if (a3 === null) return 1;
  if (b3 === null) return -1;
  if (typeof a3 == "string" && typeof b3 == "string") {
    return a3 < b3 ? -1 : 1;
  }
  if (typeof a3 == "number" && typeof b3 == "number") {
    return a3 - b3;
  }
  if (typeof a3 == "boolean" && typeof b3 == "boolean") {
    return a3 < b3 ? -1 : 1;
  }
  const aString = String(a3);
  const bString = String(b3);
  return aString == bString ? 0 : aString < bString ? -1 : 1;
}
var _DecimalPipe = class _DecimalPipe {
  constructor(_locale) {
    this._locale = _locale;
  }
  /**
   * @param value The value to be formatted.
   * @param digitsInfo Sets digit and decimal representation.
   * [See more](#digitsinfo).
   * @param locale Specifies what locale format rules to use.
   * [See more](#locale).
   */
  transform(value, digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    try {
      const num = strToNumber(value);
      return formatNumber(num, locale, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_DecimalPipe, error.message);
    }
  }
};
_DecimalPipe.\u0275fac = function DecimalPipe_Factory(t3) {
  return new (t3 || _DecimalPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
};
_DecimalPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "number",
  type: _DecimalPipe,
  pure: true,
  standalone: true
});
var DecimalPipe = _DecimalPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecimalPipe, [{
    type: Pipe,
    args: [{
      name: "number",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var _PercentPipe = class _PercentPipe {
  constructor(_locale) {
    this._locale = _locale;
  }
  /**
   *
   * @param value The number to be formatted as a percentage.
   * @param digitsInfo Decimal representation options, specified by a string
   * in the following format:<br>
   * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
   *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
   * Default is `1`.
   *   - `minFractionDigits`: The minimum number of digits after the decimal point.
   * Default is `0`.
   *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
   * Default is `0`.
   * @param locale A locale code for the locale format rules to use.
   * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
   * See [Setting your app locale](guide/i18n/locale-id).
   */
  transform(value, digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    try {
      const num = strToNumber(value);
      return formatPercent(num, locale, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_PercentPipe, error.message);
    }
  }
};
_PercentPipe.\u0275fac = function PercentPipe_Factory(t3) {
  return new (t3 || _PercentPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
};
_PercentPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "percent",
  type: _PercentPipe,
  pure: true,
  standalone: true
});
var PercentPipe = _PercentPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PercentPipe, [{
    type: Pipe,
    args: [{
      name: "percent",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var _CurrencyPipe = class _CurrencyPipe {
  constructor(_locale, _defaultCurrencyCode = "USD") {
    this._locale = _locale;
    this._defaultCurrencyCode = _defaultCurrencyCode;
  }
  /**
   *
   * @param value The number to be formatted as currency.
   * @param currencyCode The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code,
   * such as `USD` for the US dollar and `EUR` for the euro. The default currency code can be
   * configured using the `DEFAULT_CURRENCY_CODE` injection token.
   * @param display The format for the currency indicator. One of the following:
   *   - `code`: Show the code (such as `USD`).
   *   - `symbol`(default): Show the symbol (such as `$`).
   *   - `symbol-narrow`: Use the narrow symbol for locales that have two symbols for their
   * currency.
   * For example, the Canadian dollar CAD has the symbol `CA$` and the symbol-narrow `$`. If the
   * locale has no narrow symbol, uses the standard symbol for the locale.
   *   - String: Use the given string value instead of a code or a symbol.
   * For example, an empty string will suppress the currency & symbol.
   *   - Boolean (marked deprecated in v5): `true` for symbol and false for `code`.
   *
   * @param digitsInfo Decimal representation options, specified by a string
   * in the following format:<br>
   * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
   *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
   * Default is `1`.
   *   - `minFractionDigits`: The minimum number of digits after the decimal point.
   * Default is `2`.
   *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
   * Default is `2`.
   * If not provided, the number will be formatted with the proper amount of digits,
   * depending on what the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) specifies.
   * For example, the Canadian dollar has 2 digits, whereas the Chilean peso has none.
   * @param locale A locale code for the locale format rules to use.
   * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
   * See [Setting your app locale](guide/i18n/locale-id).
   */
  transform(value, currencyCode = this._defaultCurrencyCode, display = "symbol", digitsInfo, locale) {
    if (!isValue(value)) return null;
    locale ||= this._locale;
    if (typeof display === "boolean") {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && console && console.warn) {
        console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
      }
      display = display ? "symbol" : "code";
    }
    let currency = currencyCode || this._defaultCurrencyCode;
    if (display !== "code") {
      if (display === "symbol" || display === "symbol-narrow") {
        currency = getCurrencySymbol(currency, display === "symbol" ? "wide" : "narrow", locale);
      } else {
        currency = display;
      }
    }
    try {
      const num = strToNumber(value);
      return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_CurrencyPipe, error.message);
    }
  }
};
_CurrencyPipe.\u0275fac = function CurrencyPipe_Factory(t3) {
  return new (t3 || _CurrencyPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DEFAULT_CURRENCY_CODE, 16));
};
_CurrencyPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "currency",
  type: _CurrencyPipe,
  pure: true,
  standalone: true
});
var CurrencyPipe = _CurrencyPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CurrencyPipe, [{
    type: Pipe,
    args: [{
      name: "currency",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DEFAULT_CURRENCY_CODE]
    }]
  }], null);
})();
function isValue(value) {
  return !(value == null || value === "" || value !== value);
}
function strToNumber(value) {
  if (typeof value === "string" && !isNaN(Number(value) - parseFloat(value))) {
    return Number(value);
  }
  if (typeof value !== "number") {
    throw new Error(`${value} is not a number`);
  }
  return value;
}
var _SlicePipe = class _SlicePipe {
  transform(value, start, end) {
    if (value == null) return null;
    if (!this.supports(value)) {
      throw invalidPipeArgumentError(_SlicePipe, value);
    }
    return value.slice(start, end);
  }
  supports(obj) {
    return typeof obj === "string" || Array.isArray(obj);
  }
};
_SlicePipe.\u0275fac = function SlicePipe_Factory(t3) {
  return new (t3 || _SlicePipe)();
};
_SlicePipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "slice",
  type: _SlicePipe,
  pure: false,
  standalone: true
});
var SlicePipe = _SlicePipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SlicePipe, [{
    type: Pipe,
    args: [{
      name: "slice",
      pure: false,
      standalone: true
    }]
  }], null, null);
})();
var COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];
var _CommonModule = class _CommonModule {
};
_CommonModule.\u0275fac = function CommonModule_Factory(t3) {
  return new (t3 || _CommonModule)();
};
_CommonModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _CommonModule
});
_CommonModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var CommonModule = _CommonModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommonModule, [{
    type: NgModule,
    args: [{
      imports: [COMMON_DIRECTIVES, COMMON_PIPES],
      exports: [COMMON_DIRECTIVES, COMMON_PIPES]
    }]
  }], null, null);
})();
var PLATFORM_BROWSER_ID = "browser";
var PLATFORM_SERVER_ID = "server";
function isPlatformBrowser2(platformId) {
  return platformId === PLATFORM_BROWSER_ID;
}
function isPlatformServer(platformId) {
  return platformId === PLATFORM_SERVER_ID;
}
var VERSION2 = new Version("18.0.1");
var _ViewportScroller = class _ViewportScroller {
};
_ViewportScroller.\u0275prov = \u0275\u0275defineInjectable({
  token: _ViewportScroller,
  providedIn: "root",
  factory: () => isPlatformBrowser2(inject(PLATFORM_ID)) ? new BrowserViewportScroller(inject(DOCUMENT2), window) : new NullViewportScroller()
});
var ViewportScroller = _ViewportScroller;
var BrowserViewportScroller = class {
  constructor(document2, window2) {
    this.document = document2;
    this.window = window2;
    this.offset = () => [0, 0];
  }
  /**
   * Configures the top offset used when scrolling to an anchor.
   * @param offset A position in screen coordinates (a tuple with x and y values)
   * or a function that returns the top offset position.
   *
   */
  setOffset(offset) {
    if (Array.isArray(offset)) {
      this.offset = () => offset;
    } else {
      this.offset = offset;
    }
  }
  /**
   * Retrieves the current scroll position.
   * @returns The position in screen coordinates.
   */
  getScrollPosition() {
    return [this.window.scrollX, this.window.scrollY];
  }
  /**
   * Sets the scroll position.
   * @param position The new position in screen coordinates.
   */
  scrollToPosition(position) {
    this.window.scrollTo(position[0], position[1]);
  }
  /**
   * Scrolls to an element and attempts to focus the element.
   *
   * Note that the function name here is misleading in that the target string may be an ID for a
   * non-anchor element.
   *
   * @param target The ID of an element or name of the anchor.
   *
   * @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document
   * @see https://html.spec.whatwg.org/#scroll-to-fragid
   */
  scrollToAnchor(target) {
    const elSelected = findAnchorFromDocument(this.document, target);
    if (elSelected) {
      this.scrollToElement(elSelected);
      elSelected.focus();
    }
  }
  /**
   * Disables automatic scroll restoration provided by the browser.
   */
  setHistoryScrollRestoration(scrollRestoration) {
    this.window.history.scrollRestoration = scrollRestoration;
  }
  /**
   * Scrolls to an element using the native offset and the specified offset set on this scroller.
   *
   * The offset can be used when we know that there is a floating header and scrolling naively to an
   * element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.
   */
  scrollToElement(el) {
    const rect = el.getBoundingClientRect();
    const left = rect.left + this.window.pageXOffset;
    const top = rect.top + this.window.pageYOffset;
    const offset = this.offset();
    this.window.scrollTo(left - offset[0], top - offset[1]);
  }
};
function findAnchorFromDocument(document2, target) {
  const documentResult = document2.getElementById(target) || document2.getElementsByName(target)[0];
  if (documentResult) {
    return documentResult;
  }
  if (typeof document2.createTreeWalker === "function" && document2.body && typeof document2.body.attachShadow === "function") {
    const treeWalker = document2.createTreeWalker(document2.body, NodeFilter.SHOW_ELEMENT);
    let currentNode = treeWalker.currentNode;
    while (currentNode) {
      const shadowRoot = currentNode.shadowRoot;
      if (shadowRoot) {
        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
        if (result) {
          return result;
        }
      }
      currentNode = treeWalker.nextNode();
    }
  }
  return null;
}
var NullViewportScroller = class {
  /**
   * Empty implementation
   */
  setOffset(offset) {
  }
  /**
   * Empty implementation
   */
  getScrollPosition() {
    return [0, 0];
  }
  /**
   * Empty implementation
   */
  scrollToPosition(position) {
  }
  /**
   * Empty implementation
   */
  scrollToAnchor(anchor) {
  }
  /**
   * Empty implementation
   */
  setHistoryScrollRestoration(scrollRestoration) {
  }
};
var XhrFactory = class {
};
var PLACEHOLDER_QUALITY = "20";
function getUrl(src, win) {
  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);
}
function isAbsoluteUrl(src) {
  return /^https?:\/\//.test(src);
}
function extractHostname(url) {
  return isAbsoluteUrl(url) ? new URL(url).hostname : url;
}
function isValidPath(path) {
  const isString = typeof path === "string";
  if (!isString || path.trim() === "") {
    return false;
  }
  try {
    const url = new URL(path);
    return true;
  } catch {
    return false;
  }
}
function normalizePath(path) {
  return path.endsWith("/") ? path.slice(0, -1) : path;
}
function normalizeSrc(src) {
  return src.startsWith("/") ? src.slice(1) : src;
}
var noopImageLoader = (config3) => config3.src;
var IMAGE_LOADER = new InjectionToken(ngDevMode ? "ImageLoader" : "", {
  providedIn: "root",
  factory: () => noopImageLoader
});
function createImageLoader(buildUrlFn, exampleUrls) {
  return function provideImageLoader(path) {
    if (!isValidPath(path)) {
      throwInvalidPathError(path, exampleUrls || []);
    }
    path = normalizePath(path);
    const loaderFn = (config3) => {
      if (isAbsoluteUrl(config3.src)) {
        throwUnexpectedAbsoluteUrlError(path, config3.src);
      }
      return buildUrlFn(path, __spreadProps(__spreadValues({}, config3), {
        src: normalizeSrc(config3.src)
      }));
    };
    const providers = [{
      provide: IMAGE_LOADER,
      useValue: loaderFn
    }];
    return providers;
  };
}
function throwInvalidPathError(path, exampleUrls) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\`${path}\`). To fix this, supply a path using one of the following formats: ${exampleUrls.join(" or ")}`);
}
function throwUnexpectedAbsoluteUrlError(path, url) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected a \`<img>\` tag with an invalid \`ngSrc\` attribute: ${url}. This image loader expects \`ngSrc\` to be a relative URL - however the provided value is an absolute URL. To fix this, provide \`ngSrc\` as a path relative to the base URL configured for this loader (\`${path}\`).`);
}
var provideCloudflareLoader = createImageLoader(createCloudflareUrl, ngDevMode ? ["https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>"] : void 0);
function createCloudflareUrl(path, config3) {
  let params = `format=auto`;
  if (config3.width) {
    params += `,width=${config3.width}`;
  }
  if (config3.isPlaceholder) {
    params += `,quality=${PLACEHOLDER_QUALITY}`;
  }
  return `${path}/cdn-cgi/image/${params}/${config3.src}`;
}
var cloudinaryLoaderInfo = {
  name: "Cloudinary",
  testUrl: isCloudinaryUrl
};
var CLOUDINARY_LOADER_REGEX = /https?\:\/\/[^\/]+\.cloudinary\.com\/.+/;
function isCloudinaryUrl(url) {
  return CLOUDINARY_LOADER_REGEX.test(url);
}
var provideCloudinaryLoader = createImageLoader(createCloudinaryUrl, ngDevMode ? ["https://res.cloudinary.com/mysite", "https://mysite.cloudinary.com", "https://subdomain.mysite.com"] : void 0);
function createCloudinaryUrl(path, config3) {
  const quality = config3.isPlaceholder ? "q_auto:low" : "q_auto";
  let params = `f_auto,${quality}`;
  if (config3.width) {
    params += `,w_${config3.width}`;
  }
  return `${path}/image/upload/${params}/${config3.src}`;
}
var imageKitLoaderInfo = {
  name: "ImageKit",
  testUrl: isImageKitUrl
};
var IMAGE_KIT_LOADER_REGEX = /https?\:\/\/[^\/]+\.imagekit\.io\/.+/;
function isImageKitUrl(url) {
  return IMAGE_KIT_LOADER_REGEX.test(url);
}
var provideImageKitLoader = createImageLoader(createImagekitUrl, ngDevMode ? ["https://ik.imagekit.io/mysite", "https://subdomain.mysite.com"] : void 0);
function createImagekitUrl(path, config3) {
  const {
    src,
    width
  } = config3;
  const params = [];
  if (width) {
    params.push(`w-${width}`);
  }
  if (config3.isPlaceholder) {
    params.push(`q-${PLACEHOLDER_QUALITY}`);
  }
  const urlSegments = params.length ? [path, `tr:${params.join(",")}`, src] : [path, src];
  const url = new URL(urlSegments.join("/"));
  return url.href;
}
var imgixLoaderInfo = {
  name: "Imgix",
  testUrl: isImgixUrl
};
var IMGIX_LOADER_REGEX = /https?\:\/\/[^\/]+\.imgix\.net\/.+/;
function isImgixUrl(url) {
  return IMGIX_LOADER_REGEX.test(url);
}
var provideImgixLoader = createImageLoader(createImgixUrl, ngDevMode ? ["https://somepath.imgix.net/"] : void 0);
function createImgixUrl(path, config3) {
  const url = new URL(`${path}/${config3.src}`);
  url.searchParams.set("auto", "format");
  if (config3.width) {
    url.searchParams.set("w", config3.width.toString());
  }
  if (config3.isPlaceholder) {
    url.searchParams.set("q", PLACEHOLDER_QUALITY);
  }
  return url.href;
}
var netlifyLoaderInfo = {
  name: "Netlify",
  testUrl: isNetlifyUrl
};
var NETLIFY_LOADER_REGEX = /https?\:\/\/[^\/]+\.netlify\.app\/.+/;
function isNetlifyUrl(url) {
  return NETLIFY_LOADER_REGEX.test(url);
}
function imgDirectiveDetails(ngSrc, includeNgSrc = true) {
  const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \`ngSrc="${ngSrc}"\`) ` : "";
  return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;
}
function assertDevMode(checkName) {
  if (!ngDevMode) {
    throw new RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. Please make sure that the prod mode is enabled for production builds.`);
  }
}
var _LCPImageObserver = class _LCPImageObserver {
  constructor() {
    this.images = /* @__PURE__ */ new Map();
    this.window = null;
    this.observer = null;
    assertDevMode("LCP checker");
    const win = inject(DOCUMENT2).defaultView;
    if (typeof win !== "undefined" && typeof PerformanceObserver !== "undefined") {
      this.window = win;
      this.observer = this.initPerformanceObserver();
    }
  }
  /**
   * Inits PerformanceObserver and subscribes to LCP events.
   * Based on https://web.dev/lcp/#measure-lcp-in-javascript
   */
  initPerformanceObserver() {
    const observer = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      if (entries.length === 0) return;
      const lcpElement = entries[entries.length - 1];
      const imgSrc = lcpElement.element?.src ?? "";
      if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:")) return;
      const img = this.images.get(imgSrc);
      if (!img) return;
      if (!img.priority && !img.alreadyWarnedPriority) {
        img.alreadyWarnedPriority = true;
        logMissingPriorityError(imgSrc);
      }
      if (img.modified && !img.alreadyWarnedModified) {
        img.alreadyWarnedModified = true;
        logModifiedWarning(imgSrc);
      }
    });
    observer.observe({
      type: "largest-contentful-paint",
      buffered: true
    });
    return observer;
  }
  registerImage(rewrittenSrc, originalNgSrc, isPriority) {
    if (!this.observer) return;
    const newObservedImageState = {
      priority: isPriority,
      modified: false,
      alreadyWarnedModified: false,
      alreadyWarnedPriority: false
    };
    this.images.set(getUrl(rewrittenSrc, this.window).href, newObservedImageState);
  }
  unregisterImage(rewrittenSrc) {
    if (!this.observer) return;
    this.images.delete(getUrl(rewrittenSrc, this.window).href);
  }
  updateImage(originalSrc, newSrc) {
    const originalUrl = getUrl(originalSrc, this.window).href;
    const img = this.images.get(originalUrl);
    if (img) {
      img.modified = true;
      this.images.set(getUrl(newSrc, this.window).href, img);
      this.images.delete(originalUrl);
    }
  }
  ngOnDestroy() {
    if (!this.observer) return;
    this.observer.disconnect();
    this.images.clear();
  }
};
_LCPImageObserver.\u0275fac = function LCPImageObserver_Factory(t3) {
  return new (t3 || _LCPImageObserver)();
};
_LCPImageObserver.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _LCPImageObserver,
  factory: _LCPImageObserver.\u0275fac,
  providedIn: "root"
});
var LCPImageObserver = _LCPImageObserver;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LCPImageObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function logMissingPriorityError(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.error(formatRuntimeError(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element but was not marked "priority". This image should be marked "priority" in order to prioritize its loading. To fix this, add the "priority" attribute.`));
}
function logModifiedWarning(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.warn(formatRuntimeError(2964, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element and has had its "ngSrc" attribute modified. This can cause slower loading performance. It is recommended not to modify the "ngSrc" property on any image which could be the LCP element.`));
}
var INTERNAL_PRECONNECT_CHECK_BLOCKLIST = /* @__PURE__ */ new Set(["localhost", "127.0.0.1", "0.0.0.0"]);
var PRECONNECT_CHECK_BLOCKLIST = new InjectionToken(ngDevMode ? "PRECONNECT_CHECK_BLOCKLIST" : "");
var _PreconnectLinkChecker = class _PreconnectLinkChecker {
  constructor() {
    this.document = inject(DOCUMENT2);
    this.preconnectLinks = null;
    this.alreadySeen = /* @__PURE__ */ new Set();
    this.window = null;
    this.blocklist = new Set(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);
    assertDevMode("preconnect link checker");
    const win = this.document.defaultView;
    if (typeof win !== "undefined") {
      this.window = win;
    }
    const blocklist = inject(PRECONNECT_CHECK_BLOCKLIST, {
      optional: true
    });
    if (blocklist) {
      this.populateBlocklist(blocklist);
    }
  }
  populateBlocklist(origins) {
    if (Array.isArray(origins)) {
      deepForEach2(origins, (origin) => {
        this.blocklist.add(extractHostname(origin));
      });
    } else {
      this.blocklist.add(extractHostname(origins));
    }
  }
  /**
   * Checks that a preconnect resource hint exists in the head for the
   * given src.
   *
   * @param rewrittenSrc src formatted with loader
   * @param originalNgSrc ngSrc value
   */
  assertPreconnect(rewrittenSrc, originalNgSrc) {
    if (!this.window) return;
    const imgUrl = getUrl(rewrittenSrc, this.window);
    if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin)) return;
    this.alreadySeen.add(imgUrl.origin);
    this.preconnectLinks ??= this.queryPreconnectLinks();
    if (!this.preconnectLinks.has(imgUrl.origin)) {
      console.warn(formatRuntimeError(2956, `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this image. Preconnecting to the origin(s) that serve priority images ensures that these images are delivered as soon as possible. To fix this, please add the following element into the <head> of the document:
  <link rel="preconnect" href="${imgUrl.origin}">`));
    }
  }
  queryPreconnectLinks() {
    const preconnectUrls = /* @__PURE__ */ new Set();
    const selector = "link[rel=preconnect]";
    const links = Array.from(this.document.querySelectorAll(selector));
    for (let link of links) {
      const url = getUrl(link.href, this.window);
      preconnectUrls.add(url.origin);
    }
    return preconnectUrls;
  }
  ngOnDestroy() {
    this.preconnectLinks?.clear();
    this.alreadySeen.clear();
  }
};
_PreconnectLinkChecker.\u0275fac = function PreconnectLinkChecker_Factory(t3) {
  return new (t3 || _PreconnectLinkChecker)();
};
_PreconnectLinkChecker.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PreconnectLinkChecker,
  factory: _PreconnectLinkChecker.\u0275fac,
  providedIn: "root"
});
var PreconnectLinkChecker = _PreconnectLinkChecker;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreconnectLinkChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function deepForEach2(input2, fn) {
  for (let value of input2) {
    Array.isArray(value) ? deepForEach2(value, fn) : fn(value);
  }
}
var DEFAULT_PRELOADED_IMAGES_LIMIT = 5;
var PRELOADED_IMAGES = new InjectionToken("NG_OPTIMIZED_PRELOADED_IMAGES", {
  providedIn: "root",
  factory: () => /* @__PURE__ */ new Set()
});
var _PreloadLinkCreator = class _PreloadLinkCreator {
  constructor() {
    this.preloadedImages = inject(PRELOADED_IMAGES);
    this.document = inject(DOCUMENT2);
  }
  /**
   * @description Add a preload `<link>` to the `<head>` of the `index.html` that is served from the
   * server while using Angular Universal and SSR to kick off image loads for high priority images.
   *
   * The `sizes` (passed in from the user) and `srcset` (parsed and formatted from `ngSrcset`)
   * properties used to set the corresponding attributes, `imagesizes` and `imagesrcset`
   * respectively, on the preload `<link>` tag so that the correctly sized image is preloaded from
   * the CDN.
   *
   * {@link https://web.dev/preload-responsive-images/#imagesrcset-and-imagesizes}
   *
   * @param renderer The `Renderer2` passed in from the directive
   * @param src The original src of the image that is set on the `ngSrc` input.
   * @param srcset The parsed and formatted srcset created from the `ngSrcset` input
   * @param sizes The value of the `sizes` attribute passed in to the `<img>` tag
   */
  createPreloadLinkTag(renderer, src, srcset, sizes) {
    if (ngDevMode) {
      if (this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT) {
        throw new RuntimeError(2961, ngDevMode && `The \`NgOptimizedImage\` directive has detected that more than ${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. This might negatively affect an overall performance of the page. To fix this, remove the "priority" attribute from images with less priority.`);
      }
    }
    if (this.preloadedImages.has(src)) {
      return;
    }
    this.preloadedImages.add(src);
    const preload = renderer.createElement("link");
    renderer.setAttribute(preload, "as", "image");
    renderer.setAttribute(preload, "href", src);
    renderer.setAttribute(preload, "rel", "preload");
    renderer.setAttribute(preload, "fetchpriority", "high");
    if (sizes) {
      renderer.setAttribute(preload, "imageSizes", sizes);
    }
    if (srcset) {
      renderer.setAttribute(preload, "imageSrcset", srcset);
    }
    renderer.appendChild(this.document.head, preload);
  }
};
_PreloadLinkCreator.\u0275fac = function PreloadLinkCreator_Factory(t3) {
  return new (t3 || _PreloadLinkCreator)();
};
_PreloadLinkCreator.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PreloadLinkCreator,
  factory: _PreloadLinkCreator.\u0275fac,
  providedIn: "root"
});
var PreloadLinkCreator = _PreloadLinkCreator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadLinkCreator, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;
var VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\s*\d+w\s*(,|$)){1,})$/;
var VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\s*\d+(\.\d+)?x\s*(,|$)){1,})$/;
var ABSOLUTE_SRCSET_DENSITY_CAP = 3;
var RECOMMENDED_SRCSET_DENSITY_CAP = 2;
var DENSITY_SRCSET_MULTIPLIERS = [1, 2];
var VIEWPORT_BREAKPOINT_CUTOFF = 640;
var ASPECT_RATIO_TOLERANCE = 0.1;
var OVERSIZED_IMAGE_TOLERANCE2 = 1e3;
var FIXED_SRCSET_WIDTH_LIMIT = 1920;
var FIXED_SRCSET_HEIGHT_LIMIT = 1080;
var PLACEHOLDER_BLUR_AMOUNT = 15;
var DATA_URL_WARN_LIMIT = 4e3;
var DATA_URL_ERROR_LIMIT = 1e4;
var BUILT_IN_LOADERS = [imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo, netlifyLoaderInfo];
var _NgOptimizedImage = class _NgOptimizedImage {
  constructor() {
    this.imageLoader = inject(IMAGE_LOADER);
    this.config = processConfig(inject(IMAGE_CONFIG));
    this.renderer = inject(Renderer2);
    this.imgElement = inject(ElementRef).nativeElement;
    this.injector = inject(Injector);
    this.isServer = isPlatformServer(inject(PLATFORM_ID));
    this.preloadLinkCreator = inject(PreloadLinkCreator);
    this.lcpObserver = ngDevMode ? this.injector.get(LCPImageObserver) : null;
    this._renderedSrc = null;
    this.priority = false;
    this.disableOptimizedSrcset = false;
    this.fill = false;
  }
  /** @nodoc */
  ngOnInit() {
    performanceMarkFeature("NgOptimizedImage");
    if (ngDevMode) {
      const ngZone = this.injector.get(NgZone);
      assertNonEmptyInput(this, "ngSrc", this.ngSrc);
      assertValidNgSrcset(this, this.ngSrcset);
      assertNoConflictingSrc(this);
      if (this.ngSrcset) {
        assertNoConflictingSrcset(this);
      }
      assertNotBase64Image(this);
      assertNotBlobUrl(this);
      if (this.fill) {
        assertEmptyWidthAndHeight(this);
        ngZone.runOutsideAngular(() => assertNonZeroRenderedHeight(this, this.imgElement, this.renderer));
      } else {
        assertNonEmptyWidthAndHeight(this);
        if (this.height !== void 0) {
          assertGreaterThanZero(this, this.height, "height");
        }
        if (this.width !== void 0) {
          assertGreaterThanZero(this, this.width, "width");
        }
        ngZone.runOutsideAngular(() => assertNoImageDistortion(this, this.imgElement, this.renderer));
      }
      assertValidLoadingInput(this);
      if (!this.ngSrcset) {
        assertNoComplexSizes(this);
      }
      assertValidPlaceholder(this, this.imageLoader);
      assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);
      assertNoNgSrcsetWithoutLoader(this, this.imageLoader);
      assertNoLoaderParamsWithoutLoader(this, this.imageLoader);
      if (this.lcpObserver !== null) {
        const ngZone2 = this.injector.get(NgZone);
        ngZone2.runOutsideAngular(() => {
          this.lcpObserver.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);
        });
      }
      if (this.priority) {
        const checker = this.injector.get(PreconnectLinkChecker);
        checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);
      }
    }
    if (this.placeholder) {
      this.removePlaceholderOnLoad(this.imgElement);
    }
    this.setHostAttributes();
  }
  setHostAttributes() {
    if (this.fill) {
      this.sizes ||= "100vw";
    } else {
      this.setHostAttribute("width", this.width.toString());
      this.setHostAttribute("height", this.height.toString());
    }
    this.setHostAttribute("loading", this.getLoadingBehavior());
    this.setHostAttribute("fetchpriority", this.getFetchPriority());
    this.setHostAttribute("ng-img", "true");
    const rewrittenSrcset = this.updateSrcAndSrcset();
    if (this.sizes) {
      this.setHostAttribute("sizes", this.sizes);
    }
    if (this.isServer && this.priority) {
      this.preloadLinkCreator.createPreloadLinkTag(this.renderer, this.getRewrittenSrc(), rewrittenSrcset, this.sizes);
    }
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (ngDevMode) {
      assertNoPostInitInputChange(this, changes, ["ngSrcset", "width", "height", "priority", "fill", "loading", "sizes", "loaderParams", "disableOptimizedSrcset"]);
    }
    if (changes["ngSrc"] && !changes["ngSrc"].isFirstChange()) {
      const oldSrc = this._renderedSrc;
      this.updateSrcAndSrcset(true);
      const newSrc = this._renderedSrc;
      if (this.lcpObserver !== null && oldSrc && newSrc && oldSrc !== newSrc) {
        const ngZone = this.injector.get(NgZone);
        ngZone.runOutsideAngular(() => {
          this.lcpObserver?.updateImage(oldSrc, newSrc);
        });
      }
    }
  }
  callImageLoader(configWithoutCustomParams) {
    let augmentedConfig = configWithoutCustomParams;
    if (this.loaderParams) {
      augmentedConfig.loaderParams = this.loaderParams;
    }
    return this.imageLoader(augmentedConfig);
  }
  getLoadingBehavior() {
    if (!this.priority && this.loading !== void 0) {
      return this.loading;
    }
    return this.priority ? "eager" : "lazy";
  }
  getFetchPriority() {
    return this.priority ? "high" : "auto";
  }
  getRewrittenSrc() {
    if (!this._renderedSrc) {
      const imgConfig = {
        src: this.ngSrc
      };
      this._renderedSrc = this.callImageLoader(imgConfig);
    }
    return this._renderedSrc;
  }
  getRewrittenSrcset() {
    const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);
    const finalSrcs = this.ngSrcset.split(",").filter((src) => src !== "").map((srcStr) => {
      srcStr = srcStr.trim();
      const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width;
      return `${this.callImageLoader({
        src: this.ngSrc,
        width
      })} ${srcStr}`;
    });
    return finalSrcs.join(", ");
  }
  getAutomaticSrcset() {
    if (this.sizes) {
      return this.getResponsiveSrcset();
    } else {
      return this.getFixedSrcset();
    }
  }
  getResponsiveSrcset() {
    const {
      breakpoints
    } = this.config;
    let filteredBreakpoints = breakpoints;
    if (this.sizes?.trim() === "100vw") {
      filteredBreakpoints = breakpoints.filter((bp) => bp >= VIEWPORT_BREAKPOINT_CUTOFF);
    }
    const finalSrcs = filteredBreakpoints.map((bp) => `${this.callImageLoader({
      src: this.ngSrc,
      width: bp
    })} ${bp}w`);
    return finalSrcs.join(", ");
  }
  updateSrcAndSrcset(forceSrcRecalc = false) {
    if (forceSrcRecalc) {
      this._renderedSrc = null;
    }
    const rewrittenSrc = this.getRewrittenSrc();
    this.setHostAttribute("src", rewrittenSrc);
    let rewrittenSrcset = void 0;
    if (this.ngSrcset) {
      rewrittenSrcset = this.getRewrittenSrcset();
    } else if (this.shouldGenerateAutomaticSrcset()) {
      rewrittenSrcset = this.getAutomaticSrcset();
    }
    if (rewrittenSrcset) {
      this.setHostAttribute("srcset", rewrittenSrcset);
    }
    return rewrittenSrcset;
  }
  getFixedSrcset() {
    const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map((multiplier) => `${this.callImageLoader({
      src: this.ngSrc,
      width: this.width * multiplier
    })} ${multiplier}x`);
    return finalSrcs.join(", ");
  }
  shouldGenerateAutomaticSrcset() {
    let oversizedImage = false;
    if (!this.sizes) {
      oversizedImage = this.width > FIXED_SRCSET_WIDTH_LIMIT || this.height > FIXED_SRCSET_HEIGHT_LIMIT;
    }
    return !this.disableOptimizedSrcset && !this.srcset && this.imageLoader !== noopImageLoader && !oversizedImage;
  }
  /**
   * Returns an image url formatted for use with the CSS background-image property. Expects one of:
   * * A base64 encoded image, which is wrapped and passed through.
   * * A boolean. If true, calls the image loader to generate a small placeholder url.
   */
  generatePlaceholder(placeholderInput) {
    const {
      placeholderResolution
    } = this.config;
    if (placeholderInput === true) {
      return `url(${this.callImageLoader({
        src: this.ngSrc,
        width: placeholderResolution,
        isPlaceholder: true
      })})`;
    } else if (typeof placeholderInput === "string" && placeholderInput.startsWith("data:")) {
      return `url(${placeholderInput})`;
    }
    return null;
  }
  /**
   * Determines if blur should be applied, based on an optional boolean
   * property `blur` within the optional configuration object `placeholderConfig`.
   */
  shouldBlurPlaceholder(placeholderConfig) {
    if (!placeholderConfig || !placeholderConfig.hasOwnProperty("blur")) {
      return true;
    }
    return Boolean(placeholderConfig.blur);
  }
  removePlaceholderOnLoad(img) {
    const callback = () => {
      const changeDetectorRef = this.injector.get(ChangeDetectorRef);
      removeLoadListenerFn();
      removeErrorListenerFn();
      this.placeholder = false;
      changeDetectorRef.markForCheck();
    };
    const removeLoadListenerFn = this.renderer.listen(img, "load", callback);
    const removeErrorListenerFn = this.renderer.listen(img, "error", callback);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (ngDevMode) {
      if (!this.priority && this._renderedSrc !== null && this.lcpObserver !== null) {
        this.lcpObserver.unregisterImage(this._renderedSrc);
      }
    }
  }
  setHostAttribute(name, value) {
    this.renderer.setAttribute(this.imgElement, name, value);
  }
};
_NgOptimizedImage.\u0275fac = function NgOptimizedImage_Factory(t3) {
  return new (t3 || _NgOptimizedImage)();
};
_NgOptimizedImage.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgOptimizedImage,
  selectors: [["img", "ngSrc", ""]],
  hostVars: 18,
  hostBindings: function NgOptimizedImage_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("position", ctx.fill ? "absolute" : null)("width", ctx.fill ? "100%" : null)("height", ctx.fill ? "100%" : null)("inset", ctx.fill ? "0" : null)("background-size", ctx.placeholder ? "cover" : null)("background-position", ctx.placeholder ? "50% 50%" : null)("background-repeat", ctx.placeholder ? "no-repeat" : null)("background-image", ctx.placeholder ? ctx.generatePlaceholder(ctx.placeholder) : null)("filter", ctx.placeholder && ctx.shouldBlurPlaceholder(ctx.placeholderConfig) ? "blur(15px)" : null);
    }
  },
  inputs: {
    ngSrc: [2, "ngSrc", "ngSrc", unwrapSafeUrl],
    ngSrcset: "ngSrcset",
    sizes: "sizes",
    width: [2, "width", "width", numberAttribute],
    height: [2, "height", "height", numberAttribute],
    loading: "loading",
    priority: [2, "priority", "priority", booleanAttribute],
    loaderParams: "loaderParams",
    disableOptimizedSrcset: [2, "disableOptimizedSrcset", "disableOptimizedSrcset", booleanAttribute],
    fill: [2, "fill", "fill", booleanAttribute],
    placeholder: [2, "placeholder", "placeholder", booleanOrDataUrlAttribute],
    placeholderConfig: "placeholderConfig",
    src: "src",
    srcset: "srcset"
  },
  standalone: true,
  features: [\u0275\u0275InputTransformsFeature, \u0275\u0275NgOnChangesFeature]
});
var NgOptimizedImage = _NgOptimizedImage;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgOptimizedImage, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "img[ngSrc]",
      host: {
        "[style.position]": 'fill ? "absolute" : null',
        "[style.width]": 'fill ? "100%" : null',
        "[style.height]": 'fill ? "100%" : null',
        "[style.inset]": 'fill ? "0" : null',
        "[style.background-size]": 'placeholder ? "cover" : null',
        "[style.background-position]": 'placeholder ? "50% 50%" : null',
        "[style.background-repeat]": 'placeholder ? "no-repeat" : null',
        "[style.background-image]": "placeholder ? generatePlaceholder(placeholder) : null",
        "[style.filter]": `placeholder && shouldBlurPlaceholder(placeholderConfig) ? "blur(${PLACEHOLDER_BLUR_AMOUNT}px)" : null`
      }
    }]
  }], null, {
    ngSrc: [{
      type: Input,
      args: [{
        required: true,
        transform: unwrapSafeUrl
      }]
    }],
    ngSrcset: [{
      type: Input
    }],
    sizes: [{
      type: Input
    }],
    width: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    height: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    loading: [{
      type: Input
    }],
    priority: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    loaderParams: [{
      type: Input
    }],
    disableOptimizedSrcset: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    fill: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    placeholder: [{
      type: Input,
      args: [{
        transform: booleanOrDataUrlAttribute
      }]
    }],
    placeholderConfig: [{
      type: Input
    }],
    src: [{
      type: Input
    }],
    srcset: [{
      type: Input
    }]
  });
})();
function processConfig(config3) {
  let sortedBreakpoints = {};
  if (config3.breakpoints) {
    sortedBreakpoints.breakpoints = config3.breakpoints.sort((a3, b3) => a3 - b3);
  }
  return Object.assign({}, IMAGE_CONFIG_DEFAULTS, config3, sortedBreakpoints);
}
function assertNoConflictingSrc(dir) {
  if (dir.src) {
    throw new RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \`src\` and \`ngSrc\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`src\` itself based on the value of \`ngSrc\`. To fix this, please remove the \`src\` attribute.`);
  }
}
function assertNoConflictingSrcset(dir) {
  if (dir.srcset) {
    throw new RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \`srcset\` and \`ngSrcset\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`srcset\` itself based on the value of \`ngSrcset\`. To fix this, please remove the \`srcset\` attribute.`);
  }
}
function assertNotBase64Image(dir) {
  let ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("data:")) {
    if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {
      ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + "...";
    }
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`ngSrc\` is a Base64-encoded string (${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a standard \`src\` attribute instead.`);
  }
}
function assertNoComplexSizes(dir) {
  let sizes = dir.sizes;
  if (sizes?.match(/((\)|,)\s|^)\d+px/)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`sizes\` was set to a string including pixel values. For automatic \`srcset\` generation, \`sizes\` must only include responsive values, such as \`sizes="50vw"\` or \`sizes="(min-width: 768px) 50vw, 100vw"\`. To fix this, modify the \`sizes\` attribute, or provide your own \`ngSrcset\` value directly.`);
  }
}
function assertValidPlaceholder(dir, imageLoader) {
  assertNoPlaceholderConfigWithoutPlaceholder(dir);
  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);
  assertNoOversizedDataUrl(dir);
}
function assertNoPlaceholderConfigWithoutPlaceholder(dir) {
  if (dir.placeholderConfig && !dir.placeholder) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`placeholderConfig\` options were provided for an image that does not use the \`placeholder\` attribute, and will have no effect.`);
  }
}
function assertNoRelativePlaceholderWithoutLoader(dir, imageLoader) {
  if (dir.placeholder === true && imageLoader === noopImageLoader) {
    throw new RuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to true but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for the primary image and its placeholder. To fix this, provide a loader or remove the \`placeholder\` attribute from the image.`);
  }
}
function assertNoOversizedDataUrl(dir) {
  if (dir.placeholder && typeof dir.placeholder === "string" && dir.placeholder.startsWith("data:")) {
    if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {
      throw new RuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. To fix this, generate a smaller data URL placeholder.`);
    }
    if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {
      console.warn(formatRuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. For better loading performance, generate a smaller data URL placeholder.`));
    }
  }
}
function assertNotBlobUrl(dir) {
  const ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("blob:")) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrc\` was set to a blob URL (${ngSrc}). Blob URLs are not supported by the NgOptimizedImage directive. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a regular \`src\` attribute instead.`);
  }
}
function assertNonEmptyInput(dir, name, value) {
  const isString = typeof value === "string";
  const isEmptyString = isString && value.trim() === "";
  if (!isString || isEmptyString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${name}\` has an invalid value (\`${value}\`). To fix this, change the value to a non-empty string.`);
  }
}
function assertValidNgSrcset(dir, value) {
  if (value == null) return;
  assertNonEmptyInput(dir, "ngSrcset", value);
  const stringVal = value;
  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);
  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);
  if (isValidDensityDescriptor) {
    assertUnderDensityCap(dir, stringVal);
  }
  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;
  if (!isValidSrcset) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrcset\` has an invalid value (\`${value}\`). To fix this, supply \`ngSrcset\` using a comma-separated list of one or more width descriptors (e.g. "100w, 200w") or density descriptors (e.g. "1x, 2x").`);
  }
}
function assertUnderDensityCap(dir, value) {
  const underDensityCap = value.split(",").every((num) => num === "" || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);
  if (!underDensityCap) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` contains an unsupported image density:\`${value}\`. NgOptimizedImage generally recommends a max image density of ${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for most use cases. Images that will be pinch-zoomed are typically the primary use case for ${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);
  }
}
function postInitInputChangeError(dir, inputName) {
  let reason;
  if (inputName === "width" || inputName === "height") {
    reason = `Changing \`${inputName}\` may result in different attribute value applied to the underlying image element and cause layout shifts on a page.`;
  } else {
    reason = `Changing the \`${inputName}\` would have no effect on the underlying image element, because the resource loading has already occurred.`;
  }
  return new RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` was updated after initialization. The NgOptimizedImage directive will not react to this input change. ${reason} To fix this, either switch \`${inputName}\` to a static value or wrap the image element in an *ngIf that is gated on the necessary value.`);
}
function assertNoPostInitInputChange(dir, changes, inputs) {
  inputs.forEach((input2) => {
    const isUpdated = changes.hasOwnProperty(input2);
    if (isUpdated && !changes[input2].isFirstChange()) {
      if (input2 === "ngSrc") {
        dir = {
          ngSrc: changes[input2].previousValue
        };
      }
      throw postInitInputChangeError(dir, input2);
    }
  });
}
function assertGreaterThanZero(dir, inputValue, inputName) {
  const validNumber = typeof inputValue === "number" && inputValue > 0;
  const validString = typeof inputValue === "string" && /^\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;
  if (!validNumber && !validString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` has an invalid value. To fix this, provide \`${inputName}\` as a number greater than 0.`);
  }
}
function assertNoImageDistortion(dir, img, renderer) {
  const removeLoadListenerFn = renderer.listen(img, "load", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const computedStyle = window.getComputedStyle(img);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
    const boxSizing = computedStyle.getPropertyValue("box-sizing");
    if (boxSizing === "border-box") {
      const paddingTop = computedStyle.getPropertyValue("padding-top");
      const paddingRight = computedStyle.getPropertyValue("padding-right");
      const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
      const paddingLeft = computedStyle.getPropertyValue("padding-left");
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const renderedAspectRatio = renderedWidth / renderedHeight;
    const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;
    const intrinsicWidth = img.naturalWidth;
    const intrinsicHeight = img.naturalHeight;
    const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;
    const suppliedWidth = dir.width;
    const suppliedHeight = dir.height;
    const suppliedAspectRatio = suppliedWidth / suppliedHeight;
    const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;
    const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;
    if (inaccurateDimensions) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match the aspect ratio indicated by the width and height attributes. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Supplied width and height attributes: ${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(suppliedAspectRatio)}). 
To fix this, update the width and height attributes.`));
    } else if (stylingDistortion) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image does not match the image's intrinsic aspect ratio. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ${round(renderedAspectRatio)}). 
This issue can occur if "width" and "height" attributes are added to an image without updating the corresponding image styling. To fix this, adjust image styling. In most cases, adding "height: auto" or "width: auto" to the image styling will fix this issue.`));
    } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {
      const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;
      const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;
      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE2;
      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE2;
      if (oversizedWidth || oversizedHeight) {
        console.warn(formatRuntimeError(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly larger than necessary. 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. 
Recommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. 
Note: Recommended intrinsic image size is calculated assuming a maximum DPR of ${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image or consider using the "ngSrcset" and "sizes" attributes.`));
      }
    }
  });
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
}
function assertNonEmptyWidthAndHeight(dir) {
  let missingAttributes = [];
  if (dir.width === void 0) missingAttributes.push("width");
  if (dir.height === void 0) missingAttributes.push("height");
  if (missingAttributes.length > 0) {
    throw new RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes are missing: ${missingAttributes.map((attr) => `"${attr}"`).join(", ")}. Including "width" and "height" attributes will prevent image-related layout shifts. To fix this, include "width" and "height" attributes on the image tag or turn on "fill" mode with the \`fill\` attribute.`);
  }
}
function assertEmptyWidthAndHeight(dir) {
  if (dir.width || dir.height) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \`height\` and/or \`width\` are present along with the \`fill\` attribute. Because \`fill\` mode causes an image to fill its containing element, the size attributes have no effect and should be removed.`);
  }
}
function assertNonZeroRenderedHeight(dir, img, renderer) {
  const removeLoadListenerFn = renderer.listen(img, "load", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const renderedHeight = img.clientHeight;
    if (dir.fill && renderedHeight === 0) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. This is likely because the containing element does not have the CSS 'position' property set to one of the following: "relative", "fixed", or "absolute". To fix this problem, make sure the container element has the CSS 'position' property defined and the height of the element is not zero.`));
    }
  });
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
}
function assertValidLoadingInput(dir) {
  if (dir.loading && dir.priority) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute was used on an image that was marked "priority". Setting \`loading\` on priority images is not allowed because these images will always be eagerly loaded. To fix this, remove the \u201Cloading\u201D attribute from the priority image.`);
  }
  const validInputs = ["auto", "eager", "lazy"];
  if (typeof dir.loading === "string" && !validInputs.includes(dir.loading)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute has an invalid value (\`${dir.loading}\`). To fix this, provide a valid value ("lazy", "eager", or "auto").`);
  }
}
function assertNotMissingBuiltInLoader(ngSrc, imageLoader) {
  if (imageLoader === noopImageLoader) {
    let builtInLoaderName = "";
    for (const loader of BUILT_IN_LOADERS) {
      if (loader.testUrl(ngSrc)) {
        builtInLoaderName = loader.name;
        break;
      }
    }
    if (builtInLoaderName) {
      console.warn(formatRuntimeError(2962, `NgOptimizedImage: It looks like your images may be hosted on the ${builtInLoaderName} CDN, but your app is not using Angular's built-in loader for that CDN. We recommend switching to use the built-in by calling \`provide${builtInLoaderName}Loader()\` in your \`providers\` and passing it your instance's base URL. If you don't want to use the built-in loader, define a custom loader function using IMAGE_LOADER to silence this warning.`));
    }
  }
}
function assertNoNgSrcsetWithoutLoader(dir, imageLoader) {
  if (dir.ngSrcset && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` attribute is present but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for all configured sizes. To fix this, provide a loader or remove the \`ngSrcset\` attribute from the image.`));
  }
}
function assertNoLoaderParamsWithoutLoader(dir, imageLoader) {
  if (dir.loaderParams && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`loaderParams\` attribute is present but no image loader is configured (i.e. the default one is being used), which means that the loaderParams data will not be consumed and will not affect the URL. To fix this, provide a custom loader or remove the \`loaderParams\` attribute from the image.`));
  }
}
function round(input2) {
  return Number.isInteger(input2) ? input2 : input2.toFixed(2);
}
function unwrapSafeUrl(value) {
  if (typeof value === "string") {
    return value;
  }
  return unwrapSafeValue(value);
}
function booleanOrDataUrlAttribute(value) {
  if (typeof value === "string" && value.startsWith(`data:`)) {
    return value;
  }
  return booleanAttribute(value);
}

// node_modules/@angular/common/fesm2022/http.mjs
var HttpHandler = class {
};
var HttpBackend = class {
};
var HttpHeaders = class _HttpHeaders {
  /**  Constructs a new HTTP header object with the given values.*/
  constructor(headers) {
    this.normalizedNames = /* @__PURE__ */ new Map();
    this.lazyUpdate = null;
    if (!headers) {
      this.headers = /* @__PURE__ */ new Map();
    } else if (typeof headers === "string") {
      this.lazyInit = () => {
        this.headers = /* @__PURE__ */ new Map();
        headers.split("\n").forEach((line) => {
          const index3 = line.indexOf(":");
          if (index3 > 0) {
            const name = line.slice(0, index3);
            const key = name.toLowerCase();
            const value = line.slice(index3 + 1).trim();
            this.maybeSetNormalizedName(name, key);
            if (this.headers.has(key)) {
              this.headers.get(key).push(value);
            } else {
              this.headers.set(key, [value]);
            }
          }
        });
      };
    } else if (typeof Headers !== "undefined" && headers instanceof Headers) {
      this.headers = /* @__PURE__ */ new Map();
      headers.forEach((values, name) => {
        this.setHeaderEntries(name, values);
      });
    } else {
      this.lazyInit = () => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          assertValidHeaders(headers);
        }
        this.headers = /* @__PURE__ */ new Map();
        Object.entries(headers).forEach(([name, values]) => {
          this.setHeaderEntries(name, values);
        });
      };
    }
  }
  /**
   * Checks for existence of a given header.
   *
   * @param name The header name to check for existence.
   *
   * @returns True if the header exists, false otherwise.
   */
  has(name) {
    this.init();
    return this.headers.has(name.toLowerCase());
  }
  /**
   * Retrieves the first value of a given header.
   *
   * @param name The header name.
   *
   * @returns The value string if the header exists, null otherwise
   */
  get(name) {
    this.init();
    const values = this.headers.get(name.toLowerCase());
    return values && values.length > 0 ? values[0] : null;
  }
  /**
   * Retrieves the names of the headers.
   *
   * @returns A list of header names.
   */
  keys() {
    this.init();
    return Array.from(this.normalizedNames.values());
  }
  /**
   * Retrieves a list of values for a given header.
   *
   * @param name The header name from which to retrieve values.
   *
   * @returns A string of values if the header exists, null otherwise.
   */
  getAll(name) {
    this.init();
    return this.headers.get(name.toLowerCase()) || null;
  }
  /**
   * Appends a new value to the existing set of values for a header
   * and returns them in a clone of the original instance.
   *
   * @param name The header name for which to append the values.
   * @param value The value to append.
   *
   * @returns A clone of the HTTP headers object with the value appended to the given header.
   */
  append(name, value) {
    return this.clone({
      name,
      value,
      op: "a"
    });
  }
  /**
   * Sets or modifies a value for a given header in a clone of the original instance.
   * If the header already exists, its value is replaced with the given value
   * in the returned object.
   *
   * @param name The header name.
   * @param value The value or values to set or override for the given header.
   *
   * @returns A clone of the HTTP headers object with the newly set header value.
   */
  set(name, value) {
    return this.clone({
      name,
      value,
      op: "s"
    });
  }
  /**
   * Deletes values for a given header in a clone of the original instance.
   *
   * @param name The header name.
   * @param value The value or values to delete for the given header.
   *
   * @returns A clone of the HTTP headers object with the given value deleted.
   */
  delete(name, value) {
    return this.clone({
      name,
      value,
      op: "d"
    });
  }
  maybeSetNormalizedName(name, lcName) {
    if (!this.normalizedNames.has(lcName)) {
      this.normalizedNames.set(lcName, name);
    }
  }
  init() {
    if (!!this.lazyInit) {
      if (this.lazyInit instanceof _HttpHeaders) {
        this.copyFrom(this.lazyInit);
      } else {
        this.lazyInit();
      }
      this.lazyInit = null;
      if (!!this.lazyUpdate) {
        this.lazyUpdate.forEach((update) => this.applyUpdate(update));
        this.lazyUpdate = null;
      }
    }
  }
  copyFrom(other) {
    other.init();
    Array.from(other.headers.keys()).forEach((key) => {
      this.headers.set(key, other.headers.get(key));
      this.normalizedNames.set(key, other.normalizedNames.get(key));
    });
  }
  clone(update) {
    const clone = new _HttpHeaders();
    clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof _HttpHeaders ? this.lazyInit : this;
    clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
    return clone;
  }
  applyUpdate(update) {
    const key = update.name.toLowerCase();
    switch (update.op) {
      case "a":
      case "s":
        let value = update.value;
        if (typeof value === "string") {
          value = [value];
        }
        if (value.length === 0) {
          return;
        }
        this.maybeSetNormalizedName(update.name, key);
        const base = (update.op === "a" ? this.headers.get(key) : void 0) || [];
        base.push(...value);
        this.headers.set(key, base);
        break;
      case "d":
        const toDelete = update.value;
        if (!toDelete) {
          this.headers.delete(key);
          this.normalizedNames.delete(key);
        } else {
          let existing = this.headers.get(key);
          if (!existing) {
            return;
          }
          existing = existing.filter((value2) => toDelete.indexOf(value2) === -1);
          if (existing.length === 0) {
            this.headers.delete(key);
            this.normalizedNames.delete(key);
          } else {
            this.headers.set(key, existing);
          }
        }
        break;
    }
  }
  setHeaderEntries(name, values) {
    const headerValues = (Array.isArray(values) ? values : [values]).map((value) => value.toString());
    const key = name.toLowerCase();
    this.headers.set(key, headerValues);
    this.maybeSetNormalizedName(name, key);
  }
  /**
   * @internal
   */
  forEach(fn) {
    this.init();
    Array.from(this.normalizedNames.keys()).forEach((key) => fn(this.normalizedNames.get(key), this.headers.get(key)));
  }
};
function assertValidHeaders(headers) {
  for (const [key, value] of Object.entries(headers)) {
    if (!(typeof value === "string" || typeof value === "number") && !Array.isArray(value)) {
      throw new Error(`Unexpected value of the \`${key}\` header provided. Expecting either a string, a number or an array, but got: \`${value}\`.`);
    }
  }
}
var HttpUrlEncodingCodec = class {
  /**
   * Encodes a key name for a URL parameter or query-string.
   * @param key The key name.
   * @returns The encoded key name.
   */
  encodeKey(key) {
    return standardEncoding(key);
  }
  /**
   * Encodes the value of a URL parameter or query-string.
   * @param value The value.
   * @returns The encoded value.
   */
  encodeValue(value) {
    return standardEncoding(value);
  }
  /**
   * Decodes an encoded URL parameter or query-string key.
   * @param key The encoded key name.
   * @returns The decoded key name.
   */
  decodeKey(key) {
    return decodeURIComponent(key);
  }
  /**
   * Decodes an encoded URL parameter or query-string value.
   * @param value The encoded value.
   * @returns The decoded value.
   */
  decodeValue(value) {
    return decodeURIComponent(value);
  }
};
function paramParser(rawParams, codec) {
  const map2 = /* @__PURE__ */ new Map();
  if (rawParams.length > 0) {
    const params = rawParams.replace(/^\?/, "").split("&");
    params.forEach((param) => {
      const eqIdx = param.indexOf("=");
      const [key, val] = eqIdx == -1 ? [codec.decodeKey(param), ""] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];
      const list = map2.get(key) || [];
      list.push(val);
      map2.set(key, list);
    });
  }
  return map2;
}
var STANDARD_ENCODING_REGEX = /%(\d[a-f0-9])/gi;
var STANDARD_ENCODING_REPLACEMENTS = {
  "40": "@",
  "3A": ":",
  "24": "$",
  "2C": ",",
  "3B": ";",
  "3D": "=",
  "3F": "?",
  "2F": "/"
};
function standardEncoding(v3) {
  return encodeURIComponent(v3).replace(STANDARD_ENCODING_REGEX, (s3, t3) => STANDARD_ENCODING_REPLACEMENTS[t3] ?? s3);
}
function valueToString(value) {
  return `${value}`;
}
var HttpParams = class _HttpParams {
  constructor(options = {}) {
    this.updates = null;
    this.cloneFrom = null;
    this.encoder = options.encoder || new HttpUrlEncodingCodec();
    if (!!options.fromString) {
      if (!!options.fromObject) {
        throw new Error(`Cannot specify both fromString and fromObject.`);
      }
      this.map = paramParser(options.fromString, this.encoder);
    } else if (!!options.fromObject) {
      this.map = /* @__PURE__ */ new Map();
      Object.keys(options.fromObject).forEach((key) => {
        const value = options.fromObject[key];
        const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];
        this.map.set(key, values);
      });
    } else {
      this.map = null;
    }
  }
  /**
   * Reports whether the body includes one or more values for a given parameter.
   * @param param The parameter name.
   * @returns True if the parameter has one or more values,
   * false if it has no value or is not present.
   */
  has(param) {
    this.init();
    return this.map.has(param);
  }
  /**
   * Retrieves the first value for a parameter.
   * @param param The parameter name.
   * @returns The first value of the given parameter,
   * or `null` if the parameter is not present.
   */
  get(param) {
    this.init();
    const res = this.map.get(param);
    return !!res ? res[0] : null;
  }
  /**
   * Retrieves all values for a  parameter.
   * @param param The parameter name.
   * @returns All values in a string array,
   * or `null` if the parameter not present.
   */
  getAll(param) {
    this.init();
    return this.map.get(param) || null;
  }
  /**
   * Retrieves all the parameters for this body.
   * @returns The parameter names in a string array.
   */
  keys() {
    this.init();
    return Array.from(this.map.keys());
  }
  /**
   * Appends a new value to existing values for a parameter.
   * @param param The parameter name.
   * @param value The new value to add.
   * @return A new body with the appended value.
   */
  append(param, value) {
    return this.clone({
      param,
      value,
      op: "a"
    });
  }
  /**
   * Constructs a new body with appended values for the given parameter name.
   * @param params parameters and values
   * @return A new body with the new value.
   */
  appendAll(params) {
    const updates = [];
    Object.keys(params).forEach((param) => {
      const value = params[param];
      if (Array.isArray(value)) {
        value.forEach((_value) => {
          updates.push({
            param,
            value: _value,
            op: "a"
          });
        });
      } else {
        updates.push({
          param,
          value,
          op: "a"
        });
      }
    });
    return this.clone(updates);
  }
  /**
   * Replaces the value for a parameter.
   * @param param The parameter name.
   * @param value The new value.
   * @return A new body with the new value.
   */
  set(param, value) {
    return this.clone({
      param,
      value,
      op: "s"
    });
  }
  /**
   * Removes a given value or all values from a parameter.
   * @param param The parameter name.
   * @param value The value to remove, if provided.
   * @return A new body with the given value removed, or with all values
   * removed if no value is specified.
   */
  delete(param, value) {
    return this.clone({
      param,
      value,
      op: "d"
    });
  }
  /**
   * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are
   * separated by `&`s.
   */
  toString() {
    this.init();
    return this.keys().map((key) => {
      const eKey = this.encoder.encodeKey(key);
      return this.map.get(key).map((value) => eKey + "=" + this.encoder.encodeValue(value)).join("&");
    }).filter((param) => param !== "").join("&");
  }
  clone(update) {
    const clone = new _HttpParams({
      encoder: this.encoder
    });
    clone.cloneFrom = this.cloneFrom || this;
    clone.updates = (this.updates || []).concat(update);
    return clone;
  }
  init() {
    if (this.map === null) {
      this.map = /* @__PURE__ */ new Map();
    }
    if (this.cloneFrom !== null) {
      this.cloneFrom.init();
      this.cloneFrom.keys().forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));
      this.updates.forEach((update) => {
        switch (update.op) {
          case "a":
          case "s":
            const base = (update.op === "a" ? this.map.get(update.param) : void 0) || [];
            base.push(valueToString(update.value));
            this.map.set(update.param, base);
            break;
          case "d":
            if (update.value !== void 0) {
              let base2 = this.map.get(update.param) || [];
              const idx = base2.indexOf(valueToString(update.value));
              if (idx !== -1) {
                base2.splice(idx, 1);
              }
              if (base2.length > 0) {
                this.map.set(update.param, base2);
              } else {
                this.map.delete(update.param);
              }
            } else {
              this.map.delete(update.param);
              break;
            }
        }
      });
      this.cloneFrom = this.updates = null;
    }
  }
};
var HttpContext = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * Store a value in the context. If a value is already present it will be overwritten.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   * @param value The value to store.
   *
   * @returns A reference to itself for easy chaining.
   */
  set(token, value) {
    this.map.set(token, value);
    return this;
  }
  /**
   * Retrieve the value associated with the given token.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   *
   * @returns The stored value or default if one is defined.
   */
  get(token) {
    if (!this.map.has(token)) {
      this.map.set(token, token.defaultValue());
    }
    return this.map.get(token);
  }
  /**
   * Delete the value associated with the given token.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   *
   * @returns A reference to itself for easy chaining.
   */
  delete(token) {
    this.map.delete(token);
    return this;
  }
  /**
   * Checks for existence of a given token.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   *
   * @returns True if the token exists, false otherwise.
   */
  has(token) {
    return this.map.has(token);
  }
  /**
   * @returns a list of tokens currently stored in the context.
   */
  keys() {
    return this.map.keys();
  }
};
function mightHaveBody(method) {
  switch (method) {
    case "DELETE":
    case "GET":
    case "HEAD":
    case "OPTIONS":
    case "JSONP":
      return false;
    default:
      return true;
  }
}
function isArrayBuffer(value) {
  return typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer;
}
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
function isUrlSearchParams(value) {
  return typeof URLSearchParams !== "undefined" && value instanceof URLSearchParams;
}
var HttpRequest = class _HttpRequest {
  constructor(method, url, third, fourth) {
    this.url = url;
    this.body = null;
    this.reportProgress = false;
    this.withCredentials = false;
    this.responseType = "json";
    this.method = method.toUpperCase();
    let options;
    if (mightHaveBody(this.method) || !!fourth) {
      this.body = third !== void 0 ? third : null;
      options = fourth;
    } else {
      options = third;
    }
    if (options) {
      this.reportProgress = !!options.reportProgress;
      this.withCredentials = !!options.withCredentials;
      if (!!options.responseType) {
        this.responseType = options.responseType;
      }
      if (!!options.headers) {
        this.headers = options.headers;
      }
      if (!!options.context) {
        this.context = options.context;
      }
      if (!!options.params) {
        this.params = options.params;
      }
      this.transferCache = options.transferCache;
    }
    this.headers ??= new HttpHeaders();
    this.context ??= new HttpContext();
    if (!this.params) {
      this.params = new HttpParams();
      this.urlWithParams = url;
    } else {
      const params = this.params.toString();
      if (params.length === 0) {
        this.urlWithParams = url;
      } else {
        const qIdx = url.indexOf("?");
        const sep = qIdx === -1 ? "?" : qIdx < url.length - 1 ? "&" : "";
        this.urlWithParams = url + sep + params;
      }
    }
  }
  /**
   * Transform the free-form body into a serialized format suitable for
   * transmission to the server.
   */
  serializeBody() {
    if (this.body === null) {
      return null;
    }
    if (typeof this.body === "string" || isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body)) {
      return this.body;
    }
    if (this.body instanceof HttpParams) {
      return this.body.toString();
    }
    if (typeof this.body === "object" || typeof this.body === "boolean" || Array.isArray(this.body)) {
      return JSON.stringify(this.body);
    }
    return this.body.toString();
  }
  /**
   * Examine the body and attempt to infer an appropriate MIME type
   * for it.
   *
   * If no such type can be inferred, this method will return `null`.
   */
  detectContentTypeHeader() {
    if (this.body === null) {
      return null;
    }
    if (isFormData(this.body)) {
      return null;
    }
    if (isBlob(this.body)) {
      return this.body.type || null;
    }
    if (isArrayBuffer(this.body)) {
      return null;
    }
    if (typeof this.body === "string") {
      return "text/plain";
    }
    if (this.body instanceof HttpParams) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    }
    if (typeof this.body === "object" || typeof this.body === "number" || typeof this.body === "boolean") {
      return "application/json";
    }
    return null;
  }
  clone(update = {}) {
    const method = update.method || this.method;
    const url = update.url || this.url;
    const responseType = update.responseType || this.responseType;
    const transferCache = update.transferCache ?? this.transferCache;
    const body = update.body !== void 0 ? update.body : this.body;
    const withCredentials = update.withCredentials ?? this.withCredentials;
    const reportProgress = update.reportProgress ?? this.reportProgress;
    let headers = update.headers || this.headers;
    let params = update.params || this.params;
    const context2 = update.context ?? this.context;
    if (update.setHeaders !== void 0) {
      headers = Object.keys(update.setHeaders).reduce((headers2, name) => headers2.set(name, update.setHeaders[name]), headers);
    }
    if (update.setParams) {
      params = Object.keys(update.setParams).reduce((params2, param) => params2.set(param, update.setParams[param]), params);
    }
    return new _HttpRequest(method, url, body, {
      params,
      headers,
      context: context2,
      reportProgress,
      responseType,
      withCredentials,
      transferCache
    });
  }
};
var HttpEventType;
(function(HttpEventType2) {
  HttpEventType2[HttpEventType2["Sent"] = 0] = "Sent";
  HttpEventType2[HttpEventType2["UploadProgress"] = 1] = "UploadProgress";
  HttpEventType2[HttpEventType2["ResponseHeader"] = 2] = "ResponseHeader";
  HttpEventType2[HttpEventType2["DownloadProgress"] = 3] = "DownloadProgress";
  HttpEventType2[HttpEventType2["Response"] = 4] = "Response";
  HttpEventType2[HttpEventType2["User"] = 5] = "User";
})(HttpEventType || (HttpEventType = {}));
var HttpResponseBase = class {
  /**
   * Super-constructor for all responses.
   *
   * The single parameter accepted is an initialization hash. Any properties
   * of the response passed there will override the default values.
   */
  constructor(init, defaultStatus = 200, defaultStatusText = "OK") {
    this.headers = init.headers || new HttpHeaders();
    this.status = init.status !== void 0 ? init.status : defaultStatus;
    this.statusText = init.statusText || defaultStatusText;
    this.url = init.url || null;
    this.ok = this.status >= 200 && this.status < 300;
  }
};
var HttpHeaderResponse = class _HttpHeaderResponse extends HttpResponseBase {
  /**
   * Create a new `HttpHeaderResponse` with the given parameters.
   */
  constructor(init = {}) {
    super(init);
    this.type = HttpEventType.ResponseHeader;
  }
  /**
   * Copy this `HttpHeaderResponse`, overriding its contents with the
   * given parameter hash.
   */
  clone(update = {}) {
    return new _HttpHeaderResponse({
      headers: update.headers || this.headers,
      status: update.status !== void 0 ? update.status : this.status,
      statusText: update.statusText || this.statusText,
      url: update.url || this.url || void 0
    });
  }
};
var HttpResponse = class _HttpResponse extends HttpResponseBase {
  /**
   * Construct a new `HttpResponse`.
   */
  constructor(init = {}) {
    super(init);
    this.type = HttpEventType.Response;
    this.body = init.body !== void 0 ? init.body : null;
  }
  clone(update = {}) {
    return new _HttpResponse({
      body: update.body !== void 0 ? update.body : this.body,
      headers: update.headers || this.headers,
      status: update.status !== void 0 ? update.status : this.status,
      statusText: update.statusText || this.statusText,
      url: update.url || this.url || void 0
    });
  }
};
var HttpErrorResponse = class extends HttpResponseBase {
  constructor(init) {
    super(init, 0, "Unknown Error");
    this.name = "HttpErrorResponse";
    this.ok = false;
    if (this.status >= 200 && this.status < 300) {
      this.message = `Http failure during parsing for ${init.url || "(unknown url)"}`;
    } else {
      this.message = `Http failure response for ${init.url || "(unknown url)"}: ${init.status} ${init.statusText}`;
    }
    this.error = init.error || null;
  }
};
var HTTP_STATUS_CODE_OK = 200;
var HTTP_STATUS_CODE_NO_CONTENT = 204;
var HttpStatusCode;
(function(HttpStatusCode2) {
  HttpStatusCode2[HttpStatusCode2["Continue"] = 100] = "Continue";
  HttpStatusCode2[HttpStatusCode2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
  HttpStatusCode2[HttpStatusCode2["Processing"] = 102] = "Processing";
  HttpStatusCode2[HttpStatusCode2["EarlyHints"] = 103] = "EarlyHints";
  HttpStatusCode2[HttpStatusCode2["Ok"] = 200] = "Ok";
  HttpStatusCode2[HttpStatusCode2["Created"] = 201] = "Created";
  HttpStatusCode2[HttpStatusCode2["Accepted"] = 202] = "Accepted";
  HttpStatusCode2[HttpStatusCode2["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
  HttpStatusCode2[HttpStatusCode2["NoContent"] = 204] = "NoContent";
  HttpStatusCode2[HttpStatusCode2["ResetContent"] = 205] = "ResetContent";
  HttpStatusCode2[HttpStatusCode2["PartialContent"] = 206] = "PartialContent";
  HttpStatusCode2[HttpStatusCode2["MultiStatus"] = 207] = "MultiStatus";
  HttpStatusCode2[HttpStatusCode2["AlreadyReported"] = 208] = "AlreadyReported";
  HttpStatusCode2[HttpStatusCode2["ImUsed"] = 226] = "ImUsed";
  HttpStatusCode2[HttpStatusCode2["MultipleChoices"] = 300] = "MultipleChoices";
  HttpStatusCode2[HttpStatusCode2["MovedPermanently"] = 301] = "MovedPermanently";
  HttpStatusCode2[HttpStatusCode2["Found"] = 302] = "Found";
  HttpStatusCode2[HttpStatusCode2["SeeOther"] = 303] = "SeeOther";
  HttpStatusCode2[HttpStatusCode2["NotModified"] = 304] = "NotModified";
  HttpStatusCode2[HttpStatusCode2["UseProxy"] = 305] = "UseProxy";
  HttpStatusCode2[HttpStatusCode2["Unused"] = 306] = "Unused";
  HttpStatusCode2[HttpStatusCode2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
  HttpStatusCode2[HttpStatusCode2["PermanentRedirect"] = 308] = "PermanentRedirect";
  HttpStatusCode2[HttpStatusCode2["BadRequest"] = 400] = "BadRequest";
  HttpStatusCode2[HttpStatusCode2["Unauthorized"] = 401] = "Unauthorized";
  HttpStatusCode2[HttpStatusCode2["PaymentRequired"] = 402] = "PaymentRequired";
  HttpStatusCode2[HttpStatusCode2["Forbidden"] = 403] = "Forbidden";
  HttpStatusCode2[HttpStatusCode2["NotFound"] = 404] = "NotFound";
  HttpStatusCode2[HttpStatusCode2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
  HttpStatusCode2[HttpStatusCode2["NotAcceptable"] = 406] = "NotAcceptable";
  HttpStatusCode2[HttpStatusCode2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
  HttpStatusCode2[HttpStatusCode2["RequestTimeout"] = 408] = "RequestTimeout";
  HttpStatusCode2[HttpStatusCode2["Conflict"] = 409] = "Conflict";
  HttpStatusCode2[HttpStatusCode2["Gone"] = 410] = "Gone";
  HttpStatusCode2[HttpStatusCode2["LengthRequired"] = 411] = "LengthRequired";
  HttpStatusCode2[HttpStatusCode2["PreconditionFailed"] = 412] = "PreconditionFailed";
  HttpStatusCode2[HttpStatusCode2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
  HttpStatusCode2[HttpStatusCode2["UriTooLong"] = 414] = "UriTooLong";
  HttpStatusCode2[HttpStatusCode2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
  HttpStatusCode2[HttpStatusCode2["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
  HttpStatusCode2[HttpStatusCode2["ExpectationFailed"] = 417] = "ExpectationFailed";
  HttpStatusCode2[HttpStatusCode2["ImATeapot"] = 418] = "ImATeapot";
  HttpStatusCode2[HttpStatusCode2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
  HttpStatusCode2[HttpStatusCode2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
  HttpStatusCode2[HttpStatusCode2["Locked"] = 423] = "Locked";
  HttpStatusCode2[HttpStatusCode2["FailedDependency"] = 424] = "FailedDependency";
  HttpStatusCode2[HttpStatusCode2["TooEarly"] = 425] = "TooEarly";
  HttpStatusCode2[HttpStatusCode2["UpgradeRequired"] = 426] = "UpgradeRequired";
  HttpStatusCode2[HttpStatusCode2["PreconditionRequired"] = 428] = "PreconditionRequired";
  HttpStatusCode2[HttpStatusCode2["TooManyRequests"] = 429] = "TooManyRequests";
  HttpStatusCode2[HttpStatusCode2["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
  HttpStatusCode2[HttpStatusCode2["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
  HttpStatusCode2[HttpStatusCode2["InternalServerError"] = 500] = "InternalServerError";
  HttpStatusCode2[HttpStatusCode2["NotImplemented"] = 501] = "NotImplemented";
  HttpStatusCode2[HttpStatusCode2["BadGateway"] = 502] = "BadGateway";
  HttpStatusCode2[HttpStatusCode2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
  HttpStatusCode2[HttpStatusCode2["GatewayTimeout"] = 504] = "GatewayTimeout";
  HttpStatusCode2[HttpStatusCode2["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
  HttpStatusCode2[HttpStatusCode2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
  HttpStatusCode2[HttpStatusCode2["InsufficientStorage"] = 507] = "InsufficientStorage";
  HttpStatusCode2[HttpStatusCode2["LoopDetected"] = 508] = "LoopDetected";
  HttpStatusCode2[HttpStatusCode2["NotExtended"] = 510] = "NotExtended";
  HttpStatusCode2[HttpStatusCode2["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));
function addBody(options, body) {
  return {
    body,
    headers: options.headers,
    context: options.context,
    observe: options.observe,
    params: options.params,
    reportProgress: options.reportProgress,
    responseType: options.responseType,
    withCredentials: options.withCredentials,
    transferCache: options.transferCache
  };
}
var _HttpClient = class _HttpClient {
  constructor(handler) {
    this.handler = handler;
  }
  /**
   * Constructs an observable for a generic HTTP request that, when subscribed,
   * fires the request through the chain of registered interceptors and on to the
   * server.
   *
   * You can pass an `HttpRequest` directly as the only parameter. In this case,
   * the call returns an observable of the raw `HttpEvent` stream.
   *
   * Alternatively you can pass an HTTP method as the first parameter,
   * a URL string as the second, and an options hash containing the request body as the third.
   * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the
   * type of returned observable.
   *   * The `responseType` value determines how a successful response body is parsed.
   *   * If `responseType` is the default `json`, you can pass a type interface for the resulting
   * object as a type parameter to the call.
   *
   * The `observe` value determines the return type, according to what you are interested in
   * observing.
   *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including
   * progress events by default.
   *   * An `observe` value of response returns an observable of `HttpResponse<T>`,
   * where the `T` parameter depends on the `responseType` and any optionally provided type
   * parameter.
   *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.
   *
   */
  request(first2, url, options = {}) {
    let req;
    if (first2 instanceof HttpRequest) {
      req = first2;
    } else {
      let headers = void 0;
      if (options.headers instanceof HttpHeaders) {
        headers = options.headers;
      } else {
        headers = new HttpHeaders(options.headers);
      }
      let params = void 0;
      if (!!options.params) {
        if (options.params instanceof HttpParams) {
          params = options.params;
        } else {
          params = new HttpParams({
            fromObject: options.params
          });
        }
      }
      req = new HttpRequest(first2, url, options.body !== void 0 ? options.body : null, {
        headers,
        context: options.context,
        params,
        reportProgress: options.reportProgress,
        // By default, JSON is assumed to be returned for all calls.
        responseType: options.responseType || "json",
        withCredentials: options.withCredentials,
        transferCache: options.transferCache
      });
    }
    const events$ = of(req).pipe(concatMap((req2) => this.handler.handle(req2)));
    if (first2 instanceof HttpRequest || options.observe === "events") {
      return events$;
    }
    const res$ = events$.pipe(filter((event) => event instanceof HttpResponse));
    switch (options.observe || "body") {
      case "body":
        switch (req.responseType) {
          case "arraybuffer":
            return res$.pipe(map((res) => {
              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                throw new Error("Response is not an ArrayBuffer.");
              }
              return res.body;
            }));
          case "blob":
            return res$.pipe(map((res) => {
              if (res.body !== null && !(res.body instanceof Blob)) {
                throw new Error("Response is not a Blob.");
              }
              return res.body;
            }));
          case "text":
            return res$.pipe(map((res) => {
              if (res.body !== null && typeof res.body !== "string") {
                throw new Error("Response is not a string.");
              }
              return res.body;
            }));
          case "json":
          default:
            return res$.pipe(map((res) => res.body));
        }
      case "response":
        return res$;
      default:
        throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);
    }
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `DELETE` request to execute on the server. See the individual overloads for
   * details on the return type.
   *
   * @param url     The endpoint URL.
   * @param options The HTTP options to send with the request.
   *
   */
  delete(url, options = {}) {
    return this.request("DELETE", url, options);
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `GET` request to execute on the server. See the individual overloads for
   * details on the return type.
   */
  get(url, options = {}) {
    return this.request("GET", url, options);
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `HEAD` request to execute on the server. The `HEAD` method returns
   * meta information about the resource without transferring the
   * resource itself. See the individual overloads for
   * details on the return type.
   */
  head(url, options = {}) {
    return this.request("HEAD", url, options);
  }
  /**
   * Constructs an `Observable` that, when subscribed, causes a request with the special method
   * `JSONP` to be dispatched via the interceptor pipeline.
   * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain
   * API endpoints that don't support newer,
   * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.
   * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the
   * requests even if the API endpoint is not located on the same domain (origin) as the client-side
   * application making the request.
   * The endpoint API must support JSONP callback for JSONP requests to work.
   * The resource API returns the JSON response wrapped in a callback function.
   * You can pass the callback function name as one of the query parameters.
   * Note that JSONP requests can only be used with `GET` requests.
   *
   * @param url The resource URL.
   * @param callbackParam The callback function name.
   *
   */
  jsonp(url, callbackParam) {
    return this.request("JSONP", url, {
      params: new HttpParams().append(callbackParam, "JSONP_CALLBACK"),
      observe: "body",
      responseType: "json"
    });
  }
  /**
   * Constructs an `Observable` that, when subscribed, causes the configured
   * `OPTIONS` request to execute on the server. This method allows the client
   * to determine the supported HTTP methods and other capabilities of an endpoint,
   * without implying a resource action. See the individual overloads for
   * details on the return type.
   */
  options(url, options = {}) {
    return this.request("OPTIONS", url, options);
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `PATCH` request to execute on the server. See the individual overloads for
   * details on the return type.
   */
  patch(url, body, options = {}) {
    return this.request("PATCH", url, addBody(options, body));
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `POST` request to execute on the server. The server responds with the location of
   * the replaced resource. See the individual overloads for
   * details on the return type.
   */
  post(url, body, options = {}) {
    return this.request("POST", url, addBody(options, body));
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `PUT` request to execute on the server. The `PUT` method replaces an existing resource
   * with a new set of values.
   * See the individual overloads for details on the return type.
   */
  put(url, body, options = {}) {
    return this.request("PUT", url, addBody(options, body));
  }
};
_HttpClient.\u0275fac = function HttpClient_Factory(t3) {
  return new (t3 || _HttpClient)(\u0275\u0275inject(HttpHandler));
};
_HttpClient.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HttpClient,
  factory: _HttpClient.\u0275fac
});
var HttpClient = _HttpClient;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClient, [{
    type: Injectable
  }], () => [{
    type: HttpHandler
  }], null);
})();
var XSSI_PREFIX$1 = /^\)\]\}',?\n/;
var REQUEST_URL_HEADER = `X-Request-URL`;
function getResponseUrl$1(response) {
  if (response.url) {
    return response.url;
  }
  const xRequestUrl = REQUEST_URL_HEADER.toLocaleLowerCase();
  return response.headers.get(xRequestUrl);
}
var _FetchBackend = class _FetchBackend {
  constructor() {
    this.fetchImpl = inject(FetchFactory, {
      optional: true
    })?.fetch ?? fetch.bind(globalThis);
    this.ngZone = inject(NgZone);
  }
  handle(request) {
    return new Observable((observer) => {
      const aborter = new AbortController();
      this.doRequest(request, aborter.signal, observer).then(noop3, (error) => observer.error(new HttpErrorResponse({
        error
      })));
      return () => aborter.abort();
    });
  }
  doRequest(request, signal2, observer) {
    return __async(this, null, function* () {
      const init = this.createRequestInit(request);
      let response;
      try {
        const fetchPromise = this.fetchImpl(request.urlWithParams, __spreadValues({
          signal: signal2
        }, init));
        silenceSuperfluousUnhandledPromiseRejection(fetchPromise);
        observer.next({
          type: HttpEventType.Sent
        });
        response = yield fetchPromise;
      } catch (error) {
        observer.error(new HttpErrorResponse({
          error,
          status: error.status ?? 0,
          statusText: error.statusText,
          url: request.urlWithParams,
          headers: error.headers
        }));
        return;
      }
      const headers = new HttpHeaders(response.headers);
      const statusText = response.statusText;
      const url = getResponseUrl$1(response) ?? request.urlWithParams;
      let status = response.status;
      let body = null;
      if (request.reportProgress) {
        observer.next(new HttpHeaderResponse({
          headers,
          status,
          statusText,
          url
        }));
      }
      if (response.body) {
        const contentLength = response.headers.get("content-length");
        const chunks = [];
        const reader = response.body.getReader();
        let receivedLength = 0;
        let decoder;
        let partialText;
        const reqZone = typeof Zone !== "undefined" && Zone.current;
        yield this.ngZone.runOutsideAngular(() => __async(this, null, function* () {
          while (true) {
            const {
              done,
              value
            } = yield reader.read();
            if (done) {
              break;
            }
            chunks.push(value);
            receivedLength += value.length;
            if (request.reportProgress) {
              partialText = request.responseType === "text" ? (partialText ?? "") + (decoder ??= new TextDecoder()).decode(value, {
                stream: true
              }) : void 0;
              const reportProgress = () => observer.next({
                type: HttpEventType.DownloadProgress,
                total: contentLength ? +contentLength : void 0,
                loaded: receivedLength,
                partialText
              });
              reqZone ? reqZone.run(reportProgress) : reportProgress();
            }
          }
        }));
        const chunksAll = this.concatChunks(chunks, receivedLength);
        try {
          const contentType = response.headers.get("Content-Type") ?? "";
          body = this.parseBody(request, chunksAll, contentType);
        } catch (error) {
          observer.error(new HttpErrorResponse({
            error,
            headers: new HttpHeaders(response.headers),
            status: response.status,
            statusText: response.statusText,
            url: getResponseUrl$1(response) ?? request.urlWithParams
          }));
          return;
        }
      }
      if (status === 0) {
        status = body ? HTTP_STATUS_CODE_OK : 0;
      }
      const ok = status >= 200 && status < 300;
      if (ok) {
        observer.next(new HttpResponse({
          body,
          headers,
          status,
          statusText,
          url
        }));
        observer.complete();
      } else {
        observer.error(new HttpErrorResponse({
          error: body,
          headers,
          status,
          statusText,
          url
        }));
      }
    });
  }
  parseBody(request, binContent, contentType) {
    switch (request.responseType) {
      case "json":
        const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, "");
        return text === "" ? null : JSON.parse(text);
      case "text":
        return new TextDecoder().decode(binContent);
      case "blob":
        return new Blob([binContent], {
          type: contentType
        });
      case "arraybuffer":
        return binContent.buffer;
    }
  }
  createRequestInit(req) {
    const headers = {};
    const credentials = req.withCredentials ? "include" : void 0;
    req.headers.forEach((name, values) => headers[name] = values.join(","));
    headers["Accept"] ??= "application/json, text/plain, */*";
    if (!headers["Content-Type"]) {
      const detectedType = req.detectContentTypeHeader();
      if (detectedType !== null) {
        headers["Content-Type"] = detectedType;
      }
    }
    return {
      body: req.serializeBody(),
      method: req.method,
      headers,
      credentials
    };
  }
  concatChunks(chunks, totalLength) {
    const chunksAll = new Uint8Array(totalLength);
    let position = 0;
    for (const chunk of chunks) {
      chunksAll.set(chunk, position);
      position += chunk.length;
    }
    return chunksAll;
  }
};
_FetchBackend.\u0275fac = function FetchBackend_Factory(t3) {
  return new (t3 || _FetchBackend)();
};
_FetchBackend.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FetchBackend,
  factory: _FetchBackend.\u0275fac
});
var FetchBackend = _FetchBackend;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FetchBackend, [{
    type: Injectable
  }], null, null);
})();
var FetchFactory = class {
};
function noop3() {
}
function silenceSuperfluousUnhandledPromiseRejection(promise) {
  promise.then(noop3, noop3);
}
function interceptorChainEndFn(req, finalHandlerFn) {
  return finalHandlerFn(req);
}
function adaptLegacyInterceptorToChain(chainTailFn, interceptor) {
  return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {
    handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)
  });
}
function chainedInterceptorFn(chainTailFn, interceptorFn, injector) {
  return (initialRequest, finalHandlerFn) => runInInjectionContext(injector, () => interceptorFn(initialRequest, (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)));
}
var HTTP_INTERCEPTORS = new InjectionToken(ngDevMode ? "HTTP_INTERCEPTORS" : "");
var HTTP_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? "HTTP_INTERCEPTOR_FNS" : "");
var HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? "HTTP_ROOT_INTERCEPTOR_FNS" : "");
var REQUESTS_CONTRIBUTE_TO_STABILITY = new InjectionToken(ngDevMode ? "REQUESTS_CONTRIBUTE_TO_STABILITY" : "", {
  providedIn: "root",
  factory: () => true
});
function legacyInterceptorFnFactory() {
  let chain = null;
  return (req, handler) => {
    if (chain === null) {
      const interceptors = inject(HTTP_INTERCEPTORS, {
        optional: true
      }) ?? [];
      chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);
    }
    const pendingTasks = inject(PendingTasks);
    const contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);
    if (contributeToStability) {
      const taskId = pendingTasks.add();
      return chain(req, handler).pipe(finalize(() => pendingTasks.remove(taskId)));
    } else {
      return chain(req, handler);
    }
  };
}
var fetchBackendWarningDisplayed = false;
var _HttpInterceptorHandler = class _HttpInterceptorHandler extends HttpHandler {
  constructor(backend, injector) {
    super();
    this.backend = backend;
    this.injector = injector;
    this.chain = null;
    this.pendingTasks = inject(PendingTasks);
    this.contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !fetchBackendWarningDisplayed) {
      const isServer = isPlatformServer(injector.get(PLATFORM_ID));
      if (isServer && !(this.backend instanceof FetchBackend)) {
        fetchBackendWarningDisplayed = true;
        injector.get(Console).warn(formatRuntimeError(2801, "Angular detected that `HttpClient` is not configured to use `fetch` APIs. It's strongly recommended to enable `fetch` for applications that use Server-Side Rendering for better performance and compatibility. To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` call at the root of the application."));
      }
    }
  }
  handle(initialRequest) {
    if (this.chain === null) {
      const dedupedInterceptorFns = Array.from(/* @__PURE__ */ new Set([...this.injector.get(HTTP_INTERCEPTOR_FNS), ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, [])]));
      this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);
    }
    if (this.contributeToStability) {
      const taskId = this.pendingTasks.add();
      return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest)).pipe(finalize(() => this.pendingTasks.remove(taskId)));
    } else {
      return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest));
    }
  }
};
_HttpInterceptorHandler.\u0275fac = function HttpInterceptorHandler_Factory(t3) {
  return new (t3 || _HttpInterceptorHandler)(\u0275\u0275inject(HttpBackend), \u0275\u0275inject(EnvironmentInjector));
};
_HttpInterceptorHandler.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HttpInterceptorHandler,
  factory: _HttpInterceptorHandler.\u0275fac
});
var HttpInterceptorHandler = _HttpInterceptorHandler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpInterceptorHandler, [{
    type: Injectable
  }], () => [{
    type: HttpBackend
  }, {
    type: EnvironmentInjector
  }], null);
})();
var nextRequestId = 0;
var foreignDocument;
var JSONP_ERR_NO_CALLBACK = "JSONP injected script did not invoke callback.";
var JSONP_ERR_WRONG_METHOD = "JSONP requests must use JSONP request method.";
var JSONP_ERR_WRONG_RESPONSE_TYPE = "JSONP requests must use Json response type.";
var JSONP_ERR_HEADERS_NOT_SUPPORTED = "JSONP requests do not support headers.";
var JsonpCallbackContext = class {
};
function jsonpCallbackContext() {
  if (typeof window === "object") {
    return window;
  }
  return {};
}
var _JsonpClientBackend = class _JsonpClientBackend {
  constructor(callbackMap, document2) {
    this.callbackMap = callbackMap;
    this.document = document2;
    this.resolvedPromise = Promise.resolve();
  }
  /**
   * Get the name of the next callback method, by incrementing the global `nextRequestId`.
   */
  nextCallback() {
    return `ng_jsonp_callback_${nextRequestId++}`;
  }
  /**
   * Processes a JSONP request and returns an event stream of the results.
   * @param req The request object.
   * @returns An observable of the response events.
   *
   */
  handle(req) {
    if (req.method !== "JSONP") {
      throw new Error(JSONP_ERR_WRONG_METHOD);
    } else if (req.responseType !== "json") {
      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
    }
    if (req.headers.keys().length > 0) {
      throw new Error(JSONP_ERR_HEADERS_NOT_SUPPORTED);
    }
    return new Observable((observer) => {
      const callback = this.nextCallback();
      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);
      const node = this.document.createElement("script");
      node.src = url;
      let body = null;
      let finished = false;
      this.callbackMap[callback] = (data) => {
        delete this.callbackMap[callback];
        body = data;
        finished = true;
      };
      const cleanup = () => {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
        delete this.callbackMap[callback];
      };
      const onLoad = (event) => {
        this.resolvedPromise.then(() => {
          cleanup();
          if (!finished) {
            observer.error(new HttpErrorResponse({
              url,
              status: 0,
              statusText: "JSONP Error",
              error: new Error(JSONP_ERR_NO_CALLBACK)
            }));
            return;
          }
          observer.next(new HttpResponse({
            body,
            status: HTTP_STATUS_CODE_OK,
            statusText: "OK",
            url
          }));
          observer.complete();
        });
      };
      const onError = (error) => {
        cleanup();
        observer.error(new HttpErrorResponse({
          error,
          status: 0,
          statusText: "JSONP Error",
          url
        }));
      };
      node.addEventListener("load", onLoad);
      node.addEventListener("error", onError);
      this.document.body.appendChild(node);
      observer.next({
        type: HttpEventType.Sent
      });
      return () => {
        if (!finished) {
          this.removeListeners(node);
        }
        cleanup();
      };
    });
  }
  removeListeners(script) {
    foreignDocument ??= this.document.implementation.createHTMLDocument();
    foreignDocument.adoptNode(script);
  }
};
_JsonpClientBackend.\u0275fac = function JsonpClientBackend_Factory(t3) {
  return new (t3 || _JsonpClientBackend)(\u0275\u0275inject(JsonpCallbackContext), \u0275\u0275inject(DOCUMENT2));
};
_JsonpClientBackend.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _JsonpClientBackend,
  factory: _JsonpClientBackend.\u0275fac
});
var JsonpClientBackend = _JsonpClientBackend;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpClientBackend, [{
    type: Injectable
  }], () => [{
    type: JsonpCallbackContext
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
function jsonpInterceptorFn(req, next) {
  if (req.method === "JSONP") {
    return inject(JsonpClientBackend).handle(req);
  }
  return next(req);
}
var _JsonpInterceptor = class _JsonpInterceptor {
  constructor(injector) {
    this.injector = injector;
  }
  /**
   * Identifies and handles a given JSONP request.
   * @param initialRequest The outgoing request object to handle.
   * @param next The next interceptor in the chain, or the backend
   * if no interceptors remain in the chain.
   * @returns An observable of the event stream.
   */
  intercept(initialRequest, next) {
    return runInInjectionContext(this.injector, () => jsonpInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
  }
};
_JsonpInterceptor.\u0275fac = function JsonpInterceptor_Factory(t3) {
  return new (t3 || _JsonpInterceptor)(\u0275\u0275inject(EnvironmentInjector));
};
_JsonpInterceptor.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _JsonpInterceptor,
  factory: _JsonpInterceptor.\u0275fac
});
var JsonpInterceptor = _JsonpInterceptor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpInterceptor, [{
    type: Injectable
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var XSSI_PREFIX = /^\)\]\}',?\n/;
function getResponseUrl(xhr) {
  if ("responseURL" in xhr && xhr.responseURL) {
    return xhr.responseURL;
  }
  if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
    return xhr.getResponseHeader("X-Request-URL");
  }
  return null;
}
var _HttpXhrBackend = class _HttpXhrBackend {
  constructor(xhrFactory) {
    this.xhrFactory = xhrFactory;
  }
  /**
   * Processes a request and returns a stream of response events.
   * @param req The request object.
   * @returns An observable of the response events.
   */
  handle(req) {
    if (req.method === "JSONP") {
      throw new RuntimeError(-2800, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \`withJsonpSupport()\` call (if \`provideHttpClient()\` is used) or import the \`HttpClientJsonpModule\` in the root NgModule.`);
    }
    const xhrFactory = this.xhrFactory;
    const source = xhrFactory.\u0275loadImpl ? from(xhrFactory.\u0275loadImpl()) : of(null);
    return source.pipe(switchMap(() => {
      return new Observable((observer) => {
        const xhr = xhrFactory.build();
        xhr.open(req.method, req.urlWithParams);
        if (req.withCredentials) {
          xhr.withCredentials = true;
        }
        req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(",")));
        if (!req.headers.has("Accept")) {
          xhr.setRequestHeader("Accept", "application/json, text/plain, */*");
        }
        if (!req.headers.has("Content-Type")) {
          const detectedType = req.detectContentTypeHeader();
          if (detectedType !== null) {
            xhr.setRequestHeader("Content-Type", detectedType);
          }
        }
        if (req.responseType) {
          const responseType = req.responseType.toLowerCase();
          xhr.responseType = responseType !== "json" ? responseType : "text";
        }
        const reqBody = req.serializeBody();
        let headerResponse = null;
        const partialFromXhr = () => {
          if (headerResponse !== null) {
            return headerResponse;
          }
          const statusText = xhr.statusText || "OK";
          const headers = new HttpHeaders(xhr.getAllResponseHeaders());
          const url = getResponseUrl(xhr) || req.url;
          headerResponse = new HttpHeaderResponse({
            headers,
            status: xhr.status,
            statusText,
            url
          });
          return headerResponse;
        };
        const onLoad = () => {
          let {
            headers,
            status,
            statusText,
            url
          } = partialFromXhr();
          let body = null;
          if (status !== HTTP_STATUS_CODE_NO_CONTENT) {
            body = typeof xhr.response === "undefined" ? xhr.responseText : xhr.response;
          }
          if (status === 0) {
            status = !!body ? HTTP_STATUS_CODE_OK : 0;
          }
          let ok = status >= 200 && status < 300;
          if (req.responseType === "json" && typeof body === "string") {
            const originalBody = body;
            body = body.replace(XSSI_PREFIX, "");
            try {
              body = body !== "" ? JSON.parse(body) : null;
            } catch (error) {
              body = originalBody;
              if (ok) {
                ok = false;
                body = {
                  error,
                  text: body
                };
              }
            }
          }
          if (ok) {
            observer.next(new HttpResponse({
              body,
              headers,
              status,
              statusText,
              url: url || void 0
            }));
            observer.complete();
          } else {
            observer.error(new HttpErrorResponse({
              // The error in this case is the response body (error from the server).
              error: body,
              headers,
              status,
              statusText,
              url: url || void 0
            }));
          }
        };
        const onError = (error) => {
          const {
            url
          } = partialFromXhr();
          const res = new HttpErrorResponse({
            error,
            status: xhr.status || 0,
            statusText: xhr.statusText || "Unknown Error",
            url: url || void 0
          });
          observer.error(res);
        };
        let sentHeaders = false;
        const onDownProgress = (event) => {
          if (!sentHeaders) {
            observer.next(partialFromXhr());
            sentHeaders = true;
          }
          let progressEvent = {
            type: HttpEventType.DownloadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progressEvent.total = event.total;
          }
          if (req.responseType === "text" && !!xhr.responseText) {
            progressEvent.partialText = xhr.responseText;
          }
          observer.next(progressEvent);
        };
        const onUpProgress = (event) => {
          let progress = {
            type: HttpEventType.UploadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progress.total = event.total;
          }
          observer.next(progress);
        };
        xhr.addEventListener("load", onLoad);
        xhr.addEventListener("error", onError);
        xhr.addEventListener("timeout", onError);
        xhr.addEventListener("abort", onError);
        if (req.reportProgress) {
          xhr.addEventListener("progress", onDownProgress);
          if (reqBody !== null && xhr.upload) {
            xhr.upload.addEventListener("progress", onUpProgress);
          }
        }
        xhr.send(reqBody);
        observer.next({
          type: HttpEventType.Sent
        });
        return () => {
          xhr.removeEventListener("error", onError);
          xhr.removeEventListener("abort", onError);
          xhr.removeEventListener("load", onLoad);
          xhr.removeEventListener("timeout", onError);
          if (req.reportProgress) {
            xhr.removeEventListener("progress", onDownProgress);
            if (reqBody !== null && xhr.upload) {
              xhr.upload.removeEventListener("progress", onUpProgress);
            }
          }
          if (xhr.readyState !== xhr.DONE) {
            xhr.abort();
          }
        };
      });
    }));
  }
};
_HttpXhrBackend.\u0275fac = function HttpXhrBackend_Factory(t3) {
  return new (t3 || _HttpXhrBackend)(\u0275\u0275inject(XhrFactory));
};
_HttpXhrBackend.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HttpXhrBackend,
  factory: _HttpXhrBackend.\u0275fac
});
var HttpXhrBackend = _HttpXhrBackend;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXhrBackend, [{
    type: Injectable
  }], () => [{
    type: XhrFactory
  }], null);
})();
var XSRF_ENABLED = new InjectionToken(ngDevMode ? "XSRF_ENABLED" : "");
var XSRF_DEFAULT_COOKIE_NAME = "XSRF-TOKEN";
var XSRF_COOKIE_NAME = new InjectionToken(ngDevMode ? "XSRF_COOKIE_NAME" : "", {
  providedIn: "root",
  factory: () => XSRF_DEFAULT_COOKIE_NAME
});
var XSRF_DEFAULT_HEADER_NAME = "X-XSRF-TOKEN";
var XSRF_HEADER_NAME = new InjectionToken(ngDevMode ? "XSRF_HEADER_NAME" : "", {
  providedIn: "root",
  factory: () => XSRF_DEFAULT_HEADER_NAME
});
var HttpXsrfTokenExtractor = class {
};
var _HttpXsrfCookieExtractor = class _HttpXsrfCookieExtractor {
  constructor(doc, platform, cookieName) {
    this.doc = doc;
    this.platform = platform;
    this.cookieName = cookieName;
    this.lastCookieString = "";
    this.lastToken = null;
    this.parseCount = 0;
  }
  getToken() {
    if (this.platform === "server") {
      return null;
    }
    const cookieString = this.doc.cookie || "";
    if (cookieString !== this.lastCookieString) {
      this.parseCount++;
      this.lastToken = parseCookieValue(cookieString, this.cookieName);
      this.lastCookieString = cookieString;
    }
    return this.lastToken;
  }
};
_HttpXsrfCookieExtractor.\u0275fac = function HttpXsrfCookieExtractor_Factory(t3) {
  return new (t3 || _HttpXsrfCookieExtractor)(\u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(XSRF_COOKIE_NAME));
};
_HttpXsrfCookieExtractor.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HttpXsrfCookieExtractor,
  factory: _HttpXsrfCookieExtractor.\u0275fac
});
var HttpXsrfCookieExtractor = _HttpXsrfCookieExtractor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfCookieExtractor, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [XSRF_COOKIE_NAME]
    }]
  }], null);
})();
function xsrfInterceptorFn(req, next) {
  const lcUrl = req.url.toLowerCase();
  if (!inject(XSRF_ENABLED) || req.method === "GET" || req.method === "HEAD" || lcUrl.startsWith("http://") || lcUrl.startsWith("https://")) {
    return next(req);
  }
  const token = inject(HttpXsrfTokenExtractor).getToken();
  const headerName = inject(XSRF_HEADER_NAME);
  if (token != null && !req.headers.has(headerName)) {
    req = req.clone({
      headers: req.headers.set(headerName, token)
    });
  }
  return next(req);
}
var _HttpXsrfInterceptor = class _HttpXsrfInterceptor {
  constructor(injector) {
    this.injector = injector;
  }
  intercept(initialRequest, next) {
    return runInInjectionContext(this.injector, () => xsrfInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
  }
};
_HttpXsrfInterceptor.\u0275fac = function HttpXsrfInterceptor_Factory(t3) {
  return new (t3 || _HttpXsrfInterceptor)(\u0275\u0275inject(EnvironmentInjector));
};
_HttpXsrfInterceptor.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HttpXsrfInterceptor,
  factory: _HttpXsrfInterceptor.\u0275fac
});
var HttpXsrfInterceptor = _HttpXsrfInterceptor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfInterceptor, [{
    type: Injectable
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var HttpFeatureKind;
(function(HttpFeatureKind2) {
  HttpFeatureKind2[HttpFeatureKind2["Interceptors"] = 0] = "Interceptors";
  HttpFeatureKind2[HttpFeatureKind2["LegacyInterceptors"] = 1] = "LegacyInterceptors";
  HttpFeatureKind2[HttpFeatureKind2["CustomXsrfConfiguration"] = 2] = "CustomXsrfConfiguration";
  HttpFeatureKind2[HttpFeatureKind2["NoXsrfProtection"] = 3] = "NoXsrfProtection";
  HttpFeatureKind2[HttpFeatureKind2["JsonpSupport"] = 4] = "JsonpSupport";
  HttpFeatureKind2[HttpFeatureKind2["RequestsMadeViaParent"] = 5] = "RequestsMadeViaParent";
  HttpFeatureKind2[HttpFeatureKind2["Fetch"] = 6] = "Fetch";
})(HttpFeatureKind || (HttpFeatureKind = {}));
function makeHttpFeature(kind, providers) {
  return {
    \u0275kind: kind,
    \u0275providers: providers
  };
}
function provideHttpClient(...features) {
  if (ngDevMode) {
    const featureKinds = new Set(features.map((f3) => f3.\u0275kind));
    if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) && featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {
      throw new Error(ngDevMode ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.` : "");
    }
  }
  const providers = [HttpClient, HttpXhrBackend, HttpInterceptorHandler, {
    provide: HttpHandler,
    useExisting: HttpInterceptorHandler
  }, {
    provide: HttpBackend,
    useFactory: () => {
      return inject(FetchBackend, {
        optional: true
      }) ?? inject(HttpXhrBackend);
    }
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: xsrfInterceptorFn,
    multi: true
  }, {
    provide: XSRF_ENABLED,
    useValue: true
  }, {
    provide: HttpXsrfTokenExtractor,
    useClass: HttpXsrfCookieExtractor
  }];
  for (const feature of features) {
    providers.push(...feature.\u0275providers);
  }
  return makeEnvironmentProviders(providers);
}
var LEGACY_INTERCEPTOR_FN = new InjectionToken(ngDevMode ? "LEGACY_INTERCEPTOR_FN" : "");
function withInterceptorsFromDi() {
  return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [{
    provide: LEGACY_INTERCEPTOR_FN,
    useFactory: legacyInterceptorFnFactory
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useExisting: LEGACY_INTERCEPTOR_FN,
    multi: true
  }]);
}
function withXsrfConfiguration({
  cookieName,
  headerName
}) {
  const providers = [];
  if (cookieName !== void 0) {
    providers.push({
      provide: XSRF_COOKIE_NAME,
      useValue: cookieName
    });
  }
  if (headerName !== void 0) {
    providers.push({
      provide: XSRF_HEADER_NAME,
      useValue: headerName
    });
  }
  return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);
}
function withNoXsrfProtection() {
  return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [{
    provide: XSRF_ENABLED,
    useValue: false
  }]);
}
function withJsonpSupport() {
  return makeHttpFeature(HttpFeatureKind.JsonpSupport, [JsonpClientBackend, {
    provide: JsonpCallbackContext,
    useFactory: jsonpCallbackContext
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: jsonpInterceptorFn,
    multi: true
  }]);
}
var _HttpClientXsrfModule = class _HttpClientXsrfModule {
  /**
   * Disable the default XSRF protection.
   */
  static disable() {
    return {
      ngModule: _HttpClientXsrfModule,
      providers: [withNoXsrfProtection().\u0275providers]
    };
  }
  /**
   * Configure XSRF protection.
   * @param options An object that can specify either or both
   * cookie name or header name.
   * - Cookie name default is `XSRF-TOKEN`.
   * - Header name default is `X-XSRF-TOKEN`.
   *
   */
  static withOptions(options = {}) {
    return {
      ngModule: _HttpClientXsrfModule,
      providers: withXsrfConfiguration(options).\u0275providers
    };
  }
};
_HttpClientXsrfModule.\u0275fac = function HttpClientXsrfModule_Factory(t3) {
  return new (t3 || _HttpClientXsrfModule)();
};
_HttpClientXsrfModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _HttpClientXsrfModule
});
_HttpClientXsrfModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [HttpXsrfInterceptor, {
    provide: HTTP_INTERCEPTORS,
    useExisting: HttpXsrfInterceptor,
    multi: true
  }, {
    provide: HttpXsrfTokenExtractor,
    useClass: HttpXsrfCookieExtractor
  }, withXsrfConfiguration({
    cookieName: XSRF_DEFAULT_COOKIE_NAME,
    headerName: XSRF_DEFAULT_HEADER_NAME
  }).\u0275providers, {
    provide: XSRF_ENABLED,
    useValue: true
  }]
});
var HttpClientXsrfModule = _HttpClientXsrfModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientXsrfModule, [{
    type: NgModule,
    args: [{
      providers: [HttpXsrfInterceptor, {
        provide: HTTP_INTERCEPTORS,
        useExisting: HttpXsrfInterceptor,
        multi: true
      }, {
        provide: HttpXsrfTokenExtractor,
        useClass: HttpXsrfCookieExtractor
      }, withXsrfConfiguration({
        cookieName: XSRF_DEFAULT_COOKIE_NAME,
        headerName: XSRF_DEFAULT_HEADER_NAME
      }).\u0275providers, {
        provide: XSRF_ENABLED,
        useValue: true
      }]
    }]
  }], null, null);
})();
var _HttpClientModule = class _HttpClientModule {
};
_HttpClientModule.\u0275fac = function HttpClientModule_Factory(t3) {
  return new (t3 || _HttpClientModule)();
};
_HttpClientModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _HttpClientModule
});
_HttpClientModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [provideHttpClient(withInterceptorsFromDi())]
});
var HttpClientModule = _HttpClientModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientModule, [{
    type: NgModule,
    args: [{
      /**
       * Configures the dependency injector where it is imported
       * with supporting services for HTTP communications.
       */
      providers: [provideHttpClient(withInterceptorsFromDi())]
    }]
  }], null, null);
})();
var _HttpClientJsonpModule = class _HttpClientJsonpModule {
};
_HttpClientJsonpModule.\u0275fac = function HttpClientJsonpModule_Factory(t3) {
  return new (t3 || _HttpClientJsonpModule)();
};
_HttpClientJsonpModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _HttpClientJsonpModule
});
_HttpClientJsonpModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [withJsonpSupport().\u0275providers]
});
var HttpClientJsonpModule = _HttpClientJsonpModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientJsonpModule, [{
    type: NgModule,
    args: [{
      providers: [withJsonpSupport().\u0275providers]
    }]
  }], null, null);
})();
var HTTP_TRANSFER_CACHE_ORIGIN_MAP = new InjectionToken(ngDevMode ? "HTTP_TRANSFER_CACHE_ORIGIN_MAP" : "");
var CACHE_OPTIONS = new InjectionToken(ngDevMode ? "HTTP_TRANSFER_STATE_CACHE_OPTIONS" : "");

// node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs
var GenericBrowserDomAdapter = class extends DomAdapter {
  constructor() {
    super(...arguments);
    this.supportsDOMEvents = true;
  }
};
var BrowserDomAdapter = class _BrowserDomAdapter extends GenericBrowserDomAdapter {
  static makeCurrent() {
    setRootDomAdapter(new _BrowserDomAdapter());
  }
  onAndCancel(el, evt, listener) {
    el.addEventListener(evt, listener);
    return () => {
      el.removeEventListener(evt, listener);
    };
  }
  dispatchEvent(el, evt) {
    el.dispatchEvent(evt);
  }
  remove(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  createElement(tagName, doc) {
    doc = doc || this.getDefaultDocument();
    return doc.createElement(tagName);
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument("fakeTitle");
  }
  getDefaultDocument() {
    return document;
  }
  isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isShadowRoot(node) {
    return node instanceof DocumentFragment;
  }
  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */
  getGlobalEventTarget(doc, target) {
    if (target === "window") {
      return window;
    }
    if (target === "document") {
      return doc;
    }
    if (target === "body") {
      return doc.body;
    }
    return null;
  }
  getBaseHref(doc) {
    const href = getBaseElementHref();
    return href == null ? null : relativePath(href);
  }
  resetBaseElement() {
    baseElement = null;
  }
  getUserAgent() {
    return window.navigator.userAgent;
  }
  getCookie(name) {
    return parseCookieValue(document.cookie, name);
  }
};
var baseElement = null;
function getBaseElementHref() {
  baseElement = baseElement || document.querySelector("base");
  return baseElement ? baseElement.getAttribute("href") : null;
}
function relativePath(url) {
  return new URL(url, document.baseURI).pathname;
}
var BrowserGetTestability = class {
  addToWindow(registry) {
    _global["getAngularTestability"] = (elem, findInAncestors = true) => {
      const testability = registry.findTestabilityInTree(elem, findInAncestors);
      if (testability == null) {
        throw new RuntimeError(5103, (typeof ngDevMode === "undefined" || ngDevMode) && "Could not find testability for element.");
      }
      return testability;
    };
    _global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
    _global["getAllAngularRootElements"] = () => registry.getAllRootElements();
    const whenAllStable = (callback) => {
      const testabilities = _global["getAllAngularTestabilities"]();
      let count = testabilities.length;
      const decrement = function() {
        count--;
        if (count == 0) {
          callback();
        }
      };
      testabilities.forEach((testability) => {
        testability.whenStable(decrement);
      });
    };
    if (!_global["frameworkStabilizers"]) {
      _global["frameworkStabilizers"] = [];
    }
    _global["frameworkStabilizers"].push(whenAllStable);
  }
  findTestabilityInTree(registry, elem, findInAncestors) {
    if (elem == null) {
      return null;
    }
    const t3 = registry.getTestability(elem);
    if (t3 != null) {
      return t3;
    } else if (!findInAncestors) {
      return null;
    }
    if (getDOM().isShadowRoot(elem)) {
      return this.findTestabilityInTree(registry, elem.host, true);
    }
    return this.findTestabilityInTree(registry, elem.parentElement, true);
  }
};
var _BrowserXhr = class _BrowserXhr {
  build() {
    return new XMLHttpRequest();
  }
};
_BrowserXhr.\u0275fac = function BrowserXhr_Factory(t3) {
  return new (t3 || _BrowserXhr)();
};
_BrowserXhr.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _BrowserXhr,
  factory: _BrowserXhr.\u0275fac
});
var BrowserXhr = _BrowserXhr;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserXhr, [{
    type: Injectable
  }], null, null);
})();
var EVENT_MANAGER_PLUGINS = new InjectionToken(ngDevMode ? "EventManagerPlugins" : "");
var _EventManager = class _EventManager {
  /**
   * Initializes an instance of the event-manager service.
   */
  constructor(plugins, _zone) {
    this._zone = _zone;
    this._eventNameToPlugin = /* @__PURE__ */ new Map();
    plugins.forEach((plugin) => {
      plugin.manager = this;
    });
    this._plugins = plugins.slice().reverse();
  }
  /**
   * Registers a handler for a specific element and event.
   *
   * @param element The HTML element to receive event notifications.
   * @param eventName The name of the event to listen for.
   * @param handler A function to call when the notification occurs. Receives the
   * event object as an argument.
   * @returns  A callback function that can be used to remove the handler.
   */
  addEventListener(element, eventName, handler) {
    const plugin = this._findPluginFor(eventName);
    return plugin.addEventListener(element, eventName, handler);
  }
  /**
   * Retrieves the compilation zone in which event listeners are registered.
   */
  getZone() {
    return this._zone;
  }
  /** @internal */
  _findPluginFor(eventName) {
    let plugin = this._eventNameToPlugin.get(eventName);
    if (plugin) {
      return plugin;
    }
    const plugins = this._plugins;
    plugin = plugins.find((plugin2) => plugin2.supports(eventName));
    if (!plugin) {
      throw new RuntimeError(5101, (typeof ngDevMode === "undefined" || ngDevMode) && `No event manager plugin found for event ${eventName}`);
    }
    this._eventNameToPlugin.set(eventName, plugin);
    return plugin;
  }
};
_EventManager.\u0275fac = function EventManager_Factory(t3) {
  return new (t3 || _EventManager)(\u0275\u0275inject(EVENT_MANAGER_PLUGINS), \u0275\u0275inject(NgZone));
};
_EventManager.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _EventManager,
  factory: _EventManager.\u0275fac
});
var EventManager = _EventManager;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventManager, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [EVENT_MANAGER_PLUGINS]
    }]
  }, {
    type: NgZone
  }], null);
})();
var EventManagerPlugin = class {
  // TODO: remove (has some usage in G3)
  constructor(_doc) {
    this._doc = _doc;
  }
};
var APP_ID_ATTRIBUTE_NAME = "ng-app-id";
var _SharedStylesHost = class _SharedStylesHost {
  constructor(doc, appId, nonce, platformId = {}) {
    this.doc = doc;
    this.appId = appId;
    this.nonce = nonce;
    this.platformId = platformId;
    this.styleRef = /* @__PURE__ */ new Map();
    this.hostNodes = /* @__PURE__ */ new Set();
    this.styleNodesInDOM = this.collectServerRenderedStyles();
    this.platformIsServer = isPlatformServer(platformId);
    this.resetHostNodes();
  }
  addStyles(styles) {
    for (const style of styles) {
      const usageCount = this.changeUsageCount(style, 1);
      if (usageCount === 1) {
        this.onStyleAdded(style);
      }
    }
  }
  removeStyles(styles) {
    for (const style of styles) {
      const usageCount = this.changeUsageCount(style, -1);
      if (usageCount <= 0) {
        this.onStyleRemoved(style);
      }
    }
  }
  ngOnDestroy() {
    const styleNodesInDOM = this.styleNodesInDOM;
    if (styleNodesInDOM) {
      styleNodesInDOM.forEach((node) => node.remove());
      styleNodesInDOM.clear();
    }
    for (const style of this.getAllStyles()) {
      this.onStyleRemoved(style);
    }
    this.resetHostNodes();
  }
  addHost(hostNode) {
    this.hostNodes.add(hostNode);
    for (const style of this.getAllStyles()) {
      this.addStyleToHost(hostNode, style);
    }
  }
  removeHost(hostNode) {
    this.hostNodes.delete(hostNode);
  }
  getAllStyles() {
    return this.styleRef.keys();
  }
  onStyleAdded(style) {
    for (const host of this.hostNodes) {
      this.addStyleToHost(host, style);
    }
  }
  onStyleRemoved(style) {
    const styleRef = this.styleRef;
    styleRef.get(style)?.elements?.forEach((node) => node.remove());
    styleRef.delete(style);
  }
  collectServerRenderedStyles() {
    const styles = this.doc.head?.querySelectorAll(`style[${APP_ID_ATTRIBUTE_NAME}="${this.appId}"]`);
    if (styles?.length) {
      const styleMap = /* @__PURE__ */ new Map();
      styles.forEach((style) => {
        if (style.textContent != null) {
          styleMap.set(style.textContent, style);
        }
      });
      return styleMap;
    }
    return null;
  }
  changeUsageCount(style, delta) {
    const map2 = this.styleRef;
    if (map2.has(style)) {
      const styleRefValue = map2.get(style);
      styleRefValue.usage += delta;
      return styleRefValue.usage;
    }
    map2.set(style, {
      usage: delta,
      elements: []
    });
    return delta;
  }
  getStyleElement(host, style) {
    const styleNodesInDOM = this.styleNodesInDOM;
    const styleEl = styleNodesInDOM?.get(style);
    if (styleEl?.parentNode === host) {
      styleNodesInDOM.delete(style);
      styleEl.removeAttribute(APP_ID_ATTRIBUTE_NAME);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        styleEl.setAttribute("ng-style-reused", "");
      }
      return styleEl;
    } else {
      const styleEl2 = this.doc.createElement("style");
      if (this.nonce) {
        styleEl2.setAttribute("nonce", this.nonce);
      }
      styleEl2.textContent = style;
      if (this.platformIsServer) {
        styleEl2.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);
      }
      host.appendChild(styleEl2);
      return styleEl2;
    }
  }
  addStyleToHost(host, style) {
    const styleEl = this.getStyleElement(host, style);
    const styleRef = this.styleRef;
    const styleElRef = styleRef.get(style)?.elements;
    if (styleElRef) {
      styleElRef.push(styleEl);
    } else {
      styleRef.set(style, {
        elements: [styleEl],
        usage: 1
      });
    }
  }
  resetHostNodes() {
    const hostNodes = this.hostNodes;
    hostNodes.clear();
    hostNodes.add(this.doc.head);
  }
};
_SharedStylesHost.\u0275fac = function SharedStylesHost_Factory(t3) {
  return new (t3 || _SharedStylesHost)(\u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(APP_ID), \u0275\u0275inject(CSP_NONCE, 8), \u0275\u0275inject(PLATFORM_ID));
};
_SharedStylesHost.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SharedStylesHost,
  factory: _SharedStylesHost.\u0275fac
});
var SharedStylesHost = _SharedStylesHost;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedStylesHost, [{
    type: Injectable
  }], () => [{
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [APP_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CSP_NONCE]
    }, {
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], null);
})();
var NAMESPACE_URIS = {
  "svg": "http://www.w3.org/2000/svg",
  "xhtml": "http://www.w3.org/1999/xhtml",
  "xlink": "http://www.w3.org/1999/xlink",
  "xml": "http://www.w3.org/XML/1998/namespace",
  "xmlns": "http://www.w3.org/2000/xmlns/",
  "math": "http://www.w3.org/1998/Math/MathML"
};
var COMPONENT_REGEX = /%COMP%/g;
var COMPONENT_VARIABLE = "%COMP%";
var HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
var CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
var REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;
var REMOVE_STYLES_ON_COMPONENT_DESTROY = new InjectionToken(ngDevMode ? "RemoveStylesOnCompDestroy" : "", {
  providedIn: "root",
  factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT
});
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimStylesContent(compId, styles) {
  return styles.map((s3) => s3.replace(COMPONENT_REGEX, compId));
}
var _DomRendererFactory2 = class _DomRendererFactory2 {
  constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc, platformId, ngZone, nonce = null) {
    this.eventManager = eventManager;
    this.sharedStylesHost = sharedStylesHost;
    this.appId = appId;
    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
    this.doc = doc;
    this.platformId = platformId;
    this.ngZone = ngZone;
    this.nonce = nonce;
    this.rendererByCompId = /* @__PURE__ */ new Map();
    this.platformIsServer = isPlatformServer(platformId);
    this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc, ngZone, this.platformIsServer);
  }
  createRenderer(element, type) {
    if (!element || !type) {
      return this.defaultRenderer;
    }
    if (this.platformIsServer && type.encapsulation === ViewEncapsulation$1.ShadowDom) {
      type = __spreadProps(__spreadValues({}, type), {
        encapsulation: ViewEncapsulation$1.Emulated
      });
    }
    const renderer = this.getOrCreateRenderer(element, type);
    if (renderer instanceof EmulatedEncapsulationDomRenderer2) {
      renderer.applyToHost(element);
    } else if (renderer instanceof NoneEncapsulationDomRenderer) {
      renderer.applyStyles();
    }
    return renderer;
  }
  getOrCreateRenderer(element, type) {
    const rendererByCompId = this.rendererByCompId;
    let renderer = rendererByCompId.get(type.id);
    if (!renderer) {
      const doc = this.doc;
      const ngZone = this.ngZone;
      const eventManager = this.eventManager;
      const sharedStylesHost = this.sharedStylesHost;
      const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;
      const platformIsServer = this.platformIsServer;
      switch (type.encapsulation) {
        case ViewEncapsulation$1.Emulated:
          renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer);
          break;
        case ViewEncapsulation$1.ShadowDom:
          return new ShadowDomRenderer(eventManager, sharedStylesHost, element, type, doc, ngZone, this.nonce, platformIsServer);
        default:
          renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type, removeStylesOnCompDestroy, doc, ngZone, platformIsServer);
          break;
      }
      rendererByCompId.set(type.id, renderer);
    }
    return renderer;
  }
  ngOnDestroy() {
    this.rendererByCompId.clear();
  }
};
_DomRendererFactory2.\u0275fac = function DomRendererFactory2_Factory(t3) {
  return new (t3 || _DomRendererFactory2)(\u0275\u0275inject(EventManager), \u0275\u0275inject(SharedStylesHost), \u0275\u0275inject(APP_ID), \u0275\u0275inject(REMOVE_STYLES_ON_COMPONENT_DESTROY), \u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(NgZone), \u0275\u0275inject(CSP_NONCE));
};
_DomRendererFactory2.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DomRendererFactory2,
  factory: _DomRendererFactory2.\u0275fac
});
var DomRendererFactory2 = _DomRendererFactory2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomRendererFactory2, [{
    type: Injectable
  }], () => [{
    type: EventManager
  }, {
    type: SharedStylesHost
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [APP_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]
    }]
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CSP_NONCE]
    }]
  }], null);
})();
var DefaultDomRenderer2 = class {
  constructor(eventManager, doc, ngZone, platformIsServer) {
    this.eventManager = eventManager;
    this.doc = doc;
    this.ngZone = ngZone;
    this.platformIsServer = platformIsServer;
    this.data = /* @__PURE__ */ Object.create(null);
    this.throwOnSyntheticProps = true;
    this.destroyNode = null;
  }
  destroy() {
  }
  createElement(name, namespace) {
    if (namespace) {
      return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
    }
    return this.doc.createElement(name);
  }
  createComment(value) {
    return this.doc.createComment(value);
  }
  createText(value) {
    return this.doc.createTextNode(value);
  }
  appendChild(parent2, newChild) {
    const targetParent = isTemplateNode(parent2) ? parent2.content : parent2;
    targetParent.appendChild(newChild);
  }
  insertBefore(parent2, newChild, refChild) {
    if (parent2) {
      const targetParent = isTemplateNode(parent2) ? parent2.content : parent2;
      targetParent.insertBefore(newChild, refChild);
    }
  }
  removeChild(parent2, oldChild) {
    if (parent2) {
      parent2.removeChild(oldChild);
    }
  }
  selectRootElement(selectorOrNode, preserveContent) {
    let el = typeof selectorOrNode === "string" ? this.doc.querySelector(selectorOrNode) : selectorOrNode;
    if (!el) {
      throw new RuntimeError(-5104, (typeof ngDevMode === "undefined" || ngDevMode) && `The selector "${selectorOrNode}" did not match any elements`);
    }
    if (!preserveContent) {
      el.textContent = "";
    }
    return el;
  }
  parentNode(node) {
    return node.parentNode;
  }
  nextSibling(node) {
    return node.nextSibling;
  }
  setAttribute(el, name, value, namespace) {
    if (namespace) {
      name = namespace + ":" + name;
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.setAttributeNS(namespaceUri, name, value);
      } else {
        el.setAttribute(name, value);
      }
    } else {
      el.setAttribute(name, value);
    }
  }
  removeAttribute(el, name, namespace) {
    if (namespace) {
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.removeAttributeNS(namespaceUri, name);
      } else {
        el.removeAttribute(`${namespace}:${name}`);
      }
    } else {
      el.removeAttribute(name);
    }
  }
  addClass(el, name) {
    el.classList.add(name);
  }
  removeClass(el, name) {
    el.classList.remove(name);
  }
  setStyle(el, style, value, flags) {
    if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
      el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? "important" : "");
    } else {
      el.style[style] = value;
    }
  }
  removeStyle(el, style, flags) {
    if (flags & RendererStyleFlags2.DashCase) {
      el.style.removeProperty(style);
    } else {
      el.style[style] = "";
    }
  }
  setProperty(el, name, value) {
    if (el == null) {
      return;
    }
    (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(name, "property");
    el[name] = value;
  }
  setValue(node, value) {
    node.nodeValue = value;
  }
  listen(target, event, callback) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(event, "listener");
    if (typeof target === "string") {
      target = getDOM().getGlobalEventTarget(this.doc, target);
      if (!target) {
        throw new Error(`Unsupported event target ${target} for event ${event}`);
      }
    }
    return this.eventManager.addEventListener(target, event, this.decoratePreventDefault(callback));
  }
  decoratePreventDefault(eventHandler) {
    return (event) => {
      if (event === "__ngUnwrap__") {
        return eventHandler;
      }
      const allowDefaultBehavior = this.platformIsServer ? this.ngZone.runGuarded(() => eventHandler(event)) : eventHandler(event);
      if (allowDefaultBehavior === false) {
        event.preventDefault();
      }
      return void 0;
    };
  }
};
var AT_CHARCODE = (() => "@".charCodeAt(0))();
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new RuntimeError(5105, `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Either \`BrowserAnimationsModule\` or \`NoopAnimationsModule\` are imported in your application.
  - There is corresponding configuration for the animation named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.io/api/core/Component#animations).`);
  }
}
function isTemplateNode(node) {
  return node.tagName === "TEMPLATE" && node.content !== void 0;
}
var ShadowDomRenderer = class extends DefaultDomRenderer2 {
  constructor(eventManager, sharedStylesHost, hostEl, component, doc, ngZone, nonce, platformIsServer) {
    super(eventManager, doc, ngZone, platformIsServer);
    this.sharedStylesHost = sharedStylesHost;
    this.hostEl = hostEl;
    this.shadowRoot = hostEl.attachShadow({
      mode: "open"
    });
    this.sharedStylesHost.addHost(this.shadowRoot);
    const styles = shimStylesContent(component.id, component.styles);
    for (const style of styles) {
      const styleEl = document.createElement("style");
      if (nonce) {
        styleEl.setAttribute("nonce", nonce);
      }
      styleEl.textContent = style;
      this.shadowRoot.appendChild(styleEl);
    }
  }
  nodeOrShadowRoot(node) {
    return node === this.hostEl ? this.shadowRoot : node;
  }
  appendChild(parent2, newChild) {
    return super.appendChild(this.nodeOrShadowRoot(parent2), newChild);
  }
  insertBefore(parent2, newChild, refChild) {
    return super.insertBefore(this.nodeOrShadowRoot(parent2), newChild, refChild);
  }
  removeChild(parent2, oldChild) {
    return super.removeChild(this.nodeOrShadowRoot(parent2), oldChild);
  }
  parentNode(node) {
    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
  }
  destroy() {
    this.sharedStylesHost.removeHost(this.shadowRoot);
  }
};
var NoneEncapsulationDomRenderer = class extends DefaultDomRenderer2 {
  constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, compId) {
    super(eventManager, doc, ngZone, platformIsServer);
    this.sharedStylesHost = sharedStylesHost;
    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
    this.styles = compId ? shimStylesContent(compId, component.styles) : component.styles;
  }
  applyStyles() {
    this.sharedStylesHost.addStyles(this.styles);
  }
  destroy() {
    if (!this.removeStylesOnCompDestroy) {
      return;
    }
    this.sharedStylesHost.removeStyles(this.styles);
  }
};
var EmulatedEncapsulationDomRenderer2 = class extends NoneEncapsulationDomRenderer {
  constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer) {
    const compId = appId + "-" + component.id;
    super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, compId);
    this.contentAttr = shimContentAttribute(compId);
    this.hostAttr = shimHostAttribute(compId);
  }
  applyToHost(element) {
    this.applyStyles();
    this.setAttribute(element, this.hostAttr, "");
  }
  createElement(parent2, name) {
    const el = super.createElement(parent2, name);
    super.setAttribute(el, this.contentAttr, "");
    return el;
  }
};
var _DomEventsPlugin = class _DomEventsPlugin extends EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  // This plugin should come last in the list of plugins, because it accepts all
  // events.
  supports(eventName) {
    return true;
  }
  addEventListener(element, eventName, handler) {
    element.addEventListener(eventName, handler, false);
    return () => this.removeEventListener(element, eventName, handler);
  }
  removeEventListener(target, eventName, callback) {
    return target.removeEventListener(eventName, callback);
  }
};
_DomEventsPlugin.\u0275fac = function DomEventsPlugin_Factory(t3) {
  return new (t3 || _DomEventsPlugin)(\u0275\u0275inject(DOCUMENT2));
};
_DomEventsPlugin.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DomEventsPlugin,
  factory: _DomEventsPlugin.\u0275fac
});
var DomEventsPlugin = _DomEventsPlugin;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
var MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
var _keyMap = {
  "\b": "Backspace",
  "	": "Tab",
  "\x7F": "Delete",
  "\x1B": "Escape",
  "Del": "Delete",
  "Esc": "Escape",
  "Left": "ArrowLeft",
  "Right": "ArrowRight",
  "Up": "ArrowUp",
  "Down": "ArrowDown",
  "Menu": "ContextMenu",
  "Scroll": "ScrollLock",
  "Win": "OS"
};
var MODIFIER_KEY_GETTERS = {
  "alt": (event) => event.altKey,
  "control": (event) => event.ctrlKey,
  "meta": (event) => event.metaKey,
  "shift": (event) => event.shiftKey
};
var _KeyEventsPlugin = class _KeyEventsPlugin extends EventManagerPlugin {
  /**
   * Initializes an instance of the browser plug-in.
   * @param doc The document in which key events will be detected.
   */
  constructor(doc) {
    super(doc);
  }
  /**
   * Reports whether a named key event is supported.
   * @param eventName The event name to query.
   * @return True if the named key event is supported.
   */
  supports(eventName) {
    return _KeyEventsPlugin.parseEventName(eventName) != null;
  }
  /**
   * Registers a handler for a specific element and key event.
   * @param element The HTML element to receive event notifications.
   * @param eventName The name of the key event to listen for.
   * @param handler A function to call when the notification occurs. Receives the
   * event object as an argument.
   * @returns The key event that was registered.
   */
  addEventListener(element, eventName, handler) {
    const parsedEvent = _KeyEventsPlugin.parseEventName(eventName);
    const outsideHandler = _KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
    return this.manager.getZone().runOutsideAngular(() => {
      return getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler);
    });
  }
  /**
   * Parses the user provided full keyboard event definition and normalizes it for
   * later internal use. It ensures the string is all lowercase, converts special
   * characters to a standard spelling, and orders all the values consistently.
   *
   * @param eventName The name of the key event to listen for.
   * @returns an object with the full, normalized string, and the dom event name
   * or null in the case when the event doesn't match a keyboard event.
   */
  static parseEventName(eventName) {
    const parts = eventName.toLowerCase().split(".");
    const domEventName = parts.shift();
    if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
      return null;
    }
    const key = _KeyEventsPlugin._normalizeKey(parts.pop());
    let fullKey = "";
    let codeIX = parts.indexOf("code");
    if (codeIX > -1) {
      parts.splice(codeIX, 1);
      fullKey = "code.";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      const index3 = parts.indexOf(modifierName);
      if (index3 > -1) {
        parts.splice(index3, 1);
        fullKey += modifierName + ".";
      }
    });
    fullKey += key;
    if (parts.length != 0 || key.length === 0) {
      return null;
    }
    const result = {};
    result["domEventName"] = domEventName;
    result["fullKey"] = fullKey;
    return result;
  }
  /**
   * Determines whether the actual keys pressed match the configured key code string.
   * The `fullKeyCode` event is normalized in the `parseEventName` method when the
   * event is attached to the DOM during the `addEventListener` call. This is unseen
   * by the end user and is normalized for internal consistency and parsing.
   *
   * @param event The keyboard event.
   * @param fullKeyCode The normalized user defined expected key event string
   * @returns boolean.
   */
  static matchEventFullKeyCode(event, fullKeyCode) {
    let keycode = _keyMap[event.key] || event.key;
    let key = "";
    if (fullKeyCode.indexOf("code.") > -1) {
      keycode = event.code;
      key = "code.";
    }
    if (keycode == null || !keycode) return false;
    keycode = keycode.toLowerCase();
    if (keycode === " ") {
      keycode = "space";
    } else if (keycode === ".") {
      keycode = "dot";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      if (modifierName !== keycode) {
        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
        if (modifierGetter(event)) {
          key += modifierName + ".";
        }
      }
    });
    key += keycode;
    return key === fullKeyCode;
  }
  /**
   * Configures a handler callback for a key event.
   * @param fullKey The event name that combines all simultaneous keystrokes.
   * @param handler The function that responds to the key event.
   * @param zone The zone in which the event occurred.
   * @returns A callback function.
   */
  static eventCallback(fullKey, handler, zone) {
    return (event) => {
      if (_KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
        zone.runGuarded(() => handler(event));
      }
    };
  }
  /** @internal */
  static _normalizeKey(keyName) {
    return keyName === "esc" ? "escape" : keyName;
  }
};
_KeyEventsPlugin.\u0275fac = function KeyEventsPlugin_Factory(t3) {
  return new (t3 || _KeyEventsPlugin)(\u0275\u0275inject(DOCUMENT2));
};
_KeyEventsPlugin.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _KeyEventsPlugin,
  factory: _KeyEventsPlugin.\u0275fac
});
var KeyEventsPlugin = _KeyEventsPlugin;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyEventsPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
function bootstrapApplication(rootComponent, options) {
  return internalCreateApplication(__spreadValues({
    rootComponent
  }, createProvidersConfig(options)));
}
function createProvidersConfig(options) {
  return {
    appProviders: [...BROWSER_MODULE_PROVIDERS, ...options?.providers ?? []],
    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
  };
}
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new ErrorHandler();
}
function _document() {
  setDocument(document);
  return document;
}
var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
  provide: PLATFORM_ID,
  useValue: PLATFORM_BROWSER_ID
}, {
  provide: PLATFORM_INITIALIZER,
  useValue: initDomAdapter,
  multi: true
}, {
  provide: DOCUMENT2,
  useFactory: _document,
  deps: []
}];
var platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
var BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "BrowserModule Providers Marker" : "");
var TESTABILITY_PROVIDERS = [{
  provide: TESTABILITY_GETTER,
  useClass: BrowserGetTestability,
  deps: []
}, {
  provide: TESTABILITY,
  useClass: Testability,
  deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
}, {
  provide: Testability,
  // Also provide as `Testability` for backwards-compatibility.
  useClass: Testability,
  deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
}];
var BROWSER_MODULE_PROVIDERS = [{
  provide: INJECTOR_SCOPE,
  useValue: "root"
}, {
  provide: ErrorHandler,
  useFactory: errorHandler,
  deps: []
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: DomEventsPlugin,
  multi: true,
  deps: [DOCUMENT2, NgZone, PLATFORM_ID]
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: KeyEventsPlugin,
  multi: true,
  deps: [DOCUMENT2]
}, DomRendererFactory2, SharedStylesHost, EventManager, {
  provide: RendererFactory2,
  useExisting: DomRendererFactory2
}, {
  provide: XhrFactory,
  useClass: BrowserXhr,
  deps: []
}, typeof ngDevMode === "undefined" || ngDevMode ? {
  provide: BROWSER_MODULE_PROVIDERS_MARKER,
  useValue: true
} : []];
var _BrowserModule = class _BrowserModule {
  constructor(providersAlreadyPresent) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && providersAlreadyPresent) {
      throw new RuntimeError(5100, `Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
    }
  }
  /**
   * Configures a browser-based app to transition from a server-rendered app, if
   * one is present on the page.
   *
   * @param params An object containing an identifier for the app to transition.
   * The ID must match between the client and server versions of the app.
   * @returns The reconfigured `BrowserModule` to import into the app's root `AppModule`.
   *
   * @deprecated Use {@link APP_ID} instead to set the application ID.
   */
  static withServerTransition(params) {
    return {
      ngModule: _BrowserModule,
      providers: [{
        provide: APP_ID,
        useValue: params.appId
      }]
    };
  }
};
_BrowserModule.\u0275fac = function BrowserModule_Factory(t3) {
  return new (t3 || _BrowserModule)(\u0275\u0275inject(BROWSER_MODULE_PROVIDERS_MARKER, 12));
};
_BrowserModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _BrowserModule
});
_BrowserModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
  imports: [CommonModule, ApplicationModule]
});
var BrowserModule = _BrowserModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserModule, [{
    type: NgModule,
    args: [{
      providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
      exports: [CommonModule, ApplicationModule]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [BROWSER_MODULE_PROVIDERS_MARKER]
    }]
  }], null);
})();
var _Meta = class _Meta {
  constructor(_doc) {
    this._doc = _doc;
    this._dom = getDOM();
  }
  /**
   * Retrieves or creates a specific `<meta>` tag element in the current HTML document.
   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
   * values in the provided tag definition, and verifies that all other attribute values are equal.
   * If an existing element is found, it is returned and is not modified in any way.
   * @param tag The definition of a `<meta>` element to match or create.
   * @param forceCreation True to create a new element without checking whether one already exists.
   * @returns The existing element with the same attributes and values if found,
   * the new element if no match is found, or `null` if the tag parameter is not defined.
   */
  addTag(tag, forceCreation = false) {
    if (!tag) return null;
    return this._getOrCreateElement(tag, forceCreation);
  }
  /**
   * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.
   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
   * values in the provided tag definition, and verifies that all other attribute values are equal.
   * @param tags An array of tag definitions to match or create.
   * @param forceCreation True to create new elements without checking whether they already exist.
   * @returns The matching elements if found, or the new elements.
   */
  addTags(tags, forceCreation = false) {
    if (!tags) return [];
    return tags.reduce((result, tag) => {
      if (tag) {
        result.push(this._getOrCreateElement(tag, forceCreation));
      }
      return result;
    }, []);
  }
  /**
   * Retrieves a `<meta>` tag element in the current HTML document.
   * @param attrSelector The tag attribute and value to match against, in the format
   * `"tag_attribute='value string'"`.
   * @returns The matching element, if any.
   */
  getTag(attrSelector) {
    if (!attrSelector) return null;
    return this._doc.querySelector(`meta[${attrSelector}]`) || null;
  }
  /**
   * Retrieves a set of `<meta>` tag elements in the current HTML document.
   * @param attrSelector The tag attribute and value to match against, in the format
   * `"tag_attribute='value string'"`.
   * @returns The matching elements, if any.
   */
  getTags(attrSelector) {
    if (!attrSelector) return [];
    const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
    return list ? [].slice.call(list) : [];
  }
  /**
   * Modifies an existing `<meta>` tag element in the current HTML document.
   * @param tag The tag description with which to replace the existing tag content.
   * @param selector A tag attribute and value to match against, to identify
   * an existing tag. A string in the format `"tag_attribute=`value string`"`.
   * If not supplied, matches a tag with the same `name` or `property` attribute value as the
   * replacement tag.
   * @return The modified element.
   */
  updateTag(tag, selector) {
    if (!tag) return null;
    selector = selector || this._parseSelector(tag);
    const meta = this.getTag(selector);
    if (meta) {
      return this._setMetaElementAttributes(tag, meta);
    }
    return this._getOrCreateElement(tag, true);
  }
  /**
   * Removes an existing `<meta>` tag element from the current HTML document.
   * @param attrSelector A tag attribute and value to match against, to identify
   * an existing tag. A string in the format `"tag_attribute=`value string`"`.
   */
  removeTag(attrSelector) {
    this.removeTagElement(this.getTag(attrSelector));
  }
  /**
   * Removes an existing `<meta>` tag element from the current HTML document.
   * @param meta The tag definition to match against to identify an existing tag.
   */
  removeTagElement(meta) {
    if (meta) {
      this._dom.remove(meta);
    }
  }
  _getOrCreateElement(meta, forceCreation = false) {
    if (!forceCreation) {
      const selector = this._parseSelector(meta);
      const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
      if (elem !== void 0) return elem;
    }
    const element = this._dom.createElement("meta");
    this._setMetaElementAttributes(meta, element);
    const head = this._doc.getElementsByTagName("head")[0];
    head.appendChild(element);
    return element;
  }
  _setMetaElementAttributes(tag, el) {
    Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
    return el;
  }
  _parseSelector(tag) {
    const attr = tag.name ? "name" : "property";
    return `${attr}="${tag[attr]}"`;
  }
  _containsAttributes(tag, elem) {
    return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
  }
  _getMetaKeyMap(prop) {
    return META_KEYS_MAP[prop] || prop;
  }
};
_Meta.\u0275fac = function Meta_Factory(t3) {
  return new (t3 || _Meta)(\u0275\u0275inject(DOCUMENT2));
};
_Meta.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _Meta,
  factory: _Meta.\u0275fac,
  providedIn: "root"
});
var Meta = _Meta;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Meta, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
var META_KEYS_MAP = {
  httpEquiv: "http-equiv"
};
var _Title = class _Title {
  constructor(_doc) {
    this._doc = _doc;
  }
  /**
   * Get the title of the current HTML document.
   */
  getTitle() {
    return this._doc.title;
  }
  /**
   * Set the title of the current HTML document.
   * @param newTitle
   */
  setTitle(newTitle) {
    this._doc.title = newTitle || "";
  }
};
_Title.\u0275fac = function Title_Factory(t3) {
  return new (t3 || _Title)(\u0275\u0275inject(DOCUMENT2));
};
_Title.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _Title,
  factory: _Title.\u0275fac,
  providedIn: "root"
});
var Title = _Title;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Title, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
var EVENT_NAMES = {
  // pan
  "pan": true,
  "panstart": true,
  "panmove": true,
  "panend": true,
  "pancancel": true,
  "panleft": true,
  "panright": true,
  "panup": true,
  "pandown": true,
  // pinch
  "pinch": true,
  "pinchstart": true,
  "pinchmove": true,
  "pinchend": true,
  "pinchcancel": true,
  "pinchin": true,
  "pinchout": true,
  // press
  "press": true,
  "pressup": true,
  // rotate
  "rotate": true,
  "rotatestart": true,
  "rotatemove": true,
  "rotateend": true,
  "rotatecancel": true,
  // swipe
  "swipe": true,
  "swipeleft": true,
  "swiperight": true,
  "swipeup": true,
  "swipedown": true,
  // tap
  "tap": true,
  "doubletap": true
};
var HAMMER_GESTURE_CONFIG = new InjectionToken("HammerGestureConfig");
var HAMMER_LOADER = new InjectionToken("HammerLoader");
var _HammerGestureConfig = class _HammerGestureConfig {
  constructor() {
    this.events = [];
    this.overrides = {};
  }
  /**
   * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
   * and attaches it to a given HTML element.
   * @param element The element that will recognize gestures.
   * @returns A HammerJS event-manager object.
   */
  buildHammer(element) {
    const mc = new Hammer(element, this.options);
    mc.get("pinch").set({
      enable: true
    });
    mc.get("rotate").set({
      enable: true
    });
    for (const eventName in this.overrides) {
      mc.get(eventName).set(this.overrides[eventName]);
    }
    return mc;
  }
};
_HammerGestureConfig.\u0275fac = function HammerGestureConfig_Factory(t3) {
  return new (t3 || _HammerGestureConfig)();
};
_HammerGestureConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HammerGestureConfig,
  factory: _HammerGestureConfig.\u0275fac
});
var HammerGestureConfig = _HammerGestureConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGestureConfig, [{
    type: Injectable
  }], null, null);
})();
var _HammerGesturesPlugin = class _HammerGesturesPlugin extends EventManagerPlugin {
  constructor(doc, _config, console2, loader) {
    super(doc);
    this._config = _config;
    this.console = console2;
    this.loader = loader;
    this._loaderPromise = null;
  }
  supports(eventName) {
    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
      return false;
    }
    if (!window.Hammer && !this.loader) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
      }
      return false;
    }
    return true;
  }
  addEventListener(element, eventName, handler) {
    const zone = this.manager.getZone();
    eventName = eventName.toLowerCase();
    if (!window.Hammer && this.loader) {
      this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
      let cancelRegistration = false;
      let deregister = () => {
        cancelRegistration = true;
      };
      zone.runOutsideAngular(() => this._loaderPromise.then(() => {
        if (!window.Hammer) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
          }
          deregister = () => {
          };
          return;
        }
        if (!cancelRegistration) {
          deregister = this.addEventListener(element, eventName, handler);
        }
      }).catch(() => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          this.console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
        }
        deregister = () => {
        };
      }));
      return () => {
        deregister();
      };
    }
    return zone.runOutsideAngular(() => {
      const mc = this._config.buildHammer(element);
      const callback = function(eventObj) {
        zone.runGuarded(function() {
          handler(eventObj);
        });
      };
      mc.on(eventName, callback);
      return () => {
        mc.off(eventName, callback);
        if (typeof mc.destroy === "function") {
          mc.destroy();
        }
      };
    });
  }
  isCustomEvent(eventName) {
    return this._config.events.indexOf(eventName) > -1;
  }
};
_HammerGesturesPlugin.\u0275fac = function HammerGesturesPlugin_Factory(t3) {
  return new (t3 || _HammerGesturesPlugin)(\u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(HAMMER_GESTURE_CONFIG), \u0275\u0275inject(Console), \u0275\u0275inject(HAMMER_LOADER, 8));
};
_HammerGesturesPlugin.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HammerGesturesPlugin,
  factory: _HammerGesturesPlugin.\u0275fac
});
var HammerGesturesPlugin = _HammerGesturesPlugin;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGesturesPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }, {
    type: HammerGestureConfig,
    decorators: [{
      type: Inject,
      args: [HAMMER_GESTURE_CONFIG]
    }]
  }, {
    type: Console
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [HAMMER_LOADER]
    }]
  }], null);
})();
var _HammerModule = class _HammerModule {
};
_HammerModule.\u0275fac = function HammerModule_Factory(t3) {
  return new (t3 || _HammerModule)();
};
_HammerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _HammerModule
});
_HammerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [{
    provide: EVENT_MANAGER_PLUGINS,
    useClass: HammerGesturesPlugin,
    multi: true,
    deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
  }, {
    provide: HAMMER_GESTURE_CONFIG,
    useClass: HammerGestureConfig,
    deps: []
  }]
});
var HammerModule = _HammerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: EVENT_MANAGER_PLUGINS,
        useClass: HammerGesturesPlugin,
        multi: true,
        deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
      }, {
        provide: HAMMER_GESTURE_CONFIG,
        useClass: HammerGestureConfig,
        deps: []
      }]
    }]
  }], null, null);
})();
var _DomSanitizer = class _DomSanitizer {
};
_DomSanitizer.\u0275fac = function DomSanitizer_Factory(t3) {
  return new (t3 || _DomSanitizer)();
};
_DomSanitizer.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DomSanitizer,
  factory: function DomSanitizer_Factory(t3) {
    let r3 = null;
    if (t3) {
      r3 = new (t3 || _DomSanitizer)();
    } else {
      r3 = \u0275\u0275inject(DomSanitizerImpl);
    }
    return r3;
  },
  providedIn: "root"
});
var DomSanitizer = _DomSanitizer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizer, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: forwardRef(() => DomSanitizerImpl)
    }]
  }], null, null);
})();
var _DomSanitizerImpl = class _DomSanitizerImpl extends DomSanitizer {
  constructor(_doc) {
    super();
    this._doc = _doc;
  }
  sanitize(ctx, value) {
    if (value == null) return null;
    switch (ctx) {
      case SecurityContext.NONE:
        return value;
      case SecurityContext.HTML:
        if (allowSanitizationBypassAndThrow(
          value,
          "HTML"
          /* BypassType.Html */
        )) {
          return unwrapSafeValue(value);
        }
        return _sanitizeHtml(this._doc, String(value)).toString();
      case SecurityContext.STYLE:
        if (allowSanitizationBypassAndThrow(
          value,
          "Style"
          /* BypassType.Style */
        )) {
          return unwrapSafeValue(value);
        }
        return value;
      case SecurityContext.SCRIPT:
        if (allowSanitizationBypassAndThrow(
          value,
          "Script"
          /* BypassType.Script */
        )) {
          return unwrapSafeValue(value);
        }
        throw new RuntimeError(5200, (typeof ngDevMode === "undefined" || ngDevMode) && "unsafe value used in a script context");
      case SecurityContext.URL:
        if (allowSanitizationBypassAndThrow(
          value,
          "URL"
          /* BypassType.Url */
        )) {
          return unwrapSafeValue(value);
        }
        return _sanitizeUrl(String(value));
      case SecurityContext.RESOURCE_URL:
        if (allowSanitizationBypassAndThrow(
          value,
          "ResourceURL"
          /* BypassType.ResourceUrl */
        )) {
          return unwrapSafeValue(value);
        }
        throw new RuntimeError(5201, (typeof ngDevMode === "undefined" || ngDevMode) && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
      default:
        throw new RuntimeError(5202, (typeof ngDevMode === "undefined" || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${XSS_SECURITY_URL})`);
    }
  }
  bypassSecurityTrustHtml(value) {
    return bypassSanitizationTrustHtml(value);
  }
  bypassSecurityTrustStyle(value) {
    return bypassSanitizationTrustStyle(value);
  }
  bypassSecurityTrustScript(value) {
    return bypassSanitizationTrustScript(value);
  }
  bypassSecurityTrustUrl(value) {
    return bypassSanitizationTrustUrl(value);
  }
  bypassSecurityTrustResourceUrl(value) {
    return bypassSanitizationTrustResourceUrl(value);
  }
};
_DomSanitizerImpl.\u0275fac = function DomSanitizerImpl_Factory(t3) {
  return new (t3 || _DomSanitizerImpl)(\u0275\u0275inject(DOCUMENT2));
};
_DomSanitizerImpl.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DomSanitizerImpl,
  factory: _DomSanitizerImpl.\u0275fac,
  providedIn: "root"
});
var DomSanitizerImpl = _DomSanitizerImpl;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizerImpl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
var HydrationFeatureKind;
(function(HydrationFeatureKind2) {
  HydrationFeatureKind2[HydrationFeatureKind2["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
  HydrationFeatureKind2[HydrationFeatureKind2["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
  HydrationFeatureKind2[HydrationFeatureKind2["I18nSupport"] = 2] = "I18nSupport";
  HydrationFeatureKind2[HydrationFeatureKind2["EventReplay"] = 3] = "EventReplay";
})(HydrationFeatureKind || (HydrationFeatureKind = {}));
var VERSION3 = new Version("18.0.1");

// node_modules/@angular/router/fesm2022/router.mjs
var PRIMARY_OUTLET = "primary";
var RouteTitleKey = /* @__PURE__ */ Symbol("RouteTitle");
var ParamsAsMap = class {
  constructor(params) {
    this.params = params || {};
  }
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.params, name);
  }
  get(name) {
    if (this.has(name)) {
      const v3 = this.params[name];
      return Array.isArray(v3) ? v3[0] : v3;
    }
    return null;
  }
  getAll(name) {
    if (this.has(name)) {
      const v3 = this.params[name];
      return Array.isArray(v3) ? v3 : [v3];
    }
    return [];
  }
  get keys() {
    return Object.keys(this.params);
  }
};
function convertToParamMap(params) {
  return new ParamsAsMap(params);
}
function defaultUrlMatcher(segments, segmentGroup, route) {
  const parts = route.path.split("/");
  if (parts.length > segments.length) {
    return null;
  }
  if (route.pathMatch === "full" && (segmentGroup.hasChildren() || parts.length < segments.length)) {
    return null;
  }
  const posParams = {};
  for (let index3 = 0; index3 < parts.length; index3++) {
    const part = parts[index3];
    const segment = segments[index3];
    const isParameter = part[0] === ":";
    if (isParameter) {
      posParams[part.substring(1)] = segment;
    } else if (part !== segment.path) {
      return null;
    }
  }
  return {
    consumed: segments.slice(0, parts.length),
    posParams
  };
}
function shallowEqualArrays(a3, b3) {
  if (a3.length !== b3.length) return false;
  for (let i3 = 0; i3 < a3.length; ++i3) {
    if (!shallowEqual(a3[i3], b3[i3])) return false;
  }
  return true;
}
function shallowEqual(a3, b3) {
  const k1 = a3 ? getDataKeys(a3) : void 0;
  const k22 = b3 ? getDataKeys(b3) : void 0;
  if (!k1 || !k22 || k1.length != k22.length) {
    return false;
  }
  let key;
  for (let i3 = 0; i3 < k1.length; i3++) {
    key = k1[i3];
    if (!equalArraysOrString(a3[key], b3[key])) {
      return false;
    }
  }
  return true;
}
function getDataKeys(obj) {
  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];
}
function equalArraysOrString(a3, b3) {
  if (Array.isArray(a3) && Array.isArray(b3)) {
    if (a3.length !== b3.length) return false;
    const aSorted = [...a3].sort();
    const bSorted = [...b3].sort();
    return aSorted.every((val, index3) => bSorted[index3] === val);
  } else {
    return a3 === b3;
  }
}
function last3(a3) {
  return a3.length > 0 ? a3[a3.length - 1] : null;
}
function wrapIntoObservable(value) {
  if (isObservable(value)) {
    return value;
  }
  if (isPromise2(value)) {
    return from(Promise.resolve(value));
  }
  return of(value);
}
var pathCompareMap = {
  "exact": equalSegmentGroups,
  "subset": containsSegmentGroup
};
var paramCompareMap = {
  "exact": equalParams,
  "subset": containsParams,
  "ignored": () => true
};
function containsTree(container, containee, options) {
  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === "exact" && container.fragment !== containee.fragment);
}
function equalParams(container, containee) {
  return shallowEqual(container, containee);
}
function equalSegmentGroups(container, containee, matrixParams) {
  if (!equalPath(container.segments, containee.segments)) return false;
  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {
    return false;
  }
  if (container.numberOfChildren !== containee.numberOfChildren) return false;
  for (const c3 in containee.children) {
    if (!container.children[c3]) return false;
    if (!equalSegmentGroups(container.children[c3], containee.children[c3], matrixParams)) return false;
  }
  return true;
}
function containsParams(container, containee) {
  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]));
}
function containsSegmentGroup(container, containee, matrixParams) {
  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);
}
function containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {
  if (container.segments.length > containeePaths.length) {
    const current = container.segments.slice(0, containeePaths.length);
    if (!equalPath(current, containeePaths)) return false;
    if (containee.hasChildren()) return false;
    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;
    return true;
  } else if (container.segments.length === containeePaths.length) {
    if (!equalPath(container.segments, containeePaths)) return false;
    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;
    for (const c3 in containee.children) {
      if (!container.children[c3]) return false;
      if (!containsSegmentGroup(container.children[c3], containee.children[c3], matrixParams)) {
        return false;
      }
    }
    return true;
  } else {
    const current = containeePaths.slice(0, container.segments.length);
    const next = containeePaths.slice(container.segments.length);
    if (!equalPath(container.segments, current)) return false;
    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;
    if (!container.children[PRIMARY_OUTLET]) return false;
    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);
  }
}
function matrixParamsMatch(containerPaths, containeePaths, options) {
  return containeePaths.every((containeeSegment, i3) => {
    return paramCompareMap[options](containerPaths[i3].parameters, containeeSegment.parameters);
  });
}
var UrlTree = class {
  constructor(root = new UrlSegmentGroup([], {}), queryParams = {}, fragment = null) {
    this.root = root;
    this.queryParams = queryParams;
    this.fragment = fragment;
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (root.segments.length > 0) {
        throw new RuntimeError(4015, "The root `UrlSegmentGroup` should not contain `segments`. Instead, these segments belong in the `children` so they can be associated with a named outlet.");
      }
    }
  }
  get queryParamMap() {
    this._queryParamMap ??= convertToParamMap(this.queryParams);
    return this._queryParamMap;
  }
  /** @docsNotRequired */
  toString() {
    return DEFAULT_SERIALIZER.serialize(this);
  }
};
var UrlSegmentGroup = class {
  constructor(segments, children) {
    this.segments = segments;
    this.children = children;
    this.parent = null;
    Object.values(children).forEach((v3) => v3.parent = this);
  }
  /** Whether the segment has child segments */
  hasChildren() {
    return this.numberOfChildren > 0;
  }
  /** Number of child segments */
  get numberOfChildren() {
    return Object.keys(this.children).length;
  }
  /** @docsNotRequired */
  toString() {
    return serializePaths(this);
  }
};
var UrlSegment = class {
  constructor(path, parameters) {
    this.path = path;
    this.parameters = parameters;
  }
  get parameterMap() {
    this._parameterMap ??= convertToParamMap(this.parameters);
    return this._parameterMap;
  }
  /** @docsNotRequired */
  toString() {
    return serializePath(this);
  }
};
function equalSegments(as, bs) {
  return equalPath(as, bs) && as.every((a3, i3) => shallowEqual(a3.parameters, bs[i3].parameters));
}
function equalPath(as, bs) {
  if (as.length !== bs.length) return false;
  return as.every((a3, i3) => a3.path === bs[i3].path);
}
function mapChildrenIntoArray(segment, fn) {
  let res = [];
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet === PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet !== PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  return res;
}
var _UrlSerializer = class _UrlSerializer {
};
_UrlSerializer.\u0275fac = function UrlSerializer_Factory(t3) {
  return new (t3 || _UrlSerializer)();
};
_UrlSerializer.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _UrlSerializer,
  factory: () => (() => new DefaultUrlSerializer())(),
  providedIn: "root"
});
var UrlSerializer = _UrlSerializer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlSerializer, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => new DefaultUrlSerializer()
    }]
  }], null, null);
})();
var DefaultUrlSerializer = class {
  /** Parses a url into a `UrlTree` */
  parse(url) {
    const p3 = new UrlParser(url);
    return new UrlTree(p3.parseRootSegment(), p3.parseQueryParams(), p3.parseFragment());
  }
  /** Converts a `UrlTree` into a url */
  serialize(tree2) {
    const segment = `/${serializeSegment(tree2.root, true)}`;
    const query = serializeQueryParams(tree2.queryParams);
    const fragment = typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : "";
    return `${segment}${query}${fragment}`;
  }
};
var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
function serializePaths(segment) {
  return segment.segments.map((p3) => serializePath(p3)).join("/");
}
function serializeSegment(segment, root) {
  if (!segment.hasChildren()) {
    return serializePaths(segment);
  }
  if (root) {
    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : "";
    const children = [];
    Object.entries(segment.children).forEach(([k3, v3]) => {
      if (k3 !== PRIMARY_OUTLET) {
        children.push(`${k3}:${serializeSegment(v3, false)}`);
      }
    });
    return children.length > 0 ? `${primary}(${children.join("//")})` : primary;
  } else {
    const children = mapChildrenIntoArray(segment, (v3, k3) => {
      if (k3 === PRIMARY_OUTLET) {
        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
      }
      return [`${k3}:${serializeSegment(v3, false)}`];
    });
    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
      return `${serializePaths(segment)}/${children[0]}`;
    }
    return `${serializePaths(segment)}/(${children.join("//")})`;
  }
}
function encodeUriString(s3) {
  return encodeURIComponent(s3).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",");
}
function encodeUriQuery(s3) {
  return encodeUriString(s3).replace(/%3B/gi, ";");
}
function encodeUriFragment(s3) {
  return encodeURI(s3);
}
function encodeUriSegment(s3) {
  return encodeUriString(s3).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&");
}
function decode(s3) {
  return decodeURIComponent(s3);
}
function decodeQuery(s3) {
  return decode(s3.replace(/\+/g, "%20"));
}
function serializePath(path) {
  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;
}
function serializeMatrixParams(params) {
  return Object.entries(params).map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`).join("");
}
function serializeQueryParams(params) {
  const strParams = Object.entries(params).map(([name, value]) => {
    return Array.isArray(value) ? value.map((v3) => `${encodeUriQuery(name)}=${encodeUriQuery(v3)}`).join("&") : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;
  }).filter((s3) => s3);
  return strParams.length ? `?${strParams.join("&")}` : "";
}
var SEGMENT_RE = /^[^\/()?;#]+/;
function matchSegments(str) {
  const match2 = str.match(SEGMENT_RE);
  return match2 ? match2[0] : "";
}
var MATRIX_PARAM_SEGMENT_RE = /^[^\/()?;=#]+/;
function matchMatrixKeySegments(str) {
  const match2 = str.match(MATRIX_PARAM_SEGMENT_RE);
  return match2 ? match2[0] : "";
}
var QUERY_PARAM_RE = /^[^=?&#]+/;
function matchQueryParams(str) {
  const match2 = str.match(QUERY_PARAM_RE);
  return match2 ? match2[0] : "";
}
var QUERY_PARAM_VALUE_RE = /^[^&#]+/;
function matchUrlQueryParamValue(str) {
  const match2 = str.match(QUERY_PARAM_VALUE_RE);
  return match2 ? match2[0] : "";
}
var UrlParser = class {
  constructor(url) {
    this.url = url;
    this.remaining = url;
  }
  parseRootSegment() {
    this.consumeOptional("/");
    if (this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#")) {
      return new UrlSegmentGroup([], {});
    }
    return new UrlSegmentGroup([], this.parseChildren());
  }
  parseQueryParams() {
    const params = {};
    if (this.consumeOptional("?")) {
      do {
        this.parseQueryParam(params);
      } while (this.consumeOptional("&"));
    }
    return params;
  }
  parseFragment() {
    return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null;
  }
  parseChildren() {
    if (this.remaining === "") {
      return {};
    }
    this.consumeOptional("/");
    const segments = [];
    if (!this.peekStartsWith("(")) {
      segments.push(this.parseSegment());
    }
    while (this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(")) {
      this.capture("/");
      segments.push(this.parseSegment());
    }
    let children = {};
    if (this.peekStartsWith("/(")) {
      this.capture("/");
      children = this.parseParens(true);
    }
    let res = {};
    if (this.peekStartsWith("(")) {
      res = this.parseParens(false);
    }
    if (segments.length > 0 || Object.keys(children).length > 0) {
      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
    }
    return res;
  }
  // parse a segment with its matrix parameters
  // ie `name;k1=v1;k2`
  parseSegment() {
    const path = matchSegments(this.remaining);
    if (path === "" && this.peekStartsWith(";")) {
      throw new RuntimeError(4009, (typeof ngDevMode === "undefined" || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);
    }
    this.capture(path);
    return new UrlSegment(decode(path), this.parseMatrixParams());
  }
  parseMatrixParams() {
    const params = {};
    while (this.consumeOptional(";")) {
      this.parseParam(params);
    }
    return params;
  }
  parseParam(params) {
    const key = matchMatrixKeySegments(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value = "";
    if (this.consumeOptional("=")) {
      const valueMatch = matchSegments(this.remaining);
      if (valueMatch) {
        value = valueMatch;
        this.capture(value);
      }
    }
    params[decode(key)] = decode(value);
  }
  // Parse a single query parameter `name[=value]`
  parseQueryParam(params) {
    const key = matchQueryParams(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value = "";
    if (this.consumeOptional("=")) {
      const valueMatch = matchUrlQueryParamValue(this.remaining);
      if (valueMatch) {
        value = valueMatch;
        this.capture(value);
      }
    }
    const decodedKey = decodeQuery(key);
    const decodedVal = decodeQuery(value);
    if (params.hasOwnProperty(decodedKey)) {
      let currentVal = params[decodedKey];
      if (!Array.isArray(currentVal)) {
        currentVal = [currentVal];
        params[decodedKey] = currentVal;
      }
      currentVal.push(decodedVal);
    } else {
      params[decodedKey] = decodedVal;
    }
  }
  // parse `(a/b//outlet_name:c/d)`
  parseParens(allowPrimary) {
    const segments = {};
    this.capture("(");
    while (!this.consumeOptional(")") && this.remaining.length > 0) {
      const path = matchSegments(this.remaining);
      const next = this.remaining[path.length];
      if (next !== "/" && next !== ")" && next !== ";") {
        throw new RuntimeError(4010, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot parse url '${this.url}'`);
      }
      let outletName = void 0;
      if (path.indexOf(":") > -1) {
        outletName = path.slice(0, path.indexOf(":"));
        this.capture(outletName);
        this.capture(":");
      } else if (allowPrimary) {
        outletName = PRIMARY_OUTLET;
      }
      const children = this.parseChildren();
      segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
      this.consumeOptional("//");
    }
    return segments;
  }
  peekStartsWith(str) {
    return this.remaining.startsWith(str);
  }
  // Consumes the prefix when it is present and returns whether it has been consumed
  consumeOptional(str) {
    if (this.peekStartsWith(str)) {
      this.remaining = this.remaining.substring(str.length);
      return true;
    }
    return false;
  }
  capture(str) {
    if (!this.consumeOptional(str)) {
      throw new RuntimeError(4011, (typeof ngDevMode === "undefined" || ngDevMode) && `Expected "${str}".`);
    }
  }
};
function createRoot(rootCandidate) {
  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {
    [PRIMARY_OUTLET]: rootCandidate
  }) : rootCandidate;
}
function squashSegmentGroup(segmentGroup) {
  const newChildren = {};
  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {
    const childCandidate = squashSegmentGroup(child);
    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {
      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {
        newChildren[grandChildOutlet] = grandChild;
      }
    } else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
      newChildren[childOutlet] = childCandidate;
    }
  }
  const s3 = new UrlSegmentGroup(segmentGroup.segments, newChildren);
  return mergeTrivialChildren(s3);
}
function mergeTrivialChildren(s3) {
  if (s3.numberOfChildren === 1 && s3.children[PRIMARY_OUTLET]) {
    const c3 = s3.children[PRIMARY_OUTLET];
    return new UrlSegmentGroup(s3.segments.concat(c3.segments), c3.children);
  }
  return s3;
}
function isUrlTree(v3) {
  return v3 instanceof UrlTree;
}
function createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {
  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);
  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);
}
function createSegmentGroupFromRoute(route) {
  let targetGroup;
  function createSegmentGroupFromRouteRecursive(currentRoute) {
    const childOutlets = {};
    for (const childSnapshot of currentRoute.children) {
      const root = createSegmentGroupFromRouteRecursive(childSnapshot);
      childOutlets[childSnapshot.outlet] = root;
    }
    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);
    if (currentRoute === route) {
      targetGroup = segmentGroup;
    }
    return segmentGroup;
  }
  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);
  const rootSegmentGroup = createRoot(rootCandidate);
  return targetGroup ?? rootSegmentGroup;
}
function createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {
  let root = relativeTo;
  while (root.parent) {
    root = root.parent;
  }
  if (commands.length === 0) {
    return tree(root, root, root, queryParams, fragment);
  }
  const nav = computeNavigation(commands);
  if (nav.toRoot()) {
    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);
  }
  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);
  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);
  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);
}
function isMatrixParams(command) {
  return typeof command === "object" && command != null && !command.outlets && !command.segmentPath;
}
function isCommandWithOutlets(command) {
  return typeof command === "object" && command != null && command.outlets;
}
function tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {
  let qp = {};
  if (queryParams) {
    Object.entries(queryParams).forEach(([name, value]) => {
      qp[name] = Array.isArray(value) ? value.map((v3) => `${v3}`) : `${value}`;
    });
  }
  let rootCandidate;
  if (oldRoot === oldSegmentGroup) {
    rootCandidate = newSegmentGroup;
  } else {
    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);
  }
  const newRoot = createRoot(squashSegmentGroup(rootCandidate));
  return new UrlTree(newRoot, qp, fragment);
}
function replaceSegment(current, oldSegment, newSegment) {
  const children = {};
  Object.entries(current.children).forEach(([outletName, c3]) => {
    if (c3 === oldSegment) {
      children[outletName] = newSegment;
    } else {
      children[outletName] = replaceSegment(c3, oldSegment, newSegment);
    }
  });
  return new UrlSegmentGroup(current.segments, children);
}
var Navigation = class {
  constructor(isAbsolute, numberOfDoubleDots, commands) {
    this.isAbsolute = isAbsolute;
    this.numberOfDoubleDots = numberOfDoubleDots;
    this.commands = commands;
    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
      throw new RuntimeError(4003, (typeof ngDevMode === "undefined" || ngDevMode) && "Root segment cannot have matrix parameters");
    }
    const cmdWithOutlet = commands.find(isCommandWithOutlets);
    if (cmdWithOutlet && cmdWithOutlet !== last3(commands)) {
      throw new RuntimeError(4004, (typeof ngDevMode === "undefined" || ngDevMode) && "{outlets:{}} has to be the last command");
    }
  }
  toRoot() {
    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/";
  }
};
function computeNavigation(commands) {
  if (typeof commands[0] === "string" && commands.length === 1 && commands[0] === "/") {
    return new Navigation(true, 0, commands);
  }
  let numberOfDoubleDots = 0;
  let isAbsolute = false;
  const res = commands.reduce((res2, cmd, cmdIdx) => {
    if (typeof cmd === "object" && cmd != null) {
      if (cmd.outlets) {
        const outlets = {};
        Object.entries(cmd.outlets).forEach(([name, commands2]) => {
          outlets[name] = typeof commands2 === "string" ? commands2.split("/") : commands2;
        });
        return [...res2, {
          outlets
        }];
      }
      if (cmd.segmentPath) {
        return [...res2, cmd.segmentPath];
      }
    }
    if (!(typeof cmd === "string")) {
      return [...res2, cmd];
    }
    if (cmdIdx === 0) {
      cmd.split("/").forEach((urlPart, partIndex) => {
        if (partIndex == 0 && urlPart === ".") {
        } else if (partIndex == 0 && urlPart === "") {
          isAbsolute = true;
        } else if (urlPart === "..") {
          numberOfDoubleDots++;
        } else if (urlPart != "") {
          res2.push(urlPart);
        }
      });
      return res2;
    }
    return [...res2, cmd];
  }, []);
  return new Navigation(isAbsolute, numberOfDoubleDots, res);
}
var Position = class {
  constructor(segmentGroup, processChildren, index3) {
    this.segmentGroup = segmentGroup;
    this.processChildren = processChildren;
    this.index = index3;
  }
};
function findStartingPositionForTargetGroup(nav, root, target) {
  if (nav.isAbsolute) {
    return new Position(root, true, 0);
  }
  if (!target) {
    return new Position(root, false, NaN);
  }
  if (target.parent === null) {
    return new Position(target, true, 0);
  }
  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
  const index3 = target.segments.length - 1 + modifier;
  return createPositionApplyingDoubleDots(target, index3, nav.numberOfDoubleDots);
}
function createPositionApplyingDoubleDots(group, index3, numberOfDoubleDots) {
  let g4 = group;
  let ci = index3;
  let dd = numberOfDoubleDots;
  while (dd > ci) {
    dd -= ci;
    g4 = g4.parent;
    if (!g4) {
      throw new RuntimeError(4005, (typeof ngDevMode === "undefined" || ngDevMode) && "Invalid number of '../'");
    }
    ci = g4.segments.length;
  }
  return new Position(g4, false, ci - dd);
}
function getOutlets(commands) {
  if (isCommandWithOutlets(commands[0])) {
    return commands[0].outlets;
  }
  return {
    [PRIMARY_OUTLET]: commands
  };
}
function updateSegmentGroup(segmentGroup, startIndex, commands) {
  segmentGroup ??= new UrlSegmentGroup([], {});
  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
  }
  const m3 = prefixedWith(segmentGroup, startIndex, commands);
  const slicedCommands = commands.slice(m3.commandIndex);
  if (m3.match && m3.pathIndex < segmentGroup.segments.length) {
    const g4 = new UrlSegmentGroup(segmentGroup.segments.slice(0, m3.pathIndex), {});
    g4.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m3.pathIndex), segmentGroup.children);
    return updateSegmentGroupChildren(g4, 0, slicedCommands);
  } else if (m3.match && slicedCommands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else if (m3.match && !segmentGroup.hasChildren()) {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  } else if (m3.match) {
    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
  } else {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  }
}
function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
  if (commands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else {
    const outlets = getOutlets(commands);
    const children = {};
    if (Object.keys(outlets).some((o2) => o2 !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {
      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);
      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);
    }
    Object.entries(outlets).forEach(([outlet, commands2]) => {
      if (typeof commands2 === "string") {
        commands2 = [commands2];
      }
      if (commands2 !== null) {
        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);
      }
    });
    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {
      if (outlets[childOutlet] === void 0) {
        children[childOutlet] = child;
      }
    });
    return new UrlSegmentGroup(segmentGroup.segments, children);
  }
}
function prefixedWith(segmentGroup, startIndex, commands) {
  let currentCommandIndex = 0;
  let currentPathIndex = startIndex;
  const noMatch2 = {
    match: false,
    pathIndex: 0,
    commandIndex: 0
  };
  while (currentPathIndex < segmentGroup.segments.length) {
    if (currentCommandIndex >= commands.length) return noMatch2;
    const path = segmentGroup.segments[currentPathIndex];
    const command = commands[currentCommandIndex];
    if (isCommandWithOutlets(command)) {
      break;
    }
    const curr = `${command}`;
    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
    if (currentPathIndex > 0 && curr === void 0) break;
    if (curr && next && typeof next === "object" && next.outlets === void 0) {
      if (!compare(curr, next, path)) return noMatch2;
      currentCommandIndex += 2;
    } else {
      if (!compare(curr, {}, path)) return noMatch2;
      currentCommandIndex++;
    }
    currentPathIndex++;
  }
  return {
    match: true,
    pathIndex: currentPathIndex,
    commandIndex: currentCommandIndex
  };
}
function createNewSegmentGroup(segmentGroup, startIndex, commands) {
  const paths = segmentGroup.segments.slice(0, startIndex);
  let i3 = 0;
  while (i3 < commands.length) {
    const command = commands[i3];
    if (isCommandWithOutlets(command)) {
      const children = createNewSegmentChildren(command.outlets);
      return new UrlSegmentGroup(paths, children);
    }
    if (i3 === 0 && isMatrixParams(commands[0])) {
      const p3 = segmentGroup.segments[startIndex];
      paths.push(new UrlSegment(p3.path, stringify2(commands[0])));
      i3++;
      continue;
    }
    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;
    const next = i3 < commands.length - 1 ? commands[i3 + 1] : null;
    if (curr && next && isMatrixParams(next)) {
      paths.push(new UrlSegment(curr, stringify2(next)));
      i3 += 2;
    } else {
      paths.push(new UrlSegment(curr, {}));
      i3++;
    }
  }
  return new UrlSegmentGroup(paths, {});
}
function createNewSegmentChildren(outlets) {
  const children = {};
  Object.entries(outlets).forEach(([outlet, commands]) => {
    if (typeof commands === "string") {
      commands = [commands];
    }
    if (commands !== null) {
      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
    }
  });
  return children;
}
function stringify2(params) {
  const res = {};
  Object.entries(params).forEach(([k3, v3]) => res[k3] = `${v3}`);
  return res;
}
function compare(path, params, segment) {
  return path == segment.path && shallowEqual(params, segment.parameters);
}
var IMPERATIVE_NAVIGATION = "imperative";
var EventType;
(function(EventType2) {
  EventType2[EventType2["NavigationStart"] = 0] = "NavigationStart";
  EventType2[EventType2["NavigationEnd"] = 1] = "NavigationEnd";
  EventType2[EventType2["NavigationCancel"] = 2] = "NavigationCancel";
  EventType2[EventType2["NavigationError"] = 3] = "NavigationError";
  EventType2[EventType2["RoutesRecognized"] = 4] = "RoutesRecognized";
  EventType2[EventType2["ResolveStart"] = 5] = "ResolveStart";
  EventType2[EventType2["ResolveEnd"] = 6] = "ResolveEnd";
  EventType2[EventType2["GuardsCheckStart"] = 7] = "GuardsCheckStart";
  EventType2[EventType2["GuardsCheckEnd"] = 8] = "GuardsCheckEnd";
  EventType2[EventType2["RouteConfigLoadStart"] = 9] = "RouteConfigLoadStart";
  EventType2[EventType2["RouteConfigLoadEnd"] = 10] = "RouteConfigLoadEnd";
  EventType2[EventType2["ChildActivationStart"] = 11] = "ChildActivationStart";
  EventType2[EventType2["ChildActivationEnd"] = 12] = "ChildActivationEnd";
  EventType2[EventType2["ActivationStart"] = 13] = "ActivationStart";
  EventType2[EventType2["ActivationEnd"] = 14] = "ActivationEnd";
  EventType2[EventType2["Scroll"] = 15] = "Scroll";
  EventType2[EventType2["NavigationSkipped"] = 16] = "NavigationSkipped";
})(EventType || (EventType = {}));
var RouterEvent = class {
  constructor(id, url) {
    this.id = id;
    this.url = url;
  }
};
var NavigationStart = class extends RouterEvent {
  constructor(id, url, navigationTrigger = "imperative", restoredState = null) {
    super(id, url);
    this.type = EventType.NavigationStart;
    this.navigationTrigger = navigationTrigger;
    this.restoredState = restoredState;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
  }
};
var NavigationEnd = class extends RouterEvent {
  constructor(id, url, urlAfterRedirects) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.type = EventType.NavigationEnd;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
  }
};
var NavigationCancellationCode;
(function(NavigationCancellationCode2) {
  NavigationCancellationCode2[NavigationCancellationCode2["Redirect"] = 0] = "Redirect";
  NavigationCancellationCode2[NavigationCancellationCode2["SupersededByNewNavigation"] = 1] = "SupersededByNewNavigation";
  NavigationCancellationCode2[NavigationCancellationCode2["NoDataFromResolver"] = 2] = "NoDataFromResolver";
  NavigationCancellationCode2[NavigationCancellationCode2["GuardRejected"] = 3] = "GuardRejected";
})(NavigationCancellationCode || (NavigationCancellationCode = {}));
var NavigationSkippedCode;
(function(NavigationSkippedCode2) {
  NavigationSkippedCode2[NavigationSkippedCode2["IgnoredSameUrlNavigation"] = 0] = "IgnoredSameUrlNavigation";
  NavigationSkippedCode2[NavigationSkippedCode2["IgnoredByUrlHandlingStrategy"] = 1] = "IgnoredByUrlHandlingStrategy";
})(NavigationSkippedCode || (NavigationSkippedCode = {}));
var NavigationCancel = class extends RouterEvent {
  constructor(id, url, reason, code) {
    super(id, url);
    this.reason = reason;
    this.code = code;
    this.type = EventType.NavigationCancel;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
  }
};
var NavigationSkipped = class extends RouterEvent {
  constructor(id, url, reason, code) {
    super(id, url);
    this.reason = reason;
    this.code = code;
    this.type = EventType.NavigationSkipped;
  }
};
var NavigationError = class extends RouterEvent {
  constructor(id, url, error, target) {
    super(id, url);
    this.error = error;
    this.target = target;
    this.type = EventType.NavigationError;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
  }
};
var RoutesRecognized = class extends RouterEvent {
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.type = EventType.RoutesRecognized;
  }
  /** @docsNotRequired */
  toString() {
    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var GuardsCheckStart = class extends RouterEvent {
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.type = EventType.GuardsCheckStart;
  }
  toString() {
    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var GuardsCheckEnd = class extends RouterEvent {
  constructor(id, url, urlAfterRedirects, state, shouldActivate) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.shouldActivate = shouldActivate;
    this.type = EventType.GuardsCheckEnd;
  }
  toString() {
    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
  }
};
var ResolveStart = class extends RouterEvent {
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.type = EventType.ResolveStart;
  }
  toString() {
    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var ResolveEnd = class extends RouterEvent {
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.type = EventType.ResolveEnd;
  }
  toString() {
    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var RouteConfigLoadStart = class {
  constructor(route) {
    this.route = route;
    this.type = EventType.RouteConfigLoadStart;
  }
  toString() {
    return `RouteConfigLoadStart(path: ${this.route.path})`;
  }
};
var RouteConfigLoadEnd = class {
  constructor(route) {
    this.route = route;
    this.type = EventType.RouteConfigLoadEnd;
  }
  toString() {
    return `RouteConfigLoadEnd(path: ${this.route.path})`;
  }
};
var ChildActivationStart = class {
  constructor(snapshot) {
    this.snapshot = snapshot;
    this.type = EventType.ChildActivationStart;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ChildActivationStart(path: '${path}')`;
  }
};
var ChildActivationEnd = class {
  constructor(snapshot) {
    this.snapshot = snapshot;
    this.type = EventType.ChildActivationEnd;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ChildActivationEnd(path: '${path}')`;
  }
};
var ActivationStart = class {
  constructor(snapshot) {
    this.snapshot = snapshot;
    this.type = EventType.ActivationStart;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ActivationStart(path: '${path}')`;
  }
};
var ActivationEnd = class {
  constructor(snapshot) {
    this.snapshot = snapshot;
    this.type = EventType.ActivationEnd;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ActivationEnd(path: '${path}')`;
  }
};
var Scroll = class {
  constructor(routerEvent, position, anchor) {
    this.routerEvent = routerEvent;
    this.position = position;
    this.anchor = anchor;
    this.type = EventType.Scroll;
  }
  toString() {
    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
  }
};
var BeforeActivateRoutes = class {
};
var RedirectRequest = class {
  constructor(url, navigationBehaviorOptions) {
    this.url = url;
    this.navigationBehaviorOptions = navigationBehaviorOptions;
  }
};
function stringifyEvent(routerEvent) {
  switch (routerEvent.type) {
    case EventType.ActivationEnd:
      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ActivationStart:
      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationEnd:
      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationStart:
      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.GuardsCheckEnd:
      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;
    case EventType.GuardsCheckStart:
      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.NavigationCancel:
      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationSkipped:
      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationEnd:
      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;
    case EventType.NavigationError:
      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;
    case EventType.NavigationStart:
      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.ResolveEnd:
      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.ResolveStart:
      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.RouteConfigLoadEnd:
      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;
    case EventType.RouteConfigLoadStart:
      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;
    case EventType.RoutesRecognized:
      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.Scroll:
      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;
      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;
  }
}
var OutletContext = class {
  constructor(injector) {
    this.injector = injector;
    this.outlet = null;
    this.route = null;
    this.children = new ChildrenOutletContexts(this.injector);
    this.attachRef = null;
  }
};
var _ChildrenOutletContexts = class _ChildrenOutletContexts {
  /** @nodoc */
  constructor(parentInjector) {
    this.parentInjector = parentInjector;
    this.contexts = /* @__PURE__ */ new Map();
  }
  /** Called when a `RouterOutlet` directive is instantiated */
  onChildOutletCreated(childName, outlet) {
    const context2 = this.getOrCreateContext(childName);
    context2.outlet = outlet;
    this.contexts.set(childName, context2);
  }
  /**
   * Called when a `RouterOutlet` directive is destroyed.
   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
   * re-created later.
   */
  onChildOutletDestroyed(childName) {
    const context2 = this.getContext(childName);
    if (context2) {
      context2.outlet = null;
      context2.attachRef = null;
    }
  }
  /**
   * Called when the corresponding route is deactivated during navigation.
   * Because the component get destroyed, all children outlet are destroyed.
   */
  onOutletDeactivated() {
    const contexts = this.contexts;
    this.contexts = /* @__PURE__ */ new Map();
    return contexts;
  }
  onOutletReAttached(contexts) {
    this.contexts = contexts;
  }
  getOrCreateContext(childName) {
    let context2 = this.getContext(childName);
    if (!context2) {
      context2 = new OutletContext(this.parentInjector);
      this.contexts.set(childName, context2);
    }
    return context2;
  }
  getContext(childName) {
    return this.contexts.get(childName) || null;
  }
};
_ChildrenOutletContexts.\u0275fac = function ChildrenOutletContexts_Factory(t3) {
  return new (t3 || _ChildrenOutletContexts)(\u0275\u0275inject(EnvironmentInjector));
};
_ChildrenOutletContexts.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ChildrenOutletContexts,
  factory: _ChildrenOutletContexts.\u0275fac,
  providedIn: "root"
});
var ChildrenOutletContexts = _ChildrenOutletContexts;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChildrenOutletContexts, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var Tree = class {
  constructor(root) {
    this._root = root;
  }
  get root() {
    return this._root.value;
  }
  /**
   * @internal
   */
  parent(t3) {
    const p3 = this.pathFromRoot(t3);
    return p3.length > 1 ? p3[p3.length - 2] : null;
  }
  /**
   * @internal
   */
  children(t3) {
    const n2 = findNode(t3, this._root);
    return n2 ? n2.children.map((t4) => t4.value) : [];
  }
  /**
   * @internal
   */
  firstChild(t3) {
    const n2 = findNode(t3, this._root);
    return n2 && n2.children.length > 0 ? n2.children[0].value : null;
  }
  /**
   * @internal
   */
  siblings(t3) {
    const p3 = findPath(t3, this._root);
    if (p3.length < 2) return [];
    const c3 = p3[p3.length - 2].children.map((c4) => c4.value);
    return c3.filter((cc) => cc !== t3);
  }
  /**
   * @internal
   */
  pathFromRoot(t3) {
    return findPath(t3, this._root).map((s3) => s3.value);
  }
};
function findNode(value, node) {
  if (value === node.value) return node;
  for (const child of node.children) {
    const node2 = findNode(value, child);
    if (node2) return node2;
  }
  return null;
}
function findPath(value, node) {
  if (value === node.value) return [node];
  for (const child of node.children) {
    const path = findPath(value, child);
    if (path.length) {
      path.unshift(node);
      return path;
    }
  }
  return [];
}
var TreeNode = class {
  constructor(value, children) {
    this.value = value;
    this.children = children;
  }
  toString() {
    return `TreeNode(${this.value})`;
  }
};
function nodeChildrenAsMap(node) {
  const map2 = {};
  if (node) {
    node.children.forEach((child) => map2[child.value.outlet] = child);
  }
  return map2;
}
var RouterState = class extends Tree {
  /** @internal */
  constructor(root, snapshot) {
    super(root);
    this.snapshot = snapshot;
    setRouterState(this, root);
  }
  toString() {
    return this.snapshot.toString();
  }
};
function createEmptyState(rootComponent) {
  const snapshot = createEmptyStateSnapshot(rootComponent);
  const emptyUrl = new BehaviorSubject([new UrlSegment("", {})]);
  const emptyParams = new BehaviorSubject({});
  const emptyData = new BehaviorSubject({});
  const emptyQueryParams = new BehaviorSubject({});
  const fragment = new BehaviorSubject("");
  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
  activated.snapshot = snapshot.root;
  return new RouterState(new TreeNode(activated, []), snapshot);
}
function createEmptyStateSnapshot(rootComponent) {
  const emptyParams = {};
  const emptyData = {};
  const emptyQueryParams = {};
  const fragment = "";
  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});
  return new RouterStateSnapshot("", new TreeNode(activated, []));
}
var ActivatedRoute = class {
  /** @internal */
  constructor(urlSubject, paramsSubject, queryParamsSubject, fragmentSubject, dataSubject, outlet, component, futureSnapshot) {
    this.urlSubject = urlSubject;
    this.paramsSubject = paramsSubject;
    this.queryParamsSubject = queryParamsSubject;
    this.fragmentSubject = fragmentSubject;
    this.dataSubject = dataSubject;
    this.outlet = outlet;
    this.component = component;
    this._futureSnapshot = futureSnapshot;
    this.title = this.dataSubject?.pipe(map((d2) => d2[RouteTitleKey])) ?? of(void 0);
    this.url = urlSubject;
    this.params = paramsSubject;
    this.queryParams = queryParamsSubject;
    this.fragment = fragmentSubject;
    this.data = dataSubject;
  }
  /** The configuration used to match this route. */
  get routeConfig() {
    return this._futureSnapshot.routeConfig;
  }
  /** The root of the router state. */
  get root() {
    return this._routerState.root;
  }
  /** The parent of this route in the router state tree. */
  get parent() {
    return this._routerState.parent(this);
  }
  /** The first child of this route in the router state tree. */
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  /** The children of this route in the router state tree. */
  get children() {
    return this._routerState.children(this);
  }
  /** The path from the root of the router state tree to this route. */
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  /**
   * An Observable that contains a map of the required and optional parameters
   * specific to the route.
   * The map supports retrieving single and multiple values from the same parameter.
   */
  get paramMap() {
    this._paramMap ??= this.params.pipe(map((p3) => convertToParamMap(p3)));
    return this._paramMap;
  }
  /**
   * An Observable that contains a map of the query parameters available to all routes.
   * The map supports retrieving single and multiple values from the query parameter.
   */
  get queryParamMap() {
    this._queryParamMap ??= this.queryParams.pipe(map((p3) => convertToParamMap(p3)));
    return this._queryParamMap;
  }
  toString() {
    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
  }
};
function getInherited(route, parent2, paramsInheritanceStrategy = "emptyOnly") {
  let inherited;
  const {
    routeConfig
  } = route;
  if (parent2 !== null && (paramsInheritanceStrategy === "always" || // inherit parent data if route is empty path
  routeConfig?.path === "" || // inherit parent data if parent was componentless
  !parent2.component && !parent2.routeConfig?.loadComponent)) {
    inherited = {
      params: __spreadValues(__spreadValues({}, parent2.params), route.params),
      data: __spreadValues(__spreadValues({}, parent2.data), route.data),
      resolve: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, route.data), parent2.data), routeConfig?.data), route._resolvedData)
    };
  } else {
    inherited = {
      params: __spreadValues({}, route.params),
      data: __spreadValues({}, route.data),
      resolve: __spreadValues(__spreadValues({}, route.data), route._resolvedData ?? {})
    };
  }
  if (routeConfig && hasStaticTitle(routeConfig)) {
    inherited.resolve[RouteTitleKey] = routeConfig.title;
  }
  return inherited;
}
var ActivatedRouteSnapshot = class {
  /** The resolved route title */
  get title() {
    return this.data?.[RouteTitleKey];
  }
  /** @internal */
  constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, resolve) {
    this.url = url;
    this.params = params;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.data = data;
    this.outlet = outlet;
    this.component = component;
    this.routeConfig = routeConfig;
    this._resolve = resolve;
  }
  /** The root of the router state */
  get root() {
    return this._routerState.root;
  }
  /** The parent of this route in the router state tree */
  get parent() {
    return this._routerState.parent(this);
  }
  /** The first child of this route in the router state tree */
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  /** The children of this route in the router state tree */
  get children() {
    return this._routerState.children(this);
  }
  /** The path from the root of the router state tree to this route */
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  get paramMap() {
    this._paramMap ??= convertToParamMap(this.params);
    return this._paramMap;
  }
  get queryParamMap() {
    this._queryParamMap ??= convertToParamMap(this.queryParams);
    return this._queryParamMap;
  }
  toString() {
    const url = this.url.map((segment) => segment.toString()).join("/");
    const matched = this.routeConfig ? this.routeConfig.path : "";
    return `Route(url:'${url}', path:'${matched}')`;
  }
};
var RouterStateSnapshot = class extends Tree {
  /** @internal */
  constructor(url, root) {
    super(root);
    this.url = url;
    setRouterState(this, root);
  }
  toString() {
    return serializeNode(this._root);
  }
};
function setRouterState(state, node) {
  node.value._routerState = state;
  node.children.forEach((c3) => setRouterState(state, c3));
}
function serializeNode(node) {
  const c3 = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(", ")} } ` : "";
  return `${node.value}${c3}`;
}
function advanceActivatedRoute(route) {
  if (route.snapshot) {
    const currentSnapshot = route.snapshot;
    const nextSnapshot = route._futureSnapshot;
    route.snapshot = nextSnapshot;
    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
      route.queryParamsSubject.next(nextSnapshot.queryParams);
    }
    if (currentSnapshot.fragment !== nextSnapshot.fragment) {
      route.fragmentSubject.next(nextSnapshot.fragment);
    }
    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
      route.paramsSubject.next(nextSnapshot.params);
    }
    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
      route.urlSubject.next(nextSnapshot.url);
    }
    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
      route.dataSubject.next(nextSnapshot.data);
    }
  } else {
    route.snapshot = route._futureSnapshot;
    route.dataSubject.next(route._futureSnapshot.data);
  }
}
function equalParamsAndUrlSegments(a3, b3) {
  const equalUrlParams = shallowEqual(a3.params, b3.params) && equalSegments(a3.url, b3.url);
  const parentsMismatch = !a3.parent !== !b3.parent;
  return equalUrlParams && !parentsMismatch && (!a3.parent || equalParamsAndUrlSegments(a3.parent, b3.parent));
}
function hasStaticTitle(config3) {
  return typeof config3.title === "string" || config3.title === null;
}
var _RouterOutlet = class _RouterOutlet {
  constructor() {
    this.activated = null;
    this._activatedRoute = null;
    this.name = PRIMARY_OUTLET;
    this.activateEvents = new EventEmitter();
    this.deactivateEvents = new EventEmitter();
    this.attachEvents = new EventEmitter();
    this.detachEvents = new EventEmitter();
    this.parentContexts = inject(ChildrenOutletContexts);
    this.location = inject(ViewContainerRef);
    this.changeDetector = inject(ChangeDetectorRef);
    this.inputBinder = inject(INPUT_BINDER, {
      optional: true
    });
    this.supportsBindingToComponentInputs = true;
  }
  /** @internal */
  get activatedComponentRef() {
    return this.activated;
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (changes["name"]) {
      const {
        firstChange,
        previousValue
      } = changes["name"];
      if (firstChange) {
        return;
      }
      if (this.isTrackedInParentContexts(previousValue)) {
        this.deactivate();
        this.parentContexts.onChildOutletDestroyed(previousValue);
      }
      this.initializeOutletWithName();
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.isTrackedInParentContexts(this.name)) {
      this.parentContexts.onChildOutletDestroyed(this.name);
    }
    this.inputBinder?.unsubscribeFromRouteData(this);
  }
  isTrackedInParentContexts(outletName) {
    return this.parentContexts.getContext(outletName)?.outlet === this;
  }
  /** @nodoc */
  ngOnInit() {
    this.initializeOutletWithName();
  }
  initializeOutletWithName() {
    this.parentContexts.onChildOutletCreated(this.name, this);
    if (this.activated) {
      return;
    }
    const context2 = this.parentContexts.getContext(this.name);
    if (context2?.route) {
      if (context2.attachRef) {
        this.attach(context2.attachRef, context2.route);
      } else {
        this.activateWith(context2.route, context2.injector);
      }
    }
  }
  get isActivated() {
    return !!this.activated;
  }
  /**
   * @returns The currently activated component instance.
   * @throws An error if the outlet is not activated.
   */
  get component() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    return this.activated.instance;
  }
  get activatedRoute() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    return this._activatedRoute;
  }
  get activatedRouteData() {
    if (this._activatedRoute) {
      return this._activatedRoute.snapshot.data;
    }
    return {};
  }
  /**
   * Called when the `RouteReuseStrategy` instructs to detach the subtree
   */
  detach() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    this.location.detach();
    const cmp = this.activated;
    this.activated = null;
    this._activatedRoute = null;
    this.detachEvents.emit(cmp.instance);
    return cmp;
  }
  /**
   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
   */
  attach(ref, activatedRoute) {
    this.activated = ref;
    this._activatedRoute = activatedRoute;
    this.location.insert(ref.hostView);
    this.inputBinder?.bindActivatedRouteToOutletComponent(this);
    this.attachEvents.emit(ref.instance);
  }
  deactivate() {
    if (this.activated) {
      const c3 = this.component;
      this.activated.destroy();
      this.activated = null;
      this._activatedRoute = null;
      this.deactivateEvents.emit(c3);
    }
  }
  activateWith(activatedRoute, environmentInjector) {
    if (this.isActivated) {
      throw new RuntimeError(4013, (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot activate an already activated outlet");
    }
    this._activatedRoute = activatedRoute;
    const location2 = this.location;
    const snapshot = activatedRoute.snapshot;
    const component = snapshot.component;
    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
    const injector = new OutletInjector(activatedRoute, childContexts, location2.injector);
    this.activated = location2.createComponent(component, {
      index: location2.length,
      injector,
      environmentInjector
    });
    this.changeDetector.markForCheck();
    this.inputBinder?.bindActivatedRouteToOutletComponent(this);
    this.activateEvents.emit(this.activated.instance);
  }
};
_RouterOutlet.\u0275fac = function RouterOutlet_Factory(t3) {
  return new (t3 || _RouterOutlet)();
};
_RouterOutlet.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RouterOutlet,
  selectors: [["router-outlet"]],
  inputs: {
    name: "name"
  },
  outputs: {
    activateEvents: "activate",
    deactivateEvents: "deactivate",
    attachEvents: "attach",
    detachEvents: "detach"
  },
  exportAs: ["outlet"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var RouterOutlet = _RouterOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterOutlet, [{
    type: Directive,
    args: [{
      selector: "router-outlet",
      exportAs: "outlet",
      standalone: true
    }]
  }], null, {
    name: [{
      type: Input
    }],
    activateEvents: [{
      type: Output,
      args: ["activate"]
    }],
    deactivateEvents: [{
      type: Output,
      args: ["deactivate"]
    }],
    attachEvents: [{
      type: Output,
      args: ["attach"]
    }],
    detachEvents: [{
      type: Output,
      args: ["detach"]
    }]
  });
})();
var OutletInjector = class _OutletInjector {
  /**
   * This injector has a special handing for the `ActivatedRoute` and
   * `ChildrenOutletContexts` tokens: it returns corresponding values for those
   * tokens dynamically. This behavior is different from the regular injector logic,
   * when we initialize and store a value, which is later returned for all inject
   * requests.
   *
   * In some cases (e.g. when using `@defer`), this dynamic behavior requires special
   * handling. This function allows to identify an instance of the `OutletInjector` and
   * create an instance of it without referring to the class itself (so this logic can
   * be invoked from the `core` package). This helps to retain dynamic behavior for the
   * mentioned tokens.
   *
   * Note: it's a temporary solution and we should explore how to support this case better.
   */
  __ngOutletInjector(parentInjector) {
    return new _OutletInjector(this.route, this.childContexts, parentInjector);
  }
  constructor(route, childContexts, parent2) {
    this.route = route;
    this.childContexts = childContexts;
    this.parent = parent2;
  }
  get(token, notFoundValue) {
    if (token === ActivatedRoute) {
      return this.route;
    }
    if (token === ChildrenOutletContexts) {
      return this.childContexts;
    }
    return this.parent.get(token, notFoundValue);
  }
};
var INPUT_BINDER = new InjectionToken("");
var _RoutedComponentInputBinder = class _RoutedComponentInputBinder {
  constructor() {
    this.outletDataSubscriptions = /* @__PURE__ */ new Map();
  }
  bindActivatedRouteToOutletComponent(outlet) {
    this.unsubscribeFromRouteData(outlet);
    this.subscribeToRouteData(outlet);
  }
  unsubscribeFromRouteData(outlet) {
    this.outletDataSubscriptions.get(outlet)?.unsubscribe();
    this.outletDataSubscriptions.delete(outlet);
  }
  subscribeToRouteData(outlet) {
    const {
      activatedRoute
    } = outlet;
    const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index3) => {
      data = __spreadValues(__spreadValues(__spreadValues({}, queryParams), params), data);
      if (index3 === 0) {
        return of(data);
      }
      return Promise.resolve(data);
    })).subscribe((data) => {
      if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {
        this.unsubscribeFromRouteData(outlet);
        return;
      }
      const mirror = reflectComponentType(activatedRoute.component);
      if (!mirror) {
        this.unsubscribeFromRouteData(outlet);
        return;
      }
      for (const {
        templateName
      } of mirror.inputs) {
        outlet.activatedComponentRef.setInput(templateName, data[templateName]);
      }
    });
    this.outletDataSubscriptions.set(outlet, dataSubscription);
  }
};
_RoutedComponentInputBinder.\u0275fac = function RoutedComponentInputBinder_Factory(t3) {
  return new (t3 || _RoutedComponentInputBinder)();
};
_RoutedComponentInputBinder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _RoutedComponentInputBinder,
  factory: _RoutedComponentInputBinder.\u0275fac
});
var RoutedComponentInputBinder = _RoutedComponentInputBinder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RoutedComponentInputBinder, [{
    type: Injectable
  }], null, null);
})();
function createRouterState(routeReuseStrategy, curr, prevState) {
  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);
  return new RouterState(root, curr);
}
function createNode(routeReuseStrategy, curr, prevState) {
  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
    const value = prevState.value;
    value._futureSnapshot = curr.value;
    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
    return new TreeNode(value, children);
  } else {
    if (routeReuseStrategy.shouldAttach(curr.value)) {
      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
      if (detachedRouteHandle !== null) {
        const tree2 = detachedRouteHandle.route;
        tree2.value._futureSnapshot = curr.value;
        tree2.children = curr.children.map((c3) => createNode(routeReuseStrategy, c3));
        return tree2;
      }
    }
    const value = createActivatedRoute(curr.value);
    const children = curr.children.map((c3) => createNode(routeReuseStrategy, c3));
    return new TreeNode(value, children);
  }
}
function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
  return curr.children.map((child) => {
    for (const p3 of prevState.children) {
      if (routeReuseStrategy.shouldReuseRoute(child.value, p3.value.snapshot)) {
        return createNode(routeReuseStrategy, child, p3);
      }
    }
    return createNode(routeReuseStrategy, child);
  });
}
function createActivatedRoute(c3) {
  return new ActivatedRoute(new BehaviorSubject(c3.url), new BehaviorSubject(c3.params), new BehaviorSubject(c3.queryParams), new BehaviorSubject(c3.fragment), new BehaviorSubject(c3.data), c3.outlet, c3.component, c3);
}
var RedirectCommand = class {
  constructor(redirectTo, navigationBehaviorOptions) {
    this.redirectTo = redirectTo;
    this.navigationBehaviorOptions = navigationBehaviorOptions;
  }
};
var NAVIGATION_CANCELING_ERROR = "ngNavigationCancelingError";
function redirectingNavigationError(urlSerializer, redirect) {
  const {
    redirectTo,
    navigationBehaviorOptions
  } = isUrlTree(redirect) ? {
    redirectTo: redirect,
    navigationBehaviorOptions: void 0
  } : redirect;
  const error = navigationCancelingError(ngDevMode && `Redirecting to "${urlSerializer.serialize(redirectTo)}"`, NavigationCancellationCode.Redirect);
  error.url = redirectTo;
  error.navigationBehaviorOptions = navigationBehaviorOptions;
  return error;
}
function navigationCancelingError(message, code) {
  const error = new Error(`NavigationCancelingError: ${message || ""}`);
  error[NAVIGATION_CANCELING_ERROR] = true;
  error.cancellationCode = code;
  return error;
}
function isRedirectingNavigationCancelingError(error) {
  return isNavigationCancelingError(error) && isUrlTree(error.url);
}
function isNavigationCancelingError(error) {
  return !!error && error[NAVIGATION_CANCELING_ERROR];
}
var _\u0275EmptyOutletComponent = class _\u0275EmptyOutletComponent {
};
_\u0275EmptyOutletComponent.\u0275fac = function \u0275EmptyOutletComponent_Factory(t3) {
  return new (t3 || _\u0275EmptyOutletComponent)();
};
_\u0275EmptyOutletComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _\u0275EmptyOutletComponent,
  selectors: [["ng-component"]],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 1,
  vars: 0,
  template: function _EmptyOutletComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "router-outlet");
    }
  },
  dependencies: [RouterOutlet],
  encapsulation: 2
});
var \u0275EmptyOutletComponent = _\u0275EmptyOutletComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275EmptyOutletComponent, [{
    type: Component,
    args: [{
      template: `<router-outlet></router-outlet>`,
      imports: [RouterOutlet],
      standalone: true
    }]
  }], null, null);
})();
function getOrCreateRouteInjectorIfNeeded(route, currentInjector) {
  if (route.providers && !route._injector) {
    route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);
  }
  return route._injector ?? currentInjector;
}
function validateConfig(config3, parentPath = "", requireStandaloneComponents = false) {
  for (let i3 = 0; i3 < config3.length; i3++) {
    const route = config3[i3];
    const fullPath = getFullPath(parentPath, route);
    validateNode(route, fullPath, requireStandaloneComponents);
  }
}
function assertStandalone(fullPath, component) {
  if (component && isNgModule(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, but it must be used with standalone components. Use 'loadChildren' instead.`);
  } else if (component && !isStandalone(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);
  }
}
function validateNode(route, fullPath, requireStandaloneComponents) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!route) {
      throw new RuntimeError(4014, `
      Invalid configuration of route '${fullPath}': Encountered undefined route.
      The reason might be an extra comma.

      Example:
      const routes: Routes = [
        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
        { path: 'dashboard',  component: DashboardComponent },, << two commas
        { path: 'detail/:id', component: HeroDetailComponent }
      ];
    `);
    }
    if (Array.isArray(route)) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);
    }
    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
    }
    if (route.redirectTo && route.children) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);
    }
    if (route.redirectTo && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);
    }
    if (route.children && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);
    }
    if (route.redirectTo && (route.component || route.loadComponent)) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);
    }
    if (route.component && route.loadComponent) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);
    }
    if (route.redirectTo && route.canActivate) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation so canActivate will never be executed.`);
    }
    if (route.path && route.matcher) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);
    }
    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);
    }
    if (route.path === void 0 && route.matcher === void 0) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);
    }
    if (typeof route.path === "string" && route.path.charAt(0) === "/") {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);
    }
    if (route.path === "" && route.redirectTo !== void 0 && route.pathMatch === void 0) {
      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
      throw new RuntimeError(4014, `Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
    }
    if (requireStandaloneComponents) {
      assertStandalone(fullPath, route.component);
    }
  }
  if (route.children) {
    validateConfig(route.children, fullPath, requireStandaloneComponents);
  }
}
function getFullPath(parentPath, currentRoute) {
  if (!currentRoute) {
    return parentPath;
  }
  if (!parentPath && !currentRoute.path) {
    return "";
  } else if (parentPath && !currentRoute.path) {
    return `${parentPath}/`;
  } else if (!parentPath && currentRoute.path) {
    return currentRoute.path;
  } else {
    return `${parentPath}/${currentRoute.path}`;
  }
}
function standardizeConfig(r3) {
  const children = r3.children && r3.children.map(standardizeConfig);
  const c3 = children ? __spreadProps(__spreadValues({}, r3), {
    children
  }) : __spreadValues({}, r3);
  if (!c3.component && !c3.loadComponent && (children || c3.loadChildren) && c3.outlet && c3.outlet !== PRIMARY_OUTLET) {
    c3.component = \u0275EmptyOutletComponent;
  }
  return c3;
}
function getOutlet(route) {
  return route.outlet || PRIMARY_OUTLET;
}
function sortByMatchingOutlets(routes2, outletName) {
  const sortedConfig = routes2.filter((r3) => getOutlet(r3) === outletName);
  sortedConfig.push(...routes2.filter((r3) => getOutlet(r3) !== outletName));
  return sortedConfig;
}
function getClosestRouteInjector(snapshot) {
  if (!snapshot) return null;
  if (snapshot.routeConfig?._injector) {
    return snapshot.routeConfig._injector;
  }
  for (let s3 = snapshot.parent; s3; s3 = s3.parent) {
    const route = s3.routeConfig;
    if (route?._loadedInjector) return route._loadedInjector;
    if (route?._injector) return route._injector;
  }
  return null;
}
var warnedAboutUnsupportedInputBinding = false;
var activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map((t3) => {
  new ActivateRoutes(routeReuseStrategy, t3.targetRouterState, t3.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);
  return t3;
});
var ActivateRoutes = class {
  constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {
    this.routeReuseStrategy = routeReuseStrategy;
    this.futureState = futureState;
    this.currState = currState;
    this.forwardEvent = forwardEvent;
    this.inputBindingEnabled = inputBindingEnabled;
  }
  activate(parentContexts) {
    const futureRoot = this.futureState._root;
    const currRoot = this.currState ? this.currState._root : null;
    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
    advanceActivatedRoute(this.futureState.root);
    this.activateChildRoutes(futureRoot, currRoot, parentContexts);
  }
  // De-activate the child route that are not re-used for the future state
  deactivateChildRoutes(futureNode, currNode, contexts) {
    const children = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((futureChild) => {
      const childOutletName = futureChild.value.outlet;
      this.deactivateRoutes(futureChild, children[childOutletName], contexts);
      delete children[childOutletName];
    });
    Object.values(children).forEach((v3) => {
      this.deactivateRouteAndItsChildren(v3, contexts);
    });
  }
  deactivateRoutes(futureNode, currNode, parentContext) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    if (future === curr) {
      if (future.component) {
        const context2 = parentContext.getContext(future.outlet);
        if (context2) {
          this.deactivateChildRoutes(futureNode, currNode, context2.children);
        }
      } else {
        this.deactivateChildRoutes(futureNode, currNode, parentContext);
      }
    } else {
      if (curr) {
        this.deactivateRouteAndItsChildren(currNode, parentContext);
      }
    }
  }
  deactivateRouteAndItsChildren(route, parentContexts) {
    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
      this.detachAndStoreRouteSubtree(route, parentContexts);
    } else {
      this.deactivateRouteAndOutlet(route, parentContexts);
    }
  }
  detachAndStoreRouteSubtree(route, parentContexts) {
    const context2 = parentContexts.getContext(route.value.outlet);
    const contexts = context2 && route.value.component ? context2.children : parentContexts;
    const children = nodeChildrenAsMap(route);
    for (const treeNode of Object.values(children)) {
      this.deactivateRouteAndItsChildren(treeNode, contexts);
    }
    if (context2 && context2.outlet) {
      const componentRef = context2.outlet.detach();
      const contexts2 = context2.children.onOutletDeactivated();
      this.routeReuseStrategy.store(route.value.snapshot, {
        componentRef,
        route,
        contexts: contexts2
      });
    }
  }
  deactivateRouteAndOutlet(route, parentContexts) {
    const context2 = parentContexts.getContext(route.value.outlet);
    const contexts = context2 && route.value.component ? context2.children : parentContexts;
    const children = nodeChildrenAsMap(route);
    for (const treeNode of Object.values(children)) {
      this.deactivateRouteAndItsChildren(treeNode, contexts);
    }
    if (context2) {
      if (context2.outlet) {
        context2.outlet.deactivate();
        context2.children.onOutletDeactivated();
      }
      context2.attachRef = null;
      context2.route = null;
    }
  }
  activateChildRoutes(futureNode, currNode, contexts) {
    const children = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((c3) => {
      this.activateRoutes(c3, children[c3.value.outlet], contexts);
      this.forwardEvent(new ActivationEnd(c3.value.snapshot));
    });
    if (futureNode.children.length) {
      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
    }
  }
  activateRoutes(futureNode, currNode, parentContexts) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    advanceActivatedRoute(future);
    if (future === curr) {
      if (future.component) {
        const context2 = parentContexts.getOrCreateContext(future.outlet);
        this.activateChildRoutes(futureNode, currNode, context2.children);
      } else {
        this.activateChildRoutes(futureNode, currNode, parentContexts);
      }
    } else {
      if (future.component) {
        const context2 = parentContexts.getOrCreateContext(future.outlet);
        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
          const stored = this.routeReuseStrategy.retrieve(future.snapshot);
          this.routeReuseStrategy.store(future.snapshot, null);
          context2.children.onOutletReAttached(stored.contexts);
          context2.attachRef = stored.componentRef;
          context2.route = stored.route.value;
          if (context2.outlet) {
            context2.outlet.attach(stored.componentRef, stored.route.value);
          }
          advanceActivatedRoute(stored.route.value);
          this.activateChildRoutes(futureNode, null, context2.children);
        } else {
          const injector = getClosestRouteInjector(future.snapshot);
          context2.attachRef = null;
          context2.route = future;
          context2.injector = injector ?? context2.injector;
          if (context2.outlet) {
            context2.outlet.activateWith(future, context2.injector);
          }
          this.activateChildRoutes(futureNode, null, context2.children);
        }
      } else {
        this.activateChildRoutes(futureNode, null, parentContexts);
      }
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const context2 = parentContexts.getOrCreateContext(future.outlet);
      const outlet = context2.outlet;
      if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {
        console.warn(`'withComponentInputBinding' feature is enabled but this application is using an outlet that may not support binding to component inputs.`);
        warnedAboutUnsupportedInputBinding = true;
      }
    }
  }
};
var CanActivate = class {
  constructor(path) {
    this.path = path;
    this.route = this.path[this.path.length - 1];
  }
};
var CanDeactivate = class {
  constructor(component, route) {
    this.component = component;
    this.route = route;
  }
};
function getAllRouteGuards(future, curr, parentContexts) {
  const futureRoot = future._root;
  const currRoot = curr ? curr._root : null;
  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
}
function getCanActivateChild(p3) {
  const canActivateChild = p3.routeConfig ? p3.routeConfig.canActivateChild : null;
  if (!canActivateChild || canActivateChild.length === 0) return null;
  return {
    node: p3,
    guards: canActivateChild
  };
}
function getTokenOrFunctionIdentity(tokenOrFunction, injector) {
  const NOT_FOUND2 = Symbol();
  const result = injector.get(tokenOrFunction, NOT_FOUND2);
  if (result === NOT_FOUND2) {
    if (typeof tokenOrFunction === "function" && !isInjectable(tokenOrFunction)) {
      return tokenOrFunction;
    } else {
      return injector.get(tokenOrFunction);
    }
  }
  return result;
}
function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const prevChildren = nodeChildrenAsMap(currNode);
  futureNode.children.forEach((c3) => {
    getRouteGuards(c3, prevChildren[c3.value.outlet], contexts, futurePath.concat([c3.value]), checks);
    delete prevChildren[c3.value.outlet];
  });
  Object.entries(prevChildren).forEach(([k3, v3]) => deactivateRouteAndItsChildren(v3, contexts.getContext(k3), checks));
  return checks;
}
function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const future = futureNode.value;
  const curr = currNode ? currNode.value : null;
  const context2 = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
  if (curr && future.routeConfig === curr.routeConfig) {
    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
    if (shouldRun) {
      checks.canActivateChecks.push(new CanActivate(futurePath));
    } else {
      future.data = curr.data;
      future._resolvedData = curr._resolvedData;
    }
    if (future.component) {
      getChildRouteGuards(futureNode, currNode, context2 ? context2.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
    }
    if (shouldRun && context2 && context2.outlet && context2.outlet.isActivated) {
      checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, curr));
    }
  } else {
    if (curr) {
      deactivateRouteAndItsChildren(currNode, context2, checks);
    }
    checks.canActivateChecks.push(new CanActivate(futurePath));
    if (future.component) {
      getChildRouteGuards(futureNode, null, context2 ? context2.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
    }
  }
  return checks;
}
function shouldRunGuardsAndResolvers(curr, future, mode) {
  if (typeof mode === "function") {
    return mode(curr, future);
  }
  switch (mode) {
    case "pathParamsChange":
      return !equalPath(curr.url, future.url);
    case "pathParamsOrQueryParamsChange":
      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);
    case "always":
      return true;
    case "paramsOrQueryParamsChange":
      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);
    case "paramsChange":
    default:
      return !equalParamsAndUrlSegments(curr, future);
  }
}
function deactivateRouteAndItsChildren(route, context2, checks) {
  const children = nodeChildrenAsMap(route);
  const r3 = route.value;
  Object.entries(children).forEach(([childName, node]) => {
    if (!r3.component) {
      deactivateRouteAndItsChildren(node, context2, checks);
    } else if (context2) {
      deactivateRouteAndItsChildren(node, context2.children.getContext(childName), checks);
    } else {
      deactivateRouteAndItsChildren(node, null, checks);
    }
  });
  if (!r3.component) {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r3));
  } else if (context2 && context2.outlet && context2.outlet.isActivated) {
    checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, r3));
  } else {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r3));
  }
}
function isFunction2(v3) {
  return typeof v3 === "function";
}
function isBoolean(v3) {
  return typeof v3 === "boolean";
}
function isCanLoad(guard) {
  return guard && isFunction2(guard.canLoad);
}
function isCanActivate(guard) {
  return guard && isFunction2(guard.canActivate);
}
function isCanActivateChild(guard) {
  return guard && isFunction2(guard.canActivateChild);
}
function isCanDeactivate(guard) {
  return guard && isFunction2(guard.canDeactivate);
}
function isCanMatch(guard) {
  return guard && isFunction2(guard.canMatch);
}
function isEmptyError(e3) {
  return e3 instanceof EmptyError || e3?.name === "EmptyError";
}
var INITIAL_VALUE = /* @__PURE__ */ Symbol("INITIAL_VALUE");
function prioritizedGuardValue() {
  return switchMap((obs) => {
    return combineLatest(obs.map((o2) => o2.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map((results) => {
      for (const result of results) {
        if (result === true) {
          continue;
        } else if (result === INITIAL_VALUE) {
          return INITIAL_VALUE;
        } else if (result === false || isRedirect(result)) {
          return result;
        }
      }
      return true;
    }), filter((item) => item !== INITIAL_VALUE), take(1));
  });
}
function isRedirect(val) {
  return isUrlTree(val) || val instanceof RedirectCommand;
}
function checkGuards(injector, forwardEvent) {
  return mergeMap((t3) => {
    const {
      targetSnapshot,
      currentSnapshot,
      guards: {
        canActivateChecks,
        canDeactivateChecks
      }
    } = t3;
    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
      return of(__spreadProps(__spreadValues({}, t3), {
        guardsResult: true
      }));
    }
    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap((canDeactivate) => {
      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of(canDeactivate);
    }), map((guardsResult) => __spreadProps(__spreadValues({}, t3), {
      guardsResult
    })));
  });
}
function runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {
  return from(checks).pipe(mergeMap((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first((result) => {
    return result !== true;
  }, true));
}
function runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {
  return from(checks).pipe(concatMap((check) => {
    return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));
  }), first((result) => {
    return result !== true;
  }, true));
}
function fireActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ActivationStart(snapshot));
  }
  return of(true);
}
function fireChildActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ChildActivationStart(snapshot));
  }
  return of(true);
}
function runCanActivate(futureRSS, futureARS, injector) {
  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
  if (!canActivate || canActivate.length === 0) return of(true);
  const canActivateObservables = canActivate.map((canActivate2) => {
    return defer(() => {
      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
      const guard = getTokenOrFunctionIdentity(canActivate2, closestInjector);
      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
      return wrapIntoObservable(guardVal).pipe(first());
    });
  });
  return of(canActivateObservables).pipe(prioritizedGuardValue());
}
function runCanActivateChild(futureRSS, path, injector) {
  const futureARS = path[path.length - 1];
  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map((p3) => getCanActivateChild(p3)).filter((_3) => _3 !== null);
  const canActivateChildGuardsMapped = canActivateChildGuards.map((d2) => {
    return defer(() => {
      const guardsMapped = d2.guards.map((canActivateChild) => {
        const closestInjector = getClosestRouteInjector(d2.node) ?? injector;
        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);
        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
        return wrapIntoObservable(guardVal).pipe(first());
      });
      return of(guardsMapped).pipe(prioritizedGuardValue());
    });
  });
  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
}
function runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {
  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
  if (!canDeactivate || canDeactivate.length === 0) return of(true);
  const canDeactivateObservables = canDeactivate.map((c3) => {
    const closestInjector = getClosestRouteInjector(currARS) ?? injector;
    const guard = getTokenOrFunctionIdentity(c3, closestInjector);
    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));
    return wrapIntoObservable(guardVal).pipe(first());
  });
  return of(canDeactivateObservables).pipe(prioritizedGuardValue());
}
function runCanLoadGuards(injector, route, segments, urlSerializer) {
  const canLoad = route.canLoad;
  if (canLoad === void 0 || canLoad.length === 0) {
    return of(true);
  }
  const canLoadObservables = canLoad.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
function redirectIfUrlTree(urlSerializer) {
  return pipe(tap((result) => {
    if (typeof result === "boolean") return;
    throw redirectingNavigationError(urlSerializer, result);
  }), map((result) => result === true));
}
function runCanMatchGuards(injector, route, segments, urlSerializer) {
  const canMatch = route.canMatch;
  if (!canMatch || canMatch.length === 0) return of(true);
  const canMatchObservables = canMatch.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
var NoMatch = class {
  constructor(segmentGroup) {
    this.segmentGroup = segmentGroup || null;
  }
};
var AbsoluteRedirect = class extends Error {
  constructor(urlTree) {
    super();
    this.urlTree = urlTree;
  }
};
function noMatch$1(segmentGroup) {
  return throwError(new NoMatch(segmentGroup));
}
function namedOutletsRedirect(redirectTo) {
  return throwError(new RuntimeError(4e3, (typeof ngDevMode === "undefined" || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));
}
function canLoadFails(route) {
  return throwError(navigationCancelingError((typeof ngDevMode === "undefined" || ngDevMode) && `Cannot load children because the guard of the route "path: '${route.path}'" returned false`, NavigationCancellationCode.GuardRejected));
}
var ApplyRedirects = class {
  constructor(urlSerializer, urlTree) {
    this.urlSerializer = urlSerializer;
    this.urlTree = urlTree;
  }
  lineralizeSegments(route, urlTree) {
    let res = [];
    let c3 = urlTree.root;
    while (true) {
      res = res.concat(c3.segments);
      if (c3.numberOfChildren === 0) {
        return of(res);
      }
      if (c3.numberOfChildren > 1 || !c3.children[PRIMARY_OUTLET]) {
        return namedOutletsRedirect(`${route.redirectTo}`);
      }
      c3 = c3.children[PRIMARY_OUTLET];
    }
  }
  applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {
    if (typeof redirectTo !== "string") {
      const redirectToFn = redirectTo;
      const {
        queryParams,
        fragment,
        routeConfig,
        url,
        outlet,
        params,
        data,
        title
      } = currentSnapshot;
      const newRedirect = runInInjectionContext(injector, () => redirectToFn({
        params,
        data,
        queryParams,
        fragment,
        routeConfig,
        url,
        outlet,
        title
      }));
      if (newRedirect instanceof UrlTree) {
        throw new AbsoluteRedirect(newRedirect);
      }
      redirectTo = newRedirect;
    }
    const newTree = this.applyRedirectCreateUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
    if (redirectTo[0] === "/") {
      throw new AbsoluteRedirect(newTree);
    }
    return newTree;
  }
  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {
    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
  }
  createQueryParams(redirectToParams, actualParams) {
    const res = {};
    Object.entries(redirectToParams).forEach(([k3, v3]) => {
      const copySourceValue = typeof v3 === "string" && v3[0] === ":";
      if (copySourceValue) {
        const sourceName = v3.substring(1);
        res[k3] = actualParams[sourceName];
      } else {
        res[k3] = v3;
      }
    });
    return res;
  }
  createSegmentGroup(redirectTo, group, segments, posParams) {
    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
    let children = {};
    Object.entries(group.children).forEach(([name, child]) => {
      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
    });
    return new UrlSegmentGroup(updatedSegments, children);
  }
  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
    return redirectToSegments.map((s3) => s3.path[0] === ":" ? this.findPosParam(redirectTo, s3, posParams) : this.findOrReturn(s3, actualSegments));
  }
  findPosParam(redirectTo, redirectToUrlSegment, posParams) {
    const pos = posParams[redirectToUrlSegment.path.substring(1)];
    if (!pos) throw new RuntimeError(4001, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
    return pos;
  }
  findOrReturn(redirectToUrlSegment, actualSegments) {
    let idx = 0;
    for (const s3 of actualSegments) {
      if (s3.path === redirectToUrlSegment.path) {
        actualSegments.splice(idx);
        return s3;
      }
      idx++;
    }
    return redirectToUrlSegment;
  }
};
var noMatch = {
  matched: false,
  consumedSegments: [],
  remainingSegments: [],
  parameters: {},
  positionalParamSegments: {}
};
function matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {
  const result = match(segmentGroup, route, segments);
  if (!result.matched) {
    return of(result);
  }
  injector = getOrCreateRouteInjectorIfNeeded(route, injector);
  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map((v3) => v3 === true ? result : __spreadValues({}, noMatch)));
}
function match(segmentGroup, route, segments) {
  if (route.path === "**") {
    return createWildcardMatchResult(segments);
  }
  if (route.path === "") {
    if (route.pathMatch === "full" && (segmentGroup.hasChildren() || segments.length > 0)) {
      return __spreadValues({}, noMatch);
    }
    return {
      matched: true,
      consumedSegments: [],
      remainingSegments: segments,
      parameters: {},
      positionalParamSegments: {}
    };
  }
  const matcher = route.matcher || defaultUrlMatcher;
  const res = matcher(segments, segmentGroup, route);
  if (!res) return __spreadValues({}, noMatch);
  const posParams = {};
  Object.entries(res.posParams ?? {}).forEach(([k3, v3]) => {
    posParams[k3] = v3.path;
  });
  const parameters = res.consumed.length > 0 ? __spreadValues(__spreadValues({}, posParams), res.consumed[res.consumed.length - 1].parameters) : posParams;
  return {
    matched: true,
    consumedSegments: res.consumed,
    remainingSegments: segments.slice(res.consumed.length),
    // TODO(atscott): investigate combining parameters and positionalParamSegments
    parameters,
    positionalParamSegments: res.posParams ?? {}
  };
}
function createWildcardMatchResult(segments) {
  return {
    matched: true,
    parameters: segments.length > 0 ? last3(segments).parameters : {},
    consumedSegments: segments,
    remainingSegments: [],
    positionalParamSegments: {}
  };
}
function split(segmentGroup, consumedSegments, slicedSegments, config3) {
  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config3)) {
    const s4 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config3, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
    return {
      segmentGroup: s4,
      slicedSegments: []
    };
  }
  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config3)) {
    const s4 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config3, segmentGroup.children));
    return {
      segmentGroup: s4,
      slicedSegments
    };
  }
  const s3 = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
  return {
    segmentGroup: s3,
    slicedSegments
  };
}
function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes2, children) {
  const res = {};
  for (const r3 of routes2) {
    if (emptyPathMatch(segmentGroup, slicedSegments, r3) && !children[getOutlet(r3)]) {
      const s3 = new UrlSegmentGroup([], {});
      res[getOutlet(r3)] = s3;
    }
  }
  return __spreadValues(__spreadValues({}, children), res);
}
function createChildrenForEmptyPaths(routes2, primarySegment) {
  const res = {};
  res[PRIMARY_OUTLET] = primarySegment;
  for (const r3 of routes2) {
    if (r3.path === "" && getOutlet(r3) !== PRIMARY_OUTLET) {
      const s3 = new UrlSegmentGroup([], {});
      res[getOutlet(r3)] = s3;
    }
  }
  return res;
}
function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes2) {
  return routes2.some((r3) => emptyPathMatch(segmentGroup, slicedSegments, r3) && getOutlet(r3) !== PRIMARY_OUTLET);
}
function containsEmptyPathMatches(segmentGroup, slicedSegments, routes2) {
  return routes2.some((r3) => emptyPathMatch(segmentGroup, slicedSegments, r3));
}
function emptyPathMatch(segmentGroup, slicedSegments, r3) {
  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r3.pathMatch === "full") {
    return false;
  }
  return r3.path === "";
}
function isImmediateMatch(route, rawSegment, segments, outlet) {
  if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
    return false;
  }
  return match(rawSegment, route, segments).matched;
}
function noLeftoversInUrl(segmentGroup, segments, outlet) {
  return segments.length === 0 && !segmentGroup.children[outlet];
}
var NoLeftoversInUrl = class {
};
function recognize$1(injector, configLoader, rootComponentType, config3, urlTree, urlSerializer, paramsInheritanceStrategy = "emptyOnly") {
  return new Recognizer(injector, configLoader, rootComponentType, config3, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();
}
var MAX_ALLOWED_REDIRECTS = 31;
var Recognizer = class {
  constructor(injector, configLoader, rootComponentType, config3, urlTree, paramsInheritanceStrategy, urlSerializer) {
    this.injector = injector;
    this.configLoader = configLoader;
    this.rootComponentType = rootComponentType;
    this.config = config3;
    this.urlTree = urlTree;
    this.paramsInheritanceStrategy = paramsInheritanceStrategy;
    this.urlSerializer = urlSerializer;
    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);
    this.absoluteRedirectCount = 0;
    this.allowRedirects = true;
  }
  noMatchError(e3) {
    return new RuntimeError(4002, typeof ngDevMode === "undefined" || ngDevMode ? `Cannot match any routes. URL Segment: '${e3.segmentGroup}'` : `'${e3.segmentGroup}'`);
  }
  recognize() {
    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
    return this.match(rootSegmentGroup).pipe(map(({
      children,
      rootSnapshot
    }) => {
      const rootNode = new TreeNode(rootSnapshot, children);
      const routeState = new RouterStateSnapshot("", rootNode);
      const tree2 = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);
      tree2.queryParams = this.urlTree.queryParams;
      routeState.url = this.urlSerializer.serialize(tree2);
      return {
        state: routeState,
        tree: tree2
      };
    }));
  }
  match(rootSegmentGroup) {
    const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});
    return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map((children) => {
      return {
        children,
        rootSnapshot
      };
    }), catchError((e3) => {
      if (e3 instanceof AbsoluteRedirect) {
        this.urlTree = e3.urlTree;
        return this.match(e3.urlTree.root);
      }
      if (e3 instanceof NoMatch) {
        throw this.noMatchError(e3);
      }
      throw e3;
    }));
  }
  processSegmentGroup(injector, config3, segmentGroup, outlet, parentRoute) {
    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
      return this.processChildren(injector, config3, segmentGroup, parentRoute);
    }
    return this.processSegment(injector, config3, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map((child) => child instanceof TreeNode ? [child] : []));
  }
  /**
   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if
   * we cannot find a match for _any_ of the children.
   *
   * @param config - The `Routes` to match against
   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the
   *     config.
   */
  processChildren(injector, config3, segmentGroup, parentRoute) {
    const childOutlets = [];
    for (const child of Object.keys(segmentGroup.children)) {
      if (child === "primary") {
        childOutlets.unshift(child);
      } else {
        childOutlets.push(child);
      }
    }
    return from(childOutlets).pipe(concatMap((childOutlet) => {
      const child = segmentGroup.children[childOutlet];
      const sortedConfig = sortByMatchingOutlets(config3, childOutlet);
      return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);
    }), scan((children, outletChildren) => {
      children.push(...outletChildren);
      return children;
    }), defaultIfEmpty(null), last2(), mergeMap((children) => {
      if (children === null) return noMatch$1(segmentGroup);
      const mergedChildren = mergeEmptyPathMatches(children);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        checkOutletNameUniqueness(mergedChildren);
      }
      sortActivatedRouteSnapshots(mergedChildren);
      return of(mergedChildren);
    }));
  }
  processSegment(injector, routes2, segmentGroup, segments, outlet, allowRedirects, parentRoute) {
    return from(routes2).pipe(concatMap((r3) => {
      return this.processSegmentAgainstRoute(r3._injector ?? injector, routes2, r3, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError((e3) => {
        if (e3 instanceof NoMatch) {
          return of(null);
        }
        throw e3;
      }));
    }), first((x4) => !!x4), catchError((e3) => {
      if (isEmptyError(e3)) {
        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
          return of(new NoLeftoversInUrl());
        }
        return noMatch$1(segmentGroup);
      }
      throw e3;
    }));
  }
  processSegmentAgainstRoute(injector, routes2, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {
    if (!isImmediateMatch(route, rawSegment, segments, outlet)) return noMatch$1(rawSegment);
    if (route.redirectTo === void 0) {
      return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);
    }
    if (this.allowRedirects && allowRedirects) {
      return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes2, route, segments, outlet, parentRoute);
    }
    return noMatch$1(rawSegment);
  }
  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes2, route, segments, outlet, parentRoute) {
    const {
      matched,
      parameters,
      consumedSegments,
      positionalParamSegments,
      remainingSegments
    } = match(segmentGroup, route, segments);
    if (!matched) return noMatch$1(segmentGroup);
    if (typeof route.redirectTo === "string" && route.redirectTo[0] === "/") {
      this.absoluteRedirectCount++;
      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {
        if (ngDevMode) {
          throw new RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.
This is currently a dev mode only error but will become a call stack size exceeded error in production in a future major version.`);
        }
        this.allowRedirects = false;
      }
    }
    const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);
    currentSnapshot.params = Object.freeze(inherited.params);
    currentSnapshot.data = Object.freeze(inherited.data);
    const newTree = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);
    return this.applyRedirects.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments) => {
      return this.processSegment(injector, routes2, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);
    }));
  }
  matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {
    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);
    if (route.path === "**") {
      rawSegment.children = {};
    }
    return matchResult.pipe(switchMap((result) => {
      if (!result.matched) {
        return noMatch$1(rawSegment);
      }
      injector = route._injector ?? injector;
      return this.getChildConfig(injector, route, segments).pipe(switchMap(({
        routes: childConfig
      }) => {
        const childInjector = route._loadedInjector ?? injector;
        const {
          parameters,
          consumedSegments,
          remainingSegments
        } = result;
        const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
        const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);
        snapshot.params = Object.freeze(inherited.params);
        snapshot.data = Object.freeze(inherited.data);
        const {
          segmentGroup,
          slicedSegments
        } = split(rawSegment, consumedSegments, remainingSegments, childConfig);
        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
          return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map((children) => {
            return new TreeNode(snapshot, children);
          }));
        }
        if (childConfig.length === 0 && slicedSegments.length === 0) {
          return of(new TreeNode(snapshot, []));
        }
        const matchedOnOutlet = getOutlet(route) === outlet;
        return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map((child) => {
          return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);
        }));
      }));
    }));
  }
  getChildConfig(injector, route, segments) {
    if (route.children) {
      return of({
        routes: route.children,
        injector
      });
    }
    if (route.loadChildren) {
      if (route._loadedRoutes !== void 0) {
        return of({
          routes: route._loadedRoutes,
          injector: route._loadedInjector
        });
      }
      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap((shouldLoadResult) => {
        if (shouldLoadResult) {
          return this.configLoader.loadChildren(injector, route).pipe(tap((cfg) => {
            route._loadedRoutes = cfg.routes;
            route._loadedInjector = cfg.injector;
          }));
        }
        return canLoadFails(route);
      }));
    }
    return of({
      routes: [],
      injector
    });
  }
};
function sortActivatedRouteSnapshots(nodes) {
  nodes.sort((a3, b3) => {
    if (a3.value.outlet === PRIMARY_OUTLET) return -1;
    if (b3.value.outlet === PRIMARY_OUTLET) return 1;
    return a3.value.outlet.localeCompare(b3.value.outlet);
  });
}
function hasEmptyPathConfig(node) {
  const config3 = node.value.routeConfig;
  return config3 && config3.path === "";
}
function mergeEmptyPathMatches(nodes) {
  const result = [];
  const mergedNodes = /* @__PURE__ */ new Set();
  for (const node of nodes) {
    if (!hasEmptyPathConfig(node)) {
      result.push(node);
      continue;
    }
    const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);
    if (duplicateEmptyPathNode !== void 0) {
      duplicateEmptyPathNode.children.push(...node.children);
      mergedNodes.add(duplicateEmptyPathNode);
    } else {
      result.push(node);
    }
  }
  for (const mergedNode of mergedNodes) {
    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);
    result.push(new TreeNode(mergedNode.value, mergedChildren));
  }
  return result.filter((n2) => !mergedNodes.has(n2));
}
function checkOutletNameUniqueness(nodes) {
  const names = {};
  nodes.forEach((n2) => {
    const routeWithSameOutletName = names[n2.value.outlet];
    if (routeWithSameOutletName) {
      const p3 = routeWithSameOutletName.url.map((s3) => s3.toString()).join("/");
      const c3 = n2.value.url.map((s3) => s3.toString()).join("/");
      throw new RuntimeError(4006, (typeof ngDevMode === "undefined" || ngDevMode) && `Two segments cannot have the same outlet name: '${p3}' and '${c3}'.`);
    }
    names[n2.value.outlet] = n2.value;
  });
}
function getData(route) {
  return route.data || {};
}
function getResolve(route) {
  return route.resolve || {};
}
function recognize(injector, configLoader, rootComponentType, config3, serializer, paramsInheritanceStrategy) {
  return mergeMap((t3) => recognize$1(injector, configLoader, rootComponentType, config3, t3.extractedUrl, serializer, paramsInheritanceStrategy).pipe(map(({
    state: targetSnapshot,
    tree: urlAfterRedirects
  }) => {
    return __spreadProps(__spreadValues({}, t3), {
      targetSnapshot,
      urlAfterRedirects
    });
  })));
}
function resolveData(paramsInheritanceStrategy, injector) {
  return mergeMap((t3) => {
    const {
      targetSnapshot,
      guards: {
        canActivateChecks
      }
    } = t3;
    if (!canActivateChecks.length) {
      return of(t3);
    }
    const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));
    const routesNeedingDataUpdates = /* @__PURE__ */ new Set();
    for (const route of routesWithResolversToRun) {
      if (routesNeedingDataUpdates.has(route)) {
        continue;
      }
      for (const newRoute of flattenRouteTree(route)) {
        routesNeedingDataUpdates.add(newRoute);
      }
    }
    let routesProcessed = 0;
    return from(routesNeedingDataUpdates).pipe(concatMap((route) => {
      if (routesWithResolversToRun.has(route)) {
        return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);
      } else {
        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;
        return of(void 0);
      }
    }), tap(() => routesProcessed++), takeLast(1), mergeMap((_3) => routesProcessed === routesNeedingDataUpdates.size ? of(t3) : EMPTY));
  });
}
function flattenRouteTree(route) {
  const descendants = route.children.map((child) => flattenRouteTree(child)).flat();
  return [route, ...descendants];
}
function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {
  const config3 = futureARS.routeConfig;
  const resolve = futureARS._resolve;
  if (config3?.title !== void 0 && !hasStaticTitle(config3)) {
    resolve[RouteTitleKey] = config3.title;
  }
  return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData) => {
    futureARS._resolvedData = resolvedData;
    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;
    return null;
  }));
}
function resolveNode(resolve, futureARS, futureRSS, injector) {
  const keys = getDataKeys(resolve);
  if (keys.length === 0) {
    return of({});
  }
  const data = {};
  return from(keys).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap((value) => {
    if (value instanceof RedirectCommand) {
      throw redirectingNavigationError(new DefaultUrlSerializer(), value);
    }
    data[key] = value;
  }))), takeLast(1), mapTo(data), catchError((e3) => isEmptyError(e3) ? EMPTY : throwError(e3)));
}
function getResolver(injectionToken, futureARS, futureRSS, injector) {
  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);
  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));
  return wrapIntoObservable(resolverValue);
}
function switchTap(next) {
  return switchMap((v3) => {
    const nextResult = next(v3);
    if (nextResult) {
      return from(nextResult).pipe(map(() => v3));
    }
    return of(v3);
  });
}
var _TitleStrategy = class _TitleStrategy {
  /**
   * @returns The `title` of the deepest primary route.
   */
  buildTitle(snapshot) {
    let pageTitle;
    let route = snapshot.root;
    while (route !== void 0) {
      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;
      route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);
    }
    return pageTitle;
  }
  /**
   * Given an `ActivatedRouteSnapshot`, returns the final value of the
   * `Route.title` property, which can either be a static string or a resolved value.
   */
  getResolvedTitleForRoute(snapshot) {
    return snapshot.data[RouteTitleKey];
  }
};
_TitleStrategy.\u0275fac = function TitleStrategy_Factory(t3) {
  return new (t3 || _TitleStrategy)();
};
_TitleStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _TitleStrategy,
  factory: () => (() => inject(DefaultTitleStrategy))(),
  providedIn: "root"
});
var TitleStrategy = _TitleStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultTitleStrategy)
    }]
  }], null, null);
})();
var _DefaultTitleStrategy = class _DefaultTitleStrategy extends TitleStrategy {
  constructor(title) {
    super();
    this.title = title;
  }
  /**
   * Sets the title of the browser to the given value.
   *
   * @param title The `pageTitle` from the deepest primary route.
   */
  updateTitle(snapshot) {
    const title = this.buildTitle(snapshot);
    if (title !== void 0) {
      this.title.setTitle(title);
    }
  }
};
_DefaultTitleStrategy.\u0275fac = function DefaultTitleStrategy_Factory(t3) {
  return new (t3 || _DefaultTitleStrategy)(\u0275\u0275inject(Title));
};
_DefaultTitleStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DefaultTitleStrategy,
  factory: _DefaultTitleStrategy.\u0275fac,
  providedIn: "root"
});
var DefaultTitleStrategy = _DefaultTitleStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultTitleStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Title
  }], null);
})();
var ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router config" : "", {
  providedIn: "root",
  factory: () => ({})
});
var ROUTES = new InjectionToken(ngDevMode ? "ROUTES" : "");
var _RouterConfigLoader = class _RouterConfigLoader {
  constructor() {
    this.componentLoaders = /* @__PURE__ */ new WeakMap();
    this.childrenLoaders = /* @__PURE__ */ new WeakMap();
    this.compiler = inject(Compiler);
  }
  loadComponent(route) {
    if (this.componentLoaders.get(route)) {
      return this.componentLoaders.get(route);
    } else if (route._loadedComponent) {
      return of(route._loadedComponent);
    }
    if (this.onLoadStartListener) {
      this.onLoadStartListener(route);
    }
    const loadRunner = wrapIntoObservable(route.loadComponent()).pipe(map(maybeUnwrapDefaultExport), tap((component) => {
      if (this.onLoadEndListener) {
        this.onLoadEndListener(route);
      }
      (typeof ngDevMode === "undefined" || ngDevMode) && assertStandalone(route.path ?? "", component);
      route._loadedComponent = component;
    }), finalize(() => {
      this.componentLoaders.delete(route);
    }));
    const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
    this.componentLoaders.set(route, loader);
    return loader;
  }
  loadChildren(parentInjector, route) {
    if (this.childrenLoaders.get(route)) {
      return this.childrenLoaders.get(route);
    } else if (route._loadedRoutes) {
      return of({
        routes: route._loadedRoutes,
        injector: route._loadedInjector
      });
    }
    if (this.onLoadStartListener) {
      this.onLoadStartListener(route);
    }
    const moduleFactoryOrRoutes$ = loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);
    const loadRunner = moduleFactoryOrRoutes$.pipe(finalize(() => {
      this.childrenLoaders.delete(route);
    }));
    const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
    this.childrenLoaders.set(route, loader);
    return loader;
  }
};
_RouterConfigLoader.\u0275fac = function RouterConfigLoader_Factory(t3) {
  return new (t3 || _RouterConfigLoader)();
};
_RouterConfigLoader.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _RouterConfigLoader,
  factory: _RouterConfigLoader.\u0275fac,
  providedIn: "root"
});
var RouterConfigLoader = _RouterConfigLoader;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterConfigLoader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function loadChildren(route, compiler, parentInjector, onLoadEndListener) {
  return wrapIntoObservable(route.loadChildren()).pipe(map(maybeUnwrapDefaultExport), mergeMap((t3) => {
    if (t3 instanceof NgModuleFactory$1 || Array.isArray(t3)) {
      return of(t3);
    } else {
      return from(compiler.compileModuleAsync(t3));
    }
  }), map((factoryOrRoutes) => {
    if (onLoadEndListener) {
      onLoadEndListener(route);
    }
    let injector;
    let rawRoutes;
    let requireStandaloneComponents = false;
    if (Array.isArray(factoryOrRoutes)) {
      rawRoutes = factoryOrRoutes;
      requireStandaloneComponents = true;
    } else {
      injector = factoryOrRoutes.create(parentInjector).injector;
      rawRoutes = injector.get(ROUTES, [], {
        optional: true,
        self: true
      }).flat();
    }
    const routes2 = rawRoutes.map(standardizeConfig);
    (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(routes2, route.path, requireStandaloneComponents);
    return {
      routes: routes2,
      injector
    };
  }));
}
function isWrappedDefaultExport(value) {
  return value && typeof value === "object" && "default" in value;
}
function maybeUnwrapDefaultExport(input2) {
  return isWrappedDefaultExport(input2) ? input2["default"] : input2;
}
var _UrlHandlingStrategy = class _UrlHandlingStrategy {
};
_UrlHandlingStrategy.\u0275fac = function UrlHandlingStrategy_Factory(t3) {
  return new (t3 || _UrlHandlingStrategy)();
};
_UrlHandlingStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _UrlHandlingStrategy,
  factory: () => (() => inject(DefaultUrlHandlingStrategy))(),
  providedIn: "root"
});
var UrlHandlingStrategy = _UrlHandlingStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlHandlingStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultUrlHandlingStrategy)
    }]
  }], null, null);
})();
var _DefaultUrlHandlingStrategy = class _DefaultUrlHandlingStrategy {
  shouldProcessUrl(url) {
    return true;
  }
  extract(url) {
    return url;
  }
  merge(newUrlPart, wholeUrl) {
    return newUrlPart;
  }
};
_DefaultUrlHandlingStrategy.\u0275fac = function DefaultUrlHandlingStrategy_Factory(t3) {
  return new (t3 || _DefaultUrlHandlingStrategy)();
};
_DefaultUrlHandlingStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DefaultUrlHandlingStrategy,
  factory: _DefaultUrlHandlingStrategy.\u0275fac,
  providedIn: "root"
});
var DefaultUrlHandlingStrategy = _DefaultUrlHandlingStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultUrlHandlingStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? "view transition helper" : "");
var VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? "view transition options" : "");
function createViewTransition(injector, from2, to) {
  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);
  const document2 = injector.get(DOCUMENT2);
  return injector.get(NgZone).runOutsideAngular(() => {
    if (!document2.startViewTransition || transitionOptions.skipNextTransition) {
      transitionOptions.skipNextTransition = false;
      return new Promise((resolve) => setTimeout(resolve));
    }
    let resolveViewTransitionStarted;
    const viewTransitionStarted = new Promise((resolve) => {
      resolveViewTransitionStarted = resolve;
    });
    const transition = document2.startViewTransition(() => {
      resolveViewTransitionStarted();
      return createRenderPromise(injector);
    });
    const {
      onViewTransitionCreated
    } = transitionOptions;
    if (onViewTransitionCreated) {
      runInInjectionContext(injector, () => onViewTransitionCreated({
        transition,
        from: from2,
        to
      }));
    }
    return viewTransitionStarted;
  });
}
function createRenderPromise(injector) {
  return new Promise((resolve) => {
    afterNextRender(resolve, {
      injector
    });
  });
}
var NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "navigation error handler" : "");
var _NavigationTransitions = class _NavigationTransitions {
  get hasRequestedNavigation() {
    return this.navigationId !== 0;
  }
  constructor() {
    this.currentNavigation = null;
    this.currentTransition = null;
    this.lastSuccessfulNavigation = null;
    this.events = new Subject();
    this.transitionAbortSubject = new Subject();
    this.configLoader = inject(RouterConfigLoader);
    this.environmentInjector = inject(EnvironmentInjector);
    this.urlSerializer = inject(UrlSerializer);
    this.rootContexts = inject(ChildrenOutletContexts);
    this.location = inject(Location);
    this.inputBindingEnabled = inject(INPUT_BINDER, {
      optional: true
    }) !== null;
    this.titleStrategy = inject(TitleStrategy);
    this.options = inject(ROUTER_CONFIGURATION, {
      optional: true
    }) || {};
    this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly";
    this.urlHandlingStrategy = inject(UrlHandlingStrategy);
    this.createViewTransition = inject(CREATE_VIEW_TRANSITION, {
      optional: true
    });
    this.navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {
      optional: true
    });
    this.navigationId = 0;
    this.afterPreactivation = () => of(void 0);
    this.rootComponentType = null;
    const onLoadStart = (r3) => this.events.next(new RouteConfigLoadStart(r3));
    const onLoadEnd = (r3) => this.events.next(new RouteConfigLoadEnd(r3));
    this.configLoader.onLoadEndListener = onLoadEnd;
    this.configLoader.onLoadStartListener = onLoadStart;
  }
  complete() {
    this.transitions?.complete();
  }
  handleNavigationRequest(request) {
    const id = ++this.navigationId;
    this.transitions?.next(__spreadProps(__spreadValues(__spreadValues({}, this.transitions.value), request), {
      id
    }));
  }
  setupNavigations(router, initialUrlTree, initialRouterState) {
    this.transitions = new BehaviorSubject({
      id: 0,
      currentUrlTree: initialUrlTree,
      currentRawUrl: initialUrlTree,
      extractedUrl: this.urlHandlingStrategy.extract(initialUrlTree),
      urlAfterRedirects: this.urlHandlingStrategy.extract(initialUrlTree),
      rawUrl: initialUrlTree,
      extras: {},
      resolve: () => {
      },
      reject: () => {
      },
      promise: Promise.resolve(true),
      source: IMPERATIVE_NAVIGATION,
      restoredState: null,
      currentSnapshot: initialRouterState.snapshot,
      targetSnapshot: null,
      currentRouterState: initialRouterState,
      targetRouterState: null,
      guards: {
        canActivateChecks: [],
        canDeactivateChecks: []
      },
      guardsResult: null
    });
    return this.transitions.pipe(
      filter((t3) => t3.id !== 0),
      // Extract URL
      map((t3) => __spreadProps(__spreadValues({}, t3), {
        extractedUrl: this.urlHandlingStrategy.extract(t3.rawUrl)
      })),
      // Using switchMap so we cancel executing navigations when a new one comes in
      switchMap((overallTransitionState) => {
        let completed = false;
        let errored = false;
        return of(overallTransitionState).pipe(
          switchMap((t3) => {
            if (this.navigationId > overallTransitionState.id) {
              const cancellationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
              this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);
              return EMPTY;
            }
            this.currentTransition = overallTransitionState;
            this.currentNavigation = {
              id: t3.id,
              initialUrl: t3.rawUrl,
              extractedUrl: t3.extractedUrl,
              trigger: t3.source,
              extras: t3.extras,
              previousNavigation: !this.lastSuccessfulNavigation ? null : __spreadProps(__spreadValues({}, this.lastSuccessfulNavigation), {
                previousNavigation: null
              })
            };
            const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();
            const onSameUrlNavigation = t3.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;
            if (!urlTransition && onSameUrlNavigation !== "reload") {
              const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation to ${t3.rawUrl} was ignored because it is the same as the current Router URL.` : "";
              this.events.next(new NavigationSkipped(t3.id, this.urlSerializer.serialize(t3.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));
              t3.resolve(false);
              return EMPTY;
            }
            if (this.urlHandlingStrategy.shouldProcessUrl(t3.rawUrl)) {
              return of(t3).pipe(
                // Fire NavigationStart event
                switchMap((t4) => {
                  const transition = this.transitions?.getValue();
                  this.events.next(new NavigationStart(t4.id, this.urlSerializer.serialize(t4.extractedUrl), t4.source, t4.restoredState));
                  if (transition !== this.transitions?.getValue()) {
                    return EMPTY;
                  }
                  return Promise.resolve(t4);
                }),
                // Recognize
                recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy),
                // Update URL if in `eager` update mode
                tap((t4) => {
                  overallTransitionState.targetSnapshot = t4.targetSnapshot;
                  overallTransitionState.urlAfterRedirects = t4.urlAfterRedirects;
                  this.currentNavigation = __spreadProps(__spreadValues({}, this.currentNavigation), {
                    finalUrl: t4.urlAfterRedirects
                  });
                  const routesRecognized = new RoutesRecognized(t4.id, this.urlSerializer.serialize(t4.extractedUrl), this.urlSerializer.serialize(t4.urlAfterRedirects), t4.targetSnapshot);
                  this.events.next(routesRecognized);
                })
              );
            } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t3.currentRawUrl)) {
              const {
                id,
                extractedUrl,
                source,
                restoredState,
                extras
              } = t3;
              const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);
              this.events.next(navStart);
              const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;
              this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t3), {
                targetSnapshot,
                urlAfterRedirects: extractedUrl,
                extras: __spreadProps(__spreadValues({}, extras), {
                  skipLocationChange: false,
                  replaceUrl: false
                })
              });
              this.currentNavigation.finalUrl = extractedUrl;
              return of(overallTransitionState);
            } else {
              const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy indicated neither the current URL ${t3.currentRawUrl} nor target URL ${t3.rawUrl} should be processed.` : "";
              this.events.next(new NavigationSkipped(t3.id, this.urlSerializer.serialize(t3.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));
              t3.resolve(false);
              return EMPTY;
            }
          }),
          // --- GUARDS ---
          tap((t3) => {
            const guardsStart = new GuardsCheckStart(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot);
            this.events.next(guardsStart);
          }),
          map((t3) => {
            this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t3), {
              guards: getAllRouteGuards(t3.targetSnapshot, t3.currentSnapshot, this.rootContexts)
            });
            return overallTransitionState;
          }),
          checkGuards(this.environmentInjector, (evt) => this.events.next(evt)),
          tap((t3) => {
            overallTransitionState.guardsResult = t3.guardsResult;
            if (t3.guardsResult && typeof t3.guardsResult !== "boolean") {
              throw redirectingNavigationError(this.urlSerializer, t3.guardsResult);
            }
            const guardsEnd = new GuardsCheckEnd(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot, !!t3.guardsResult);
            this.events.next(guardsEnd);
          }),
          filter((t3) => {
            if (!t3.guardsResult) {
              this.cancelNavigationTransition(t3, "", NavigationCancellationCode.GuardRejected);
              return false;
            }
            return true;
          }),
          // --- RESOLVE ---
          switchTap((t3) => {
            if (t3.guards.canActivateChecks.length) {
              return of(t3).pipe(tap((t4) => {
                const resolveStart = new ResolveStart(t4.id, this.urlSerializer.serialize(t4.extractedUrl), this.urlSerializer.serialize(t4.urlAfterRedirects), t4.targetSnapshot);
                this.events.next(resolveStart);
              }), switchMap((t4) => {
                let dataResolved = false;
                return of(t4).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({
                  next: () => dataResolved = true,
                  complete: () => {
                    if (!dataResolved) {
                      this.cancelNavigationTransition(t4, typeof ngDevMode === "undefined" || ngDevMode ? `At least one route resolver didn't emit any value.` : "", NavigationCancellationCode.NoDataFromResolver);
                    }
                  }
                }));
              }), tap((t4) => {
                const resolveEnd = new ResolveEnd(t4.id, this.urlSerializer.serialize(t4.extractedUrl), this.urlSerializer.serialize(t4.urlAfterRedirects), t4.targetSnapshot);
                this.events.next(resolveEnd);
              }));
            }
            return void 0;
          }),
          // --- LOAD COMPONENTS ---
          switchTap((t3) => {
            const loadComponents = (route) => {
              const loaders = [];
              if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {
                loaders.push(this.configLoader.loadComponent(route.routeConfig).pipe(tap((loadedComponent) => {
                  route.component = loadedComponent;
                }), map(() => void 0)));
              }
              for (const child of route.children) {
                loaders.push(...loadComponents(child));
              }
              return loaders;
            };
            return combineLatest(loadComponents(t3.targetSnapshot.root)).pipe(defaultIfEmpty(null), take(1));
          }),
          switchTap(() => this.afterPreactivation()),
          switchMap(() => {
            const {
              currentSnapshot,
              targetSnapshot
            } = overallTransitionState;
            const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);
            return viewTransitionStarted ? from(viewTransitionStarted).pipe(map(() => overallTransitionState)) : of(overallTransitionState);
          }),
          map((t3) => {
            const targetRouterState = createRouterState(router.routeReuseStrategy, t3.targetSnapshot, t3.currentRouterState);
            this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t3), {
              targetRouterState
            });
            this.currentNavigation.targetRouterState = targetRouterState;
            return overallTransitionState;
          }),
          tap(() => {
            this.events.next(new BeforeActivateRoutes());
          }),
          activateRoutes(this.rootContexts, router.routeReuseStrategy, (evt) => this.events.next(evt), this.inputBindingEnabled),
          // Ensure that if some observable used to drive the transition doesn't
          // complete, the navigation still finalizes This should never happen, but
          // this is done as a safety measure to avoid surfacing this error (#49567).
          take(1),
          tap({
            next: (t3) => {
              completed = true;
              this.lastSuccessfulNavigation = this.currentNavigation;
              this.events.next(new NavigationEnd(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects)));
              this.titleStrategy?.updateTitle(t3.targetRouterState.snapshot);
              t3.resolve(true);
            },
            complete: () => {
              completed = true;
            }
          }),
          // There used to be a lot more logic happening directly within the
          // transition Observable. Some of this logic has been refactored out to
          // other places but there may still be errors that happen there. This gives
          // us a way to cancel the transition from the outside. This may also be
          // required in the future to support something like the abort signal of the
          // Navigation API where the navigation gets aborted from outside the
          // transition.
          takeUntil(this.transitionAbortSubject.pipe(tap((err) => {
            throw err;
          }))),
          finalize(() => {
            if (!completed && !errored) {
              const cancelationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
              this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);
            }
            if (this.currentTransition?.id === overallTransitionState.id) {
              this.currentNavigation = null;
              this.currentTransition = null;
            }
          }),
          catchError((e3) => {
            errored = true;
            if (isNavigationCancelingError(e3)) {
              this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e3.message, e3.cancellationCode));
              if (!isRedirectingNavigationCancelingError(e3)) {
                overallTransitionState.resolve(false);
              } else {
                this.events.next(new RedirectRequest(e3.url, e3.navigationBehaviorOptions));
              }
            } else {
              const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e3, overallTransitionState.targetSnapshot ?? void 0);
              try {
                const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));
                if (navigationErrorHandlerResult instanceof RedirectCommand) {
                  const {
                    message,
                    cancellationCode
                  } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);
                  this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));
                  this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));
                } else {
                  this.events.next(navigationError);
                  const errorHandlerResult = router.errorHandler(e3);
                  overallTransitionState.resolve(!!errorHandlerResult);
                }
              } catch (ee) {
                if (this.options.resolveNavigationPromiseOnError) {
                  overallTransitionState.resolve(false);
                } else {
                  overallTransitionState.reject(ee);
                }
              }
            }
            return EMPTY;
          })
        );
      })
    );
  }
  cancelNavigationTransition(t3, reason, code) {
    const navCancel = new NavigationCancel(t3.id, this.urlSerializer.serialize(t3.extractedUrl), reason, code);
    this.events.next(navCancel);
    t3.resolve(false);
  }
  /**
   * @returns Whether we're navigating to somewhere that is not what the Router is
   * currently set to.
   */
  isUpdatingInternalState() {
    return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();
  }
  /**
   * @returns Whether we're updating the browser URL to something new (navigation is going
   * to somewhere not displayed in the URL bar and we will update the URL
   * bar if navigation succeeds).
   */
  isUpdatedBrowserUrl() {
    const extractedBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));
    return extractedBrowserUrl.toString() !== this.currentTransition?.extractedUrl.toString() && !this.currentTransition?.extras.skipLocationChange;
  }
};
_NavigationTransitions.\u0275fac = function NavigationTransitions_Factory(t3) {
  return new (t3 || _NavigationTransitions)();
};
_NavigationTransitions.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NavigationTransitions,
  factory: _NavigationTransitions.\u0275fac,
  providedIn: "root"
});
var NavigationTransitions = _NavigationTransitions;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationTransitions, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function isBrowserTriggeredNavigation(source) {
  return source !== IMPERATIVE_NAVIGATION;
}
var _RouteReuseStrategy = class _RouteReuseStrategy {
};
_RouteReuseStrategy.\u0275fac = function RouteReuseStrategy_Factory(t3) {
  return new (t3 || _RouteReuseStrategy)();
};
_RouteReuseStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _RouteReuseStrategy,
  factory: () => (() => inject(DefaultRouteReuseStrategy))(),
  providedIn: "root"
});
var RouteReuseStrategy = _RouteReuseStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouteReuseStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultRouteReuseStrategy)
    }]
  }], null, null);
})();
var BaseRouteReuseStrategy = class {
  /**
   * Whether the given route should detach for later reuse.
   * Always returns false for `BaseRouteReuseStrategy`.
   * */
  shouldDetach(route) {
    return false;
  }
  /**
   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.
   */
  store(route, detachedTree) {
  }
  /** Returns `false`, meaning the route (and its subtree) is never reattached */
  shouldAttach(route) {
    return false;
  }
  /** Returns `null` because this strategy does not store routes for later re-use. */
  retrieve(route) {
    return null;
  }
  /**
   * Determines if a route should be reused.
   * This strategy returns `true` when the future route config and current route config are
   * identical.
   */
  shouldReuseRoute(future, curr) {
    return future.routeConfig === curr.routeConfig;
  }
};
var _DefaultRouteReuseStrategy = class _DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {
};
_DefaultRouteReuseStrategy.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275DefaultRouteReuseStrategy_BaseFactory;
  return function DefaultRouteReuseStrategy_Factory(t3) {
    return (\u0275DefaultRouteReuseStrategy_BaseFactory || (\u0275DefaultRouteReuseStrategy_BaseFactory = \u0275\u0275getInheritedFactory(_DefaultRouteReuseStrategy)))(t3 || _DefaultRouteReuseStrategy);
  };
})();
_DefaultRouteReuseStrategy.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DefaultRouteReuseStrategy,
  factory: _DefaultRouteReuseStrategy.\u0275fac,
  providedIn: "root"
});
var DefaultRouteReuseStrategy = _DefaultRouteReuseStrategy;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultRouteReuseStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _StateManager = class _StateManager {
};
_StateManager.\u0275fac = function StateManager_Factory(t3) {
  return new (t3 || _StateManager)();
};
_StateManager.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _StateManager,
  factory: () => (() => inject(HistoryStateManager))(),
  providedIn: "root"
});
var StateManager = _StateManager;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StateManager, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(HistoryStateManager)
    }]
  }], null, null);
})();
var _HistoryStateManager = class _HistoryStateManager extends StateManager {
  constructor() {
    super(...arguments);
    this.location = inject(Location);
    this.urlSerializer = inject(UrlSerializer);
    this.options = inject(ROUTER_CONFIGURATION, {
      optional: true
    }) || {};
    this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace";
    this.urlHandlingStrategy = inject(UrlHandlingStrategy);
    this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
    this.currentUrlTree = new UrlTree();
    this.rawUrlTree = this.currentUrlTree;
    this.currentPageId = 0;
    this.lastSuccessfulId = -1;
    this.routerState = createEmptyState(null);
    this.stateMemento = this.createStateMemento();
  }
  getCurrentUrlTree() {
    return this.currentUrlTree;
  }
  getRawUrlTree() {
    return this.rawUrlTree;
  }
  restoredState() {
    return this.location.getState();
  }
  /**
   * The routerPageId of whatever page is currently active in the browser history. This is
   * important for computing the target page id for new navigations because we need to ensure each
   * page id in the browser history is 1 more than the previous entry.
   */
  get browserPageId() {
    if (this.canceledNavigationResolution !== "computed") {
      return this.currentPageId;
    }
    return this.restoredState()?.\u0275routerPageId ?? this.currentPageId;
  }
  getRouterState() {
    return this.routerState;
  }
  createStateMemento() {
    return {
      rawUrlTree: this.rawUrlTree,
      currentUrlTree: this.currentUrlTree,
      routerState: this.routerState
    };
  }
  registerNonRouterCurrentEntryChangeListener(listener) {
    return this.location.subscribe((event) => {
      if (event["type"] === "popstate") {
        listener(event["url"], event.state);
      }
    });
  }
  handleRouterEvent(e3, currentTransition) {
    if (e3 instanceof NavigationStart) {
      this.stateMemento = this.createStateMemento();
    } else if (e3 instanceof NavigationSkipped) {
      this.rawUrlTree = currentTransition.initialUrl;
    } else if (e3 instanceof RoutesRecognized) {
      if (this.urlUpdateStrategy === "eager") {
        if (!currentTransition.extras.skipLocationChange) {
          const rawUrl = this.urlHandlingStrategy.merge(currentTransition.finalUrl, currentTransition.initialUrl);
          this.setBrowserUrl(rawUrl, currentTransition);
        }
      }
    } else if (e3 instanceof BeforeActivateRoutes) {
      this.currentUrlTree = currentTransition.finalUrl;
      this.rawUrlTree = this.urlHandlingStrategy.merge(currentTransition.finalUrl, currentTransition.initialUrl);
      this.routerState = currentTransition.targetRouterState;
      if (this.urlUpdateStrategy === "deferred") {
        if (!currentTransition.extras.skipLocationChange) {
          this.setBrowserUrl(this.rawUrlTree, currentTransition);
        }
      }
    } else if (e3 instanceof NavigationCancel && (e3.code === NavigationCancellationCode.GuardRejected || e3.code === NavigationCancellationCode.NoDataFromResolver)) {
      this.restoreHistory(currentTransition);
    } else if (e3 instanceof NavigationError) {
      this.restoreHistory(currentTransition, true);
    } else if (e3 instanceof NavigationEnd) {
      this.lastSuccessfulId = e3.id;
      this.currentPageId = this.browserPageId;
    }
  }
  setBrowserUrl(url, transition) {
    const path = this.urlSerializer.serialize(url);
    if (this.location.isCurrentPathEqualTo(path) || !!transition.extras.replaceUrl) {
      const currentBrowserPageId = this.browserPageId;
      const state = __spreadValues(__spreadValues({}, transition.extras.state), this.generateNgRouterState(transition.id, currentBrowserPageId));
      this.location.replaceState(path, "", state);
    } else {
      const state = __spreadValues(__spreadValues({}, transition.extras.state), this.generateNgRouterState(transition.id, this.browserPageId + 1));
      this.location.go(path, "", state);
    }
  }
  /**
   * Performs the necessary rollback action to restore the browser URL to the
   * state before the transition.
   */
  restoreHistory(navigation, restoringFromCaughtError = false) {
    if (this.canceledNavigationResolution === "computed") {
      const currentBrowserPageId = this.browserPageId;
      const targetPagePosition = this.currentPageId - currentBrowserPageId;
      if (targetPagePosition !== 0) {
        this.location.historyGo(targetPagePosition);
      } else if (this.currentUrlTree === navigation.finalUrl && targetPagePosition === 0) {
        this.resetState(navigation);
        this.resetUrlToCurrentUrlTree();
      } else {
      }
    } else if (this.canceledNavigationResolution === "replace") {
      if (restoringFromCaughtError) {
        this.resetState(navigation);
      }
      this.resetUrlToCurrentUrlTree();
    }
  }
  resetState(navigation) {
    this.routerState = this.stateMemento.routerState;
    this.currentUrlTree = this.stateMemento.currentUrlTree;
    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, navigation.finalUrl ?? this.rawUrlTree);
  }
  resetUrlToCurrentUrlTree() {
    this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));
  }
  generateNgRouterState(navigationId, routerPageId) {
    if (this.canceledNavigationResolution === "computed") {
      return {
        navigationId,
        \u0275routerPageId: routerPageId
      };
    }
    return {
      navigationId
    };
  }
};
_HistoryStateManager.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275HistoryStateManager_BaseFactory;
  return function HistoryStateManager_Factory(t3) {
    return (\u0275HistoryStateManager_BaseFactory || (\u0275HistoryStateManager_BaseFactory = \u0275\u0275getInheritedFactory(_HistoryStateManager)))(t3 || _HistoryStateManager);
  };
})();
_HistoryStateManager.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _HistoryStateManager,
  factory: _HistoryStateManager.\u0275fac,
  providedIn: "root"
});
var HistoryStateManager = _HistoryStateManager;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HistoryStateManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NavigationResult;
(function(NavigationResult2) {
  NavigationResult2[NavigationResult2["COMPLETE"] = 0] = "COMPLETE";
  NavigationResult2[NavigationResult2["FAILED"] = 1] = "FAILED";
  NavigationResult2[NavigationResult2["REDIRECTING"] = 2] = "REDIRECTING";
})(NavigationResult || (NavigationResult = {}));
function afterNextNavigation(router, action) {
  router.events.pipe(filter((e3) => e3 instanceof NavigationEnd || e3 instanceof NavigationCancel || e3 instanceof NavigationError || e3 instanceof NavigationSkipped), map((e3) => {
    if (e3 instanceof NavigationEnd || e3 instanceof NavigationSkipped) {
      return NavigationResult.COMPLETE;
    }
    const redirecting = e3 instanceof NavigationCancel ? e3.code === NavigationCancellationCode.Redirect || e3.code === NavigationCancellationCode.SupersededByNewNavigation : false;
    return redirecting ? NavigationResult.REDIRECTING : NavigationResult.FAILED;
  }), filter((result) => result !== NavigationResult.REDIRECTING), take(1)).subscribe(() => {
    action();
  });
}
function defaultErrorHandler2(error) {
  throw error;
}
var exactMatchOptions = {
  paths: "exact",
  fragment: "ignored",
  matrixParams: "ignored",
  queryParams: "exact"
};
var subsetMatchOptions = {
  paths: "subset",
  fragment: "ignored",
  matrixParams: "ignored",
  queryParams: "subset"
};
var _Router = class _Router {
  get currentUrlTree() {
    return this.stateManager.getCurrentUrlTree();
  }
  get rawUrlTree() {
    return this.stateManager.getRawUrlTree();
  }
  /**
   * An event stream for routing events.
   */
  get events() {
    return this._events;
  }
  /**
   * The current state of routing in this NgModule.
   */
  get routerState() {
    return this.stateManager.getRouterState();
  }
  constructor() {
    this.disposed = false;
    this.console = inject(Console);
    this.stateManager = inject(StateManager);
    this.options = inject(ROUTER_CONFIGURATION, {
      optional: true
    }) || {};
    this.pendingTasks = inject(PendingTasks);
    this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
    this.navigationTransitions = inject(NavigationTransitions);
    this.urlSerializer = inject(UrlSerializer);
    this.location = inject(Location);
    this.urlHandlingStrategy = inject(UrlHandlingStrategy);
    this._events = new Subject();
    this.errorHandler = this.options.errorHandler || defaultErrorHandler2;
    this.navigated = false;
    this.routeReuseStrategy = inject(RouteReuseStrategy);
    this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore";
    this.config = inject(ROUTES, {
      optional: true
    })?.flat() ?? [];
    this.componentInputBindingEnabled = !!inject(INPUT_BINDER, {
      optional: true
    });
    this.eventsSubscription = new Subscription();
    this.resetConfig(this.config);
    this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe({
      error: (e3) => {
        this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e3}` : e3);
      }
    });
    this.subscribeToNavigationEvents();
  }
  subscribeToNavigationEvents() {
    const subscription = this.navigationTransitions.events.subscribe((e3) => {
      try {
        const currentTransition = this.navigationTransitions.currentTransition;
        const currentNavigation = this.navigationTransitions.currentNavigation;
        if (currentTransition !== null && currentNavigation !== null) {
          this.stateManager.handleRouterEvent(e3, currentNavigation);
          if (e3 instanceof NavigationCancel && e3.code !== NavigationCancellationCode.Redirect && e3.code !== NavigationCancellationCode.SupersededByNewNavigation) {
            this.navigated = true;
          } else if (e3 instanceof NavigationEnd) {
            this.navigated = true;
          } else if (e3 instanceof RedirectRequest) {
            const opts = e3.navigationBehaviorOptions;
            const mergedTree = this.urlHandlingStrategy.merge(e3.url, currentTransition.currentRawUrl);
            const extras = __spreadValues({
              // Persist transient navigation info from the original navigation request.
              info: currentTransition.extras.info,
              skipLocationChange: currentTransition.extras.skipLocationChange,
              // The URL is already updated at this point if we have 'eager' URL
              // updates or if the navigation was triggered by the browser (back
              // button, URL bar, etc). We want to replace that item in history
              // if the navigation is rejected.
              replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === "eager" || isBrowserTriggeredNavigation(currentTransition.source)
            }, opts);
            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {
              resolve: currentTransition.resolve,
              reject: currentTransition.reject,
              promise: currentTransition.promise
            });
          }
        }
        if (isPublicRouterEvent(e3)) {
          this._events.next(e3);
        }
      } catch (e4) {
        this.navigationTransitions.transitionAbortSubject.next(e4);
      }
    });
    this.eventsSubscription.add(subscription);
  }
  /** @internal */
  resetRootComponentType(rootComponentType) {
    this.routerState.root.component = rootComponentType;
    this.navigationTransitions.rootComponentType = rootComponentType;
  }
  /**
   * Sets up the location change listener and performs the initial navigation.
   */
  initialNavigation() {
    this.setUpLocationChangeListener();
    if (!this.navigationTransitions.hasRequestedNavigation) {
      this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());
    }
  }
  /**
   * Sets up the location change listener. This listener detects navigations triggered from outside
   * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router
   * navigation so that the correct events, guards, etc. are triggered.
   */
  setUpLocationChangeListener() {
    this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state) => {
      setTimeout(() => {
        this.navigateToSyncWithBrowser(url, "popstate", state);
      }, 0);
    });
  }
  /**
   * Schedules a router navigation to synchronize Router state with the browser state.
   *
   * This is done as a response to a popstate event and the initial navigation. These
   * two scenarios represent times when the browser URL/state has been updated and
   * the Router needs to respond to ensure its internal state matches.
   */
  navigateToSyncWithBrowser(url, source, state) {
    const extras = {
      replaceUrl: true
    };
    const restoredState = state?.navigationId ? state : null;
    if (state) {
      const stateCopy = __spreadValues({}, state);
      delete stateCopy.navigationId;
      delete stateCopy.\u0275routerPageId;
      if (Object.keys(stateCopy).length !== 0) {
        extras.state = stateCopy;
      }
    }
    const urlTree = this.parseUrl(url);
    this.scheduleNavigation(urlTree, source, restoredState, extras);
  }
  /** The current URL. */
  get url() {
    return this.serializeUrl(this.currentUrlTree);
  }
  /**
   * Returns the current `Navigation` object when the router is navigating,
   * and `null` when idle.
   */
  getCurrentNavigation() {
    return this.navigationTransitions.currentNavigation;
  }
  /**
   * The `Navigation` object of the most recent navigation to succeed and `null` if there
   *     has not been a successful navigation yet.
   */
  get lastSuccessfulNavigation() {
    return this.navigationTransitions.lastSuccessfulNavigation;
  }
  /**
   * Resets the route configuration used for navigation and generating links.
   *
   * @param config The route array for the new configuration.
   *
   * @usageNotes
   *
   * ```
   * router.resetConfig([
   *  { path: 'team/:id', component: TeamCmp, children: [
   *    { path: 'simple', component: SimpleCmp },
   *    { path: 'user/:name', component: UserCmp }
   *  ]}
   * ]);
   * ```
   */
  resetConfig(config3) {
    (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(config3);
    this.config = config3.map(standardizeConfig);
    this.navigated = false;
  }
  /** @nodoc */
  ngOnDestroy() {
    this.dispose();
  }
  /** Disposes of the router. */
  dispose() {
    this.navigationTransitions.complete();
    if (this.nonRouterCurrentEntryChangeSubscription) {
      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();
      this.nonRouterCurrentEntryChangeSubscription = void 0;
    }
    this.disposed = true;
    this.eventsSubscription.unsubscribe();
  }
  /**
   * Appends URL segments to the current URL tree to create a new URL tree.
   *
   * @param commands An array of URL fragments with which to construct the new URL tree.
   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path
   * segments, followed by the parameters for each segment.
   * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`
   * property of the options object, if supplied.
   * @param navigationExtras Options that control the navigation strategy.
   * @returns The new URL tree.
   *
   * @usageNotes
   *
   * ```
   * // create /team/33/user/11
   * router.createUrlTree(['/team', 33, 'user', 11]);
   *
   * // create /team/33;expand=true/user/11
   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
   *
   * // you can collapse static segments like this (this works only with the first passed-in value):
   * router.createUrlTree(['/team/33/user', userId]);
   *
   * // If the first segment can contain slashes, and you do not want the router to split it,
   * // you can do the following:
   * router.createUrlTree([{segmentPath: '/one/two'}]);
   *
   * // create /team/33/(user/11//right:chat)
   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
   *
   * // remove the right secondary node
   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
   *
   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
   *
   * // navigate to /team/33/user/11/details
   * router.createUrlTree(['details'], {relativeTo: route});
   *
   * // navigate to /team/33/user/22
   * router.createUrlTree(['../22'], {relativeTo: route});
   *
   * // navigate to /team/44/user/22
   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
   *
   * Note that a value of `null` or `undefined` for `relativeTo` indicates that the
   * tree should be created relative to the root.
   * ```
   */
  createUrlTree(commands, navigationExtras = {}) {
    const {
      relativeTo,
      queryParams,
      fragment,
      queryParamsHandling,
      preserveFragment
    } = navigationExtras;
    const f3 = preserveFragment ? this.currentUrlTree.fragment : fragment;
    let q3 = null;
    switch (queryParamsHandling) {
      case "merge":
        q3 = __spreadValues(__spreadValues({}, this.currentUrlTree.queryParams), queryParams);
        break;
      case "preserve":
        q3 = this.currentUrlTree.queryParams;
        break;
      default:
        q3 = queryParams || null;
    }
    if (q3 !== null) {
      q3 = this.removeEmptyProps(q3);
    }
    let relativeToUrlSegmentGroup;
    try {
      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;
      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);
    } catch (e3) {
      if (typeof commands[0] !== "string" || commands[0][0] !== "/") {
        commands = [];
      }
      relativeToUrlSegmentGroup = this.currentUrlTree.root;
    }
    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q3, f3 ?? null);
  }
  /**
   * Navigates to a view using an absolute route path.
   *
   * @param url An absolute path for a defined route. The function does not apply any delta to the
   *     current URL.
   * @param extras An object containing properties that modify the navigation strategy.
   *
   * @returns A Promise that resolves to 'true' when navigation succeeds,
   * to 'false' when navigation fails, or is rejected on error.
   *
   * @usageNotes
   *
   * The following calls request navigation to an absolute path.
   *
   * ```
   * router.navigateByUrl("/team/33/user/11");
   *
   * // Navigate without updating the URL
   * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
   * ```
   *
   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)
   *
   */
  navigateByUrl(url, extras = {
    skipLocationChange: false
  }) {
    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);
  }
  /**
   * Navigate based on the provided array of commands and a starting point.
   * If no starting route is provided, the navigation is absolute.
   *
   * @param commands An array of URL fragments with which to construct the target URL.
   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path
   * segments, followed by the parameters for each segment.
   * The fragments are applied to the current URL or the one provided  in the `relativeTo` property
   * of the options object, if supplied.
   * @param extras An options object that determines how the URL should be constructed or
   *     interpreted.
   *
   * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation
   *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is
   * not `true`.
   *
   * @usageNotes
   *
   * The following calls request navigation to a dynamic route path relative to the current URL.
   *
   * ```
   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
   *
   * // Navigate without updating the URL, overriding the default behavior
   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
   * ```
   *
   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)
   *
   */
  navigate(commands, extras = {
    skipLocationChange: false
  }) {
    validateCommands(commands);
    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
  }
  /** Serializes a `UrlTree` into a string */
  serializeUrl(url) {
    return this.urlSerializer.serialize(url);
  }
  /** Parses a string into a `UrlTree` */
  parseUrl(url) {
    try {
      return this.urlSerializer.parse(url);
    } catch {
      return this.urlSerializer.parse("/");
    }
  }
  isActive(url, matchOptions) {
    let options;
    if (matchOptions === true) {
      options = __spreadValues({}, exactMatchOptions);
    } else if (matchOptions === false) {
      options = __spreadValues({}, subsetMatchOptions);
    } else {
      options = matchOptions;
    }
    if (isUrlTree(url)) {
      return containsTree(this.currentUrlTree, url, options);
    }
    const urlTree = this.parseUrl(url);
    return containsTree(this.currentUrlTree, urlTree, options);
  }
  removeEmptyProps(params) {
    return Object.entries(params).reduce((result, [key, value]) => {
      if (value !== null && value !== void 0) {
        result[key] = value;
      }
      return result;
    }, {});
  }
  scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
    if (this.disposed) {
      return Promise.resolve(false);
    }
    let resolve;
    let reject;
    let promise;
    if (priorPromise) {
      resolve = priorPromise.resolve;
      reject = priorPromise.reject;
      promise = priorPromise.promise;
    } else {
      promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
    }
    const taskId = this.pendingTasks.add();
    afterNextNavigation(this, () => {
      queueMicrotask(() => this.pendingTasks.remove(taskId));
    });
    this.navigationTransitions.handleNavigationRequest({
      source,
      restoredState,
      currentUrlTree: this.currentUrlTree,
      currentRawUrl: this.currentUrlTree,
      rawUrl,
      extras,
      resolve,
      reject,
      promise,
      currentSnapshot: this.routerState.snapshot,
      currentRouterState: this.routerState
    });
    return promise.catch((e3) => {
      return Promise.reject(e3);
    });
  }
};
_Router.\u0275fac = function Router_Factory(t3) {
  return new (t3 || _Router)();
};
_Router.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _Router,
  factory: _Router.\u0275fac,
  providedIn: "root"
});
var Router = _Router;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Router, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function validateCommands(commands) {
  for (let i3 = 0; i3 < commands.length; i3++) {
    const cmd = commands[i3];
    if (cmd == null) {
      throw new RuntimeError(4008, (typeof ngDevMode === "undefined" || ngDevMode) && `The requested path contains ${cmd} segment at index ${i3}`);
    }
  }
}
function isPublicRouterEvent(e3) {
  return !(e3 instanceof BeforeActivateRoutes) && !(e3 instanceof RedirectRequest);
}
var _RouterLink = class _RouterLink {
  constructor(router, route, tabIndexAttribute, renderer, el, locationStrategy) {
    this.router = router;
    this.route = route;
    this.tabIndexAttribute = tabIndexAttribute;
    this.renderer = renderer;
    this.el = el;
    this.locationStrategy = locationStrategy;
    this.href = null;
    this.commands = null;
    this.onChanges = new Subject();
    this.preserveFragment = false;
    this.skipLocationChange = false;
    this.replaceUrl = false;
    const tagName = el.nativeElement.tagName?.toLowerCase();
    this.isAnchorElement = tagName === "a" || tagName === "area";
    if (this.isAnchorElement) {
      this.subscription = router.events.subscribe((s3) => {
        if (s3 instanceof NavigationEnd) {
          this.updateHref();
        }
      });
    } else {
      this.setTabIndexIfNotOnNativeEl("0");
    }
  }
  /**
   * Modifies the tab index if there was not a tabindex attribute on the element during
   * instantiation.
   */
  setTabIndexIfNotOnNativeEl(newTabIndex) {
    if (this.tabIndexAttribute != null || this.isAnchorElement) {
      return;
    }
    this.applyAttributeValue("tabindex", newTabIndex);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this.isAnchorElement) {
      this.updateHref();
    }
    this.onChanges.next(this);
  }
  /**
   * Commands to pass to {@link Router#createUrlTree}.
   *   - **array**: commands to pass to {@link Router#createUrlTree}.
   *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`
   *   - **null|undefined**: effectively disables the `routerLink`
   * @see {@link Router#createUrlTree}
   */
  set routerLink(commands) {
    if (commands != null) {
      this.commands = Array.isArray(commands) ? commands : [commands];
      this.setTabIndexIfNotOnNativeEl("0");
    } else {
      this.commands = null;
      this.setTabIndexIfNotOnNativeEl(null);
    }
  }
  /** @nodoc */
  onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
    const urlTree = this.urlTree;
    if (urlTree === null) {
      return true;
    }
    if (this.isAnchorElement) {
      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
        return true;
      }
      if (typeof this.target === "string" && this.target != "_self") {
        return true;
      }
    }
    const extras = {
      skipLocationChange: this.skipLocationChange,
      replaceUrl: this.replaceUrl,
      state: this.state,
      info: this.info
    };
    this.router.navigateByUrl(urlTree, extras);
    return !this.isAnchorElement;
  }
  /** @nodoc */
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  updateHref() {
    const urlTree = this.urlTree;
    this.href = urlTree !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) : null;
    const sanitizedValue = this.href === null ? null : (
      // This class represents a directive that can be added to both `<a>` elements,
      // as well as other elements. As a result, we can't define security context at
      // compile time. So the security context is deferred to runtime.
      // The `sanitizeUrlOrResourceUrl` selects the necessary sanitizer function
      // based on the tag and property names. The logic mimics the one from
      // `packages/compiler/src/schema/dom_security_schema.ts`, which is used at compile time.
      //
      // Note: we should investigate whether we can switch to using `@HostBinding('attr.href')`
      // instead of applying a value via a renderer, after a final merge of the
      // `RouterLinkWithHref` directive.
      \u0275\u0275sanitizeUrlOrResourceUrl(this.href, this.el.nativeElement.tagName.toLowerCase(), "href")
    );
    this.applyAttributeValue("href", sanitizedValue);
  }
  applyAttributeValue(attrName, attrValue) {
    const renderer = this.renderer;
    const nativeElement = this.el.nativeElement;
    if (attrValue !== null) {
      renderer.setAttribute(nativeElement, attrName, attrValue);
    } else {
      renderer.removeAttribute(nativeElement, attrName);
    }
  }
  get urlTree() {
    if (this.commands === null) {
      return null;
    }
    return this.router.createUrlTree(this.commands, {
      // If the `relativeTo` input is not defined, we want to use `this.route` by default.
      // Otherwise, we should use the value provided by the user in the input.
      relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
      queryParams: this.queryParams,
      fragment: this.fragment,
      queryParamsHandling: this.queryParamsHandling,
      preserveFragment: this.preserveFragment
    });
  }
};
_RouterLink.\u0275fac = function RouterLink_Factory(t3) {
  return new (t3 || _RouterLink)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275injectAttribute("tabindex"), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(LocationStrategy));
};
_RouterLink.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RouterLink,
  selectors: [["", "routerLink", ""]],
  hostVars: 1,
  hostBindings: function RouterLink_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function RouterLink_click_HostBindingHandler($event) {
        return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("target", ctx.target);
    }
  },
  inputs: {
    target: "target",
    queryParams: "queryParams",
    fragment: "fragment",
    queryParamsHandling: "queryParamsHandling",
    state: "state",
    info: "info",
    relativeTo: "relativeTo",
    preserveFragment: [2, "preserveFragment", "preserveFragment", booleanAttribute],
    skipLocationChange: [2, "skipLocationChange", "skipLocationChange", booleanAttribute],
    replaceUrl: [2, "replaceUrl", "replaceUrl", booleanAttribute],
    routerLink: "routerLink"
  },
  standalone: true,
  features: [\u0275\u0275InputTransformsFeature, \u0275\u0275NgOnChangesFeature]
});
var RouterLink = _RouterLink;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLink, [{
    type: Directive,
    args: [{
      selector: "[routerLink]",
      standalone: true
    }]
  }], () => [{
    type: Router
  }, {
    type: ActivatedRoute
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["tabindex"]
    }]
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: LocationStrategy
  }], {
    target: [{
      type: HostBinding,
      args: ["attr.target"]
    }, {
      type: Input
    }],
    queryParams: [{
      type: Input
    }],
    fragment: [{
      type: Input
    }],
    queryParamsHandling: [{
      type: Input
    }],
    state: [{
      type: Input
    }],
    info: [{
      type: Input
    }],
    relativeTo: [{
      type: Input
    }],
    preserveFragment: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    skipLocationChange: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    replaceUrl: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    routerLink: [{
      type: Input
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event.button", "$event.ctrlKey", "$event.shiftKey", "$event.altKey", "$event.metaKey"]]
    }]
  });
})();
var _RouterLinkActive = class _RouterLinkActive {
  get isActive() {
    return this._isActive;
  }
  constructor(router, element, renderer, cdr, link) {
    this.router = router;
    this.element = element;
    this.renderer = renderer;
    this.cdr = cdr;
    this.link = link;
    this.classes = [];
    this._isActive = false;
    this.routerLinkActiveOptions = {
      exact: false
    };
    this.isActiveChange = new EventEmitter();
    this.routerEventsSubscription = router.events.subscribe((s3) => {
      if (s3 instanceof NavigationEnd) {
        this.update();
      }
    });
  }
  /** @nodoc */
  ngAfterContentInit() {
    of(this.links.changes, of(null)).pipe(mergeAll()).subscribe((_3) => {
      this.update();
      this.subscribeToEachLinkOnChanges();
    });
  }
  subscribeToEachLinkOnChanges() {
    this.linkInputChangesSubscription?.unsubscribe();
    const allLinkChanges = [...this.links.toArray(), this.link].filter((link) => !!link).map((link) => link.onChanges);
    this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe((link) => {
      if (this._isActive !== this.isLinkActive(this.router)(link)) {
        this.update();
      }
    });
  }
  set routerLinkActive(data) {
    const classes = Array.isArray(data) ? data : data.split(" ");
    this.classes = classes.filter((c3) => !!c3);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this.update();
  }
  /** @nodoc */
  ngOnDestroy() {
    this.routerEventsSubscription.unsubscribe();
    this.linkInputChangesSubscription?.unsubscribe();
  }
  update() {
    if (!this.links || !this.router.navigated) return;
    queueMicrotask(() => {
      const hasActiveLinks = this.hasActiveLinks();
      this.classes.forEach((c3) => {
        if (hasActiveLinks) {
          this.renderer.addClass(this.element.nativeElement, c3);
        } else {
          this.renderer.removeClass(this.element.nativeElement, c3);
        }
      });
      if (hasActiveLinks && this.ariaCurrentWhenActive !== void 0) {
        this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString());
      } else {
        this.renderer.removeAttribute(this.element.nativeElement, "aria-current");
      }
      if (this._isActive !== hasActiveLinks) {
        this._isActive = hasActiveLinks;
        this.cdr.markForCheck();
        this.isActiveChange.emit(hasActiveLinks);
      }
    });
  }
  isLinkActive(router) {
    const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : (
      // While the types should disallow `undefined` here, it's possible without strict inputs
      this.routerLinkActiveOptions.exact || false
    );
    return (link) => {
      const urlTree = link.urlTree;
      return urlTree ? router.isActive(urlTree, options) : false;
    };
  }
  hasActiveLinks() {
    const isActiveCheckFn = this.isLinkActive(this.router);
    return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);
  }
};
_RouterLinkActive.\u0275fac = function RouterLinkActive_Factory(t3) {
  return new (t3 || _RouterLinkActive)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(RouterLink, 8));
};
_RouterLinkActive.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RouterLinkActive,
  selectors: [["", "routerLinkActive", ""]],
  contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, RouterLink, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.links = _t);
    }
  },
  inputs: {
    routerLinkActiveOptions: "routerLinkActiveOptions",
    ariaCurrentWhenActive: "ariaCurrentWhenActive",
    routerLinkActive: "routerLinkActive"
  },
  outputs: {
    isActiveChange: "isActiveChange"
  },
  exportAs: ["routerLinkActive"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var RouterLinkActive = _RouterLinkActive;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLinkActive, [{
    type: Directive,
    args: [{
      selector: "[routerLinkActive]",
      exportAs: "routerLinkActive",
      standalone: true
    }]
  }], () => [{
    type: Router
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: RouterLink,
    decorators: [{
      type: Optional
    }]
  }], {
    links: [{
      type: ContentChildren,
      args: [RouterLink, {
        descendants: true
      }]
    }],
    routerLinkActiveOptions: [{
      type: Input
    }],
    ariaCurrentWhenActive: [{
      type: Input
    }],
    isActiveChange: [{
      type: Output
    }],
    routerLinkActive: [{
      type: Input
    }]
  });
})();
function isActiveMatchOptions(options) {
  return !!options.paths;
}
var PreloadingStrategy = class {
};
var _PreloadAllModules = class _PreloadAllModules {
  preload(route, fn) {
    return fn().pipe(catchError(() => of(null)));
  }
};
_PreloadAllModules.\u0275fac = function PreloadAllModules_Factory(t3) {
  return new (t3 || _PreloadAllModules)();
};
_PreloadAllModules.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _PreloadAllModules,
  factory: _PreloadAllModules.\u0275fac,
  providedIn: "root"
});
var PreloadAllModules = _PreloadAllModules;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadAllModules, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _NoPreloading = class _NoPreloading {
  preload(route, fn) {
    return of(null);
  }
};
_NoPreloading.\u0275fac = function NoPreloading_Factory(t3) {
  return new (t3 || _NoPreloading)();
};
_NoPreloading.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NoPreloading,
  factory: _NoPreloading.\u0275fac,
  providedIn: "root"
});
var NoPreloading = _NoPreloading;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoPreloading, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _RouterPreloader = class _RouterPreloader {
  constructor(router, compiler, injector, preloadingStrategy, loader) {
    this.router = router;
    this.injector = injector;
    this.preloadingStrategy = preloadingStrategy;
    this.loader = loader;
  }
  setUpPreloading() {
    this.subscription = this.router.events.pipe(filter((e3) => e3 instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {
    });
  }
  preload() {
    return this.processRoutes(this.injector, this.router.config);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  processRoutes(injector, routes2) {
    const res = [];
    for (const route of routes2) {
      if (route.providers && !route._injector) {
        route._injector = createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);
      }
      const injectorForCurrentRoute = route._injector ?? injector;
      const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;
      if (route.loadChildren && !route._loadedRoutes && route.canLoad === void 0 || route.loadComponent && !route._loadedComponent) {
        res.push(this.preloadConfig(injectorForCurrentRoute, route));
      }
      if (route.children || route._loadedRoutes) {
        res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));
      }
    }
    return from(res).pipe(mergeAll());
  }
  preloadConfig(injector, route) {
    return this.preloadingStrategy.preload(route, () => {
      let loadedChildren$;
      if (route.loadChildren && route.canLoad === void 0) {
        loadedChildren$ = this.loader.loadChildren(injector, route);
      } else {
        loadedChildren$ = of(null);
      }
      const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap((config3) => {
        if (config3 === null) {
          return of(void 0);
        }
        route._loadedRoutes = config3.routes;
        route._loadedInjector = config3.injector;
        return this.processRoutes(config3.injector ?? injector, config3.routes);
      }));
      if (route.loadComponent && !route._loadedComponent) {
        const loadComponent$ = this.loader.loadComponent(route);
        return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());
      } else {
        return recursiveLoadChildren$;
      }
    });
  }
};
_RouterPreloader.\u0275fac = function RouterPreloader_Factory(t3) {
  return new (t3 || _RouterPreloader)(\u0275\u0275inject(Router), \u0275\u0275inject(Compiler), \u0275\u0275inject(EnvironmentInjector), \u0275\u0275inject(PreloadingStrategy), \u0275\u0275inject(RouterConfigLoader));
};
_RouterPreloader.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _RouterPreloader,
  factory: _RouterPreloader.\u0275fac,
  providedIn: "root"
});
var RouterPreloader = _RouterPreloader;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterPreloader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Router
  }, {
    type: Compiler
  }, {
    type: EnvironmentInjector
  }, {
    type: PreloadingStrategy
  }, {
    type: RouterConfigLoader
  }], null);
})();
var ROUTER_SCROLLER = new InjectionToken("");
var _RouterScroller = class _RouterScroller {
  /** @nodoc */
  constructor(urlSerializer, transitions, viewportScroller, zone, options = {}) {
    this.urlSerializer = urlSerializer;
    this.transitions = transitions;
    this.viewportScroller = viewportScroller;
    this.zone = zone;
    this.options = options;
    this.lastId = 0;
    this.lastSource = "imperative";
    this.restoredId = 0;
    this.store = {};
    this.environmentInjector = inject(EnvironmentInjector);
    options.scrollPositionRestoration ||= "disabled";
    options.anchorScrolling ||= "disabled";
  }
  init() {
    if (this.options.scrollPositionRestoration !== "disabled") {
      this.viewportScroller.setHistoryScrollRestoration("manual");
    }
    this.routerEventsSubscription = this.createScrollEvents();
    this.scrollEventsSubscription = this.consumeScrollEvents();
  }
  createScrollEvents() {
    return this.transitions.events.subscribe((e3) => {
      if (e3 instanceof NavigationStart) {
        this.store[this.lastId] = this.viewportScroller.getScrollPosition();
        this.lastSource = e3.navigationTrigger;
        this.restoredId = e3.restoredState ? e3.restoredState.navigationId : 0;
      } else if (e3 instanceof NavigationEnd) {
        this.lastId = e3.id;
        this.scheduleScrollEvent(e3, this.urlSerializer.parse(e3.urlAfterRedirects).fragment);
      } else if (e3 instanceof NavigationSkipped && e3.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {
        this.lastSource = void 0;
        this.restoredId = 0;
        this.scheduleScrollEvent(e3, this.urlSerializer.parse(e3.url).fragment);
      }
    });
  }
  consumeScrollEvents() {
    return this.transitions.events.subscribe((e3) => {
      if (!(e3 instanceof Scroll)) return;
      if (e3.position) {
        if (this.options.scrollPositionRestoration === "top") {
          this.viewportScroller.scrollToPosition([0, 0]);
        } else if (this.options.scrollPositionRestoration === "enabled") {
          this.viewportScroller.scrollToPosition(e3.position);
        }
      } else {
        if (e3.anchor && this.options.anchorScrolling === "enabled") {
          this.viewportScroller.scrollToAnchor(e3.anchor);
        } else if (this.options.scrollPositionRestoration !== "disabled") {
          this.viewportScroller.scrollToPosition([0, 0]);
        }
      }
    });
  }
  scheduleScrollEvent(routerEvent, anchor) {
    this.zone.runOutsideAngular(() => __async(this, null, function* () {
      yield new Promise((resolve) => {
        setTimeout(() => {
          resolve();
        });
        afterNextRender(() => {
          resolve();
        }, {
          injector: this.environmentInjector
        });
      });
      this.zone.run(() => {
        this.transitions.events.next(new Scroll(routerEvent, this.lastSource === "popstate" ? this.store[this.restoredId] : null, anchor));
      });
    }));
  }
  /** @nodoc */
  ngOnDestroy() {
    this.routerEventsSubscription?.unsubscribe();
    this.scrollEventsSubscription?.unsubscribe();
  }
};
_RouterScroller.\u0275fac = function RouterScroller_Factory(t3) {
  \u0275\u0275invalidFactory();
};
_RouterScroller.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _RouterScroller,
  factory: _RouterScroller.\u0275fac
});
var RouterScroller = _RouterScroller;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterScroller, [{
    type: Injectable
  }], () => [{
    type: UrlSerializer
  }, {
    type: NavigationTransitions
  }, {
    type: ViewportScroller
  }, {
    type: NgZone
  }, {
    type: void 0
  }], null);
})();
function provideRouter(routes2, ...features) {
  return makeEnvironmentProviders([{
    provide: ROUTES,
    multi: true,
    useValue: routes2
  }, typeof ngDevMode === "undefined" || ngDevMode ? {
    provide: ROUTER_IS_PROVIDED,
    useValue: true
  } : [], {
    provide: ActivatedRoute,
    useFactory: rootRoute,
    deps: [Router]
  }, {
    provide: APP_BOOTSTRAP_LISTENER,
    multi: true,
    useFactory: getBootstrapListener
  }, features.map((feature) => feature.\u0275providers)]);
}
function rootRoute(router) {
  return router.routerState.root;
}
function routerFeature(kind, providers) {
  return {
    \u0275kind: kind,
    \u0275providers: providers
  };
}
var ROUTER_IS_PROVIDED = new InjectionToken("", {
  providedIn: "root",
  factory: () => false
});
function getBootstrapListener() {
  const injector = inject(Injector);
  return (bootstrappedComponentRef) => {
    const ref = injector.get(ApplicationRef);
    if (bootstrappedComponentRef !== ref.components[0]) {
      return;
    }
    const router = injector.get(Router);
    const bootstrapDone = injector.get(BOOTSTRAP_DONE);
    if (injector.get(INITIAL_NAVIGATION) === 1) {
      router.initialNavigation();
    }
    injector.get(ROUTER_PRELOADER, null, InjectFlags.Optional)?.setUpPreloading();
    injector.get(ROUTER_SCROLLER, null, InjectFlags.Optional)?.init();
    router.resetRootComponentType(ref.componentTypes[0]);
    if (!bootstrapDone.closed) {
      bootstrapDone.next();
      bootstrapDone.complete();
      bootstrapDone.unsubscribe();
    }
  };
}
var BOOTSTRAP_DONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "bootstrap done indicator" : "", {
  factory: () => {
    return new Subject();
  }
});
var INITIAL_NAVIGATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "initial navigation" : "", {
  providedIn: "root",
  factory: () => 1
  /* InitialNavigation.EnabledNonBlocking */
});
function withEnabledBlockingInitialNavigation() {
  const providers = [{
    provide: INITIAL_NAVIGATION,
    useValue: 0
    /* InitialNavigation.EnabledBlocking */
  }, {
    provide: APP_INITIALIZER,
    multi: true,
    deps: [Injector],
    useFactory: (injector) => {
      const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());
      return () => {
        return locationInitialized.then(() => {
          return new Promise((resolve) => {
            const router = injector.get(Router);
            const bootstrapDone = injector.get(BOOTSTRAP_DONE);
            afterNextNavigation(router, () => {
              resolve(true);
            });
            injector.get(NavigationTransitions).afterPreactivation = () => {
              resolve(true);
              return bootstrapDone.closed ? of(void 0) : bootstrapDone;
            };
            router.initialNavigation();
          });
        });
      };
    }
  }];
  return routerFeature(2, providers);
}
function withDisabledInitialNavigation() {
  const providers = [{
    provide: APP_INITIALIZER,
    multi: true,
    useFactory: () => {
      const router = inject(Router);
      return () => {
        router.setUpLocationChangeListener();
      };
    }
  }, {
    provide: INITIAL_NAVIGATION,
    useValue: 2
    /* InitialNavigation.Disabled */
  }];
  return routerFeature(3, providers);
}
function withDebugTracing() {
  let providers = [];
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    providers = [{
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const router = inject(Router);
        return () => router.events.subscribe((e3) => {
          console.group?.(`Router Event: ${e3.constructor.name}`);
          console.log(stringifyEvent(e3));
          console.log(e3);
          console.groupEnd?.();
        });
      }
    }];
  } else {
    providers = [];
  }
  return routerFeature(1, providers);
}
var ROUTER_PRELOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router preloader" : "");
function withPreloading(preloadingStrategy) {
  const providers = [{
    provide: ROUTER_PRELOADER,
    useExisting: RouterPreloader
  }, {
    provide: PreloadingStrategy,
    useExisting: preloadingStrategy
  }];
  return routerFeature(0, providers);
}
function withComponentInputBinding() {
  const providers = [RoutedComponentInputBinder, {
    provide: INPUT_BINDER,
    useExisting: RoutedComponentInputBinder
  }];
  return routerFeature(8, providers);
}
function withViewTransitions(options) {
  const providers = [{
    provide: CREATE_VIEW_TRANSITION,
    useValue: createViewTransition
  }, {
    provide: VIEW_TRANSITION_OPTIONS,
    useValue: __spreadValues({
      skipNextTransition: !!options?.skipInitialTransition
    }, options)
  }];
  return routerFeature(9, providers);
}
var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent];
var ROUTER_FORROOT_GUARD = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router duplicate forRoot guard" : "ROUTER_FORROOT_GUARD");
var ROUTER_PROVIDERS = [
  Location,
  {
    provide: UrlSerializer,
    useClass: DefaultUrlSerializer
  },
  Router,
  ChildrenOutletContexts,
  {
    provide: ActivatedRoute,
    useFactory: rootRoute,
    deps: [Router]
  },
  RouterConfigLoader,
  // Only used to warn when `provideRoutes` is used without `RouterModule` or `provideRouter`. Can
  // be removed when `provideRoutes` is removed.
  typeof ngDevMode === "undefined" || ngDevMode ? {
    provide: ROUTER_IS_PROVIDED,
    useValue: true
  } : []
];
var _RouterModule = class _RouterModule {
  constructor(guard) {
  }
  /**
   * Creates and configures a module with all the router providers and directives.
   * Optionally sets up an application listener to perform an initial navigation.
   *
   * When registering the NgModule at the root, import as follows:
   *
   * ```
   * @NgModule({
   *   imports: [RouterModule.forRoot(ROUTES)]
   * })
   * class MyNgModule {}
   * ```
   *
   * @param routes An array of `Route` objects that define the navigation paths for the application.
   * @param config An `ExtraOptions` configuration object that controls how navigation is performed.
   * @return The new `NgModule`.
   *
   */
  static forRoot(routes2, config3) {
    return {
      ngModule: _RouterModule,
      providers: [ROUTER_PROVIDERS, typeof ngDevMode === "undefined" || ngDevMode ? config3?.enableTracing ? withDebugTracing().\u0275providers : [] : [], {
        provide: ROUTES,
        multi: true,
        useValue: routes2
      }, {
        provide: ROUTER_FORROOT_GUARD,
        useFactory: provideForRootGuard,
        deps: [[Router, new Optional(), new SkipSelf()]]
      }, {
        provide: ROUTER_CONFIGURATION,
        useValue: config3 ? config3 : {}
      }, config3?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config3?.preloadingStrategy ? withPreloading(config3.preloadingStrategy).\u0275providers : [], config3?.initialNavigation ? provideInitialNavigation(config3) : [], config3?.bindToComponentInputs ? withComponentInputBinding().\u0275providers : [], config3?.enableViewTransitions ? withViewTransitions().\u0275providers : [], provideRouterInitializer()]
    };
  }
  /**
   * Creates a module with all the router directives and a provider registering routes,
   * without creating a new Router service.
   * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:
   *
   * ```
   * @NgModule({
   *   imports: [RouterModule.forChild(ROUTES)]
   * })
   * class MyNgModule {}
   * ```
   *
   * @param routes An array of `Route` objects that define the navigation paths for the submodule.
   * @return The new NgModule.
   *
   */
  static forChild(routes2) {
    return {
      ngModule: _RouterModule,
      providers: [{
        provide: ROUTES,
        multi: true,
        useValue: routes2
      }]
    };
  }
};
_RouterModule.\u0275fac = function RouterModule_Factory(t3) {
  return new (t3 || _RouterModule)(\u0275\u0275inject(ROUTER_FORROOT_GUARD, 8));
};
_RouterModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _RouterModule
});
_RouterModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var RouterModule = _RouterModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterModule, [{
    type: NgModule,
    args: [{
      imports: ROUTER_DIRECTIVES,
      exports: ROUTER_DIRECTIVES
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ROUTER_FORROOT_GUARD]
    }]
  }], null);
})();
function provideRouterScroller() {
  return {
    provide: ROUTER_SCROLLER,
    useFactory: () => {
      const viewportScroller = inject(ViewportScroller);
      const zone = inject(NgZone);
      const config3 = inject(ROUTER_CONFIGURATION);
      const transitions = inject(NavigationTransitions);
      const urlSerializer = inject(UrlSerializer);
      if (config3.scrollOffset) {
        viewportScroller.setOffset(config3.scrollOffset);
      }
      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config3);
    }
  };
}
function provideHashLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: HashLocationStrategy
  };
}
function providePathLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: PathLocationStrategy
  };
}
function provideForRootGuard(router) {
  if ((typeof ngDevMode === "undefined" || ngDevMode) && router) {
    throw new RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.`);
  }
  return "guarded";
}
function provideInitialNavigation(config3) {
  return [config3.initialNavigation === "disabled" ? withDisabledInitialNavigation().\u0275providers : [], config3.initialNavigation === "enabledBlocking" ? withEnabledBlockingInitialNavigation().\u0275providers : []];
}
var ROUTER_INITIALIZER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Router Initializer" : "");
function provideRouterInitializer() {
  return [
    // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just
    // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.
    {
      provide: ROUTER_INITIALIZER,
      useFactory: getBootstrapListener
    },
    {
      provide: APP_BOOTSTRAP_LISTENER,
      multi: true,
      useExisting: ROUTER_INITIALIZER
    }
  ];
}
var VERSION4 = new Version("18.0.1");

// src/app/navbar/navbar.component.ts
var _NavbarComponent = class _NavbarComponent {
};
_NavbarComponent.\u0275fac = function NavbarComponent_Factory(t3) {
  return new (t3 || _NavbarComponent)();
};
_NavbarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NavbarComponent, selectors: [["app-navbar"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 25, vars: 0, consts: [["data-bs-theme", "dark", 1, "navbar", "navbar-expand-lg", "bg-dark"], [1, "container-fluid"], ["href", "#", 1, "navbar-brand"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#navbarColor02", "aria-controls", "navbarColor02", "aria-expanded", "false", "aria-label", "Toggle navigation", 1, "navbar-toggler"], [1, "navbar-toggler-icon"], ["id", "navbarColor02", 1, "collapse", "navbar-collapse"], [1, "navbar-nav", "me-auto"], [1, "nav-item"], ["routerLink", "/home", "routerLinkActive", "active", 1, "nav-link", "active"], [1, "visually-hidden"], ["routerLink", "/lista", "routerLinkActive", "active", 1, "nav-link"], ["routerLink", "/ubicacion", "routerLinkActive", "active", 1, "nav-link"], ["routerLink", "/calendario", "routerLinkActive", "active", 1, "nav-link"], ["routerLink", "/datos", "routerLinkActive", "active", 1, "nav-link"]], template: function NavbarComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nav", 0)(1, "div", 1)(2, "a", 2);
    \u0275\u0275text(3, "ScapeRoom");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 3);
    \u0275\u0275element(5, "span", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 5)(7, "ul", 6)(8, "li", 7)(9, "a", 8);
    \u0275\u0275text(10, "Home ");
    \u0275\u0275elementStart(11, "span", 9);
    \u0275\u0275text(12, "(current)");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(13, "li", 7)(14, "a", 10);
    \u0275\u0275text(15, "Lista");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(16, "li", 7)(17, "a", 11);
    \u0275\u0275text(18, "Ubicaci\xF3n");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(19, "li", 7)(20, "a", 12);
    \u0275\u0275text(21, "Calendario");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "li", 7)(23, "a", 13);
    \u0275\u0275text(24, "Datos");
    \u0275\u0275elementEnd()()()()()();
  }
}, dependencies: [RouterModule, RouterLink, RouterLinkActive] });
var NavbarComponent = _NavbarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NavbarComponent, { className: "NavbarComponent", filePath: "src\\app\\navbar\\navbar.component.ts", lineNumber: 11 });
})();

// src/app/home/home.component.ts
var _HomeComponent = class _HomeComponent {
};
_HomeComponent.\u0275fac = function HomeComponent_Factory(t3) {
  return new (t3 || _HomeComponent)();
};
_HomeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _HomeComponent, selectors: [["app-home"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 0, consts: [["src", "assets/cutecat.jpg", "alt", "Cute Cat", 1, "responsive-img"]], template: function HomeComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 0);
  }
}, styles: ["\n\n.responsive-img[_ngcontent-%COMP%] {\n  width: 100%;\n  height: auto;\n  max-width: 100%;\n}\n/*# sourceMappingURL=home.component.css.map */"] });
var HomeComponent = _HomeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(HomeComponent, { className: "HomeComponent", filePath: "src\\app\\home\\home.component.ts", lineNumber: 10 });
})();

// node_modules/@angular/forms/fesm2022/forms.mjs
var _BaseControlValueAccessor = class _BaseControlValueAccessor {
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
    this.onChange = (_3) => {
    };
    this.onTouched = () => {
    };
  }
  /**
   * Helper method that sets a property on a target element using the current Renderer
   * implementation.
   * @nodoc
   */
  setProperty(key, value) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
  }
  /**
   * Registers a function called when the control is touched.
   * @nodoc
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * Sets the "disabled" property on the range input element.
   * @nodoc
   */
  setDisabledState(isDisabled) {
    this.setProperty("disabled", isDisabled);
  }
};
_BaseControlValueAccessor.\u0275fac = function BaseControlValueAccessor_Factory(t3) {
  return new (t3 || _BaseControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
};
_BaseControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _BaseControlValueAccessor
});
var BaseControlValueAccessor = _BaseControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
var _BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
};
_BuiltInControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BuiltInControlValueAccessor_BaseFactory;
  return function BuiltInControlValueAccessor_Factory(t3) {
    return (\u0275BuiltInControlValueAccessor_BaseFactory || (\u0275BuiltInControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_BuiltInControlValueAccessor)))(t3 || _BuiltInControlValueAccessor);
  };
})();
_BuiltInControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _BuiltInControlValueAccessor,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var BuiltInControlValueAccessor = _BuiltInControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
    type: Directive
  }], null, null);
})();
var NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? "NgValueAccessor" : "");
var CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CheckboxControlValueAccessor),
  multi: true
};
var _CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "checked" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("checked", value);
  }
};
_CheckboxControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275CheckboxControlValueAccessor_BaseFactory;
  return function CheckboxControlValueAccessor_Factory(t3) {
    return (\u0275CheckboxControlValueAccessor_BaseFactory || (\u0275CheckboxControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxControlValueAccessor)))(t3 || _CheckboxControlValueAccessor);
  };
})();
_CheckboxControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CheckboxControlValueAccessor,
  selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
  hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.checked);
      })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var CheckboxControlValueAccessor = _CheckboxControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
      host: {
        "(change)": "onChange($event.target.checked)",
        "(blur)": "onTouched()"
      },
      providers: [CHECKBOX_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? "CompositionEventMode" : "");
var _DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    this._composing = false;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /** @internal */
  _handleInput(value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value);
    }
  }
  /** @internal */
  _compositionStart() {
    this._composing = true;
  }
  /** @internal */
  _compositionEnd(value) {
    this._composing = false;
    this._compositionMode && this.onChange(value);
  }
};
_DefaultValueAccessor.\u0275fac = function DefaultValueAccessor_Factory(t3) {
  return new (t3 || _DefaultValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(COMPOSITION_BUFFER_MODE, 8));
};
_DefaultValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _DefaultValueAccessor,
  selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
  hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
        return ctx._handleInput($event.target.value);
      })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
        return ctx._compositionStart();
      })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
        return ctx._compositionEnd($event.target.value);
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([DEFAULT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var DefaultValueAccessor = _DefaultValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
      // TODO: vsavkin replace the above selector with the one below it once
      // https://github.com/angular/angular/issues/3011 is implemented
      // selector: '[ngModel],[formControl],[formControlName]',
      host: {
        "(input)": "$any(this)._handleInput($event.target.value)",
        "(blur)": "onTouched()",
        "(compositionstart)": "$any(this)._compositionStart()",
        "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
      },
      providers: [DEFAULT_VALUE_ACCESSOR]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value) {
  return value == null || (typeof value === "string" || Array.isArray(value)) && value.length === 0;
}
function hasValidLength(value) {
  return value != null && typeof value.length === "number";
}
var NG_VALIDATORS = new InjectionToken(ngDevMode ? "NgValidators" : "");
var NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? "NgAsyncValidators" : "");
var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var Validators = class {
  /**
   * @description
   * Validator that requires the control's value to be greater than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a minimum of 3
   *
   * ```typescript
   * const control = new FormControl(2, Validators.min(3));
   *
   * console.log(control.errors); // {min: {min: 3, actual: 2}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `min` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static min(min) {
    return minValidator(min);
  }
  /**
   * @description
   * Validator that requires the control's value to be less than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a maximum of 15
   *
   * ```typescript
   * const control = new FormControl(16, Validators.max(15));
   *
   * console.log(control.errors); // {max: {max: 15, actual: 16}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `max` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static max(max) {
    return maxValidator(max);
  }
  /**
   * @description
   * Validator that requires the control have a non-empty value.
   *
   * @usageNotes
   *
   * ### Validate that the field is non-empty
   *
   * ```typescript
   * const control = new FormControl('', Validators.required);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map with the `required` property
   * if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static required(control) {
    return requiredValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value be true. This validator is commonly
   * used for required checkboxes.
   *
   * @usageNotes
   *
   * ### Validate that the field value is true
   *
   * ```typescript
   * const control = new FormControl('some value', Validators.requiredTrue);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map that contains the `required` property
   * set to `true` if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static requiredTrue(control) {
    return requiredTrueValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value pass an email validation test.
   *
   * Tests the value using a [regular
   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
   * pattern suitable for common use cases. The pattern is based on the definition of a valid email
   * address in the [WHATWG HTML
   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
   * lengths of different parts of the address).
   *
   * The differences from the WHATWG version include:
   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).
   * - Disallow `local-part` to be longer than 64 characters.
   * - Disallow the whole address to be longer than 254 characters.
   *
   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to
   * validate the value against a different pattern.
   *
   * @usageNotes
   *
   * ### Validate that the field matches a valid email pattern
   *
   * ```typescript
   * const control = new FormControl('bad@', Validators.email);
   *
   * console.log(control.errors); // {email: true}
   * ```
   *
   * @returns An error map with the `email` property
   * if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static email(control) {
    return emailValidator(control);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be greater than or equal
   * to the provided minimum length. This validator is also provided by default if you use the
   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays. The
   * `minLength` validator logic is also not invoked for values when their `length` property is 0
   * (for example in case of an empty string or an empty array), to support optional controls. You
   * can use the standard `required` validator if empty values should not be considered valid.
   *
   * @usageNotes
   *
   * ### Validate that the field has a minimum of 3 characters
   *
   * ```typescript
   * const control = new FormControl('ng', Validators.minLength(3));
   *
   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
   * ```
   *
   * ```html
   * <input minlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `minlength` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static minLength(minLength) {
    return minLengthValidator(minLength);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be less than or equal
   * to the provided maximum length. This validator is also provided by default if you use the
   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays.
   *
   * @usageNotes
   *
   * ### Validate that the field has maximum of 5 characters
   *
   * ```typescript
   * const control = new FormControl('Angular', Validators.maxLength(5));
   *
   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
   * ```
   *
   * ```html
   * <input maxlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `maxlength` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static maxLength(maxLength) {
    return maxLengthValidator(maxLength);
  }
  /**
   * @description
   * Validator that requires the control's value to match a regex pattern. This validator is also
   * provided by default if you use the HTML5 `pattern` attribute.
   *
   * @usageNotes
   *
   * ### Validate that the field only contains letters or spaces
   *
   * ```typescript
   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
   *
   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
   * ```
   *
   * ```html
   * <input pattern="[a-zA-Z ]*">
   * ```
   *
   * ### Pattern matching with the global or sticky flag
   *
   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`
   * can produce different results on the same input when validations are run consecutively. This is
   * due to how the behavior of `RegExp.prototype.test` is
   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)
   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).
   * Due to this behavior, it is recommended that when using
   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky
   * flag enabled.
   *
   * ```typescript
   * // Not recommended (since the `g` flag is used)
   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));
   *
   * // Good
   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));
   * ```
   *
   * @param pattern A regular expression to be used as is to test the values, or a string.
   * If a string is passed, the `^` character is prepended and the `$` character is
   * appended to the provided string (if not already present), and the resulting regular
   * expression is used to test the values.
   *
   * @returns A validator function that returns an error map with the
   * `pattern` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static pattern(pattern) {
    return patternValidator(pattern);
  }
  /**
   * @description
   * Validator that performs no operation.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static nullValidator(control) {
    return nullValidator(control);
  }
  static compose(validators) {
    return compose(validators);
  }
  /**
   * @description
   * Compose multiple async validators into a single function that returns the union
   * of the individual error objects for the provided control.
   *
   * @returns A validator function that returns an error map with the
   * merged error objects of the async validators if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static composeAsync(validators) {
    return composeAsync(validators);
  }
};
function minValidator(min) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      "min": {
        "min": min,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      "max": {
        "max": max,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
      return null;
    }
    return control.value.length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    return hasValidLength(control.value) && control.value.length > maxLength ? {
      "maxlength": {
        "requiredLength": maxLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^") regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$") regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o2) {
  return o2 != null;
}
function toObservable(value) {
  const obs = isPromise2(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c3) => validator.validate(c3);
  });
}
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v3) => {
    if (!hasValidator(current, v3)) {
      current.push(v3);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v3) => !hasValidator(validators, v3));
}
var AbstractControlDirective = class {
  constructor() {
    this._rawValidators = [];
    this._rawAsyncValidators = [];
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Reports the value of the control if it is present, otherwise null.
   */
  get value() {
    return this.control ? this.control.value : null;
  }
  /**
   * @description
   * Reports whether the control is valid. A control is considered valid if no
   * validation errors exist with the current value.
   * If the control is not present, null is returned.
   */
  get valid() {
    return this.control ? this.control.valid : null;
  }
  /**
   * @description
   * Reports whether the control is invalid, meaning that an error exists in the input value.
   * If the control is not present, null is returned.
   */
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  /**
   * @description
   * Reports whether a control is pending, meaning that async validation is occurring and
   * errors are not yet available for the input value. If the control is not present, null is
   * returned.
   */
  get pending() {
    return this.control ? this.control.pending : null;
  }
  /**
   * @description
   * Reports whether the control is disabled, meaning that the control is disabled
   * in the UI and is exempt from validation checks and excluded from aggregate
   * values of ancestor controls. If the control is not present, null is returned.
   */
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  /**
   * @description
   * Reports whether the control is enabled, meaning that the control is included in ancestor
   * calculations of validity or value. If the control is not present, null is returned.
   */
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  /**
   * @description
   * Reports the control's validation errors. If the control is not present, null is returned.
   */
  get errors() {
    return this.control ? this.control.errors : null;
  }
  /**
   * @description
   * Reports whether the control is pristine, meaning that the user has not yet changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  /**
   * @description
   * Reports whether the control is dirty, meaning that the user has changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  /**
   * @description
   * Reports whether the control is touched, meaning that the user has triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get touched() {
    return this.control ? this.control.touched : null;
  }
  /**
   * @description
   * Reports the validation status of the control. Possible values include:
   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
   * If the control is not present, null is returned.
   */
  get status() {
    return this.control ? this.control.status : null;
  }
  /**
   * @description
   * Reports whether the control is untouched, meaning that the user has not yet triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  /**
   * @description
   * Returns a multicasting observable that emits a validation status whenever it is
   * calculated for the control. If the control is not present, null is returned.
   */
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  /**
   * @description
   * Returns a multicasting observable of value changes for the control that emits every time the
   * value of the control changes in the UI or programmatically.
   * If the control is not present, null is returned.
   */
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return null;
  }
  /**
   * Sets synchronous validators for this directive.
   * @internal
   */
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  /**
   * Sets asynchronous validators for this directive.
   * @internal
   */
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  /**
   * @description
   * Synchronous validator function composed of all the synchronous validators registered with this
   * directive.
   */
  get validator() {
    return this._composedValidatorFn || null;
  }
  /**
   * @description
   * Asynchronous validator function composed of all the asynchronous validators registered with
   * this directive.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  /**
   * Internal function to register callbacks that should be invoked
   * when directive instance is being destroyed.
   * @internal
   */
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  /**
   * Internal function to invoke all registered "on destroy" callbacks.
   * Note: calling this function also clears the list of callbacks.
   * @internal
   */
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach((fn) => fn());
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Resets the control with the provided value if the control is present.
   */
  reset(value = void 0) {
    if (this.control) this.control.reset(value);
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return this.control ? this.control.hasError(errorCode, path) : false;
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    return this.control ? this.control.getError(errorCode, path) : null;
  }
};
var ControlContainer = class extends AbstractControlDirective {
  /**
   * @description
   * The top-level form directive for the control.
   */
  get formDirective() {
    return null;
  }
  /**
   * @description
   * The path to this group.
   */
  get path() {
    return null;
  }
};
var NgControl = class extends AbstractControlDirective {
  constructor() {
    super(...arguments);
    this._parent = null;
    this.name = null;
    this.valueAccessor = null;
  }
};
var AbstractControlStatus = class {
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    return !!this._cd?.submitted;
  }
};
var ngControlStatusHost = {
  "[class.ng-untouched]": "isUntouched",
  "[class.ng-touched]": "isTouched",
  "[class.ng-pristine]": "isPristine",
  "[class.ng-dirty]": "isDirty",
  "[class.ng-valid]": "isValid",
  "[class.ng-invalid]": "isInvalid",
  "[class.ng-pending]": "isPending"
};
var ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
  "[class.ng-submitted]": "isSubmitted"
});
var _NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
};
_NgControlStatus.\u0275fac = function NgControlStatus_Factory(t3) {
  return new (t3 || _NgControlStatus)(\u0275\u0275directiveInject(NgControl, 2));
};
_NgControlStatus.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgControlStatus,
  selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
  hostVars: 14,
  hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NgControlStatus = _NgControlStatus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
    type: Directive,
    args: [{
      selector: "[formControlName],[ngModel],[formControl]",
      host: ngControlStatusHost
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Self
    }]
  }], null);
})();
var _NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
};
_NgControlStatusGroup.\u0275fac = function NgControlStatusGroup_Factory(t3) {
  return new (t3 || _NgControlStatusGroup)(\u0275\u0275directiveInject(ControlContainer, 10));
};
_NgControlStatusGroup.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgControlStatusGroup,
  selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
  hostVars: 16,
  hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NgControlStatusGroup = _NgControlStatusGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
    type: Directive,
    args: [{
      selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
      host: ngGroupStatusHost
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
var formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
var formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
var ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
var ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException(nameOrIndex) {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive. You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      ${describeFormControl(nameOrIndex)}

    Example:

    ${formControlNameExample}`);
}
function describeFormControl(nameOrIndex) {
  if (nameOrIndex == null || nameOrIndex === "") {
    return "";
  }
  const valueType = typeof nameOrIndex === "string" ? "name" : "index";
  return `Affected Form Control ${valueType}: "${nameOrIndex}"`;
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
var disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
var asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
var VALID = "VALID";
var INVALID = "INVALID";
var PENDING = "PENDING";
var DISABLED = "DISABLED";
var ControlEvent = class {
};
var ValueChangeEvent = class extends ControlEvent {
  constructor(value, source) {
    super();
    this.value = value;
    this.source = source;
  }
};
var PristineChangeEvent = class extends ControlEvent {
  constructor(pristine, source) {
    super();
    this.pristine = pristine;
    this.source = source;
  }
};
var TouchedChangeEvent = class extends ControlEvent {
  constructor(touched, source) {
    super();
    this.touched = touched;
    this.source = source;
  }
};
var StatusChangeEvent = class extends ControlEvent {
  constructor(status, source) {
    super();
    this.status = status;
    this.source = source;
  }
};
var FormSubmittedEvent = class extends ControlEvent {
  constructor(source) {
    super();
    this.source = source;
  }
};
var FormResetEvent = class extends ControlEvent {
  constructor(source) {
    super();
    this.source = source;
  }
};
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent2, isGroup, key) {
  const controls = parent2.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_3, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
var AbstractControl = class {
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    this._pendingDirty = false;
    this._hasOwnPendingAsyncValidator = null;
    this._pendingTouched = false;
    this._onCollectionChange = () => {
    };
    this._parent = null;
    this.pristine = true;
    this.touched = false;
    this._events = new Subject();
    this.events = this._events.asObservable();
    this._onDisabledChange = [];
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._assignValidators(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<string | null>('', Validators.required);
   * ctrl.removeValidators(Validators.required);
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<string | null>('', minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   *
   * ctrl.removeValidators(minValidator);
   * ```
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<number | null>(0, Validators.required);
   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<number | null>(0, minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   * ```
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  markAsTouched(opts = {}) {
    const changed = this.touched === false;
    this.touched = true;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(true, sourceControl));
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see {@link markAsTouched()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `emitEvent`: When true or not supplied (the default), the `events`
   * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.
   * When false, no events are emitted.
   */
  markAllAsTouched(opts = {}) {
    this.markAsTouched({
      onlySelf: true,
      emitEvent: opts.emitEvent,
      sourceControl: this
    });
    this._forEachChild((control) => control.markAllAsTouched(opts));
  }
  markAsUntouched(opts = {}) {
    const changed = this.touched === true;
    this.touched = false;
    this._pendingTouched = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsUntouched({
        onlySelf: true,
        emitEvent: opts.emitEvent,
        sourceControl
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(false, sourceControl));
    }
  }
  markAsDirty(opts = {}) {
    const changed = this.pristine === true;
    this.pristine = false;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(false, sourceControl));
    }
  }
  markAsPristine(opts = {}) {
    const changed = this.pristine === false;
    this.pristine = true;
    this._pendingDirty = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsPristine({
        onlySelf: true,
        emitEvent: opts.emitEvent
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(true, sourceControl));
    }
  }
  markAsPending(opts = {}) {
    this.status = PENDING;
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild((control) => {
      control.disable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,
   * `valueChanges` and `events`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild((control) => {
      control.enable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(false));
  }
  _updateAncestors(opts, sourceControl) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine({}, sourceControl);
      }
      this._parent._updateTouched({}, sourceControl);
    }
  }
  /**
   * Sets the parent of the control
   *
   * @param parent The new parent.
   */
  setParent(parent2) {
    this._parent = parent2;
  }
  /**
   * The raw value of this control. For most control implementations, the raw value will include
   * disabled children.
   */
  getRawValue() {
    return this.value;
  }
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      const shouldHaveEmitted = this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);
      }
    }
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(shouldHaveEmitted, emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = {
        emitEvent: emitEvent !== false
      };
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe((errors) => {
        this._hasOwnPendingAsyncValidator = null;
        this.setErrors(errors, {
          emitEvent,
          shouldHaveEmitted
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      const shouldHaveEmitted = this._hasOwnPendingAsyncValidator?.emitEvent ?? false;
      this._hasOwnPendingAsyncValidator = null;
      return shouldHaveEmitted;
    }
    return false;
  }
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control. If a string is provided, passing it as a string literal will result in improved type
   * information. Likewise, if an array is provided, passing it `as const` will cause improved type
   * information to be available.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path) {
    let currPath = path;
    if (currPath == null) return null;
    if (!Array.isArray(currPath)) currPath = currPath.split(".");
    if (currPath.length === 0) return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x4 = this;
    while (x4._parent) {
      x4 = x4._parent;
    }
    return x4;
  }
  /** @internal */
  _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (emitEvent || shouldHaveEmitted) {
      this._events.next(new StatusChangeEvent(this.status, changedControl));
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new EventEmitter();
    this.statusChanges = new EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls((control) => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls((control) => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls((control) => control.touched);
  }
  /** @internal */
  _updatePristine(opts, changedControl) {
    const newPristine = !this._anyControlsDirty();
    const changed = this.pristine !== newPristine;
    this.pristine = newPristine;
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, changedControl);
    }
    if (changed) {
      this._events.next(new PristineChangeEvent(this.pristine, changedControl));
    }
  }
  /** @internal */
  _updateTouched(opts = {}, changedControl) {
    this.touched = this._anyControlsTouched();
    this._events.next(new TouchedChangeEvent(this.touched, changedControl));
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, changedControl);
    }
  }
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  /** @internal */
  _find(name) {
    return null;
  }
  /**
   * Internal implementation of the `setValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  /**
   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
};
var FormGroup = class extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  registerControl(name, control) {
    if (this.controls[name]) return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group. In a strongly-typed group, required controls cannot be
   * removed.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    if (control) this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, true, value);
    Object.keys(value).forEach((name) => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null) return;
    Object.keys(value).forEach((name) => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(
          /* Guaranteed to be present, due to the outer forEach. */
          value[name],
          {
            onlySelf: true,
            emitEvent: options.emitEvent
          }
        );
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to their default values, or null if no defaults were provided.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value ? value[name] : null, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach((key) => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc2, control, name) => {
      if (control.enabled || this.disabled) {
        acc2[name] = control.value;
      }
      return acc2;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
};
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
var FormRecord = class extends FormGroup {
};
var CALL_SET_DISABLED_STATE = new InjectionToken("CallSetDisabledState", {
  providedIn: "root",
  factory: () => setDisabledStateDefault
});
var setDisabledStateDefault = "always";
function controlPath(name, parent2) {
  return [...parent2.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control) _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop4 = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop4);
    dir.valueAccessor.registerOnTouched(noop4);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop4 = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop4);
  registerOnValidatorChange(dir._rawAsyncValidators, noop4);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change") updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== "submit") control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1) return `path: '${path.join(" -> ")}'`;
  if (path?.[0]) return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model")) return false;
  const change = changes["model"];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode)) _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v3) => {
    if (v3.constructor === DefaultValueAccessor) {
      defaultAccessor = v3;
    } else if (isBuiltInAccessor(v3)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v3;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v3;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el) {
  const index3 = list.indexOf(el);
  if (index3 > -1) list.splice(index3, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never") return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
var formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgForm)
};
var resolvedPromise$1 = (() => Promise.resolve())();
var _NgForm = class _NgForm extends ControlContainer {
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.submitted = false;
    this._directives = /* @__PURE__ */ new Set();
    this.ngSubmit = new EventEmitter();
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  /** @nodoc */
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  /**
   * @description
   * The directive instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * The internal `FormGroup` instance.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it is always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Returns a map of the controls in this group.
   */
  get controls() {
    return this.form.controls;
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `NgModel` directive instance.
   */
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `NgModel` directive.
   *
   * @param dir The `NgModel` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `NgModel` instance from the internal list of directives
   *
   * @param dir The `NgModel` directive instance.
   */
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  /**
   * @description
   * Adds a new `NgModelGroup` directive instance to the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group = new FormGroup({});
      setUpFormContainer(group, dir);
      container.registerControl(dir.name, group);
      group.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  /**
   * @description
   * Removes the `NgModelGroup` directive instance from the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `NgControl` directive.
   *
   * @param dir The `NgControl` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    });
  }
  /**
   * @description
   * Sets the value for this `FormGroup`.
   *
   * @param value The new value
   */
  setValue(value) {
    this.control.setValue(value);
  }
  /**
   * @description
   * Method called when the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submitted = true;
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submitted = false;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path) {
    path.pop();
    return path.length ? this.form.get(path) : this.form;
  }
};
_NgForm.\u0275fac = function NgForm_Factory(t3) {
  return new (t3 || _NgForm)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_NgForm.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgForm,
  selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
  hostBindings: function NgForm_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("submit", function NgForm_submit_HostBindingHandler($event) {
        return ctx.onSubmit($event);
      })("reset", function NgForm_reset_HostBindingHandler() {
        return ctx.onReset();
      });
    }
  },
  inputs: {
    options: [0, "ngFormOptions", "options"]
  },
  outputs: {
    ngSubmit: "ngSubmit"
  },
  exportAs: ["ngForm"],
  features: [\u0275\u0275ProvidersFeature([formDirectiveProvider$1]), \u0275\u0275InheritDefinitionFeature]
});
var NgForm = _NgForm;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
      providers: [formDirectiveProvider$1],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      outputs: ["ngSubmit"],
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: Input,
      args: ["ngFormOptions"]
    }]
  });
})();
function removeListItem(list, el) {
  const index3 = list.indexOf(el);
  if (index3 > -1) list.splice(index3, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
var FormControl = class FormControl2 extends AbstractControl {
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.defaultValue = null;
    this._onChange = [];
    this._pendingChange = false;
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set
      // `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**  @internal */
  _updateValue() {
  }
  /**  @internal */
  _anyControls(condition) {
    return false;
  }
  /**  @internal */
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /** @internal */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /** @internal */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /** @internal */
  _forEachChild(cb) {
  }
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === "submit") {
      if (this._pendingDirty) this.markAsDirty();
      if (this._pendingTouched) this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
var isFormControl = (control) => control instanceof FormControl;
var _AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
  /** @nodoc */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  /**
   * @description
   * The `FormGroup` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  /**
   * @description
   * The path to this group from the top-level directive.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /** @internal */
  _checkParentType() {
  }
};
_AbstractFormGroupDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275AbstractFormGroupDirective_BaseFactory;
  return function AbstractFormGroupDirective_Factory(t3) {
    return (\u0275AbstractFormGroupDirective_BaseFactory || (\u0275AbstractFormGroupDirective_BaseFactory = \u0275\u0275getInheritedFactory(_AbstractFormGroupDirective)))(t3 || _AbstractFormGroupDirective);
  };
})();
_AbstractFormGroupDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AbstractFormGroupDirective,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var AbstractFormGroupDirective = _AbstractFormGroupDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
    type: Directive
  }], null, null);
})();
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
var modelGroupProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgModelGroup)
};
var _NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
  constructor(parent2, validators, asyncValidators) {
    super();
    this.name = "";
    this._parent = parent2;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
};
_NgModelGroup.\u0275fac = function NgModelGroup_Factory(t3) {
  return new (t3 || _NgModelGroup)(\u0275\u0275directiveInject(ControlContainer, 5), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
};
_NgModelGroup.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgModelGroup,
  selectors: [["", "ngModelGroup", ""]],
  inputs: {
    name: [0, "ngModelGroup", "name"]
  },
  exportAs: ["ngModelGroup"],
  features: [\u0275\u0275ProvidersFeature([modelGroupProvider]), \u0275\u0275InheritDefinitionFeature]
});
var NgModelGroup = _NgModelGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
    type: Directive,
    args: [{
      selector: "[ngModelGroup]",
      providers: [modelGroupProvider],
      exportAs: "ngModelGroup"
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["ngModelGroup"]
    }]
  });
})();
var formControlBinding$1 = {
  provide: NgControl,
  useExisting: forwardRef(() => NgModel)
};
var resolvedPromise = (() => Promise.resolve())();
var _NgModel = class _NgModel extends NgControl {
  constructor(parent2, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this.control = new FormControl();
    this._registered = false;
    this.name = "";
    this.update = new EventEmitter();
    this._parent = parent2;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || "name" in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes["name"].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ("isDisabled" in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return this._getPath(this.name);
  }
  /**
   * @description
   * The top-level directive for this control if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value emitted by `ngModelChange`.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if (!this._isStandalone()) {
      this._checkParentType();
    }
    this._checkName();
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
        throw formGroupNameException();
      } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
        throw modelParentException();
      }
    }
  }
  _checkName() {
    if (this.options && this.options.name) this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value) {
    resolvedPromise.then(() => {
      this.control.setValue(value, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes["isDisabled"].currentValue;
    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
};
_NgModel.\u0275fac = function NgModel_Factory(t3) {
  return new (t3 || _NgModel)(\u0275\u0275directiveInject(ControlContainer, 9), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(ChangeDetectorRef, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_NgModel.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgModel,
  selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
  inputs: {
    name: "name",
    isDisabled: [0, "disabled", "isDisabled"],
    model: [0, "ngModel", "model"],
    options: [0, "ngModelOptions", "options"]
  },
  outputs: {
    update: "ngModelChange"
  },
  exportAs: ["ngModel"],
  features: [\u0275\u0275ProvidersFeature([formControlBinding$1]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var NgModel = _NgModel;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
    type: Directive,
    args: [{
      selector: "[ngModel]:not([formControlName]):not([formControl])",
      providers: [formControlBinding$1],
      exportAs: "ngModel"
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: ChangeDetectorRef,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    options: [{
      type: Input,
      args: ["ngModelOptions"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var _\u0275NgNoValidate = class _\u0275NgNoValidate {
};
_\u0275NgNoValidate.\u0275fac = function \u0275NgNoValidate_Factory(t3) {
  return new (t3 || _\u0275NgNoValidate)();
};
_\u0275NgNoValidate.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _\u0275NgNoValidate,
  selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
  hostAttrs: ["novalidate", ""]
});
var \u0275NgNoValidate = _\u0275NgNoValidate;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgNoValidate, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([ngNativeValidate])",
      host: {
        "novalidate": ""
      }
    }]
  }], null, null);
})();
var NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NumberValueAccessor),
  multi: true
};
var _NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
};
_NumberValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NumberValueAccessor_BaseFactory;
  return function NumberValueAccessor_Factory(t3) {
    return (\u0275NumberValueAccessor_BaseFactory || (\u0275NumberValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_NumberValueAccessor)))(t3 || _NumberValueAccessor);
  };
})();
_NumberValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NumberValueAccessor,
  selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
  hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([NUMBER_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var NumberValueAccessor = _NumberValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
      host: {
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [NUMBER_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
var _RadioControlRegistry = class _RadioControlRegistry {
  constructor() {
    this._accessors = [];
  }
  /**
   * @description
   * Adds a control to the internal registry. For internal use only.
   */
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  /**
   * @description
   * Removes a control from the internal registry. For internal use only.
   */
  remove(accessor) {
    for (let i3 = this._accessors.length - 1; i3 >= 0; --i3) {
      if (this._accessors[i3][1] === accessor) {
        this._accessors.splice(i3, 1);
        return;
      }
    }
  }
  /**
   * @description
   * Selects a radio button. For internal use only.
   */
  select(accessor) {
    this._accessors.forEach((c3) => {
      if (this._isSameGroup(c3, accessor) && c3[1] !== accessor) {
        c3[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control) return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
};
_RadioControlRegistry.\u0275fac = function RadioControlRegistry_Factory(t3) {
  return new (t3 || _RadioControlRegistry)();
};
_RadioControlRegistry.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _RadioControlRegistry,
  factory: _RadioControlRegistry.\u0275fac,
  providedIn: "root"
});
var RadioControlRegistry = _RadioControlRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
    this.setDisabledStateFired = false;
    this.onChange = () => {
    };
    this.callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {
      optional: true
    }) ?? setDisabledStateDefault;
  }
  /** @nodoc */
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  /** @nodoc */
  ngOnDestroy() {
    this._registry.remove(this);
  }
  /**
   * Sets the "checked" property value on the radio input element.
   * @nodoc
   */
  writeValue(value) {
    this._state = value === this.value;
    this.setProperty("checked", this._state);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  /** @nodoc */
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
      this.setProperty("disabled", isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  /**
   * Sets the "value" on the radio input element and unchecks it.
   *
   * @param value
   */
  fireUncheck(value) {
    this.writeValue(value);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName) this.name = this.formControlName;
  }
};
_RadioControlValueAccessor.\u0275fac = function RadioControlValueAccessor_Factory(t3) {
  return new (t3 || _RadioControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(RadioControlRegistry), \u0275\u0275directiveInject(Injector));
};
_RadioControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RadioControlValueAccessor,
  selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
  hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
        return ctx.onChange();
      })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    name: "name",
    formControlName: "formControlName",
    value: "value"
  },
  features: [\u0275\u0275ProvidersFeature([RADIO_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var RadioControlValueAccessor = _RadioControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
      host: {
        "(change)": "onChange()",
        "(blur)": "onTouched()"
      },
      providers: [RADIO_VALUE_ACCESSOR]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: Injector
  }], {
    name: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RangeValueAccessor),
  multi: true
};
var _RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("value", parseFloat(value));
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
};
_RangeValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275RangeValueAccessor_BaseFactory;
  return function RangeValueAccessor_Factory(t3) {
    return (\u0275RangeValueAccessor_BaseFactory || (\u0275RangeValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_RangeValueAccessor)))(t3 || _RangeValueAccessor);
  };
})();
_RangeValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RangeValueAccessor,
  selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
  hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([RANGE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var RangeValueAccessor = _RangeValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [RANGE_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? "NgModelWithFormControlWarning" : "");
var formControlBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlDirective)
};
var _FormControlDirective = class _FormControlDirective extends NgControl {
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this.update = new EventEmitter();
    this._ngModelWarningSent = false;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes["form"].previousValue;
      if (previousForm) {
        cleanUpControl(
          previousForm,
          this,
          /* validateControlPresenceOnChange */
          false
        );
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(
        this.form,
        this,
        /* validateControlPresenceOnChange */
        false
      );
    }
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * The `FormControl` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty("form");
  }
};
_FormControlDirective._ngModelWarningSentOnce = false;
_FormControlDirective.\u0275fac = function FormControlDirective_Factory(t3) {
  return new (t3 || _FormControlDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_FormControlDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormControlDirective,
  selectors: [["", "formControl", ""]],
  inputs: {
    form: [0, "formControl", "form"],
    isDisabled: [0, "disabled", "isDisabled"],
    model: [0, "ngModel", "model"]
  },
  outputs: {
    update: "ngModelChange"
  },
  exportAs: ["ngForm"],
  features: [\u0275\u0275ProvidersFeature([formControlBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var FormControlDirective = _FormControlDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
    type: Directive,
    args: [{
      selector: "[formControl]",
      providers: [formControlBinding],
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formControl"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupDirective)
};
var _FormGroupDirective = class _FormGroupDirective extends ControlContainer {
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.submitted = false;
    this._onCollectionChange = () => this._updateDomValue();
    this.directives = [];
    this.form = null;
    this.ngSubmit = new EventEmitter();
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkFormPresent();
    if (changes.hasOwnProperty("form")) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {
        });
      }
    }
  }
  /**
   * @description
   * Returns this directive's instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * Returns the `FormGroup` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `FormControlName` directive instance.
   */
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `FormControlName` directive
   *
   * @param dir The `FormControlName` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `FormControlName` instance from the internal list of directives
   *
   * @param dir The `FormControlName` directive instance.
   */
  removeControl(dir) {
    cleanUpControl(
      dir.control || null,
      dir,
      /* validateControlPresenceOnChange */
      false
    );
    removeListItem$1(this.directives, dir);
  }
  /**
   * Adds a new `FormGroupName` directive instance to the form.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
   *
   * @param dir The `FormGroupName` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `FormControlName` directive.
   *
   * @param dir The `FormControlName` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value);
  }
  /**
   * @description
   * Method called with the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submitted = true;
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submitted = false;
    this.form._events.next(new FormResetEvent(this.form));
  }
  /** @internal */
  _updateDomValue() {
    this.directives.forEach((dir) => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {
      });
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  _checkFormPresent() {
    if (!this.form && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingFormException();
    }
  }
};
_FormGroupDirective.\u0275fac = function FormGroupDirective_Factory(t3) {
  return new (t3 || _FormGroupDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_FormGroupDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormGroupDirective,
  selectors: [["", "formGroup", ""]],
  hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
        return ctx.onSubmit($event);
      })("reset", function FormGroupDirective_reset_HostBindingHandler() {
        return ctx.onReset();
      });
    }
  },
  inputs: {
    form: [0, "formGroup", "form"]
  },
  outputs: {
    ngSubmit: "ngSubmit"
  },
  exportAs: ["ngForm"],
  features: [\u0275\u0275ProvidersFeature([formDirectiveProvider]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var FormGroupDirective = _FormGroupDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[formGroup]",
      providers: [formDirectiveProvider],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formGroup"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupName)
};
var _FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
  constructor(parent2, validators, asyncValidators) {
    super();
    this.name = null;
    this._parent = parent2;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw groupParentException();
    }
  }
};
_FormGroupName.\u0275fac = function FormGroupName_Factory(t3) {
  return new (t3 || _FormGroupName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
};
_FormGroupName.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormGroupName,
  selectors: [["", "formGroupName", ""]],
  inputs: {
    name: [0, "formGroupName", "name"]
  },
  features: [\u0275\u0275ProvidersFeature([formGroupNameProvider]), \u0275\u0275InheritDefinitionFeature]
});
var FormGroupName = _FormGroupName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
    type: Directive,
    args: [{
      selector: "[formGroupName]",
      providers: [formGroupNameProvider]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formGroupName"]
    }]
  });
})();
var formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayName)
};
var _FormArrayName = class _FormArrayName extends ControlContainer {
  constructor(parent2, validators, asyncValidators) {
    super();
    this.name = null;
    this._parent = parent2;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /**
   * A lifecycle method called when the directive's inputs are initialized. For internal use only.
   * @throws If the directive does not have a valid parent.
   * @nodoc
   */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormArray(this);
  }
  /**
   * A lifecycle method called before the directive's instance is destroyed. For internal use only.
   * @nodoc
   */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormArray(this);
    }
  }
  /**
   * @description
   * The `FormArray` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormArray(this);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw arrayParentException();
    }
  }
};
_FormArrayName.\u0275fac = function FormArrayName_Factory(t3) {
  return new (t3 || _FormArrayName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
};
_FormArrayName.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormArrayName,
  selectors: [["", "formArrayName", ""]],
  inputs: {
    name: [0, "formArrayName", "name"]
  },
  features: [\u0275\u0275ProvidersFeature([formArrayNameProvider]), \u0275\u0275InheritDefinitionFeature]
});
var FormArrayName = _FormArrayName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
    type: Directive,
    args: [{
      selector: "[formArrayName]",
      providers: [formArrayNameProvider]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formArrayName"]
    }]
  });
})();
function _hasInvalidParent(parent2) {
  return !(parent2 instanceof FormGroupName) && !(parent2 instanceof FormGroupDirective) && !(parent2 instanceof FormArrayName);
}
var controlNameBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlName)
};
var _FormControlName = class _FormControlName extends NgControl {
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  constructor(parent2, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._added = false;
    this.name = null;
    this.update = new EventEmitter();
    this._ngModelWarningSent = false;
    this._parent = parent2;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (!this._added) this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
        throw ngModelGroupException();
      } else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) && !(this._parent instanceof FormArrayName)) {
        throw controlParentException(this.name);
      }
    }
  }
  _setUpControl() {
    this._checkParentType();
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
};
_FormControlName._ngModelWarningSentOnce = false;
_FormControlName.\u0275fac = function FormControlName_Factory(t3) {
  return new (t3 || _FormControlName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
};
_FormControlName.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormControlName,
  selectors: [["", "formControlName", ""]],
  inputs: {
    name: [0, "formControlName", "name"],
    isDisabled: [0, "disabled", "isDisabled"],
    model: [0, "ngModel", "model"]
  },
  outputs: {
    update: "ngModelChange"
  },
  features: [\u0275\u0275ProvidersFeature([controlNameBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var FormControlName = _FormControlName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
    type: Directive,
    args: [{
      selector: "[formControlName]",
      providers: [controlNameBinding]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formControlName"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null) return `${value}`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
var _SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
  constructor() {
    super(...arguments);
    this._optionMap = /* @__PURE__ */ new Map();
    this._idCounter = 0;
    this._compareWith = Object.is;
  }
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  /**
   * Sets the "value" property on the select element.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    const id = this._getOptionId(value);
    const valueString = _buildValueString$1(id, value);
    this.setProperty("value", valueString);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (valueString) => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  /** @internal */
  _registerOption() {
    return (this._idCounter++).toString();
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id), value)) return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId$1(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
  }
};
_SelectControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275SelectControlValueAccessor_BaseFactory;
  return function SelectControlValueAccessor_Factory(t3) {
    return (\u0275SelectControlValueAccessor_BaseFactory || (\u0275SelectControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectControlValueAccessor)))(t3 || _SelectControlValueAccessor);
  };
})();
_SelectControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _SelectControlValueAccessor,
  selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
  hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    compareWith: "compareWith"
  },
  features: [\u0275\u0275ProvidersFeature([SELECT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var SelectControlValueAccessor = _SelectControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_VALUE_ACCESSOR]
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var _NgSelectOption = class _NgSelectOption {
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) this.id = this._select._registerOption();
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null) return;
    this._select._optionMap.set(this.id, value);
    this._setElementValue(_buildValueString$1(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    this._setElementValue(value);
    if (this._select) this._select.writeValue(this._select.value);
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
};
_NgSelectOption.\u0275fac = function NgSelectOption_Factory(t3) {
  return new (t3 || _NgSelectOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectControlValueAccessor, 9));
};
_NgSelectOption.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgSelectOption,
  selectors: [["option"]],
  inputs: {
    ngValue: "ngValue",
    value: "value"
  }
});
var NgSelectOption = _NgSelectOption;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
    type: Directive,
    args: [{
      selector: "option"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
var SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null) return `${value}`;
  if (typeof value === "string") value = `'${value}'`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
var _SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  constructor() {
    super(...arguments);
    this._optionMap = /* @__PURE__ */ new Map();
    this._idCounter = 0;
    this._compareWith = Object.is;
  }
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  /**
   * Sets the "value" property on one or of more of the select's options.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    let optionSelectedStateSetter;
    if (Array.isArray(value)) {
      const ids = value.map((v3) => this._getOptionId(v3));
      optionSelectedStateSetter = (opt, o2) => {
        opt._setSelected(ids.indexOf(o2.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o2) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  /**
   * Registers a function called when the control value changes
   * and writes an array of the selected options.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (element) => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== void 0) {
        const options = selectedOptions;
        for (let i3 = 0; i3 < options.length; i3++) {
          const opt = options[i3];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i3 = 0; i3 < options.length; i3++) {
          const opt = options[i3];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  /** @internal */
  _registerOption(value) {
    const id = (this._idCounter++).toString();
    this._optionMap.set(id, value);
    return id;
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id)._value, value)) return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
  }
};
_SelectMultipleControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275SelectMultipleControlValueAccessor_BaseFactory;
  return function SelectMultipleControlValueAccessor_Factory(t3) {
    return (\u0275SelectMultipleControlValueAccessor_BaseFactory || (\u0275SelectMultipleControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectMultipleControlValueAccessor)))(t3 || _SelectMultipleControlValueAccessor);
  };
})();
_SelectMultipleControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _SelectMultipleControlValueAccessor,
  selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
  hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target);
      })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    compareWith: "compareWith"
  },
  features: [\u0275\u0275ProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var SelectMultipleControlValueAccessor = _SelectMultipleControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
      host: {
        "(change)": "onChange($event.target)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var _\u0275NgSelectMultipleOption = class _\u0275NgSelectMultipleOption {
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null) return;
    this._value = value;
    this._setElementValue(_buildValueString(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    if (this._select) {
      this._value = value;
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value);
    }
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @internal */
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
};
_\u0275NgSelectMultipleOption.\u0275fac = function \u0275NgSelectMultipleOption_Factory(t3) {
  return new (t3 || _\u0275NgSelectMultipleOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectMultipleControlValueAccessor, 9));
};
_\u0275NgSelectMultipleOption.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _\u0275NgSelectMultipleOption,
  selectors: [["option"]],
  inputs: {
    ngValue: "ngValue",
    value: "value"
  }
});
var \u0275NgSelectMultipleOption = _\u0275NgSelectMultipleOption;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgSelectMultipleOption, [{
    type: Directive,
    args: [{
      selector: "option"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
var _AbstractValidatorDirective = class _AbstractValidatorDirective {
  constructor() {
    this._validator = nullValidator;
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input2 = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input2);
      this._validator = this._enabled ? this.createValidator(input2) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  /** @nodoc */
  validate(control) {
    return this._validator(control);
  }
  /** @nodoc */
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  /**
   * @description
   * Determines whether this validator should be active or not based on an input.
   * Base class implementation checks whether an input is defined (if the value is different from
   * `null` and `undefined`). Validator classes that extend this base class can override this
   * function with the logic specific to a particular validator directive.
   */
  enabled(input2) {
    return input2 != null;
  }
};
_AbstractValidatorDirective.\u0275fac = function AbstractValidatorDirective_Factory(t3) {
  return new (t3 || _AbstractValidatorDirective)();
};
_AbstractValidatorDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AbstractValidatorDirective,
  features: [\u0275\u0275NgOnChangesFeature]
});
var AbstractValidatorDirective = _AbstractValidatorDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
    type: Directive
  }], null, null);
})();
var MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxValidator),
  multi: true
};
var _MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "max";
    this.normalizeInput = (input2) => toFloat(input2);
    this.createValidator = (max) => maxValidator(max);
  }
};
_MaxValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MaxValidator_BaseFactory;
  return function MaxValidator_Factory(t3) {
    return (\u0275MaxValidator_BaseFactory || (\u0275MaxValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxValidator)))(t3 || _MaxValidator);
  };
})();
_MaxValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MaxValidator,
  selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MaxValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("max", ctx._enabled ? ctx.max : null);
    }
  },
  inputs: {
    max: "max"
  },
  features: [\u0275\u0275ProvidersFeature([MAX_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MaxValidator = _MaxValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
      providers: [MAX_VALIDATOR],
      host: {
        "[attr.max]": "_enabled ? max : null"
      }
    }]
  }], null, {
    max: [{
      type: Input
    }]
  });
})();
var MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinValidator),
  multi: true
};
var _MinValidator = class _MinValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "min";
    this.normalizeInput = (input2) => toFloat(input2);
    this.createValidator = (min) => minValidator(min);
  }
};
_MinValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MinValidator_BaseFactory;
  return function MinValidator_Factory(t3) {
    return (\u0275MinValidator_BaseFactory || (\u0275MinValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinValidator)))(t3 || _MinValidator);
  };
})();
_MinValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MinValidator,
  selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MinValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("min", ctx._enabled ? ctx.min : null);
    }
  },
  inputs: {
    min: "min"
  },
  features: [\u0275\u0275ProvidersFeature([MIN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MinValidator = _MinValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
      providers: [MIN_VALIDATOR],
      host: {
        "[attr.min]": "_enabled ? min : null"
      }
    }]
  }], null, {
    min: [{
      type: Input
    }]
  });
})();
var REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RequiredValidator),
  multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CheckboxRequiredValidator),
  multi: true
};
var _RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "required";
    this.normalizeInput = booleanAttribute;
    this.createValidator = (input2) => requiredValidator;
  }
  /** @nodoc */
  enabled(input2) {
    return input2;
  }
};
_RequiredValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275RequiredValidator_BaseFactory;
  return function RequiredValidator_Factory(t3) {
    return (\u0275RequiredValidator_BaseFactory || (\u0275RequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_RequiredValidator)))(t3 || _RequiredValidator);
  };
})();
_RequiredValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RequiredValidator,
  selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
  hostVars: 1,
  hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("required", ctx._enabled ? "" : null);
    }
  },
  inputs: {
    required: "required"
  },
  features: [\u0275\u0275ProvidersFeature([REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var RequiredValidator = _RequiredValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
    type: Directive,
    args: [{
      selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
      providers: [REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      }
    }]
  }], null, {
    required: [{
      type: Input
    }]
  });
})();
var _CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
  constructor() {
    super(...arguments);
    this.createValidator = (input2) => requiredTrueValidator;
  }
};
_CheckboxRequiredValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275CheckboxRequiredValidator_BaseFactory;
  return function CheckboxRequiredValidator_Factory(t3) {
    return (\u0275CheckboxRequiredValidator_BaseFactory || (\u0275CheckboxRequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxRequiredValidator)))(t3 || _CheckboxRequiredValidator);
  };
})();
_CheckboxRequiredValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CheckboxRequiredValidator,
  selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("required", ctx._enabled ? "" : null);
    }
  },
  features: [\u0275\u0275ProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var CheckboxRequiredValidator = _CheckboxRequiredValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      }
    }]
  }], null, null);
})();
var EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => EmailValidator),
  multi: true
};
var _EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "email";
    this.normalizeInput = booleanAttribute;
    this.createValidator = (input2) => emailValidator;
  }
  /** @nodoc */
  enabled(input2) {
    return input2;
  }
};
_EmailValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275EmailValidator_BaseFactory;
  return function EmailValidator_Factory(t3) {
    return (\u0275EmailValidator_BaseFactory || (\u0275EmailValidator_BaseFactory = \u0275\u0275getInheritedFactory(_EmailValidator)))(t3 || _EmailValidator);
  };
})();
_EmailValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _EmailValidator,
  selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
  inputs: {
    email: "email"
  },
  features: [\u0275\u0275ProvidersFeature([EMAIL_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var EmailValidator = _EmailValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
    type: Directive,
    args: [{
      selector: "[email][formControlName],[email][formControl],[email][ngModel]",
      providers: [EMAIL_VALIDATOR]
    }]
  }], null, {
    email: [{
      type: Input
    }]
  });
})();
var MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinLengthValidator),
  multi: true
};
var _MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "minlength";
    this.normalizeInput = (input2) => toInteger(input2);
    this.createValidator = (minlength) => minLengthValidator(minlength);
  }
};
_MinLengthValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MinLengthValidator_BaseFactory;
  return function MinLengthValidator_Factory(t3) {
    return (\u0275MinLengthValidator_BaseFactory || (\u0275MinLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinLengthValidator)))(t3 || _MinLengthValidator);
  };
})();
_MinLengthValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MinLengthValidator,
  selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("minlength", ctx._enabled ? ctx.minlength : null);
    }
  },
  inputs: {
    minlength: "minlength"
  },
  features: [\u0275\u0275ProvidersFeature([MIN_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MinLengthValidator = _MinLengthValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        "[attr.minlength]": "_enabled ? minlength : null"
      }
    }]
  }], null, {
    minlength: [{
      type: Input
    }]
  });
})();
var MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxLengthValidator),
  multi: true
};
var _MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "maxlength";
    this.normalizeInput = (input2) => toInteger(input2);
    this.createValidator = (maxlength) => maxLengthValidator(maxlength);
  }
};
_MaxLengthValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MaxLengthValidator_BaseFactory;
  return function MaxLengthValidator_Factory(t3) {
    return (\u0275MaxLengthValidator_BaseFactory || (\u0275MaxLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxLengthValidator)))(t3 || _MaxLengthValidator);
  };
})();
_MaxLengthValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MaxLengthValidator,
  selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("maxlength", ctx._enabled ? ctx.maxlength : null);
    }
  },
  inputs: {
    maxlength: "maxlength"
  },
  features: [\u0275\u0275ProvidersFeature([MAX_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MaxLengthValidator = _MaxLengthValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        "[attr.maxlength]": "_enabled ? maxlength : null"
      }
    }]
  }], null, {
    maxlength: [{
      type: Input
    }]
  });
})();
var PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => PatternValidator),
  multi: true
};
var _PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "pattern";
    this.normalizeInput = (input2) => input2;
    this.createValidator = (input2) => patternValidator(input2);
  }
};
_PatternValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275PatternValidator_BaseFactory;
  return function PatternValidator_Factory(t3) {
    return (\u0275PatternValidator_BaseFactory || (\u0275PatternValidator_BaseFactory = \u0275\u0275getInheritedFactory(_PatternValidator)))(t3 || _PatternValidator);
  };
})();
_PatternValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _PatternValidator,
  selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function PatternValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("pattern", ctx._enabled ? ctx.pattern : null);
    }
  },
  inputs: {
    pattern: "pattern"
  },
  features: [\u0275\u0275ProvidersFeature([PATTERN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var PatternValidator = _PatternValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
    type: Directive,
    args: [{
      selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
      providers: [PATTERN_VALIDATOR],
      host: {
        "[attr.pattern]": "_enabled ? pattern : null"
      }
    }]
  }], null, {
    pattern: [{
      type: Input
    }]
  });
})();
var SHARED_FORM_DIRECTIVES = [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
var _\u0275InternalFormsSharedModule = class _\u0275InternalFormsSharedModule {
};
_\u0275InternalFormsSharedModule.\u0275fac = function \u0275InternalFormsSharedModule_Factory(t3) {
  return new (t3 || _\u0275InternalFormsSharedModule)();
};
_\u0275InternalFormsSharedModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _\u0275InternalFormsSharedModule
});
_\u0275InternalFormsSharedModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var \u0275InternalFormsSharedModule = _\u0275InternalFormsSharedModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275InternalFormsSharedModule, [{
    type: NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
var FormArray = class extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
   *     around from the back, and if index is greatly negative (less than `-length`), the result is
   * undefined. This behavior is the same as `Array.at(index)`.
   */
  at(index3) {
    return this.controls[this._adjustIndex(index3)];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
   * This behavior is the same as `Array.splice(index, 0, control)`.
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index3, control, options = {}) {
    this.controls.splice(index3, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control.  If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), removes the first
   *     element. This behavior is the same as `Array.splice(index, 1)`.
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index3, options = {}) {
    let adjustedIndex = this._adjustIndex(index3);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
   *     element. This behavior is the same as `Array.splice(index, 1, control)`.
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index3, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index3);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, false, value);
    value.forEach((newValue, index3) => {
      assertControlPresent(this, false, index3);
      this.at(index3).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control
   * value is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null) return;
    value.forEach((newValue, index3) => {
      if (this.at(index3)) {
        this.at(index3).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value = [], options = {}) {
    this._forEachChild((control, index3) => {
      control.reset(value[index3], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   */
  getRawValue() {
    return this.controls.map((control) => control.getRawValue());
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1) return;
    this._forEachChild((control) => control._registerOnCollectionChange(() => {
    }));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Adjusts a negative index by summing it with the length of the array. For very negative
   * indices, the result may remain negative.
   * @internal
   */
  _adjustIndex(index3) {
    return index3 < 0 ? index3 + this.length : index3;
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index3) => {
      cb(control, index3);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some((control) => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => this._registerControl(control));
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled) return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  /** @internal */
  _find(name) {
    return this.at(name) ?? null;
  }
};
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var _FormBuilder = class _FormBuilder {
  constructor() {
    this.useNonNullable = false;
  }
  /**
   * @description
   * Returns a FormBuilder in which automatically constructed `FormControl` elements
   * have `{nonNullable: true}` and are non-nullable.
   *
   * **Constructing non-nullable controls**
   *
   * When constructing a control, it will be non-nullable, and will reset to its initial value.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.control('Alex'); // FormControl<string>
   * name.reset();
   * console.log(name); // 'Alex'
   * ```
   *
   * **Constructing non-nullable groups or arrays**
   *
   * When constructing a group or array, all automatically created inner controls will be
   * non-nullable, and will reset to their initial values.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
   * name.reset();
   * console.log(name); // {who: 'Alex'}
   * ```
   * **Constructing *nullable* fields on groups or arrays**
   *
   * It is still possible to have a nullable field. In particular, any `FormControl` which is
   * *already* constructed will not be altered. For example:
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * // FormGroup<{who: FormControl<string|null>}>
   * let name = nnfb.group({who: new FormControl('Alex')});
   * name.reset(); console.log(name); // {who: null}
   * ```
   *
   * Because the inner control is constructed explicitly by the caller, the builder has
   * no control over how it is created, and cannot exclude the `null`.
   */
  get nonNullable() {
    const nnfb = new _FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  /**
   * @description
   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
   * containing all the keys and corresponding inner control types.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param options Configuration options object for the `FormRecord`. The object should have the
   * `AbstractControlOptions` type and might contain the following fields:
   * * `validators`: A synchronous validator function, or an array of validator functions.
   * * `asyncValidators`: A single async validator or array of async validator functions.
   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
   * | submit').
   */
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  /**
   * @description
   * Constructs a new `FormControl` with the given state, validators and options. Sets
   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
   * control will be nullable. Accepts a single generic argument, which is the type  of the
   * control's value.
   *
   * @param formState Initializes the control with an initial state value, or
   * with an object that contains both a value and a disabled status.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or a `FormControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator
   * functions.
   *
   * @usageNotes
   *
   * ### Initialize a control as disabled
   *
   * The following example returns a control with an initial value in a disabled state.
   *
   * <code-example path="forms/ts/formBuilder/form_builder_example.ts" region="disabled-control">
   * </code-example>
   */
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
      nonNullable: true
    }));
  }
  /**
   * Constructs a new `FormArray` from the given array of configurations,
   * validators and options. Accepts a single generic argument, which is the type of each control
   * inside the array.
   *
   * @param controls An array of child controls or control configs. Each child control is given an
   *     index when it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
   *     `AbstractControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions.
   */
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map((c3) => this._createControl(c3));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  /** @internal */
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach((controlName) => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  /** @internal */
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
};
_FormBuilder.\u0275fac = function FormBuilder_Factory(t3) {
  return new (t3 || _FormBuilder)();
};
_FormBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FormBuilder,
  factory: _FormBuilder.\u0275fac,
  providedIn: "root"
});
var FormBuilder = _FormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _NonNullableFormBuilder = class _NonNullableFormBuilder {
};
_NonNullableFormBuilder.\u0275fac = function NonNullableFormBuilder_Factory(t3) {
  return new (t3 || _NonNullableFormBuilder)();
};
_NonNullableFormBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NonNullableFormBuilder,
  factory: () => (() => inject(FormBuilder).nonNullable)(),
  providedIn: "root"
});
var NonNullableFormBuilder = _NonNullableFormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(FormBuilder).nonNullable
    }]
  }], null, null);
})();
var _UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  /**
   * Like `FormBuilder#control`, except the resulting control is untyped.
   */
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  /**
   * Like `FormBuilder#array`, except the resulting array is untyped.
   */
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
};
_UntypedFormBuilder.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275UntypedFormBuilder_BaseFactory;
  return function UntypedFormBuilder_Factory(t3) {
    return (\u0275UntypedFormBuilder_BaseFactory || (\u0275UntypedFormBuilder_BaseFactory = \u0275\u0275getInheritedFactory(_UntypedFormBuilder)))(t3 || _UntypedFormBuilder);
  };
})();
_UntypedFormBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _UntypedFormBuilder,
  factory: _UntypedFormBuilder.\u0275fac,
  providedIn: "root"
});
var UntypedFormBuilder = _UntypedFormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var VERSION5 = new Version("18.0.1");
var _FormsModule = class _FormsModule {
  /**
   * @description
   * Provides options for configuring the forms module.
   *
   * @param opts An object of configuration options
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
};
_FormsModule.\u0275fac = function FormsModule_Factory(t3) {
  return new (t3 || _FormsModule)();
};
_FormsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _FormsModule
});
_FormsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [\u0275InternalFormsSharedModule]
});
var FormsModule = _FormsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
    type: NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [\u0275InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
var _ReactiveFormsModule = class _ReactiveFormsModule {
  /**
   * @description
   * Provides options for configuring the reactive forms module.
   *
   * @param opts An object of configuration options
   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
   * binding is used with reactive form directives.
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? "always"
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
};
_ReactiveFormsModule.\u0275fac = function ReactiveFormsModule_Factory(t3) {
  return new (t3 || _ReactiveFormsModule)();
};
_ReactiveFormsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ReactiveFormsModule
});
_ReactiveFormsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [\u0275InternalFormsSharedModule]
});
var ReactiveFormsModule = _ReactiveFormsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
    type: NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [\u0275InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();

// src/app/shared/progress-bar/progress-bar.component.ts
var _ProgressBarComponent = class _ProgressBarComponent {
};
_ProgressBarComponent.\u0275fac = function ProgressBarComponent_Factory(t3) {
  return new (t3 || _ProgressBarComponent)();
};
_ProgressBarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ProgressBarComponent, selectors: [["app-progress-bar"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, consts: [[1, "progress"], ["role", "progressbar", "aria-valuenow", "100", "aria-valuemin", "0", "aria-valuemax", "100", 1, "progress-bar", "progress-bar-striped", "progress-bar-animated", "bg-info", 2, "width", "100%"]], template: function ProgressBarComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275element(1, "div", 1);
    \u0275\u0275elementEnd();
  }
} });
var ProgressBarComponent = _ProgressBarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ProgressBarComponent, { className: "ProgressBarComponent", filePath: "src\\app\\shared\\progress-bar\\progress-bar.component.ts", lineNumber: 10 });
})();

// src/app/environments/environments.ts
var environment = {
  production: false,
  endpoint: "http://localhost:3001/",
  mapbox: {
    accessToken: "pk.eyJ1IjoibGFlenJhIiwiYSI6ImNseG1jOTBqbjA5Ynkya3NldThoY3JhYWwifQ.WDeqMoFRVHX-Xwnfvj9LMQ"
  }
};

// src/app/servicio.service.ts
var _ServicioService = class _ServicioService {
  constructor(http) {
    this.http = http;
    this.myAppUrl = environment.endpoint;
    this.myApiUrl = "api/products/";
  }
  getListProducts() {
    return this.http.get(`${this.myAppUrl}${this.myApiUrl}`);
  }
  deleteProduct(id) {
    return this.http.delete(`${this.myAppUrl}${this.myApiUrl}${id}`);
  }
  saveProduct(product) {
    return this.http.post(`${this.myAppUrl}${this.myApiUrl}`, product);
  }
  getProduct(id) {
    return this.http.get(`${this.myAppUrl}${this.myApiUrl}${id}`);
  }
  updateProduct(id, product) {
    return this.http.put(`${this.myAppUrl}${this.myApiUrl}${id}`, product);
  }
  getLocations() {
    return this.http.get(`${this.myAppUrl}api/locations`);
  }
  saveLocation(location2) {
    return this.http.post(`${this.myAppUrl}api/locations`, location2);
  }
  deleteLocation(id) {
    return this.http.delete(`${this.myAppUrl}api/locations/${id}`);
  }
};
_ServicioService.\u0275fac = function ServicioService_Factory(t3) {
  return new (t3 || _ServicioService)(\u0275\u0275inject(HttpClient));
};
_ServicioService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ServicioService, factory: _ServicioService.\u0275fac, providedIn: "root" });
var ServicioService = _ServicioService;

// src/app/addedit/addedit.component.ts
function AddeditComponent_app_progress_bar_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-progress-bar");
  }
}
function AddeditComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2)(1, "div", 3)(2, "div", 4);
    \u0275\u0275element(3, "div", 5);
    \u0275\u0275elementStart(4, "div", 6)(5, "h4", 7);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "form", 8);
    \u0275\u0275listener("ngSubmit", function AddeditComponent_div_1_Template_form_ngSubmit_7_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.addScapeRoom());
    });
    \u0275\u0275element(8, "input", 9)(9, "input", 10)(10, "input", 11)(11, "input", 12);
    \u0275\u0275elementStart(12, "div", 13)(13, "div", 14)(14, "button", 15);
    \u0275\u0275text(15, "Aceptar");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(16, "div", 14)(17, "button", 16);
    \u0275\u0275text(18, "Volver");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275element(19, "div");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1("", ctx_r1.operacion, " ScapeRoom");
    \u0275\u0275advance();
    \u0275\u0275property("formGroup", ctx_r1.form);
    \u0275\u0275advance(7);
    \u0275\u0275property("disabled", ctx_r1.form.invalid);
  }
}
var _AddeditComponent = class _AddeditComponent {
  constructor(fb, _productService, router, aRouter) {
    this.fb = fb;
    this._productService = _productService;
    this.router = router;
    this.aRouter = aRouter;
    this.loading = false;
    this.operacion = "Agregar";
    this.form = this.fb.group({
      nombre: ["", Validators.required],
      tipo: ["", Validators.required],
      nota: [null, Validators.required],
      ubicacion: ["", Validators.required]
    });
    this.id = Number(aRouter.snapshot.paramMap.get("id"));
  }
  ngOnInit() {
    if (this.id != 0) {
      this.operacion = "Editar";
      this.getProduct(this.id);
    }
  }
  getProduct(id) {
    this.loading = true;
    this._productService.getProduct(id).subscribe((data) => {
      console.log(data);
      this.loading = false;
      this.form.setValue({
        nombre: data.nombre,
        tipo: data.tipo,
        nota: data.nota,
        ubicacion: data.ubicacion
      });
    });
  }
  addScapeRoom() {
    const scapeRoom = {
      nombre: this.form.value.nombre,
      tipo: this.form.value.tipo,
      nota: this.form.value.nota,
      ubicacion: this.form.value.ubicacion
    };
    this.loading = true;
    if (this.id !== 0) {
      scapeRoom.id = this.id;
      this._productService.updateProduct(this.id, scapeRoom).subscribe(() => {
        this.loading = false;
        this.router.navigate(["/lista"]);
      });
    } else {
      this._productService.saveProduct(scapeRoom).subscribe(() => {
        this.loading = false;
        this.router.navigate(["/lista"]);
      });
    }
  }
};
_AddeditComponent.\u0275fac = function AddeditComponent_Factory(t3) {
  return new (t3 || _AddeditComponent)(\u0275\u0275directiveInject(FormBuilder), \u0275\u0275directiveInject(ServicioService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute));
};
_AddeditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AddeditComponent, selectors: [["app-addedit"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 2, consts: [[4, "ngIf"], ["class", "row mt-5", 4, "ngIf"], [1, "row", "mt-5"], [1, "col-lg-4", "offset-lg-5"], [1, "card", "text-white", "bg-info", "mb-3", 2, "max-width", "20rem"], [1, "card-header"], [1, "card-body"], [1, "card-title"], [3, "ngSubmit", "formGroup"], ["formControlName", "nombre", "type", "text", "placeholder", "Escribe nombre del ScapeRoom", "id", "inputDefault", 1, "form-control", "mt-4"], ["formControlName", "tipo", "type", "text", "placeholder", "Escribe la tem\xE1tica", "id", "inputDefault", 1, "form-control", "mt-4"], ["formControlName", "nota", "type", "number", "placeholder", "\xBFQu\xE9 nota le pones?", "id", "inputDefault", 1, "form-control", "mt-4"], ["formControlName", "ubicacion", "type", "text", "placeholder", "Escribe la ubicaci\xF3n", "id", "inputDefault", 1, "form-control", "mt-4", "mb-4"], [1, "row", "mt-2", "text-center"], [1, "col-lg-6"], ["type", "submit", 1, "btn", "btn-secondary", 3, "disabled"], ["routerLink", "/lista", "type", "button", 1, "btn", "btn-light"]], template: function AddeditComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, AddeditComponent_app_progress_bar_0_Template, 1, 0, "app-progress-bar", 0)(1, AddeditComponent_div_1_Template, 20, 3, "div", 1);
  }
  if (rf & 2) {
    \u0275\u0275property("ngIf", ctx.loading);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.loading);
  }
}, dependencies: [CommonModule, NgIf, FormsModule, \u0275NgNoValidate, DefaultValueAccessor, NumberValueAccessor, NgControlStatus, NgControlStatusGroup, RouterLink, ReactiveFormsModule, FormGroupDirective, FormControlName, ProgressBarComponent] });
var AddeditComponent = _AddeditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AddeditComponent, { className: "AddeditComponent", filePath: "src\\app\\addedit\\addedit.component.ts", lineNumber: 16 });
})();

// src/app/list/list.component.ts
var _c0 = () => ["/add"];
function ListComponent_app_progress_bar_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-progress-bar");
  }
}
function ListComponent_div_1_tr_19_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr", 8)(1, "td");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "td");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "td");
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "td");
    \u0275\u0275text(8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "td")(10, "button", 9);
    \u0275\u0275text(11, "Editar");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "button", 10);
    \u0275\u0275listener("click", function ListComponent_div_1_tr_19_Template_button_click_12_listener() {
      const item_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.deleteProduct(item_r2.id));
    });
    \u0275\u0275text(13, "Quitar");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r2.nombre);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r2.tipo);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r2.nota);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r2.ubicacion);
    \u0275\u0275advance(2);
    \u0275\u0275propertyInterpolate1("routerLink", "/edit/", item_r2.id, "");
  }
}
function ListComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2)(1, "div", 3)(2, "h4");
    \u0275\u0275text(3, "Listado de ScapeRoms");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 4);
    \u0275\u0275text(5, "Agregar");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "table", 5)(7, "thead")(8, "tr")(9, "th", 6);
    \u0275\u0275text(10, "Nombre");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "th", 6);
    \u0275\u0275text(12, "Tipo");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "th", 6);
    \u0275\u0275text(14, "Nota");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "th", 6);
    \u0275\u0275text(16, "Ubicaci\xF3n");
    \u0275\u0275elementEnd();
    \u0275\u0275element(17, "th", 6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "tbody");
    \u0275\u0275template(19, ListComponent_div_1_tr_19_Template, 14, 6, "tr", 7);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(2, _c0));
    \u0275\u0275advance(15);
    \u0275\u0275property("ngForOf", ctx_r2.listScapeRoom);
  }
}
var _ListComponent = class _ListComponent {
  constructor(_servicioService) {
    this._servicioService = _servicioService;
    this.listScapeRoom = [];
    this.loading = false;
  }
  ngOnInit() {
    this.getListProducts();
  }
  getListProducts() {
    this.loading = true;
    this._servicioService.getListProducts().subscribe((data) => {
      this.listScapeRoom = data;
      this.loading = false;
    });
  }
  deleteProduct(id) {
    this.loading = true;
    this._servicioService.deleteProduct(id).subscribe(() => {
      this.getListProducts();
    });
  }
};
_ListComponent.\u0275fac = function ListComponent_Factory(t3) {
  return new (t3 || _ListComponent)(\u0275\u0275directiveInject(ServicioService));
};
_ListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ListComponent, selectors: [["app-list"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 2, consts: [[4, "ngIf"], ["class", "container", 4, "ngIf"], [1, "container"], [1, "title", "mt-4", "mb-4"], ["type", "button", "routerLinkActive", "router-link-active", 1, "btn", "btn-info", 3, "routerLink"], [1, "table", "table-hover", "rounded"], ["scope", "col"], ["class", "table-light", 4, "ngFor", "ngForOf"], [1, "table-light"], ["type", "button", 1, "btn", "btn-info", "btn-sm", 3, "routerLink"], ["type", "button", 1, "btn", "btn-secondary", "btn-sm", "ms-2", 3, "click"]], template: function ListComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ListComponent_app_progress_bar_0_Template, 1, 0, "app-progress-bar", 0)(1, ListComponent_div_1_Template, 20, 3, "div", 1);
  }
  if (rf & 2) {
    \u0275\u0275property("ngIf", ctx.loading);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.loading);
  }
}, dependencies: [CommonModule, NgForOf, NgIf, RouterLink, ProgressBarComponent], styles: ["\n\n.title[_ngcontent-%COMP%] {\n  display: flex;\n  justify-content: space-between;\n}\n/*# sourceMappingURL=list.component.css.map */"] });
var ListComponent = _ListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ListComponent, { className: "ListComponent", filePath: "src\\app\\list\\list.component.ts", lineNumber: 16 });
})();

// src/app/app.component.ts
var _AppComponent = class _AppComponent {
  constructor() {
    this.title = "sprint8";
  }
};
_AppComponent.\u0275fac = function AppComponent_Factory(t3) {
  return new (t3 || _AppComponent)();
};
_AppComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppComponent, selectors: [["app-root"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 0, template: function AppComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-navbar")(1, "router-outlet");
  }
}, dependencies: [RouterOutlet, NavbarComponent, RouterModule] });
var AppComponent = _AppComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppComponent, { className: "AppComponent", filePath: "src\\app\\app.component.ts", lineNumber: 17 });
})();

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u2;
var i;
var t;
var r;
var o;
var f;
var e;
var c = {};
var s = [];
var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function h(n2, l3) {
  for (var u4 in l3) n2[u4] = l3[u4];
  return n2;
}
function v(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function y(l3, u4, i3) {
  var t3, r3, o2, f3 = {};
  for (o2 in u4) "key" == o2 ? t3 = u4[o2] : "ref" == o2 ? r3 = u4[o2] : f3[o2] = u4[o2];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), "function" == typeof l3 && null != l3.defaultProps) for (o2 in l3.defaultProps) void 0 === f3[o2] && (f3[o2] = l3.defaultProps[o2]);
  return p(l3, f3, t3, r3, null);
}
function p(n2, i3, t3, r3, o2) {
  var f3 = { type: n2, props: i3, key: t3, ref: r3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o2 ? ++u2 : o2 };
  return null == o2 && null != l.vnode && l.vnode(f3), f3;
}
function d() {
  return { current: null };
}
function _(n2) {
  return n2.children;
}
function k(n2, l3, u4, i3, t3) {
  var r3;
  for (r3 in u4) "children" === r3 || "key" === r3 || r3 in l3 || g(n2, r3, null, u4[r3], i3);
  for (r3 in l3) t3 && "function" != typeof l3[r3] || "children" === r3 || "key" === r3 || "value" === r3 || "checked" === r3 || u4[r3] === l3[r3] || g(n2, r3, l3[r3], u4[r3], i3);
}
function b(n2, l3, u4) {
  "-" === l3[0] ? n2.setProperty(l3, null == u4 ? "" : u4) : n2[l3] = null == u4 ? "" : "number" != typeof u4 || a.test(l3) ? u4 : u4 + "px";
}
function g(n2, l3, u4, i3, t3) {
  var r3;
  n: if ("style" === l3) if ("string" == typeof u4) n2.style.cssText = u4;
  else {
    if ("string" == typeof i3 && (n2.style.cssText = i3 = ""), i3) for (l3 in i3) u4 && l3 in u4 || b(n2.style, l3, "");
    if (u4) for (l3 in u4) i3 && u4[l3] === i3[l3] || b(n2.style, l3, u4[l3]);
  }
  else if ("o" === l3[0] && "n" === l3[1]) r3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r3] = u4, u4 ? i3 || n2.addEventListener(l3, r3 ? w : m, r3) : n2.removeEventListener(l3, r3 ? w : m, r3);
  else if ("dangerouslySetInnerHTML" !== l3) {
    if (t3) l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n2) try {
      n2[l3] = null == u4 ? "" : u4;
      break n;
    } catch (n3) {
    }
    "function" == typeof u4 || (null == u4 || false === u4 && -1 == l3.indexOf("-") ? n2.removeAttribute(l3) : n2.setAttribute(l3, u4));
  }
}
function m(n2) {
  t = true;
  try {
    return this.l[n2.type + false](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function w(n2) {
  t = true;
  try {
    return this.l[n2.type + true](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function x(n2, l3) {
  this.props = n2, this.context = l3;
}
function A(n2, l3) {
  if (null == l3) return n2.__ ? A(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u4; l3 < n2.__k.length; l3++) if (null != (u4 = n2.__k[l3]) && null != u4.__e) return u4.__e;
  return "function" == typeof n2.type ? A(n2) : null;
}
function P(n2) {
  var l3, u4;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++) if (null != (u4 = n2.__k[l3]) && null != u4.__e) {
      n2.__e = n2.__c.base = u4.__e;
      break;
    }
    return P(n2);
  }
}
function C(n2) {
  t ? setTimeout(n2) : f(n2);
}
function T(n2) {
  (!n2.__d && (n2.__d = true) && r.push(n2) && !$.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($);
}
function $() {
  var n2, l3, u4, i3, t3, o2, f3, e3;
  for (r.sort(function(n3, l4) {
    return n3.__v.__b - l4.__v.__b;
  }); n2 = r.shift(); ) n2.__d && (l3 = r.length, i3 = void 0, t3 = void 0, f3 = (o2 = (u4 = n2).__v).__e, (e3 = u4.__P) && (i3 = [], (t3 = h({}, o2)).__v = o2.__v + 1, M(e3, o2, t3, u4.__n, void 0 !== e3.ownerSVGElement, null != o2.__h ? [f3] : null, i3, null == f3 ? A(o2) : f3, o2.__h), N(i3, o2), o2.__e != f3 && P(o2)), r.length > l3 && r.sort(function(n3, l4) {
    return n3.__v.__b - l4.__v.__b;
  }));
  $.__r = 0;
}
function H(n2, l3, u4, i3, t3, r3, o2, f3, e3, a3) {
  var h3, v3, y3, d2, k3, b3, g4, m3 = i3 && i3.__k || s, w4 = m3.length;
  for (u4.__k = [], h3 = 0; h3 < l3.length; h3++) if (null != (d2 = u4.__k[h3] = null == (d2 = l3[h3]) || "boolean" == typeof d2 ? null : "string" == typeof d2 || "number" == typeof d2 || "bigint" == typeof d2 ? p(null, d2, null, null, d2) : Array.isArray(d2) ? p(_, { children: d2 }, null, null, null) : d2.__b > 0 ? p(d2.type, d2.props, d2.key, d2.ref ? d2.ref : null, d2.__v) : d2)) {
    if (d2.__ = u4, d2.__b = u4.__b + 1, null === (y3 = m3[h3]) || y3 && d2.key == y3.key && d2.type === y3.type) m3[h3] = void 0;
    else for (v3 = 0; v3 < w4; v3++) {
      if ((y3 = m3[v3]) && d2.key == y3.key && d2.type === y3.type) {
        m3[v3] = void 0;
        break;
      }
      y3 = null;
    }
    M(n2, d2, y3 = y3 || c, t3, r3, o2, f3, e3, a3), k3 = d2.__e, (v3 = d2.ref) && y3.ref != v3 && (g4 || (g4 = []), y3.ref && g4.push(y3.ref, null, d2), g4.push(v3, d2.__c || k3, d2)), null != k3 ? (null == b3 && (b3 = k3), "function" == typeof d2.type && d2.__k === y3.__k ? d2.__d = e3 = I(d2, e3, n2) : e3 = z(n2, d2, y3, m3, k3, e3), "function" == typeof u4.type && (u4.__d = e3)) : e3 && y3.__e == e3 && e3.parentNode != n2 && (e3 = A(y3));
  }
  for (u4.__e = b3, h3 = w4; h3--; ) null != m3[h3] && ("function" == typeof u4.type && null != m3[h3].__e && m3[h3].__e == u4.__d && (u4.__d = L(i3).nextSibling), q(m3[h3], m3[h3]));
  if (g4) for (h3 = 0; h3 < g4.length; h3++) S(g4[h3], g4[++h3], g4[++h3]);
}
function I(n2, l3, u4) {
  for (var i3, t3 = n2.__k, r3 = 0; t3 && r3 < t3.length; r3++) (i3 = t3[r3]) && (i3.__ = n2, l3 = "function" == typeof i3.type ? I(i3, l3, u4) : z(u4, i3, i3, t3, i3.__e, l3));
  return l3;
}
function j(n2, l3) {
  return l3 = l3 || [], null == n2 || "boolean" == typeof n2 || (Array.isArray(n2) ? n2.some(function(n3) {
    j(n3, l3);
  }) : l3.push(n2)), l3;
}
function z(n2, l3, u4, i3, t3, r3) {
  var o2, f3, e3;
  if (void 0 !== l3.__d) o2 = l3.__d, l3.__d = void 0;
  else if (null == u4 || t3 != r3 || null == t3.parentNode) n: if (null == r3 || r3.parentNode !== n2) n2.appendChild(t3), o2 = null;
  else {
    for (f3 = r3, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 1) if (f3 == t3) break n;
    n2.insertBefore(t3, r3), o2 = r3;
  }
  return void 0 !== o2 ? o2 : t3.nextSibling;
}
function L(n2) {
  var l3, u4, i3;
  if (null == n2.type || "string" == typeof n2.type) return n2.__e;
  if (n2.__k) {
    for (l3 = n2.__k.length - 1; l3 >= 0; l3--) if ((u4 = n2.__k[l3]) && (i3 = L(u4))) return i3;
  }
  return null;
}
function M(n2, u4, i3, t3, r3, o2, f3, e3, c3) {
  var s3, a3, v3, y3, p3, d2, k3, b3, g4, m3, w4, A3, P3, C3, T4, $3 = u4.type;
  if (void 0 !== u4.constructor) return null;
  null != i3.__h && (c3 = i3.__h, e3 = u4.__e = i3.__e, u4.__h = null, o2 = [e3]), (s3 = l.__b) && s3(u4);
  try {
    n: if ("function" == typeof $3) {
      if (b3 = u4.props, g4 = (s3 = $3.contextType) && t3[s3.__c], m3 = s3 ? g4 ? g4.props.value : s3.__ : t3, i3.__c ? k3 = (a3 = u4.__c = i3.__c).__ = a3.__E : ("prototype" in $3 && $3.prototype.render ? u4.__c = a3 = new $3(b3, m3) : (u4.__c = a3 = new x(b3, m3), a3.constructor = $3, a3.render = B), g4 && g4.sub(a3), a3.props = b3, a3.state || (a3.state = {}), a3.context = m3, a3.__n = t3, v3 = a3.__d = true, a3.__h = [], a3._sb = []), null == a3.__s && (a3.__s = a3.state), null != $3.getDerivedStateFromProps && (a3.__s == a3.state && (a3.__s = h({}, a3.__s)), h(a3.__s, $3.getDerivedStateFromProps(b3, a3.__s))), y3 = a3.props, p3 = a3.state, a3.__v = u4, v3) null == $3.getDerivedStateFromProps && null != a3.componentWillMount && a3.componentWillMount(), null != a3.componentDidMount && a3.__h.push(a3.componentDidMount);
      else {
        if (null == $3.getDerivedStateFromProps && b3 !== y3 && null != a3.componentWillReceiveProps && a3.componentWillReceiveProps(b3, m3), !a3.__e && null != a3.shouldComponentUpdate && false === a3.shouldComponentUpdate(b3, a3.__s, m3) || u4.__v === i3.__v) {
          for (u4.__v !== i3.__v && (a3.props = b3, a3.state = a3.__s, a3.__d = false), u4.__e = i3.__e, u4.__k = i3.__k, u4.__k.forEach(function(n3) {
            n3 && (n3.__ = u4);
          }), w4 = 0; w4 < a3._sb.length; w4++) a3.__h.push(a3._sb[w4]);
          a3._sb = [], a3.__h.length && f3.push(a3);
          break n;
        }
        null != a3.componentWillUpdate && a3.componentWillUpdate(b3, a3.__s, m3), null != a3.componentDidUpdate && a3.__h.push(function() {
          a3.componentDidUpdate(y3, p3, d2);
        });
      }
      if (a3.context = m3, a3.props = b3, a3.__P = n2, A3 = l.__r, P3 = 0, "prototype" in $3 && $3.prototype.render) {
        for (a3.state = a3.__s, a3.__d = false, A3 && A3(u4), s3 = a3.render(a3.props, a3.state, a3.context), C3 = 0; C3 < a3._sb.length; C3++) a3.__h.push(a3._sb[C3]);
        a3._sb = [];
      } else do {
        a3.__d = false, A3 && A3(u4), s3 = a3.render(a3.props, a3.state, a3.context), a3.state = a3.__s;
      } while (a3.__d && ++P3 < 25);
      a3.state = a3.__s, null != a3.getChildContext && (t3 = h(h({}, t3), a3.getChildContext())), v3 || null == a3.getSnapshotBeforeUpdate || (d2 = a3.getSnapshotBeforeUpdate(y3, p3)), T4 = null != s3 && s3.type === _ && null == s3.key ? s3.props.children : s3, H(n2, Array.isArray(T4) ? T4 : [T4], u4, i3, t3, r3, o2, f3, e3, c3), a3.base = u4.__e, u4.__h = null, a3.__h.length && f3.push(a3), k3 && (a3.__E = a3.__ = null), a3.__e = false;
    } else null == o2 && u4.__v === i3.__v ? (u4.__k = i3.__k, u4.__e = i3.__e) : u4.__e = O(i3.__e, u4, i3, t3, r3, o2, f3, c3);
    (s3 = l.diffed) && s3(u4);
  } catch (n3) {
    u4.__v = null, (c3 || null != o2) && (u4.__e = e3, u4.__h = !!c3, o2[o2.indexOf(e3)] = null), l.__e(n3, u4, i3);
  }
}
function N(n2, u4) {
  l.__c && l.__c(u4, n2), n2.some(function(u5) {
    try {
      n2 = u5.__h, u5.__h = [], n2.some(function(n3) {
        n3.call(u5);
      });
    } catch (n3) {
      l.__e(n3, u5.__v);
    }
  });
}
function O(l3, u4, i3, t3, r3, o2, f3, e3) {
  var s3, a3, h3, y3 = i3.props, p3 = u4.props, d2 = u4.type, _3 = 0;
  if ("svg" === d2 && (r3 = true), null != o2) {
    for (; _3 < o2.length; _3++) if ((s3 = o2[_3]) && "setAttribute" in s3 == !!d2 && (d2 ? s3.localName === d2 : 3 === s3.nodeType)) {
      l3 = s3, o2[_3] = null;
      break;
    }
  }
  if (null == l3) {
    if (null === d2) return document.createTextNode(p3);
    l3 = r3 ? document.createElementNS("http://www.w3.org/2000/svg", d2) : document.createElement(d2, p3.is && p3), o2 = null, e3 = false;
  }
  if (null === d2) y3 === p3 || e3 && l3.data === p3 || (l3.data = p3);
  else {
    if (o2 = o2 && n.call(l3.childNodes), a3 = (y3 = i3.props || c).dangerouslySetInnerHTML, h3 = p3.dangerouslySetInnerHTML, !e3) {
      if (null != o2) for (y3 = {}, _3 = 0; _3 < l3.attributes.length; _3++) y3[l3.attributes[_3].name] = l3.attributes[_3].value;
      (h3 || a3) && (h3 && (a3 && h3.__html == a3.__html || h3.__html === l3.innerHTML) || (l3.innerHTML = h3 && h3.__html || ""));
    }
    if (k(l3, p3, y3, r3, e3), h3) u4.__k = [];
    else if (_3 = u4.props.children, H(l3, Array.isArray(_3) ? _3 : [_3], u4, i3, t3, r3 && "foreignObject" !== d2, o2, f3, o2 ? o2[0] : i3.__k && A(i3, 0), e3), null != o2) for (_3 = o2.length; _3--; ) null != o2[_3] && v(o2[_3]);
    e3 || ("value" in p3 && void 0 !== (_3 = p3.value) && (_3 !== l3.value || "progress" === d2 && !_3 || "option" === d2 && _3 !== y3.value) && g(l3, "value", _3, y3.value, false), "checked" in p3 && void 0 !== (_3 = p3.checked) && _3 !== l3.checked && g(l3, "checked", _3, y3.checked, false));
  }
  return l3;
}
function S(n2, u4, i3) {
  try {
    "function" == typeof n2 ? n2(u4) : n2.current = u4;
  } catch (n3) {
    l.__e(n3, i3);
  }
}
function q(n2, u4, i3) {
  var t3, r3;
  if (l.unmount && l.unmount(n2), (t3 = n2.ref) && (t3.current && t3.current !== n2.__e || S(t3, null, u4)), null != (t3 = n2.__c)) {
    if (t3.componentWillUnmount) try {
      t3.componentWillUnmount();
    } catch (n3) {
      l.__e(n3, u4);
    }
    t3.base = t3.__P = null, n2.__c = void 0;
  }
  if (t3 = n2.__k) for (r3 = 0; r3 < t3.length; r3++) t3[r3] && q(t3[r3], u4, i3 || "function" != typeof n2.type);
  i3 || null == n2.__e || v(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function B(n2, l3, u4) {
  return this.constructor(n2, u4);
}
function D(u4, i3, t3) {
  var r3, o2, f3;
  l.__ && l.__(u4, i3), o2 = (r3 = "function" == typeof t3) ? null : t3 && t3.__k || i3.__k, f3 = [], M(i3, u4 = (!r3 && t3 || i3).__k = y(_, null, [u4]), o2 || c, c, void 0 !== i3.ownerSVGElement, !r3 && t3 ? [t3] : o2 ? null : i3.firstChild ? n.call(i3.childNodes) : null, f3, !r3 && t3 ? t3 : o2 ? o2.__e : i3.firstChild, r3), N(f3, u4);
}
function G(n2, l3) {
  var u4 = { __c: l3 = "__cC" + e++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u5, i3;
    return this.getChildContext || (u5 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u5.some(function(n5) {
        n5.__e = true, T(n5);
      });
    }, this.sub = function(n4) {
      u5.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u5.splice(u5.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u4.Provider.__ = u4.Consumer.contextType = u4;
}
n = s.slice, l = { __e: function(n2, l3, u4, i3) {
  for (var t3, r3, o2; l3 = l3.__; ) if ((t3 = l3.__c) && !t3.__) try {
    if ((r3 = t3.constructor) && null != r3.getDerivedStateFromError && (t3.setState(r3.getDerivedStateFromError(n2)), o2 = t3.__d), null != t3.componentDidCatch && (t3.componentDidCatch(n2, i3 || {}), o2 = t3.__d), o2) return t3.__E = t3;
  } catch (l4) {
    n2 = l4;
  }
  throw n2;
} }, u2 = 0, i = function(n2) {
  return null != n2 && void 0 === n2.constructor;
}, t = false, x.prototype.setState = function(n2, l3) {
  var u4;
  u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n2 && (n2 = n2(h({}, u4), this.props)), n2 && h(u4, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), T(this));
}, x.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), T(this));
}, x.prototype.render = _, r = [], f = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $.__r = 0, e = 0;

// node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u3;
var i2;
var f2 = [];
var c2 = [];
var e2 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function b2() {
  for (var t3; t3 = f2.shift(); ) if (t3.__P && t3.__H) try {
    t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
  } catch (r3) {
    t3.__H.__h = [], l.__e(r3, t3.__v);
  }
}
l.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, l.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i3 = (r2 = n2.__c).__H;
  i3 && (u3 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = void 0;
  })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u3 = r2;
}, l.diffed = function(t3) {
  v2 && v2(t3);
  var o2 = t3.__c;
  o2 && o2.__H && (o2.__H.__h.length && (1 !== f2.push(o2) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o2.__H.__.forEach(function(n2) {
    n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c2;
  })), u3 = r2 = null;
}, l.__c = function(t3, r3) {
  r3.some(function(t4) {
    try {
      t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n2) {
        return !n2.__ || w2(n2);
      });
    } catch (u4) {
      r3.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), r3 = [], l.__e(u4, t4.__v);
    }
  }), l2 && l2(t3, r3);
}, l.unmount = function(t3) {
  m2 && m2(t3);
  var r3, u4 = t3.__c;
  u4 && u4.__H && (u4.__H.__.forEach(function(n2) {
    try {
      k2(n2);
    } catch (n3) {
      r3 = n3;
    }
  }), u4.__H = void 0, r3 && l.__e(r3, u4.__v));
};
var g2 = "function" == typeof requestAnimationFrame;
function j2(n2) {
  var t3, r3 = function() {
    clearTimeout(u4), g2 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u4 = setTimeout(r3, 100);
  g2 && (t3 = requestAnimationFrame(r3));
}
function k2(n2) {
  var t3 = r2, u4 = n2.__c;
  "function" == typeof u4 && (n2.__c = void 0, u4()), r2 = t3;
}
function w2(n2) {
  var t3 = r2;
  n2.__c = n2.__(), r2 = t3;
}

// node_modules/preact/compat/dist/compat.module.js
function g3(n2, t3) {
  for (var e3 in t3) n2[e3] = t3[e3];
  return n2;
}
function C2(n2, t3) {
  for (var e3 in n2) if ("__source" !== e3 && !(e3 in t3)) return true;
  for (var r3 in t3) if ("__source" !== r3 && n2[r3] !== t3[r3]) return true;
  return false;
}
function w3(n2) {
  this.props = n2;
}
(w3.prototype = new x()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n2, t3) {
  return C2(this.props, n2) || C2(this.state, t3);
};
var x3 = l.__b;
l.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x3 && x3(n2);
};
var N2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
var T3 = l.__e;
l.__e = function(n2, t3, e3, r3) {
  if (n2.then) {
    for (var u4, o2 = t3; o2 = o2.__; ) if ((u4 = o2.__c) && u4.__c) return null == t3.__e && (t3.__e = e3.__e, t3.__k = e3.__k), u4.__c(n2, t3);
  }
  T3(n2, t3, e3, r3);
};
var I2 = l.unmount;
function L2(n2, t3, e3) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = g3({}, n2)).__c && (n2.__c.__P === e3 && (n2.__c.__P = t3), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return L2(n3, t3, e3);
  })), n2;
}
function U(n2, t3, e3) {
  return n2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return U(n3, t3, e3);
  }), n2.__c && n2.__c.__P === t3 && (n2.__e && e3.insertBefore(n2.__e, n2.__d), n2.__c.__e = true, n2.__c.__P = e3)), n2;
}
function D2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F3(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.__a && t3.__a(n2);
}
function V2() {
  this.u = null, this.o = null;
}
l.unmount = function(n2) {
  var t3 = n2.__c;
  t3 && t3.__R && t3.__R(), t3 && true === n2.__h && (n2.type = null), I2 && I2(n2);
}, (D2.prototype = new x()).__c = function(n2, t3) {
  var e3 = t3.__c, r3 = this;
  null == r3.t && (r3.t = []), r3.t.push(e3);
  var u4 = F3(r3.__v), o2 = false, i3 = function() {
    o2 || (o2 = true, e3.__R = null, u4 ? u4(l3) : l3());
  };
  e3.__R = i3;
  var l3 = function() {
    if (!--r3.__u) {
      if (r3.state.__a) {
        var n3 = r3.state.__a;
        r3.__v.__k[0] = U(n3, n3.__c.__P, n3.__c.__O);
      }
      var t4;
      for (r3.setState({ __a: r3.__b = null }); t4 = r3.t.pop(); ) t4.forceUpdate();
    }
  }, c3 = true === t3.__h;
  r3.__u++ || c3 || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n2.then(i3, i3);
}, D2.prototype.componentWillUnmount = function() {
  this.t = [];
}, D2.prototype.render = function(n2, e3) {
  if (this.__b) {
    if (this.__v.__k) {
      var r3 = document.createElement("div"), o2 = this.__v.__k[0].__c;
      this.__v.__k[0] = L2(this.__b, r3, o2.__O = o2.__P);
    }
    this.__b = null;
  }
  var i3 = e3.__a && y(_, null, n2.fallback);
  return i3 && (i3.__h = null), [y(_, null, e3.__a ? null : n2.children), i3];
};
var W = function(n2, t3, e3) {
  if (++e3[1] === e3[0] && n2.o.delete(t3), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.o.size)) for (e3 = n2.u; e3; ) {
    for (; e3.length > 3; ) e3.pop()();
    if (e3[1] < e3[0]) break;
    n2.u = e3 = e3[2];
  }
};
function P2(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function $2(n2) {
  var e3 = this, r3 = n2.i;
  e3.componentWillUnmount = function() {
    D(null, e3.l), e3.l = null, e3.i = null;
  }, e3.i && e3.i !== r3 && e3.componentWillUnmount(), n2.__v ? (e3.l || (e3.i = r3, e3.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, insertBefore: function(n3, t3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, removeChild: function(n3) {
    this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e3.i.removeChild(n3);
  } }), D(y(P2, { context: e3.context }, n2.__v), e3.l)) : e3.l && e3.componentWillUnmount();
}
function j3(n2, e3) {
  var r3 = y($2, { __v: n2, i: e3 });
  return r3.containerInfo = e3, r3;
}
(V2.prototype = new x()).__a = function(n2) {
  var t3 = this, e3 = F3(t3.__v), r3 = t3.o.get(n2);
  return r3[0]++, function(u4) {
    var o2 = function() {
      t3.props.revealOrder ? (r3.push(u4), W(t3, n2, r3)) : u4();
    };
    e3 ? e3(o2) : o2();
  };
}, V2.prototype.render = function(n2) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t3 = j(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t3.reverse();
  for (var e3 = t3.length; e3--; ) this.o.set(t3[e3], this.u = [1, 0, this.u]);
  return n2.children;
}, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
  var n2 = this;
  this.o.forEach(function(t3, e3) {
    W(n2, e3, t3);
  });
};
var z2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var B2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var H2 = "undefined" != typeof document;
var Z = function(n2) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n2);
};
x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
  Object.defineProperty(x.prototype, t3, { configurable: true, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n2) {
    Object.defineProperty(this, t3, { configurable: true, writable: true, value: n2 });
  } });
});
var G2 = l.event;
function J() {
}
function K() {
  return this.cancelBubble;
}
function Q() {
  return this.defaultPrevented;
}
l.event = function(n2) {
  return G2 && (n2 = G2(n2)), n2.persist = J, n2.isPropagationStopped = K, n2.isDefaultPrevented = Q, n2.nativeEvent = n2;
};
var X;
var nn = { configurable: true, get: function() {
  return this.class;
} };
var tn = l.vnode;
l.vnode = function(n2) {
  var t3 = n2.type, e3 = n2.props, u4 = e3;
  if ("string" == typeof t3) {
    var o2 = -1 === t3.indexOf("-");
    for (var i3 in u4 = {}, e3) {
      var l3 = e3[i3];
      H2 && "children" === i3 && "noscript" === t3 || "value" === i3 && "defaultValue" in e3 && null == l3 || ("defaultValue" === i3 && "value" in e3 && null == e3.value ? i3 = "value" : "download" === i3 && true === l3 ? l3 = "" : /ondoubleclick/i.test(i3) ? i3 = "ondblclick" : /^onchange(textarea|input)/i.test(i3 + t3) && !Z(e3.type) ? i3 = "oninput" : /^onfocus$/i.test(i3) ? i3 = "onfocusin" : /^onblur$/i.test(i3) ? i3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i3) ? i3 = i3.toLowerCase() : o2 && B2.test(i3) ? i3 = i3.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l3 && (l3 = void 0), /^oninput$/i.test(i3) && (i3 = i3.toLowerCase(), u4[i3] && (i3 = "oninputCapture")), u4[i3] = l3);
    }
    "select" == t3 && u4.multiple && Array.isArray(u4.value) && (u4.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = -1 != u4.value.indexOf(n3.props.value);
    })), "select" == t3 && null != u4.defaultValue && (u4.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = u4.multiple ? -1 != u4.defaultValue.indexOf(n3.props.value) : u4.defaultValue == n3.props.value;
    })), n2.props = u4, e3.class != e3.className && (nn.enumerable = "className" in e3, null != e3.className && (u4.class = e3.className), Object.defineProperty(u4, "className", nn));
  }
  n2.$$typeof = z2, tn && tn(n2);
};
var en = l.__r;
l.__r = function(n2) {
  en && en(n2), X = n2.__c;
};

// node_modules/@fullcalendar/core/internal-common.js
var styleTexts = [];
var styleEls = /* @__PURE__ */ new Map();
function injectStyles(styleText) {
  styleTexts.push(styleText);
  styleEls.forEach((styleEl) => {
    appendStylesTo(styleEl, styleText);
  });
}
function ensureElHasStyles(el) {
  if (el.isConnected && // sometimes true if SSR system simulates DOM
  el.getRootNode) {
    registerStylesRoot(el.getRootNode());
  }
}
function registerStylesRoot(rootNode) {
  let styleEl = styleEls.get(rootNode);
  if (!styleEl || !styleEl.isConnected) {
    styleEl = rootNode.querySelector("style[data-fullcalendar]");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.setAttribute("data-fullcalendar", "");
      const nonce = getNonceValue();
      if (nonce) {
        styleEl.nonce = nonce;
      }
      const parentEl = rootNode === document ? document.head : rootNode;
      const insertBefore = rootNode === document ? parentEl.querySelector("script,link[rel=stylesheet],link[as=style],style") : parentEl.firstChild;
      parentEl.insertBefore(styleEl, insertBefore);
    }
    styleEls.set(rootNode, styleEl);
    hydrateStylesRoot(styleEl);
  }
}
function hydrateStylesRoot(styleEl) {
  for (const styleText of styleTexts) {
    appendStylesTo(styleEl, styleText);
  }
}
function appendStylesTo(styleEl, styleText) {
  const { sheet } = styleEl;
  const ruleCnt = sheet.cssRules.length;
  styleText.split("}").forEach((styleStr, i3) => {
    styleStr = styleStr.trim();
    if (styleStr) {
      sheet.insertRule(styleStr + "}", ruleCnt + i3);
    }
  });
}
var queriedNonceValue;
function getNonceValue() {
  if (queriedNonceValue === void 0) {
    queriedNonceValue = queryNonceValue();
  }
  return queriedNonceValue;
}
function queryNonceValue() {
  const metaWithNonce = document.querySelector('meta[name="csp-nonce"]');
  if (metaWithNonce && metaWithNonce.hasAttribute("content")) {
    return metaWithNonce.getAttribute("content");
  }
  const elWithNonce = document.querySelector("script[nonce]");
  if (elWithNonce) {
    return elWithNonce.nonce || "";
  }
  return "";
}
if (typeof document !== "undefined") {
  registerStylesRoot(document);
}
var css_248z = ':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url("data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") format("truetype")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:"\\e900"}.fc-icon-chevron-right:before{content:"\\e901"}.fc-icon-chevrons-left:before{content:"\\e902"}.fc-icon-chevrons-right:before{content:"\\e903"}.fc-icon-minus-square:before{content:"\\e904"}.fc-icon-plus-square:before{content:"\\e905"}.fc-icon-x:before{content:"\\e906"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:"";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:"";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:"";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}';
injectStyles(css_248z);
var DelayedRunner = class {
  constructor(drainedOption) {
    this.drainedOption = drainedOption;
    this.isRunning = false;
    this.isDirty = false;
    this.pauseDepths = {};
    this.timeoutId = 0;
  }
  request(delay) {
    this.isDirty = true;
    if (!this.isPaused()) {
      this.clearTimeout();
      if (delay == null) {
        this.tryDrain();
      } else {
        this.timeoutId = setTimeout(
          // NOT OPTIMAL! TODO: look at debounce
          this.tryDrain.bind(this),
          delay
        );
      }
    }
  }
  pause(scope = "") {
    let { pauseDepths } = this;
    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
    this.clearTimeout();
  }
  resume(scope = "", force) {
    let { pauseDepths } = this;
    if (scope in pauseDepths) {
      if (force) {
        delete pauseDepths[scope];
      } else {
        pauseDepths[scope] -= 1;
        let depth = pauseDepths[scope];
        if (depth <= 0) {
          delete pauseDepths[scope];
        }
      }
      this.tryDrain();
    }
  }
  isPaused() {
    return Object.keys(this.pauseDepths).length;
  }
  tryDrain() {
    if (!this.isRunning && !this.isPaused()) {
      this.isRunning = true;
      while (this.isDirty) {
        this.isDirty = false;
        this.drained();
      }
      this.isRunning = false;
    }
  }
  clear() {
    this.clearTimeout();
    this.isDirty = false;
    this.pauseDepths = {};
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = 0;
    }
  }
  drained() {
    if (this.drainedOption) {
      this.drainedOption();
    }
  }
};
function removeElement(el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
}
function elementClosest(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  if (!document.documentElement.contains(el)) {
    return null;
  }
  do {
    if (elementMatches(el, selector)) {
      return el;
    }
    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);
  return null;
}
function elementMatches(el, selector) {
  let method = el.matches || el.matchesSelector || el.msMatchesSelector;
  return method.call(el, selector);
}
function findElements(container, selector) {
  let containers = container instanceof HTMLElement ? [container] : container;
  let allMatches = [];
  for (let i3 = 0; i3 < containers.length; i3 += 1) {
    let matches = containers[i3].querySelectorAll(selector);
    for (let j4 = 0; j4 < matches.length; j4 += 1) {
      allMatches.push(matches[j4]);
    }
  }
  return allMatches;
}
var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
function applyStyle(el, props) {
  for (let propName in props) {
    applyStyleProp(el, propName, props[propName]);
  }
}
function applyStyleProp(el, name, val) {
  if (val == null) {
    el.style[name] = "";
  } else if (typeof val === "number" && PIXEL_PROP_RE.test(name)) {
    el.style[name] = `${val}px`;
  } else {
    el.style[name] = val;
  }
}
function getEventTargetViaRoot(ev) {
  var _a, _b;
  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
}
var guid$1 = 0;
function getUniqueDomId() {
  guid$1 += 1;
  return "fc-dom-" + guid$1;
}
function preventDefault(ev) {
  ev.preventDefault();
}
function buildDelegationHandler(selector, handler) {
  return (ev) => {
    let matchedChild = elementClosest(ev.target, selector);
    if (matchedChild) {
      handler.call(matchedChild, ev, matchedChild);
    }
  };
}
function listenBySelector(container, eventType, selector, handler) {
  let attachedHandler = buildDelegationHandler(selector, handler);
  container.addEventListener(eventType, attachedHandler);
  return () => {
    container.removeEventListener(eventType, attachedHandler);
  };
}
function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
  let currentMatchedChild;
  return listenBySelector(container, "mouseover", selector, (mouseOverEv, matchedChild) => {
    if (matchedChild !== currentMatchedChild) {
      currentMatchedChild = matchedChild;
      onMouseEnter(mouseOverEv, matchedChild);
      let realOnMouseLeave = (mouseLeaveEv) => {
        currentMatchedChild = null;
        onMouseLeave(mouseLeaveEv, matchedChild);
        matchedChild.removeEventListener("mouseleave", realOnMouseLeave);
      };
      matchedChild.addEventListener("mouseleave", realOnMouseLeave);
    }
  });
}
var transitionEventNames = [
  "webkitTransitionEnd",
  "otransitionend",
  "oTransitionEnd",
  "msTransitionEnd",
  "transitionend"
];
function whenTransitionDone(el, callback) {
  let realCallback = (ev) => {
    callback(ev);
    transitionEventNames.forEach((eventName) => {
      el.removeEventListener(eventName, realCallback);
    });
  };
  transitionEventNames.forEach((eventName) => {
    el.addEventListener(eventName, realCallback);
  });
}
function createAriaClickAttrs(handler) {
  return Object.assign({ onClick: handler }, createAriaKeyboardAttrs(handler));
}
function createAriaKeyboardAttrs(handler) {
  return {
    tabIndex: 0,
    onKeyDown(ev) {
      if (ev.key === "Enter" || ev.key === " ") {
        handler(ev);
        ev.preventDefault();
      }
    }
  };
}
var guidNumber = 0;
function guid() {
  guidNumber += 1;
  return String(guidNumber);
}
function disableCursor() {
  document.body.classList.add("fc-not-allowed");
}
function enableCursor() {
  document.body.classList.remove("fc-not-allowed");
}
function preventSelection(el) {
  el.style.userSelect = "none";
  el.style.webkitUserSelect = "none";
  el.addEventListener("selectstart", preventDefault);
}
function allowSelection(el) {
  el.style.userSelect = "";
  el.style.webkitUserSelect = "";
  el.removeEventListener("selectstart", preventDefault);
}
function preventContextMenu(el) {
  el.addEventListener("contextmenu", preventDefault);
}
function allowContextMenu(el) {
  el.removeEventListener("contextmenu", preventDefault);
}
function parseFieldSpecs(input2) {
  let specs = [];
  let tokens = [];
  let i3;
  let token;
  if (typeof input2 === "string") {
    tokens = input2.split(/\s*,\s*/);
  } else if (typeof input2 === "function") {
    tokens = [input2];
  } else if (Array.isArray(input2)) {
    tokens = input2;
  }
  for (i3 = 0; i3 < tokens.length; i3 += 1) {
    token = tokens[i3];
    if (typeof token === "string") {
      specs.push(token.charAt(0) === "-" ? { field: token.substring(1), order: -1 } : { field: token, order: 1 });
    } else if (typeof token === "function") {
      specs.push({ func: token });
    }
  }
  return specs;
}
function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
  let i3;
  let cmp;
  for (i3 = 0; i3 < fieldSpecs.length; i3 += 1) {
    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i3]);
    if (cmp) {
      return cmp;
    }
  }
  return 0;
}
function compareByFieldSpec(obj0, obj1, fieldSpec) {
  if (fieldSpec.func) {
    return fieldSpec.func(obj0, obj1);
  }
  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
}
function flexibleCompare(a3, b3) {
  if (!a3 && !b3) {
    return 0;
  }
  if (b3 == null) {
    return -1;
  }
  if (a3 == null) {
    return 1;
  }
  if (typeof a3 === "string" || typeof b3 === "string") {
    return String(a3).localeCompare(String(b3));
  }
  return a3 - b3;
}
function padStart(val, len) {
  let s3 = String(val);
  return "000".substr(0, len - s3.length) + s3;
}
function formatWithOrdinals(formatter, args, fallbackText) {
  if (typeof formatter === "function") {
    return formatter(...args);
  }
  if (typeof formatter === "string") {
    return args.reduce((str, arg, index3) => str.replace("$" + index3, arg || ""), formatter);
  }
  return fallbackText;
}
function compareNumbers(a3, b3) {
  return a3 - b3;
}
function isInt(n2) {
  return n2 % 1 === 0;
}
function computeSmallestCellWidth(cellEl) {
  let allWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-frame");
  let contentWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-cushion");
  if (!allWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-frame className");
  }
  if (!contentWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-cushion className");
  }
  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
  contentWidthEl.getBoundingClientRect().width;
}
var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
function createDuration(input2, unit) {
  if (typeof input2 === "string") {
    return parseString(input2);
  }
  if (typeof input2 === "object" && input2) {
    return parseObject(input2);
  }
  if (typeof input2 === "number") {
    return parseObject({ [unit || "milliseconds"]: input2 });
  }
  return null;
}
function parseString(s3) {
  let m3 = PARSE_RE.exec(s3);
  if (m3) {
    let sign = m3[1] ? -1 : 1;
    return {
      years: 0,
      months: 0,
      days: sign * (m3[2] ? parseInt(m3[2], 10) : 0),
      milliseconds: sign * ((m3[3] ? parseInt(m3[3], 10) : 0) * 60 * 60 * 1e3 + // hours
      (m3[4] ? parseInt(m3[4], 10) : 0) * 60 * 1e3 + // minutes
      (m3[5] ? parseInt(m3[5], 10) : 0) * 1e3 + // seconds
      (m3[6] ? parseInt(m3[6], 10) : 0))
    };
  }
  return null;
}
function parseObject(obj) {
  let duration = {
    years: obj.years || obj.year || 0,
    months: obj.months || obj.month || 0,
    days: obj.days || obj.day || 0,
    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1e3 + // hours
    (obj.minutes || obj.minute || 0) * 60 * 1e3 + // minutes
    (obj.seconds || obj.second || 0) * 1e3 + // seconds
    (obj.milliseconds || obj.millisecond || obj.ms || 0)
    // ms
  };
  let weeks = obj.weeks || obj.week;
  if (weeks) {
    duration.days += weeks * 7;
    duration.specifiedWeeks = true;
  }
  return duration;
}
function durationsEqual(d0, d1) {
  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
}
function subtractDurations(d1, d0) {
  return {
    years: d1.years - d0.years,
    months: d1.months - d0.months,
    days: d1.days - d0.days,
    milliseconds: d1.milliseconds - d0.milliseconds
  };
}
function asRoughYears(dur) {
  return asRoughDays(dur) / 365;
}
function asRoughMonths(dur) {
  return asRoughDays(dur) / 30;
}
function asRoughDays(dur) {
  return asRoughMs(dur) / 864e5;
}
function asRoughMs(dur) {
  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
}
function greatestDurationDenominator(dur) {
  let ms = dur.milliseconds;
  if (ms) {
    if (ms % 1e3 !== 0) {
      return { unit: "millisecond", value: ms };
    }
    if (ms % (1e3 * 60) !== 0) {
      return { unit: "second", value: ms / 1e3 };
    }
    if (ms % (1e3 * 60 * 60) !== 0) {
      return { unit: "minute", value: ms / (1e3 * 60) };
    }
    if (ms) {
      return { unit: "hour", value: ms / (1e3 * 60 * 60) };
    }
  }
  if (dur.days) {
    if (dur.specifiedWeeks && dur.days % 7 === 0) {
      return { unit: "week", value: dur.days / 7 };
    }
    return { unit: "day", value: dur.days };
  }
  if (dur.months) {
    return { unit: "month", value: dur.months };
  }
  if (dur.years) {
    return { unit: "year", value: dur.years };
  }
  return { unit: "millisecond", value: 0 };
}
function isArraysEqual(a0, a1, equalityFunc) {
  if (a0 === a1) {
    return true;
  }
  let len = a0.length;
  let i3;
  if (len !== a1.length) {
    return false;
  }
  for (i3 = 0; i3 < len; i3 += 1) {
    if (!(equalityFunc ? equalityFunc(a0[i3], a1[i3]) : a0[i3] === a1[i3])) {
      return false;
    }
  }
  return true;
}
var DAY_IDS = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function addWeeks(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2 * 7;
  return arrayToUtcDate(a3);
}
function addDays(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2;
  return arrayToUtcDate(a3);
}
function addMs(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[6] += n2;
  return arrayToUtcDate(a3);
}
function diffWeeks(m0, m1) {
  return diffDays(m0, m1) / 7;
}
function diffDays(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60 * 24);
}
function diffHours(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60);
}
function diffMinutes(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60);
}
function diffSeconds(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / 1e3;
}
function diffDayAndTime(m0, m1) {
  let m0day = startOfDay(m0);
  let m1day = startOfDay(m1);
  return {
    years: 0,
    months: 0,
    days: Math.round(diffDays(m0day, m1day)),
    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
  };
}
function diffWholeWeeks(m0, m1) {
  let d2 = diffWholeDays(m0, m1);
  if (d2 !== null && d2 % 7 === 0) {
    return d2 / 7;
  }
  return null;
}
function diffWholeDays(m0, m1) {
  if (timeAsMs(m0) === timeAsMs(m1)) {
    return Math.round(diffDays(m0, m1));
  }
  return null;
}
function startOfDay(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate()
  ]);
}
function startOfHour(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours()
  ]);
}
function startOfMinute(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes()
  ]);
}
function startOfSecond(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes(),
    m3.getUTCSeconds()
  ]);
}
function weekOfYear(marker, dow, doy) {
  let y3 = marker.getUTCFullYear();
  let w4 = weekOfGivenYear(marker, y3, dow, doy);
  if (w4 < 1) {
    return weekOfGivenYear(marker, y3 - 1, dow, doy);
  }
  let nextW = weekOfGivenYear(marker, y3 + 1, dow, doy);
  if (nextW >= 1) {
    return Math.min(w4, nextW);
  }
  return w4;
}
function weekOfGivenYear(marker, year, dow, doy) {
  let firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
  let dayStart = startOfDay(marker);
  let days = Math.round(diffDays(firstWeekStart, dayStart));
  return Math.floor(days / 7) + 1;
}
function firstWeekOffset(year, dow, doy) {
  let fwd = 7 + dow - doy;
  let fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dateToLocalArray(date) {
  return [
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  ];
}
function arrayToLocalDate(a3) {
  return new Date(
    a3[0],
    a3[1] || 0,
    a3[2] == null ? 1 : a3[2],
    // day of month
    a3[3] || 0,
    a3[4] || 0,
    a3[5] || 0
  );
}
function dateToUtcArray(date) {
  return [
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds(),
    date.getUTCMilliseconds()
  ];
}
function arrayToUtcDate(a3) {
  if (a3.length === 1) {
    a3 = a3.concat([0]);
  }
  return new Date(Date.UTC(...a3));
}
function isValidDate(m3) {
  return !isNaN(m3.valueOf());
}
function timeAsMs(m3) {
  return m3.getUTCHours() * 1e3 * 60 * 60 + m3.getUTCMinutes() * 1e3 * 60 + m3.getUTCSeconds() * 1e3 + m3.getUTCMilliseconds();
}
function buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {
  let s3 = marker.toISOString();
  s3 = s3.replace(".000", "");
  if (stripZeroTime) {
    s3 = s3.replace("T00:00:00Z", "");
  }
  if (s3.length > 10) {
    if (timeZoneOffset == null) {
      s3 = s3.replace("Z", "");
    } else if (timeZoneOffset !== 0) {
      s3 = s3.replace("Z", formatTimeZoneOffset(timeZoneOffset, true));
    }
  }
  return s3;
}
function formatDayString(marker) {
  return marker.toISOString().replace(/T.*$/, "");
}
function formatIsoMonthStr(marker) {
  return marker.toISOString().match(/^\d{4}-\d{2}/)[0];
}
function formatTimeZoneOffset(minutes, doIso = false) {
  let sign = minutes < 0 ? "-" : "+";
  let abs = Math.abs(minutes);
  let hours = Math.floor(abs / 60);
  let mins = Math.round(abs % 60);
  if (doIso) {
    return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;
  }
  return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : ""}`;
}
function memoize(workerFunc, resEquality, teardownFunc) {
  let currentArgs;
  let currentRes;
  return function(...newArgs) {
    if (!currentArgs) {
      currentRes = workerFunc.apply(this, newArgs);
    } else if (!isArraysEqual(currentArgs, newArgs)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.apply(this, newArgs);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArgs = newArgs;
    return currentRes;
  };
}
function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
  let currentArg;
  let currentRes;
  return (newArg) => {
    if (!currentArg) {
      currentRes = workerFunc.call(this, newArg);
    } else if (!isPropsEqual(currentArg, newArg)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.call(this, newArg);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArg = newArg;
    return currentRes;
  };
}
var EXTENDED_SETTINGS_AND_SEVERITIES = {
  week: 3,
  separator: 0,
  omitZeroMinute: 0,
  meridiem: 0,
  omitCommas: 0
};
var STANDARD_DATE_PROP_SEVERITIES = {
  timeZoneName: 7,
  era: 6,
  year: 5,
  month: 4,
  day: 2,
  weekday: 2,
  hour: 1,
  minute: 1,
  second: 1
};
var MERIDIEM_RE = /\s*([ap])\.?m\.?/i;
var COMMA_RE = /,/g;
var MULTI_SPACE_RE = /\s+/g;
var LTR_RE = /\u200e/g;
var UTC_RE = /UTC|GMT/;
var NativeFormatter = class {
  constructor(formatSettings) {
    let standardDateProps = {};
    let extendedSettings = {};
    let severity = 0;
    for (let name in formatSettings) {
      if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {
        extendedSettings[name] = formatSettings[name];
        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);
      } else {
        standardDateProps[name] = formatSettings[name];
        if (name in STANDARD_DATE_PROP_SEVERITIES) {
          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);
        }
      }
    }
    this.standardDateProps = standardDateProps;
    this.extendedSettings = extendedSettings;
    this.severity = severity;
    this.buildFormattingFunc = memoize(buildFormattingFunc);
  }
  format(date, context2) {
    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context2)(date);
  }
  formatRange(start, end, context2, betterDefaultSeparator) {
    let { standardDateProps, extendedSettings } = this;
    let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context2.calendarSystem);
    if (!diffSeverity) {
      return this.format(start, context2);
    }
    let biggestUnitForPartial = diffSeverity;
    if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time
    (standardDateProps.year === "numeric" || standardDateProps.year === "2-digit") && (standardDateProps.month === "numeric" || standardDateProps.month === "2-digit") && (standardDateProps.day === "numeric" || standardDateProps.day === "2-digit")) {
      biggestUnitForPartial = 1;
    }
    let full0 = this.format(start, context2);
    let full1 = this.format(end, context2);
    if (full0 === full1) {
      return full0;
    }
    let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
    let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context2);
    let partial0 = partialFormattingFunc(start);
    let partial1 = partialFormattingFunc(end);
    let insertion = findCommonInsertion(full0, partial0, full1, partial1);
    let separator = extendedSettings.separator || betterDefaultSeparator || context2.defaultSeparator || "";
    if (insertion) {
      return insertion.before + partial0 + separator + partial1 + insertion.after;
    }
    return full0 + separator + full1;
  }
  getLargestUnit() {
    switch (this.severity) {
      case 7:
      case 6:
      case 5:
        return "year";
      case 4:
        return "month";
      case 3:
        return "week";
      case 2:
        return "day";
      default:
        return "time";
    }
  }
};
function buildFormattingFunc(standardDateProps, extendedSettings, context2) {
  let standardDatePropCnt = Object.keys(standardDateProps).length;
  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === "short") {
    return (date) => formatTimeZoneOffset(date.timeZoneOffset);
  }
  if (standardDatePropCnt === 0 && extendedSettings.week) {
    return (date) => formatWeekNumber(context2.computeWeekNumber(date.marker), context2.weekText, context2.weekTextLong, context2.locale, extendedSettings.week);
  }
  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context2);
}
function buildNativeFormattingFunc(standardDateProps, extendedSettings, context2) {
  standardDateProps = Object.assign({}, standardDateProps);
  extendedSettings = Object.assign({}, extendedSettings);
  sanitizeSettings(standardDateProps, extendedSettings);
  standardDateProps.timeZone = "UTC";
  let normalFormat = new Intl.DateTimeFormat(context2.locale.codes, standardDateProps);
  let zeroFormat;
  if (extendedSettings.omitZeroMinute) {
    let zeroProps = Object.assign({}, standardDateProps);
    delete zeroProps.minute;
    zeroFormat = new Intl.DateTimeFormat(context2.locale.codes, zeroProps);
  }
  return (date) => {
    let { marker } = date;
    let format;
    if (zeroFormat && !marker.getUTCMinutes()) {
      format = zeroFormat;
    } else {
      format = normalFormat;
    }
    let s3 = format.format(marker);
    return postProcess(s3, date, standardDateProps, extendedSettings, context2);
  };
}
function sanitizeSettings(standardDateProps, extendedSettings) {
  if (standardDateProps.timeZoneName) {
    if (!standardDateProps.hour) {
      standardDateProps.hour = "2-digit";
    }
    if (!standardDateProps.minute) {
      standardDateProps.minute = "2-digit";
    }
  }
  if (standardDateProps.timeZoneName === "long") {
    standardDateProps.timeZoneName = "short";
  }
  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
    delete extendedSettings.omitZeroMinute;
  }
}
function postProcess(s3, date, standardDateProps, extendedSettings, context2) {
  s3 = s3.replace(LTR_RE, "");
  if (standardDateProps.timeZoneName === "short") {
    s3 = injectTzoStr(s3, context2.timeZone === "UTC" || date.timeZoneOffset == null ? "UTC" : (
      // important to normalize for IE, which does "GMT"
      formatTimeZoneOffset(date.timeZoneOffset)
    ));
  }
  if (extendedSettings.omitCommas) {
    s3 = s3.replace(COMMA_RE, "").trim();
  }
  if (extendedSettings.omitZeroMinute) {
    s3 = s3.replace(":00", "");
  }
  if (extendedSettings.meridiem === false) {
    s3 = s3.replace(MERIDIEM_RE, "").trim();
  } else if (extendedSettings.meridiem === "narrow") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => m1.toLocaleLowerCase());
  } else if (extendedSettings.meridiem === "short") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => `${m1.toLocaleLowerCase()}m`);
  } else if (extendedSettings.meridiem === "lowercase") {
    s3 = s3.replace(MERIDIEM_RE, (m0) => m0.toLocaleLowerCase());
  }
  s3 = s3.replace(MULTI_SPACE_RE, " ");
  s3 = s3.trim();
  return s3;
}
function injectTzoStr(s3, tzoStr) {
  let replaced = false;
  s3 = s3.replace(UTC_RE, () => {
    replaced = true;
    return tzoStr;
  });
  if (!replaced) {
    s3 += ` ${tzoStr}`;
  }
  return s3;
}
function formatWeekNumber(num, weekText, weekTextLong, locale, display) {
  let parts = [];
  if (display === "long") {
    parts.push(weekTextLong);
  } else if (display === "short" || display === "narrow") {
    parts.push(weekText);
  }
  if (display === "long" || display === "short") {
    parts.push(" ");
  }
  parts.push(locale.simpleNumberFormat.format(num));
  if (locale.options.direction === "rtl") {
    parts.reverse();
  }
  return parts.join("");
}
function computeMarkerDiffSeverity(d0, d1, ca) {
  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
    return 5;
  }
  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
    return 4;
  }
  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
    return 2;
  }
  if (timeAsMs(d0) !== timeAsMs(d1)) {
    return 1;
  }
  return 0;
}
function computePartialFormattingOptions(options, biggestUnit) {
  let partialOptions = {};
  for (let name in options) {
    if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
    STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {
      partialOptions[name] = options[name];
    }
  }
  return partialOptions;
}
function findCommonInsertion(full0, partial0, full1, partial1) {
  let i0 = 0;
  while (i0 < full0.length) {
    let found0 = full0.indexOf(partial0, i0);
    if (found0 === -1) {
      break;
    }
    let before0 = full0.substr(0, found0);
    i0 = found0 + partial0.length;
    let after0 = full0.substr(i0);
    let i1 = 0;
    while (i1 < full1.length) {
      let found1 = full1.indexOf(partial1, i1);
      if (found1 === -1) {
        break;
      }
      let before1 = full1.substr(0, found1);
      i1 = found1 + partial1.length;
      let after1 = full1.substr(i1);
      if (before0 === before1 && after0 === after1) {
        return {
          before: before0,
          after: after0
        };
      }
    }
  }
  return null;
}
function expandZonedMarker(dateInfo, calendarSystem) {
  let a3 = calendarSystem.markerToArray(dateInfo.marker);
  return {
    marker: dateInfo.marker,
    timeZoneOffset: dateInfo.timeZoneOffset,
    array: a3,
    year: a3[0],
    month: a3[1],
    day: a3[2],
    hour: a3[3],
    minute: a3[4],
    second: a3[5],
    millisecond: a3[6]
  };
}
function createVerboseFormattingArg(start, end, context2, betterDefaultSeparator) {
  let startInfo = expandZonedMarker(start, context2.calendarSystem);
  let endInfo = end ? expandZonedMarker(end, context2.calendarSystem) : null;
  return {
    date: startInfo,
    start: startInfo,
    end: endInfo,
    timeZone: context2.timeZone,
    localeCodes: context2.locale.codes,
    defaultSeparator: betterDefaultSeparator || context2.defaultSeparator
  };
}
var CmdFormatter = class {
  constructor(cmdStr) {
    this.cmdStr = cmdStr;
  }
  format(date, context2, betterDefaultSeparator) {
    return context2.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context2, betterDefaultSeparator));
  }
  formatRange(start, end, context2, betterDefaultSeparator) {
    return context2.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context2, betterDefaultSeparator));
  }
};
var FuncFormatter = class {
  constructor(func) {
    this.func = func;
  }
  format(date, context2, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(date, null, context2, betterDefaultSeparator));
  }
  formatRange(start, end, context2, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(start, end, context2, betterDefaultSeparator));
  }
};
function createFormatter(input2) {
  if (typeof input2 === "object" && input2) {
    return new NativeFormatter(input2);
  }
  if (typeof input2 === "string") {
    return new CmdFormatter(input2);
  }
  if (typeof input2 === "function") {
    return new FuncFormatter(input2);
  }
  return null;
}
var BASE_OPTION_REFINERS = {
  navLinkDayClick: identity2,
  navLinkWeekClick: identity2,
  duration: createDuration,
  bootstrapFontAwesome: identity2,
  buttonIcons: identity2,
  customButtons: identity2,
  defaultAllDayEventDuration: createDuration,
  defaultTimedEventDuration: createDuration,
  nextDayThreshold: createDuration,
  scrollTime: createDuration,
  scrollTimeReset: Boolean,
  slotMinTime: createDuration,
  slotMaxTime: createDuration,
  dayPopoverFormat: createFormatter,
  slotDuration: createDuration,
  snapDuration: createDuration,
  headerToolbar: identity2,
  footerToolbar: identity2,
  defaultRangeSeparator: String,
  titleRangeSeparator: String,
  forceEventDuration: Boolean,
  dayHeaders: Boolean,
  dayHeaderFormat: createFormatter,
  dayHeaderClassNames: identity2,
  dayHeaderContent: identity2,
  dayHeaderDidMount: identity2,
  dayHeaderWillUnmount: identity2,
  dayCellClassNames: identity2,
  dayCellContent: identity2,
  dayCellDidMount: identity2,
  dayCellWillUnmount: identity2,
  initialView: String,
  aspectRatio: Number,
  weekends: Boolean,
  weekNumberCalculation: identity2,
  weekNumbers: Boolean,
  weekNumberClassNames: identity2,
  weekNumberContent: identity2,
  weekNumberDidMount: identity2,
  weekNumberWillUnmount: identity2,
  editable: Boolean,
  viewClassNames: identity2,
  viewDidMount: identity2,
  viewWillUnmount: identity2,
  nowIndicator: Boolean,
  nowIndicatorClassNames: identity2,
  nowIndicatorContent: identity2,
  nowIndicatorDidMount: identity2,
  nowIndicatorWillUnmount: identity2,
  showNonCurrentDates: Boolean,
  lazyFetching: Boolean,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  timeZone: String,
  locales: identity2,
  locale: identity2,
  themeSystem: String,
  dragRevertDuration: Number,
  dragScroll: Boolean,
  allDayMaintainDuration: Boolean,
  unselectAuto: Boolean,
  dropAccept: identity2,
  eventOrder: parseFieldSpecs,
  eventOrderStrict: Boolean,
  handleWindowResize: Boolean,
  windowResizeDelay: Number,
  longPressDelay: Number,
  eventDragMinDistance: Number,
  expandRows: Boolean,
  height: identity2,
  contentHeight: identity2,
  direction: String,
  weekNumberFormat: createFormatter,
  eventResizableFromStart: Boolean,
  displayEventTime: Boolean,
  displayEventEnd: Boolean,
  weekText: String,
  weekTextLong: String,
  progressiveEventRendering: Boolean,
  businessHours: identity2,
  initialDate: identity2,
  now: identity2,
  eventDataTransform: identity2,
  stickyHeaderDates: identity2,
  stickyFooterScrollbar: identity2,
  viewHeight: identity2,
  defaultAllDay: Boolean,
  eventSourceFailure: identity2,
  eventSourceSuccess: identity2,
  eventDisplay: String,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventOverlap: identity2,
  eventConstraint: identity2,
  eventAllow: identity2,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String,
  eventClassNames: identity2,
  eventContent: identity2,
  eventDidMount: identity2,
  eventWillUnmount: identity2,
  selectConstraint: identity2,
  selectOverlap: identity2,
  selectAllow: identity2,
  droppable: Boolean,
  unselectCancel: String,
  slotLabelFormat: identity2,
  slotLaneClassNames: identity2,
  slotLaneContent: identity2,
  slotLaneDidMount: identity2,
  slotLaneWillUnmount: identity2,
  slotLabelClassNames: identity2,
  slotLabelContent: identity2,
  slotLabelDidMount: identity2,
  slotLabelWillUnmount: identity2,
  dayMaxEvents: identity2,
  dayMaxEventRows: identity2,
  dayMinWidth: Number,
  slotLabelInterval: createDuration,
  allDayText: String,
  allDayClassNames: identity2,
  allDayContent: identity2,
  allDayDidMount: identity2,
  allDayWillUnmount: identity2,
  slotMinWidth: Number,
  navLinks: Boolean,
  eventTimeFormat: createFormatter,
  rerenderDelay: Number,
  moreLinkText: identity2,
  moreLinkHint: identity2,
  selectMinDistance: Number,
  selectable: Boolean,
  selectLongPressDelay: Number,
  eventLongPressDelay: Number,
  selectMirror: Boolean,
  eventMaxStack: Number,
  eventMinHeight: Number,
  eventMinWidth: Number,
  eventShortHeight: Number,
  slotEventOverlap: Boolean,
  plugins: identity2,
  firstDay: Number,
  dayCount: Number,
  dateAlignment: String,
  dateIncrement: createDuration,
  hiddenDays: identity2,
  fixedWeekCount: Boolean,
  validRange: identity2,
  visibleRange: identity2,
  titleFormat: identity2,
  eventInteractive: Boolean,
  // only used by list-view, but languages define the value, so we need it in base options
  noEventsText: String,
  viewHint: identity2,
  navLinkHint: identity2,
  closeHint: String,
  timeHint: String,
  eventHint: String,
  moreLinkClick: identity2,
  moreLinkClassNames: identity2,
  moreLinkContent: identity2,
  moreLinkDidMount: identity2,
  moreLinkWillUnmount: identity2,
  monthStartFormat: createFormatter,
  // for connectors
  // (can't be part of plugin system b/c must be provided at runtime)
  handleCustomRendering: identity2,
  customRenderingMetaMap: identity2,
  customRenderingReplaces: Boolean
};
var BASE_OPTION_DEFAULTS = {
  eventDisplay: "auto",
  defaultRangeSeparator: " - ",
  titleRangeSeparator: " \u2013 ",
  defaultTimedEventDuration: "01:00:00",
  defaultAllDayEventDuration: { day: 1 },
  forceEventDuration: false,
  nextDayThreshold: "00:00:00",
  dayHeaders: true,
  initialView: "",
  aspectRatio: 1.35,
  headerToolbar: {
    start: "title",
    center: "",
    end: "today prev,next"
  },
  weekends: true,
  weekNumbers: false,
  weekNumberCalculation: "local",
  editable: false,
  nowIndicator: false,
  scrollTime: "06:00:00",
  scrollTimeReset: true,
  slotMinTime: "00:00:00",
  slotMaxTime: "24:00:00",
  showNonCurrentDates: true,
  lazyFetching: true,
  startParam: "start",
  endParam: "end",
  timeZoneParam: "timeZone",
  timeZone: "local",
  locales: [],
  locale: "",
  themeSystem: "standard",
  dragRevertDuration: 500,
  dragScroll: true,
  allDayMaintainDuration: false,
  unselectAuto: true,
  dropAccept: "*",
  eventOrder: "start,-duration,allDay,title",
  dayPopoverFormat: { month: "long", day: "numeric", year: "numeric" },
  handleWindowResize: true,
  windowResizeDelay: 100,
  longPressDelay: 1e3,
  eventDragMinDistance: 5,
  expandRows: false,
  navLinks: false,
  selectable: false,
  eventMinHeight: 15,
  eventMinWidth: 30,
  eventShortHeight: 30,
  monthStartFormat: { month: "long", day: "numeric" }
};
var CALENDAR_LISTENER_REFINERS = {
  datesSet: identity2,
  eventsSet: identity2,
  eventAdd: identity2,
  eventChange: identity2,
  eventRemove: identity2,
  windowResize: identity2,
  eventClick: identity2,
  eventMouseEnter: identity2,
  eventMouseLeave: identity2,
  select: identity2,
  unselect: identity2,
  loading: identity2,
  // internal
  _unmount: identity2,
  _beforeprint: identity2,
  _afterprint: identity2,
  _noEventDrop: identity2,
  _noEventResize: identity2,
  _resize: identity2,
  _scrollRequest: identity2
};
var CALENDAR_OPTION_REFINERS = {
  buttonText: identity2,
  buttonHints: identity2,
  views: identity2,
  plugins: identity2,
  initialEvents: identity2,
  events: identity2,
  eventSources: identity2
};
var COMPLEX_OPTION_COMPARATORS = {
  headerToolbar: isMaybeObjectsEqual,
  footerToolbar: isMaybeObjectsEqual,
  buttonText: isMaybeObjectsEqual,
  buttonHints: isMaybeObjectsEqual,
  buttonIcons: isMaybeObjectsEqual,
  dateIncrement: isMaybeObjectsEqual,
  plugins: isMaybeArraysEqual,
  events: isMaybeArraysEqual,
  eventSources: isMaybeArraysEqual,
  ["resources"]: isMaybeArraysEqual
};
function isMaybeObjectsEqual(a3, b3) {
  if (typeof a3 === "object" && typeof b3 === "object" && a3 && b3) {
    return isPropsEqual(a3, b3);
  }
  return a3 === b3;
}
function isMaybeArraysEqual(a3, b3) {
  if (Array.isArray(a3) && Array.isArray(b3)) {
    return isArraysEqual(a3, b3);
  }
  return a3 === b3;
}
var VIEW_OPTION_REFINERS = {
  type: String,
  component: identity2,
  buttonText: String,
  buttonTextKey: String,
  dateProfileGeneratorClass: identity2,
  usesMinMaxTime: Boolean,
  classNames: identity2,
  content: identity2,
  didMount: identity2,
  willUnmount: identity2
};
function mergeRawOptions(optionSets) {
  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
}
function refineProps(input2, refiners) {
  let refined = {};
  let extra = {};
  for (let propName in refiners) {
    if (propName in input2) {
      refined[propName] = refiners[propName](input2[propName]);
    }
  }
  for (let propName in input2) {
    if (!(propName in refiners)) {
      extra[propName] = input2[propName];
    }
  }
  return { refined, extra };
}
function identity2(raw) {
  return raw;
}
var { hasOwnProperty } = Object.prototype;
function mergeProps(propObjs, complexPropsMap) {
  let dest = {};
  if (complexPropsMap) {
    for (let name in complexPropsMap) {
      if (complexPropsMap[name] === isMaybeObjectsEqual) {
        let complexObjs = [];
        for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
          let val = propObjs[i3][name];
          if (typeof val === "object" && val) {
            complexObjs.unshift(val);
          } else if (val !== void 0) {
            dest[name] = val;
            break;
          }
        }
        if (complexObjs.length) {
          dest[name] = mergeProps(complexObjs);
        }
      }
    }
  }
  for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
    let props = propObjs[i3];
    for (let name in props) {
      if (!(name in dest)) {
        dest[name] = props[name];
      }
    }
  }
  return dest;
}
function filterHash(hash, func) {
  let filtered = {};
  for (let key in hash) {
    if (func(hash[key], key)) {
      filtered[key] = hash[key];
    }
  }
  return filtered;
}
function mapHash(hash, func) {
  let newHash = {};
  for (let key in hash) {
    newHash[key] = func(hash[key], key);
  }
  return newHash;
}
function arrayToHash(a3) {
  let hash = {};
  for (let item of a3) {
    hash[item] = true;
  }
  return hash;
}
function hashValuesToArray(obj) {
  let a3 = [];
  for (let key in obj) {
    a3.push(obj[key]);
  }
  return a3;
}
function isPropsEqual(obj0, obj1) {
  if (obj0 === obj1) {
    return true;
  }
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        return false;
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        return false;
      }
    }
  }
  return true;
}
var HANDLER_RE = /^on[A-Z]/;
function isNonHandlerPropsEqual(obj0, obj1) {
  const keys = getUnequalProps(obj0, obj1);
  for (let key of keys) {
    if (!HANDLER_RE.test(key)) {
      return false;
    }
  }
  return true;
}
function getUnequalProps(obj0, obj1) {
  let keys = [];
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        keys.push(key);
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        keys.push(key);
      }
    }
  }
  return keys;
}
function compareObjs(oldProps, newProps, equalityFuncs = {}) {
  if (oldProps === newProps) {
    return true;
  }
  for (let key in newProps) {
    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;
    else {
      return false;
    }
  }
  for (let key in oldProps) {
    if (!(key in newProps)) {
      return false;
    }
  }
  return true;
}
function isObjValsEqual(val0, val1, comparator) {
  if (val0 === val1 || comparator === true) {
    return true;
  }
  if (comparator) {
    return comparator(val0, val1);
  }
  return false;
}
function collectFromHash(hash, startIndex = 0, endIndex, step = 1) {
  let res = [];
  if (endIndex == null) {
    endIndex = Object.keys(hash).length;
  }
  for (let i3 = startIndex; i3 < endIndex; i3 += step) {
    let val = hash[i3];
    if (val !== void 0) {
      res.push(val);
    }
  }
  return res;
}
var calendarSystemClassMap = {};
function registerCalendarSystem(name, theClass) {
  calendarSystemClassMap[name] = theClass;
}
function createCalendarSystem(name) {
  return new calendarSystemClassMap[name]();
}
var GregorianCalendarSystem = class {
  getMarkerYear(d2) {
    return d2.getUTCFullYear();
  }
  getMarkerMonth(d2) {
    return d2.getUTCMonth();
  }
  getMarkerDay(d2) {
    return d2.getUTCDate();
  }
  arrayToMarker(arr) {
    return arrayToUtcDate(arr);
  }
  markerToArray(marker) {
    return dateToUtcArray(marker);
  }
};
registerCalendarSystem("gregory", GregorianCalendarSystem);
var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
function parse(str) {
  let m3 = ISO_RE.exec(str);
  if (m3) {
    let marker = new Date(Date.UTC(Number(m3[1]), m3[3] ? Number(m3[3]) - 1 : 0, Number(m3[5] || 1), Number(m3[7] || 0), Number(m3[8] || 0), Number(m3[10] || 0), m3[12] ? Number(`0.${m3[12]}`) * 1e3 : 0));
    if (isValidDate(marker)) {
      let timeZoneOffset = null;
      if (m3[13]) {
        timeZoneOffset = (m3[15] === "-" ? -1 : 1) * (Number(m3[16] || 0) * 60 + Number(m3[18] || 0));
      }
      return {
        marker,
        isTimeUnspecified: !m3[6],
        timeZoneOffset
      };
    }
  }
  return null;
}
var DateEnv = class {
  constructor(settings) {
    let timeZone = this.timeZone = settings.timeZone;
    let isNamedTimeZone = timeZone !== "local" && timeZone !== "UTC";
    if (settings.namedTimeZoneImpl && isNamedTimeZone) {
      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
    }
    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
    this.calendarSystem = createCalendarSystem(settings.calendarSystem);
    this.locale = settings.locale;
    this.weekDow = settings.locale.week.dow;
    this.weekDoy = settings.locale.week.doy;
    if (settings.weekNumberCalculation === "ISO") {
      this.weekDow = 1;
      this.weekDoy = 4;
    }
    if (typeof settings.firstDay === "number") {
      this.weekDow = settings.firstDay;
    }
    if (typeof settings.weekNumberCalculation === "function") {
      this.weekNumberFunc = settings.weekNumberCalculation;
    }
    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
    this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
    this.cmdFormatter = settings.cmdFormatter;
    this.defaultSeparator = settings.defaultSeparator;
  }
  // Creating / Parsing
  createMarker(input2) {
    let meta = this.createMarkerMeta(input2);
    if (meta === null) {
      return null;
    }
    return meta.marker;
  }
  createNowMarker() {
    if (this.canComputeOffset) {
      return this.timestampToMarker((/* @__PURE__ */ new Date()).valueOf());
    }
    return arrayToUtcDate(dateToLocalArray(/* @__PURE__ */ new Date()));
  }
  createMarkerMeta(input2) {
    if (typeof input2 === "string") {
      return this.parse(input2);
    }
    let marker = null;
    if (typeof input2 === "number") {
      marker = this.timestampToMarker(input2);
    } else if (input2 instanceof Date) {
      input2 = input2.valueOf();
      if (!isNaN(input2)) {
        marker = this.timestampToMarker(input2);
      }
    } else if (Array.isArray(input2)) {
      marker = arrayToUtcDate(input2);
    }
    if (marker === null || !isValidDate(marker)) {
      return null;
    }
    return { marker, isTimeUnspecified: false, forcedTzo: null };
  }
  parse(s3) {
    let parts = parse(s3);
    if (parts === null) {
      return null;
    }
    let { marker } = parts;
    let forcedTzo = null;
    if (parts.timeZoneOffset !== null) {
      if (this.canComputeOffset) {
        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1e3);
      } else {
        forcedTzo = parts.timeZoneOffset;
      }
    }
    return { marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo };
  }
  // Accessors
  getYear(marker) {
    return this.calendarSystem.getMarkerYear(marker);
  }
  getMonth(marker) {
    return this.calendarSystem.getMarkerMonth(marker);
  }
  getDay(marker) {
    return this.calendarSystem.getMarkerDay(marker);
  }
  // Adding / Subtracting
  add(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += dur.years;
    a3[1] += dur.months;
    a3[2] += dur.days;
    a3[6] += dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  subtract(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] -= dur.years;
    a3[1] -= dur.months;
    a3[2] -= dur.days;
    a3[6] -= dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addYears(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addMonths(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[1] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  // Diffing Whole Units
  diffWholeYears(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
    }
    return null;
  }
  diffWholeMonths(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
    }
    return null;
  }
  // Range / Duration
  greatestWholeUnit(m0, m1) {
    let n2 = this.diffWholeYears(m0, m1);
    if (n2 !== null) {
      return { unit: "year", value: n2 };
    }
    n2 = this.diffWholeMonths(m0, m1);
    if (n2 !== null) {
      return { unit: "month", value: n2 };
    }
    n2 = diffWholeWeeks(m0, m1);
    if (n2 !== null) {
      return { unit: "week", value: n2 };
    }
    n2 = diffWholeDays(m0, m1);
    if (n2 !== null) {
      return { unit: "day", value: n2 };
    }
    n2 = diffHours(m0, m1);
    if (isInt(n2)) {
      return { unit: "hour", value: n2 };
    }
    n2 = diffMinutes(m0, m1);
    if (isInt(n2)) {
      return { unit: "minute", value: n2 };
    }
    n2 = diffSeconds(m0, m1);
    if (isInt(n2)) {
      return { unit: "second", value: n2 };
    }
    return { unit: "millisecond", value: m1.valueOf() - m0.valueOf() };
  }
  countDurationsBetween(m0, m1, d2) {
    let diff;
    if (d2.years) {
      diff = this.diffWholeYears(m0, m1);
      if (diff !== null) {
        return diff / asRoughYears(d2);
      }
    }
    if (d2.months) {
      diff = this.diffWholeMonths(m0, m1);
      if (diff !== null) {
        return diff / asRoughMonths(d2);
      }
    }
    if (d2.days) {
      diff = diffWholeDays(m0, m1);
      if (diff !== null) {
        return diff / asRoughDays(d2);
      }
    }
    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d2);
  }
  // Start-Of
  // these DON'T return zoned-dates. only UTC start-of dates
  startOf(m3, unit) {
    if (unit === "year") {
      return this.startOfYear(m3);
    }
    if (unit === "month") {
      return this.startOfMonth(m3);
    }
    if (unit === "week") {
      return this.startOfWeek(m3);
    }
    if (unit === "day") {
      return startOfDay(m3);
    }
    if (unit === "hour") {
      return startOfHour(m3);
    }
    if (unit === "minute") {
      return startOfMinute(m3);
    }
    if (unit === "second") {
      return startOfSecond(m3);
    }
    return null;
  }
  startOfYear(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3)
    ]);
  }
  startOfMonth(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3)
    ]);
  }
  startOfWeek(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3),
      m3.getUTCDate() - (m3.getUTCDay() - this.weekDow + 7) % 7
    ]);
  }
  // Week Number
  computeWeekNumber(marker) {
    if (this.weekNumberFunc) {
      return this.weekNumberFunc(this.toDate(marker));
    }
    return weekOfYear(marker, this.weekDow, this.weekDoy);
  }
  // TODO: choke on timeZoneName: long
  format(marker, formatter, dateOptions = {}) {
    return formatter.format({
      marker,
      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
    }, this);
  }
  formatRange(start, end, formatter, dateOptions = {}) {
    if (dateOptions.isEndExclusive) {
      end = addMs(end, -1);
    }
    return formatter.formatRange({
      marker: start,
      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)
    }, {
      marker: end,
      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
    }, this, dateOptions.defaultSeparator);
  }
  /*
  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
  might as well use buildIsoString or some other util directly
  */
  formatIso(marker, extraOptions = {}) {
    let timeZoneOffset = null;
    if (!extraOptions.omitTimeZoneOffset) {
      if (extraOptions.forcedTzo != null) {
        timeZoneOffset = extraOptions.forcedTzo;
      } else {
        timeZoneOffset = this.offsetForMarker(marker);
      }
    }
    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
  }
  // TimeZone
  timestampToMarker(ms) {
    if (this.timeZone === "local") {
      return arrayToUtcDate(dateToLocalArray(new Date(ms)));
    }
    if (this.timeZone === "UTC" || !this.namedTimeZoneImpl) {
      return new Date(ms);
    }
    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
  }
  offsetForMarker(m3) {
    if (this.timeZone === "local") {
      return -arrayToLocalDate(dateToUtcArray(m3)).getTimezoneOffset();
    }
    if (this.timeZone === "UTC") {
      return 0;
    }
    if (this.namedTimeZoneImpl) {
      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3));
    }
    return null;
  }
  // Conversion
  toDate(m3, forcedTzo) {
    if (this.timeZone === "local") {
      return arrayToLocalDate(dateToUtcArray(m3));
    }
    if (this.timeZone === "UTC") {
      return new Date(m3.valueOf());
    }
    if (!this.namedTimeZoneImpl) {
      return new Date(m3.valueOf() - (forcedTzo || 0));
    }
    return new Date(m3.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3)) * 1e3 * 60);
  }
};
var Theme = class {
  constructor(calendarOptions) {
    if (this.iconOverrideOption) {
      this.setIconOverride(calendarOptions[this.iconOverrideOption]);
    }
  }
  setIconOverride(iconOverrideHash) {
    let iconClassesCopy;
    let buttonName;
    if (typeof iconOverrideHash === "object" && iconOverrideHash) {
      iconClassesCopy = Object.assign({}, this.iconClasses);
      for (buttonName in iconOverrideHash) {
        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
      }
      this.iconClasses = iconClassesCopy;
    } else if (iconOverrideHash === false) {
      this.iconClasses = {};
    }
  }
  applyIconOverridePrefix(className) {
    let prefix = this.iconOverridePrefix;
    if (prefix && className.indexOf(prefix) !== 0) {
      className = prefix + className;
    }
    return className;
  }
  getClass(key) {
    return this.classes[key] || "";
  }
  getIconClass(buttonName, isRtl) {
    let className;
    if (isRtl && this.rtlIconClasses) {
      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
    } else {
      className = this.iconClasses[buttonName];
    }
    if (className) {
      return `${this.baseIconClass} ${className}`;
    }
    return "";
  }
  getCustomButtonIconClass(customButtonProps) {
    let className;
    if (this.iconOverrideCustomButtonOption) {
      className = customButtonProps[this.iconOverrideCustomButtonOption];
      if (className) {
        return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;
      }
    }
    return "";
  }
};
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = "";
Theme.prototype.iconOverridePrefix = "";
function flushSync(runBeforeFlush) {
  runBeforeFlush();
  let oldDebounceRendering = l.debounceRendering;
  let callbackQ = [];
  function execCallbackSync(callback) {
    callbackQ.push(callback);
  }
  l.debounceRendering = execCallbackSync;
  D(y(FakeComponent, {}), document.createElement("div"));
  while (callbackQ.length) {
    callbackQ.shift()();
  }
  l.debounceRendering = oldDebounceRendering;
}
var FakeComponent = class extends x {
  render() {
    return y("div", {});
  }
  componentDidMount() {
    this.setState({});
  }
};
function createContext(defaultValue) {
  let ContextType = G(defaultValue);
  let origProvider = ContextType.Provider;
  ContextType.Provider = function() {
    let isNew = !this.getChildContext;
    let children = origProvider.apply(this, arguments);
    if (isNew) {
      let subs = [];
      this.shouldComponentUpdate = (_props) => {
        if (this.props.value !== _props.value) {
          subs.forEach((c3) => {
            c3.context = _props.value;
            c3.forceUpdate();
          });
        }
      };
      this.sub = (c3) => {
        subs.push(c3);
        let old = c3.componentWillUnmount;
        c3.componentWillUnmount = () => {
          subs.splice(subs.indexOf(c3), 1);
          old && old.call(c3);
        };
      };
    }
    return children;
  };
  return ContextType;
}
var ScrollResponder = class {
  constructor(execFunc, emitter, scrollTime, scrollTimeReset) {
    this.execFunc = execFunc;
    this.emitter = emitter;
    this.scrollTime = scrollTime;
    this.scrollTimeReset = scrollTimeReset;
    this.handleScrollRequest = (request) => {
      this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);
      this.drain();
    };
    emitter.on("_scrollRequest", this.handleScrollRequest);
    this.fireInitialScroll();
  }
  detach() {
    this.emitter.off("_scrollRequest", this.handleScrollRequest);
  }
  update(isDatesNew) {
    if (isDatesNew && this.scrollTimeReset) {
      this.fireInitialScroll();
    } else {
      this.drain();
    }
  }
  fireInitialScroll() {
    this.handleScrollRequest({
      time: this.scrollTime
    });
  }
  drain() {
    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
      this.queuedRequest = null;
    }
  }
};
var ViewContextType = createContext({});
function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
  return {
    dateEnv,
    options: viewOptions,
    pluginHooks,
    emitter,
    dispatch,
    getCurrentData,
    calendarApi,
    viewSpec,
    viewApi,
    dateProfileGenerator,
    theme,
    isRtl: viewOptions.direction === "rtl",
    addResizeHandler(handler) {
      emitter.on("_resize", handler);
    },
    removeResizeHandler(handler) {
      emitter.off("_resize", handler);
    },
    createScrollResponder(execFunc) {
      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
    },
    registerInteractiveComponent,
    unregisterInteractiveComponent
  };
}
var PureComponent = class extends x {
  shouldComponentUpdate(nextProps, nextState) {
    if (this.debug) {
      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
    }
    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);
  }
  // HACK for freakin' React StrictMode
  safeSetState(newState) {
    if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {
      this.setState(newState);
    }
  }
};
PureComponent.addPropsEquality = addPropsEquality;
PureComponent.addStateEquality = addStateEquality;
PureComponent.contextType = ViewContextType;
PureComponent.prototype.propEquality = {};
PureComponent.prototype.stateEquality = {};
var BaseComponent = class extends PureComponent {
};
BaseComponent.contextType = ViewContextType;
function addPropsEquality(propEquality) {
  let hash = Object.create(this.prototype.propEquality);
  Object.assign(hash, propEquality);
  this.prototype.propEquality = hash;
}
function addStateEquality(stateEquality) {
  let hash = Object.create(this.prototype.stateEquality);
  Object.assign(hash, stateEquality);
  this.prototype.stateEquality = hash;
}
function setRef(ref, current) {
  if (typeof ref === "function") {
    ref(current);
  } else if (ref) {
    ref.current = current;
  }
}
var ContentInjector = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.id = guid();
    this.queuedDomNodes = [];
    this.currentDomNodes = [];
    this.handleEl = (el) => {
      const { options } = this.context;
      const { generatorName } = this.props;
      if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {
        this.updateElRef(el);
      }
    };
    this.updateElRef = (el) => {
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
  }
  render() {
    const { props, context: context2 } = this;
    const { options } = context2;
    const { customGenerator, defaultGenerator, renderProps } = props;
    const attrs = buildElAttrs(props, [], this.handleEl);
    let useDefault = false;
    let innerContent;
    let queuedDomNodes = [];
    let currentGeneratorMeta;
    if (customGenerator != null) {
      const customGeneratorRes = typeof customGenerator === "function" ? customGenerator(renderProps, y) : customGenerator;
      if (customGeneratorRes === true) {
        useDefault = true;
      } else {
        const isObject = customGeneratorRes && typeof customGeneratorRes === "object";
        if (isObject && "html" in customGeneratorRes) {
          attrs.dangerouslySetInnerHTML = { __html: customGeneratorRes.html };
        } else if (isObject && "domNodes" in customGeneratorRes) {
          queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);
        } else if (isObject ? i(customGeneratorRes) : typeof customGeneratorRes !== "function") {
          innerContent = customGeneratorRes;
        } else {
          currentGeneratorMeta = customGeneratorRes;
        }
      }
    } else {
      useDefault = !hasCustomRenderingHandler(props.generatorName, options);
    }
    if (useDefault && defaultGenerator) {
      innerContent = defaultGenerator(renderProps);
    }
    this.queuedDomNodes = queuedDomNodes;
    this.currentGeneratorMeta = currentGeneratorMeta;
    return y(props.elTag, attrs, innerContent);
  }
  componentDidMount() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentDidUpdate() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentWillUnmount() {
    this.triggerCustomRendering(false);
  }
  triggerCustomRendering(isActive) {
    var _a;
    const { props, context: context2 } = this;
    const { handleCustomRendering, customRenderingMetaMap } = context2.options;
    if (handleCustomRendering) {
      const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];
      if (generatorMeta) {
        handleCustomRendering(Object.assign(Object.assign({
          id: this.id,
          isActive,
          containerEl: this.base,
          reportNewContainerEl: this.updateElRef,
          // front-end framework tells us about new container els
          generatorMeta
        }, props), { elClasses: (props.elClasses || []).filter(isTruthy) }));
      }
    }
  }
  applyQueueudDomNodes() {
    const { queuedDomNodes, currentDomNodes } = this;
    const el = this.base;
    if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {
      currentDomNodes.forEach(removeElement);
      for (let newNode of queuedDomNodes) {
        el.appendChild(newNode);
      }
      this.currentDomNodes = queuedDomNodes;
    }
  }
};
ContentInjector.addPropsEquality({
  elClasses: isArraysEqual,
  elStyle: isPropsEqual,
  elAttrs: isNonHandlerPropsEqual,
  renderProps: isPropsEqual
});
function hasCustomRenderingHandler(generatorName, options) {
  var _a;
  return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));
}
function buildElAttrs(props, extraClassNames, elRef) {
  const attrs = Object.assign(Object.assign({}, props.elAttrs), { ref: elRef });
  if (props.elClasses || extraClassNames) {
    attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(" ");
  }
  if (props.elStyle) {
    attrs.style = props.elStyle;
  }
  return attrs;
}
function isTruthy(val) {
  return Boolean(val);
}
var RenderId = createContext(0);
var ContentContainer = class extends x {
  constructor() {
    super(...arguments);
    this.InnerContent = InnerContentInjector.bind(void 0, this);
    this.handleEl = (el) => {
      this.el = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
        if (el && this.didMountMisfire) {
          this.componentDidMount();
        }
      }
    };
  }
  render() {
    const { props } = this;
    const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);
    if (props.children) {
      const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);
      const children = props.children(this.InnerContent, props.renderProps, elAttrs);
      if (props.elTag) {
        return y(props.elTag, elAttrs, children);
      } else {
        return children;
      }
    } else {
      return y(ContentInjector, Object.assign(Object.assign({}, props), { elRef: this.handleEl, elTag: props.elTag || "div", elClasses: (props.elClasses || []).concat(generatedClassNames), renderId: this.context }));
    }
  }
  componentDidMount() {
    var _a, _b;
    if (this.el) {
      (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
    } else {
      this.didMountMisfire = true;
    }
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
  }
};
ContentContainer.contextType = RenderId;
function InnerContentInjector(containerComponent, props) {
  const parentProps = containerComponent.props;
  return y(ContentInjector, Object.assign({ renderProps: parentProps.renderProps, generatorName: parentProps.generatorName, customGenerator: parentProps.customGenerator, defaultGenerator: parentProps.defaultGenerator, renderId: containerComponent.context }, props));
}
function generateClassNames(classNameGenerator, renderProps) {
  const classNames = typeof classNameGenerator === "function" ? classNameGenerator(renderProps) : classNameGenerator || [];
  return typeof classNames === "string" ? [classNames] : classNames;
}
var ViewContainer = class extends BaseComponent {
  render() {
    let { props, context: context2 } = this;
    let { options } = context2;
    let renderProps = { view: context2.viewApi };
    return y(ContentContainer, Object.assign({}, props, { elTag: props.elTag || "div", elClasses: [
      ...buildViewClassNames(props.viewSpec),
      ...props.elClasses || []
    ], renderProps, classNameGenerator: options.viewClassNames, generatorName: void 0, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount }), () => props.children);
  }
};
function buildViewClassNames(viewSpec) {
  return [
    `fc-${viewSpec.type}-view`,
    "fc-view"
  ];
}
function parseRange(input2, dateEnv) {
  let start = null;
  let end = null;
  if (input2.start) {
    start = dateEnv.createMarker(input2.start);
  }
  if (input2.end) {
    end = dateEnv.createMarker(input2.end);
  }
  if (!start && !end) {
    return null;
  }
  if (start && end && end < start) {
    return null;
  }
  return { start, end };
}
function invertRanges(ranges, constraintRange) {
  let invertedRanges = [];
  let { start } = constraintRange;
  let i3;
  let dateRange;
  ranges.sort(compareRanges);
  for (i3 = 0; i3 < ranges.length; i3 += 1) {
    dateRange = ranges[i3];
    if (dateRange.start > start) {
      invertedRanges.push({ start, end: dateRange.start });
    }
    if (dateRange.end > start) {
      start = dateRange.end;
    }
  }
  if (start < constraintRange.end) {
    invertedRanges.push({ start, end: constraintRange.end });
  }
  return invertedRanges;
}
function compareRanges(range0, range1) {
  return range0.start.valueOf() - range1.start.valueOf();
}
function intersectRanges(range0, range1) {
  let { start, end } = range0;
  let newRange = null;
  if (range1.start !== null) {
    if (start === null) {
      start = range1.start;
    } else {
      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
    }
  }
  if (range1.end != null) {
    if (end === null) {
      end = range1.end;
    } else {
      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
    }
  }
  if (start === null || end === null || start < end) {
    newRange = { start, end };
  }
  return newRange;
}
function rangesEqual(range0, range1) {
  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
}
function rangesIntersect(range0, range1) {
  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
}
function rangeContainsRange(outerRange, innerRange) {
  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
}
function rangeContainsMarker(range, date) {
  return (range.start === null || date >= range.start) && (range.end === null || date < range.end);
}
function constrainMarkerToRange(date, range) {
  if (range.start != null && date < range.start) {
    return range.start;
  }
  if (range.end != null && date >= range.end) {
    return new Date(range.end.valueOf() - 1);
  }
  return date;
}
function computeAlignedDayRange(timedRange) {
  let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
  let start = startOfDay(timedRange.start);
  let end = addDays(start, dayCnt);
  return { start, end };
}
function computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {
  let startDay = null;
  let endDay = null;
  if (timedRange.end) {
    endDay = startOfDay(timedRange.end);
    let endTimeMS = timedRange.end.valueOf() - endDay.valueOf();
    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
      endDay = addDays(endDay, 1);
    }
  }
  if (timedRange.start) {
    startDay = startOfDay(timedRange.start);
    if (endDay && endDay <= startDay) {
      endDay = addDays(startDay, 1);
    }
  }
  return { start: startDay, end: endDay };
}
function diffDates(date0, date1, dateEnv, largeUnit) {
  if (largeUnit === "year") {
    return createDuration(dateEnv.diffWholeYears(date0, date1), "year");
  }
  if (largeUnit === "month") {
    return createDuration(dateEnv.diffWholeMonths(date0, date1), "month");
  }
  return diffDayAndTime(date0, date1);
}
function reduceCurrentDate(currentDate, action) {
  switch (action.type) {
    case "CHANGE_DATE":
      return action.dateMarker;
    default:
      return currentDate;
  }
}
function getInitialDate(options, dateEnv) {
  let initialDateInput = options.initialDate;
  if (initialDateInput != null) {
    return dateEnv.createMarker(initialDateInput);
  }
  return getNow(options.now, dateEnv);
}
function getNow(nowInput, dateEnv) {
  if (typeof nowInput === "function") {
    nowInput = nowInput();
  }
  if (nowInput == null) {
    return dateEnv.createNowMarker();
  }
  return dateEnv.createMarker(nowInput);
}
var DateProfileGenerator = class {
  constructor(props) {
    this.props = props;
    this.nowDate = getNow(props.nowInput, props.dateEnv);
    this.initHiddenDays();
  }
  /* Date Range Computation
  ------------------------------------------------------------------------------------------------------------------*/
  // Builds a structure with info about what the dates/ranges will be for the "prev" view.
  buildPrev(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let prevDate = dateEnv.subtract(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(prevDate, -1, forceToValid);
  }
  // Builds a structure with info about what the dates/ranges will be for the "next" view.
  buildNext(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let nextDate = dateEnv.add(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(nextDate, 1, forceToValid);
  }
  // Builds a structure holding dates/ranges for rendering around the given date.
  // Optional direction param indicates whether the date is being incremented/decremented
  // from its previous value. decremented = -1, incremented = 1 (default).
  build(currentDate, direction, forceToValid = true) {
    let { props } = this;
    let validRange;
    let currentInfo;
    let isRangeAllDay;
    let renderRange;
    let activeRange;
    let isValid;
    validRange = this.buildValidRange();
    validRange = this.trimHiddenDays(validRange);
    if (forceToValid) {
      currentDate = constrainMarkerToRange(currentDate, validRange);
    }
    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
    renderRange = this.trimHiddenDays(renderRange);
    activeRange = renderRange;
    if (!props.showNonCurrentDates) {
      activeRange = intersectRanges(activeRange, currentInfo.range);
    }
    activeRange = this.adjustActiveRange(activeRange);
    activeRange = intersectRanges(activeRange, validRange);
    isValid = rangesIntersect(currentInfo.range, validRange);
    if (!rangeContainsMarker(renderRange, currentDate)) {
      currentDate = renderRange.start;
    }
    return {
      currentDate,
      // constraint for where prev/next operations can go and where events can be dragged/resized to.
      // an object with optional start and end properties.
      validRange,
      // range the view is formally responsible for.
      // for example, a month view might have 1st-31st, excluding padded dates
      currentRange: currentInfo.range,
      // name of largest unit being displayed, like "month" or "week"
      currentRangeUnit: currentInfo.unit,
      isRangeAllDay,
      // dates that display events and accept drag-n-drop
      // will be `null` if no dates accept events
      activeRange,
      // date range with a rendered skeleton
      // includes not-active days that need some sort of DOM
      renderRange,
      // Duration object that denotes the first visible time of any given day
      slotMinTime: props.slotMinTime,
      // Duration object that denotes the exclusive visible end time of any given day
      slotMaxTime: props.slotMaxTime,
      isValid,
      // how far the current date will move for a prev/next operation
      dateIncrement: this.buildDateIncrement(currentInfo.duration)
      // pass a fallback (might be null) ^
    };
  }
  // Builds an object with optional start/end properties.
  // Indicates the minimum/maximum dates to display.
  // not responsible for trimming hidden days.
  buildValidRange() {
    let input2 = this.props.validRangeInput;
    let simpleInput = typeof input2 === "function" ? input2.call(this.props.calendarApi, this.nowDate) : input2;
    return this.refineRange(simpleInput) || { start: null, end: null };
  }
  // Builds a structure with info about the "current" range, the range that is
  // highlighted as being the current month for example.
  // See build() for a description of `direction`.
  // Guaranteed to have `range` and `unit` properties. `duration` is optional.
  buildCurrentRangeInfo(date, direction) {
    let { props } = this;
    let duration = null;
    let unit = null;
    let range = null;
    let dayCount;
    if (props.duration) {
      duration = props.duration;
      unit = props.durationUnit;
      range = this.buildRangeFromDuration(date, direction, duration, unit);
    } else if (dayCount = this.props.dayCount) {
      unit = "day";
      range = this.buildRangeFromDayCount(date, direction, dayCount);
    } else if (range = this.buildCustomVisibleRange(date)) {
      unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;
    } else {
      duration = this.getFallbackDuration();
      unit = greatestDurationDenominator(duration).unit;
      range = this.buildRangeFromDuration(date, direction, duration, unit);
    }
    return { duration, unit, range };
  }
  getFallbackDuration() {
    return createDuration({ day: 1 });
  }
  // Returns a new activeRange to have time values (un-ambiguate)
  // slotMinTime or slotMaxTime causes the range to expand.
  adjustActiveRange(range) {
    let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;
    let { start, end } = range;
    if (usesMinMaxTime) {
      if (asRoughDays(slotMinTime) < 0) {
        start = startOfDay(start);
        start = dateEnv.add(start, slotMinTime);
      }
      if (asRoughDays(slotMaxTime) > 1) {
        end = startOfDay(end);
        end = addDays(end, -1);
        end = dateEnv.add(end, slotMaxTime);
      }
    }
    return { start, end };
  }
  // Builds the "current" range when it is specified as an explicit duration.
  // `unit` is the already-computed greatestDurationDenominator unit of duration.
  buildRangeFromDuration(date, direction, duration, unit) {
    let { dateEnv, dateAlignment } = this.props;
    let start;
    let end;
    let res;
    if (!dateAlignment) {
      let { dateIncrement } = this.props;
      if (dateIncrement) {
        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
          dateAlignment = greatestDurationDenominator(dateIncrement).unit;
        } else {
          dateAlignment = unit;
        }
      } else {
        dateAlignment = unit;
      }
    }
    if (asRoughDays(duration) <= 1) {
      if (this.isHiddenDay(start)) {
        start = this.skipHiddenDays(start, direction);
        start = startOfDay(start);
      }
    }
    function computeRes() {
      start = dateEnv.startOf(date, dateAlignment);
      end = dateEnv.add(start, duration);
      res = { start, end };
    }
    computeRes();
    if (!this.trimHiddenDays(res)) {
      date = this.skipHiddenDays(date, direction);
      computeRes();
    }
    return res;
  }
  // Builds the "current" range when a dayCount is specified.
  buildRangeFromDayCount(date, direction, dayCount) {
    let { dateEnv, dateAlignment } = this.props;
    let runningCount = 0;
    let start = date;
    let end;
    if (dateAlignment) {
      start = dateEnv.startOf(start, dateAlignment);
    }
    start = startOfDay(start);
    start = this.skipHiddenDays(start, direction);
    end = start;
    do {
      end = addDays(end, 1);
      if (!this.isHiddenDay(end)) {
        runningCount += 1;
      }
    } while (runningCount < dayCount);
    return { start, end };
  }
  // Builds a normalized range object for the "visible" range,
  // which is a way to define the currentRange and activeRange at the same time.
  buildCustomVisibleRange(date) {
    let { props } = this;
    let input2 = props.visibleRangeInput;
    let simpleInput = typeof input2 === "function" ? input2.call(props.calendarApi, props.dateEnv.toDate(date)) : input2;
    let range = this.refineRange(simpleInput);
    if (range && (range.start == null || range.end == null)) {
      return null;
    }
    return range;
  }
  // Computes the range that will represent the element/cells for *rendering*,
  // but which may have voided days/times.
  // not responsible for trimming hidden days.
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    return currentRange;
  }
  // Compute the duration value that should be added/substracted to the current date
  // when a prev/next operation happens.
  buildDateIncrement(fallback) {
    let { dateIncrement } = this.props;
    let customAlignment;
    if (dateIncrement) {
      return dateIncrement;
    }
    if (customAlignment = this.props.dateAlignment) {
      return createDuration(1, customAlignment);
    }
    if (fallback) {
      return fallback;
    }
    return createDuration({ days: 1 });
  }
  refineRange(rangeInput) {
    if (rangeInput) {
      let range = parseRange(rangeInput, this.props.dateEnv);
      if (range) {
        range = computeVisibleDayRange(range);
      }
      return range;
    }
    return null;
  }
  /* Hidden Days
  ------------------------------------------------------------------------------------------------------------------*/
  // Initializes internal variables related to calculating hidden days-of-week
  initHiddenDays() {
    let hiddenDays = this.props.hiddenDays || [];
    let isHiddenDayHash = [];
    let dayCnt = 0;
    let i3;
    if (this.props.weekends === false) {
      hiddenDays.push(0, 6);
    }
    for (i3 = 0; i3 < 7; i3 += 1) {
      if (!(isHiddenDayHash[i3] = hiddenDays.indexOf(i3) !== -1)) {
        dayCnt += 1;
      }
    }
    if (!dayCnt) {
      throw new Error("invalid hiddenDays");
    }
    this.isHiddenDayHash = isHiddenDayHash;
  }
  // Remove days from the beginning and end of the range that are computed as hidden.
  // If the whole range is trimmed off, returns null
  trimHiddenDays(range) {
    let { start, end } = range;
    if (start) {
      start = this.skipHiddenDays(start);
    }
    if (end) {
      end = this.skipHiddenDays(end, -1, true);
    }
    if (start == null || end == null || start < end) {
      return { start, end };
    }
    return null;
  }
  // Is the current day hidden?
  // `day` is a day-of-week index (0-6), or a Date (used for UTC)
  isHiddenDay(day) {
    if (day instanceof Date) {
      day = day.getUTCDay();
    }
    return this.isHiddenDayHash[day];
  }
  // Incrementing the current day until it is no longer a hidden day, returning a copy.
  // DOES NOT CONSIDER validRange!
  // If the initial value of `date` is not a hidden day, don't do anything.
  // Pass `isExclusive` as `true` if you are dealing with an end date.
  // `inc` defaults to `1` (increment one day forward each time)
  skipHiddenDays(date, inc = 1, isExclusive = false) {
    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
      date = addDays(date, inc);
    }
    return date;
  }
};
function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
  return {
    instanceId: guid(),
    defId,
    range,
    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
  };
}
function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
  for (let i3 = 0; i3 < recurringTypes.length; i3 += 1) {
    let parsed = recurringTypes[i3].parse(refined, dateEnv);
    if (parsed) {
      let { allDay } = refined;
      if (allDay == null) {
        allDay = defaultAllDay;
        if (allDay == null) {
          allDay = parsed.allDayGuess;
          if (allDay == null) {
            allDay = false;
          }
        }
      }
      return {
        allDay,
        duration: parsed.duration,
        typeData: parsed.typeData,
        typeId: i3
      };
    }
  }
  return null;
}
function expandRecurring(eventStore, framingRange, context2) {
  let { dateEnv, pluginHooks, options } = context2;
  let { defs, instances } = eventStore;
  instances = filterHash(instances, (instance) => !defs[instance.defId].recurringDef);
  for (let defId in defs) {
    let def = defs[defId];
    if (def.recurringDef) {
      let { duration } = def.recurringDef;
      if (!duration) {
        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
      }
      let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);
      for (let start of starts) {
        let instance = createEventInstance(defId, {
          start,
          end: dateEnv.add(start, duration)
        });
        instances[instance.instanceId] = instance;
      }
    }
  }
  return { defs, instances };
}
function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
  let typeDef = recurringTypes[eventDef.recurringDef.typeId];
  let markers = typeDef.expand(eventDef.recurringDef.typeData, {
    start: dateEnv.subtract(framingRange.start, duration),
    end: framingRange.end
  }, dateEnv);
  if (eventDef.allDay) {
    markers = markers.map(startOfDay);
  }
  return markers;
}
var EVENT_NON_DATE_REFINERS = {
  id: String,
  groupId: String,
  title: String,
  url: String,
  interactive: Boolean
};
var EVENT_DATE_REFINERS = {
  start: identity2,
  end: identity2,
  date: identity2,
  allDay: Boolean
};
var EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity2 });
function parseEvent(raw, eventSource, context2, allowOpenRange, refiners = buildEventRefiners(context2), defIdMap, instanceIdMap) {
  let { refined, extra } = refineEventDef(raw, context2, refiners);
  let defaultAllDay = computeIsDefaultAllDay(eventSource, context2);
  let recurringRes = parseRecurring(refined, defaultAllDay, context2.dateEnv, context2.pluginHooks.recurringTypes);
  if (recurringRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", recurringRes.allDay, Boolean(recurringRes.duration), context2, defIdMap);
    def.recurringDef = {
      typeId: recurringRes.typeId,
      typeData: recurringRes.typeData,
      duration: recurringRes.duration
    };
    return { def, instance: null };
  }
  let singleRes = parseSingle(refined, defaultAllDay, context2, allowOpenRange);
  if (singleRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", singleRes.allDay, singleRes.hasEnd, context2, defIdMap);
    let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
    if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {
      instance.instanceId = instanceIdMap[def.publicId];
    }
    return { def, instance };
  }
  return null;
}
function refineEventDef(raw, context2, refiners = buildEventRefiners(context2)) {
  return refineProps(raw, refiners);
}
function buildEventRefiners(context2) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context2.pluginHooks.eventRefiners);
}
function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context2, defIdMap) {
  let def = {
    title: refined.title || "",
    groupId: refined.groupId || "",
    publicId: refined.id || "",
    url: refined.url || "",
    recurringDef: null,
    defId: (defIdMap && refined.id ? defIdMap[refined.id] : "") || guid(),
    sourceId,
    allDay,
    hasEnd,
    interactive: refined.interactive,
    ui: createEventUi(refined, context2),
    extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)
  };
  for (let memberAdder of context2.pluginHooks.eventDefMemberAdders) {
    Object.assign(def, memberAdder(refined));
  }
  Object.freeze(def.ui.classNames);
  Object.freeze(def.extendedProps);
  return def;
}
function parseSingle(refined, defaultAllDay, context2, allowOpenRange) {
  let { allDay } = refined;
  let startMeta;
  let startMarker = null;
  let hasEnd = false;
  let endMeta;
  let endMarker = null;
  let startInput = refined.start != null ? refined.start : refined.date;
  startMeta = context2.dateEnv.createMarkerMeta(startInput);
  if (startMeta) {
    startMarker = startMeta.marker;
  } else if (!allowOpenRange) {
    return null;
  }
  if (refined.end != null) {
    endMeta = context2.dateEnv.createMarkerMeta(refined.end);
  }
  if (allDay == null) {
    if (defaultAllDay != null) {
      allDay = defaultAllDay;
    } else {
      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
    }
  }
  if (allDay && startMarker) {
    startMarker = startOfDay(startMarker);
  }
  if (endMeta) {
    endMarker = endMeta.marker;
    if (allDay) {
      endMarker = startOfDay(endMarker);
    }
    if (startMarker && endMarker <= startMarker) {
      endMarker = null;
    }
  }
  if (endMarker) {
    hasEnd = true;
  } else if (!allowOpenRange) {
    hasEnd = context2.options.forceEventDuration || false;
    endMarker = context2.dateEnv.add(startMarker, allDay ? context2.options.defaultAllDayEventDuration : context2.options.defaultTimedEventDuration);
  }
  return {
    allDay,
    hasEnd,
    range: { start: startMarker, end: endMarker },
    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
    forcedEndTzo: endMeta ? endMeta.forcedTzo : null
  };
}
function computeIsDefaultAllDay(eventSource, context2) {
  let res = null;
  if (eventSource) {
    res = eventSource.defaultAllDay;
  }
  if (res == null) {
    res = context2.options.defaultAllDay;
  }
  return res;
}
function parseEvents(rawEvents, eventSource, context2, allowOpenRange, defIdMap, instanceIdMap) {
  let eventStore = createEmptyEventStore();
  let eventRefiners = buildEventRefiners(context2);
  for (let rawEvent of rawEvents) {
    let tuple = parseEvent(rawEvent, eventSource, context2, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);
    if (tuple) {
      eventTupleToStore(tuple, eventStore);
    }
  }
  return eventStore;
}
function eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {
  eventStore.defs[tuple.def.defId] = tuple.def;
  if (tuple.instance) {
    eventStore.instances[tuple.instance.instanceId] = tuple.instance;
  }
  return eventStore;
}
function getRelevantEvents(eventStore, instanceId) {
  let instance = eventStore.instances[instanceId];
  if (instance) {
    let def = eventStore.defs[instance.defId];
    let newStore = filterEventStoreDefs(eventStore, (lookDef) => isEventDefsGrouped(def, lookDef));
    newStore.defs[def.defId] = def;
    newStore.instances[instance.instanceId] = instance;
    return newStore;
  }
  return createEmptyEventStore();
}
function isEventDefsGrouped(def0, def1) {
  return Boolean(def0.groupId && def0.groupId === def1.groupId);
}
function createEmptyEventStore() {
  return { defs: {}, instances: {} };
}
function mergeEventStores(store0, store1) {
  return {
    defs: Object.assign(Object.assign({}, store0.defs), store1.defs),
    instances: Object.assign(Object.assign({}, store0.instances), store1.instances)
  };
}
function filterEventStoreDefs(eventStore, filterFunc) {
  let defs = filterHash(eventStore.defs, filterFunc);
  let instances = filterHash(eventStore.instances, (instance) => defs[instance.defId]);
  return { defs, instances };
}
function excludeSubEventStore(master, sub) {
  let { defs, instances } = master;
  let filteredDefs = {};
  let filteredInstances = {};
  for (let defId in defs) {
    if (!sub.defs[defId]) {
      filteredDefs[defId] = defs[defId];
    }
  }
  for (let instanceId in instances) {
    if (!sub.instances[instanceId] && // not explicitly excluded
    filteredDefs[instances[instanceId].defId]) {
      filteredInstances[instanceId] = instances[instanceId];
    }
  }
  return {
    defs: filteredDefs,
    instances: filteredInstances
  };
}
function normalizeConstraint(input2, context2) {
  if (Array.isArray(input2)) {
    return parseEvents(input2, null, context2, true);
  }
  if (typeof input2 === "object" && input2) {
    return parseEvents([input2], null, context2, true);
  }
  if (input2 != null) {
    return String(input2);
  }
  return null;
}
function parseClassNames(raw) {
  if (Array.isArray(raw)) {
    return raw;
  }
  if (typeof raw === "string") {
    return raw.split(/\s+/);
  }
  return [];
}
var EVENT_UI_REFINERS = {
  display: String,
  editable: Boolean,
  startEditable: Boolean,
  durationEditable: Boolean,
  constraint: identity2,
  overlap: identity2,
  allow: identity2,
  className: parseClassNames,
  classNames: parseClassNames,
  color: String,
  backgroundColor: String,
  borderColor: String,
  textColor: String
};
var EMPTY_EVENT_UI = {
  display: null,
  startEditable: null,
  durationEditable: null,
  constraints: [],
  overlap: null,
  allows: [],
  backgroundColor: "",
  borderColor: "",
  textColor: "",
  classNames: []
};
function createEventUi(refined, context2) {
  let constraint = normalizeConstraint(refined.constraint, context2);
  return {
    display: refined.display || null,
    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
    constraints: constraint != null ? [constraint] : [],
    overlap: refined.overlap != null ? refined.overlap : null,
    allows: refined.allow != null ? [refined.allow] : [],
    backgroundColor: refined.backgroundColor || refined.color || "",
    borderColor: refined.borderColor || refined.color || "",
    textColor: refined.textColor || "",
    classNames: (refined.className || []).concat(refined.classNames || [])
    // join singular and plural
  };
}
function combineEventUis(uis) {
  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
}
function combineTwoEventUis(item0, item1) {
  return {
    display: item1.display != null ? item1.display : item0.display,
    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
    constraints: item0.constraints.concat(item1.constraints),
    overlap: typeof item1.overlap === "boolean" ? item1.overlap : item0.overlap,
    allows: item0.allows.concat(item1.allows),
    backgroundColor: item1.backgroundColor || item0.backgroundColor,
    borderColor: item1.borderColor || item0.borderColor,
    textColor: item1.textColor || item0.textColor,
    classNames: item0.classNames.concat(item1.classNames)
  };
}
var EVENT_SOURCE_REFINERS = {
  id: String,
  defaultAllDay: Boolean,
  url: String,
  format: String,
  events: identity2,
  eventDataTransform: identity2,
  // for any network-related sources
  success: identity2,
  failure: identity2
};
function parseEventSource(raw, context2, refiners = buildEventSourceRefiners(context2)) {
  let rawObj;
  if (typeof raw === "string") {
    rawObj = { url: raw };
  } else if (typeof raw === "function" || Array.isArray(raw)) {
    rawObj = { events: raw };
  } else if (typeof raw === "object" && raw) {
    rawObj = raw;
  }
  if (rawObj) {
    let { refined, extra } = refineProps(rawObj, refiners);
    let metaRes = buildEventSourceMeta(refined, context2);
    if (metaRes) {
      return {
        _raw: raw,
        isFetching: false,
        latestFetchId: "",
        fetchRange: null,
        defaultAllDay: refined.defaultAllDay,
        eventDataTransform: refined.eventDataTransform,
        success: refined.success,
        failure: refined.failure,
        publicId: refined.id || "",
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        ui: createEventUi(refined, context2),
        extendedProps: extra
      };
    }
  }
  return null;
}
function buildEventSourceRefiners(context2) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context2.pluginHooks.eventSourceRefiners);
}
function buildEventSourceMeta(raw, context2) {
  let defs = context2.pluginHooks.eventSourceDefs;
  for (let i3 = defs.length - 1; i3 >= 0; i3 -= 1) {
    let def = defs[i3];
    let meta = def.parseMeta(raw);
    if (meta) {
      return { sourceDefId: i3, meta };
    }
  }
  return null;
}
function reduceEventStore(eventStore, action, eventSources, dateProfile, context2) {
  switch (action.type) {
    case "RECEIVE_EVENTS":
      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context2);
    case "RESET_RAW_EVENTS":
      return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context2);
    case "ADD_EVENTS":
      return addEvent(
        eventStore,
        action.eventStore,
        // new ones
        dateProfile ? dateProfile.activeRange : null,
        context2
      );
    case "RESET_EVENTS":
      return action.eventStore;
    case "MERGE_EVENTS":
      return mergeEventStores(eventStore, action.eventStore);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return expandRecurring(eventStore, dateProfile.activeRange, context2);
      }
      return eventStore;
    case "REMOVE_EVENTS":
      return excludeSubEventStore(eventStore, action.eventStore);
    case "REMOVE_EVENT_SOURCE":
      return excludeEventsBySourceId(eventStore, action.sourceId);
    case "REMOVE_ALL_EVENT_SOURCES":
      return filterEventStoreDefs(eventStore, (eventDef) => !eventDef.sourceId);
    case "REMOVE_ALL_EVENTS":
      return createEmptyEventStore();
    default:
      return eventStore;
  }
}
function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context2) {
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context2), eventSource, context2);
    if (fetchRange) {
      subset = expandRecurring(subset, fetchRange, context2);
    }
    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
  }
  return eventStore;
}
function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context2) {
  const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);
  let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context2), eventSource, context2, false, defIdMap, instanceIdMap);
  return expandRecurring(newEventStore, activeRange, context2);
}
function transformRawEvents(rawEvents, eventSource, context2) {
  let calEachTransform = context2.options.eventDataTransform;
  let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
  if (sourceEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
  }
  if (calEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
  }
  return rawEvents;
}
function transformEachRawEvent(rawEvents, func) {
  let refinedEvents;
  if (!func) {
    refinedEvents = rawEvents;
  } else {
    refinedEvents = [];
    for (let rawEvent of rawEvents) {
      let refinedEvent = func(rawEvent);
      if (refinedEvent) {
        refinedEvents.push(refinedEvent);
      } else if (refinedEvent == null) {
        refinedEvents.push(rawEvent);
      }
    }
  }
  return refinedEvents;
}
function addEvent(eventStore, subset, expandRange, context2) {
  if (expandRange) {
    subset = expandRecurring(subset, expandRange, context2);
  }
  return mergeEventStores(eventStore, subset);
}
function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
  let { defs } = eventStore;
  let instances = mapHash(eventStore.instances, (instance) => {
    let def = defs[instance.defId];
    if (def.allDay) {
      return instance;
    }
    return Object.assign(Object.assign({}, instance), { range: {
      start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
      end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
    }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
  });
  return { defs, instances };
}
function excludeEventsBySourceId(eventStore, sourceId) {
  return filterEventStoreDefs(eventStore, (eventDef) => eventDef.sourceId !== sourceId);
}
function excludeInstances(eventStore, removals) {
  return {
    defs: eventStore.defs,
    instances: filterHash(eventStore.instances, (instance) => !removals[instance.instanceId])
  };
}
function buildPublicIdMaps(eventStore) {
  const { defs, instances } = eventStore;
  const defIdMap = {};
  const instanceIdMap = {};
  for (let defId in defs) {
    const def = defs[defId];
    const { publicId } = def;
    if (publicId) {
      defIdMap[publicId] = defId;
    }
  }
  for (let instanceId in instances) {
    const instance = instances[instanceId];
    const def = defs[instance.defId];
    const { publicId } = def;
    if (publicId) {
      instanceIdMap[publicId] = instanceId;
    }
  }
  return { defIdMap, instanceIdMap };
}
var Emitter = class {
  constructor() {
    this.handlers = {};
    this.thisContext = null;
  }
  setThisContext(thisContext) {
    this.thisContext = thisContext;
  }
  setOptions(options) {
    this.options = options;
  }
  on(type, handler) {
    addToHash(this.handlers, type, handler);
  }
  off(type, handler) {
    removeFromHash(this.handlers, type, handler);
  }
  trigger(type, ...args) {
    let attachedHandlers = this.handlers[type] || [];
    let optionHandler = this.options && this.options[type];
    let handlers = [].concat(optionHandler || [], attachedHandlers);
    for (let handler of handlers) {
      handler.apply(this.thisContext, args);
    }
  }
  hasHandlers(type) {
    return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);
  }
};
function addToHash(hash, type, handler) {
  (hash[type] || (hash[type] = [])).push(handler);
}
function removeFromHash(hash, type, handler) {
  if (handler) {
    if (hash[type]) {
      hash[type] = hash[type].filter((func) => func !== handler);
    }
  } else {
    delete hash[type];
  }
}
var DEF_DEFAULTS = {
  startTime: "09:00",
  endTime: "17:00",
  daysOfWeek: [1, 2, 3, 4, 5],
  display: "inverse-background",
  classNames: "fc-non-business",
  groupId: "_businessHours"
  // so multiple defs get grouped
};
function parseBusinessHours(input2, context2) {
  return parseEvents(refineInputs(input2), null, context2);
}
function refineInputs(input2) {
  let rawDefs;
  if (input2 === true) {
    rawDefs = [{}];
  } else if (Array.isArray(input2)) {
    rawDefs = input2.filter((rawDef) => rawDef.daysOfWeek);
  } else if (typeof input2 === "object" && input2) {
    rawDefs = [input2];
  } else {
    rawDefs = [];
  }
  rawDefs = rawDefs.map((rawDef) => Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));
  return rawDefs;
}
function triggerDateSelect(selection, pev, context2) {
  context2.emitter.trigger("select", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context2)), { jsEvent: pev ? pev.origEvent : null, view: context2.viewApi || context2.calendarApi.view }));
}
function triggerDateUnselect(pev, context2) {
  context2.emitter.trigger("unselect", {
    jsEvent: pev ? pev.origEvent : null,
    view: context2.viewApi || context2.calendarApi.view
  });
}
function buildDateSpanApiWithContext(dateSpan, context2) {
  let props = {};
  for (let transform of context2.pluginHooks.dateSpanTransforms) {
    Object.assign(props, transform(dateSpan, context2));
  }
  Object.assign(props, buildDateSpanApi(dateSpan, context2.dateEnv));
  return props;
}
function getDefaultEventEnd(allDay, marker, context2) {
  let { dateEnv, options } = context2;
  let end = marker;
  if (allDay) {
    end = startOfDay(end);
    end = dateEnv.add(end, options.defaultAllDayEventDuration);
  } else {
    end = dateEnv.add(end, options.defaultTimedEventDuration);
  }
  return end;
}
function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context2) {
  let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
  let dest = createEmptyEventStore();
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context2);
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = dest.defs[instance.defId];
    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context2);
  }
  return dest;
}
function applyMutationToEventDef(eventDef, eventConfig, mutation, context2) {
  let standardProps = mutation.standardProps || {};
  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
    standardProps.hasEnd = true;
  }
  let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), { ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui) });
  if (mutation.extendedProps) {
    copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);
  }
  for (let applier of context2.pluginHooks.eventDefMutationAppliers) {
    applier(copy, mutation, context2);
  }
  if (!copy.hasEnd && context2.options.forceEventDuration) {
    copy.hasEnd = true;
  }
  return copy;
}
function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context2) {
  let { dateEnv } = context2;
  let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
  let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
  let copy = Object.assign({}, eventInstance);
  if (forceAllDay) {
    copy.range = computeAlignedDayRange(copy.range);
  }
  if (mutation.datesDelta && eventConfig.startEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.datesDelta),
      end: dateEnv.add(copy.range.end, mutation.datesDelta)
    };
  }
  if (mutation.startDelta && eventConfig.durationEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.startDelta),
      end: copy.range.end
    };
  }
  if (mutation.endDelta && eventConfig.durationEditable) {
    copy.range = {
      start: copy.range.start,
      end: dateEnv.add(copy.range.end, mutation.endDelta)
    };
  }
  if (clearEnd) {
    copy.range = {
      start: copy.range.start,
      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context2)
    };
  }
  if (eventDef.allDay) {
    copy.range = {
      start: startOfDay(copy.range.start),
      end: startOfDay(copy.range.end)
    };
  }
  if (copy.range.end < copy.range.start) {
    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context2);
  }
  return copy;
}
var EventSourceImpl = class {
  constructor(context2, internalEventSource) {
    this.context = context2;
    this.internalEventSource = internalEventSource;
  }
  remove() {
    this.context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: this.internalEventSource.sourceId
    });
  }
  refetch() {
    this.context.dispatch({
      type: "FETCH_EVENT_SOURCES",
      sourceIds: [this.internalEventSource.sourceId],
      isRefetch: true
    });
  }
  get id() {
    return this.internalEventSource.publicId;
  }
  get url() {
    return this.internalEventSource.meta.url;
  }
  get format() {
    return this.internalEventSource.meta.format;
  }
};
var EventImpl = class _EventImpl {
  // instance will be null if expressing a recurring event that has no current instances,
  // OR if trying to validate an incoming external event that has no dates assigned
  constructor(context2, def, instance) {
    this._context = context2;
    this._def = def;
    this._instance = instance || null;
  }
  /*
  TODO: make event struct more responsible for this
  */
  setProp(name, val) {
    if (name in EVENT_DATE_REFINERS) {
      console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead.");
    } else if (name === "id") {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { publicId: val }
        // hardcoded internal name
      });
    } else if (name in EVENT_NON_DATE_REFINERS) {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { [name]: val }
      });
    } else if (name in EVENT_UI_REFINERS) {
      let ui = EVENT_UI_REFINERS[name](val);
      if (name === "color") {
        ui = { backgroundColor: val, borderColor: val };
      } else if (name === "editable") {
        ui = { startEditable: val, durationEditable: val };
      } else {
        ui = { [name]: val };
      }
      this.mutate({
        standardProps: { ui }
      });
    } else {
      console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);
    }
  }
  setExtendedProp(name, val) {
    this.mutate({
      extendedProps: { [name]: val }
    });
  }
  setStart(startInput, options = {}) {
    let { dateEnv } = this._context;
    let start = dateEnv.createMarker(startInput);
    if (start && this._instance) {
      let instanceRange = this._instance.range;
      let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
      if (options.maintainDuration) {
        this.mutate({ datesDelta: startDelta });
      } else {
        this.mutate({ startDelta });
      }
    }
  }
  setEnd(endInput, options = {}) {
    let { dateEnv } = this._context;
    let end;
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      if (end) {
        let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
        this.mutate({ endDelta });
      } else {
        this.mutate({ standardProps: { hasEnd: false } });
      }
    }
  }
  setDates(startInput, endInput, options = {}) {
    let { dateEnv } = this._context;
    let standardProps = { allDay: options.allDay };
    let start = dateEnv.createMarker(startInput);
    let end;
    if (!start) {
      return;
    }
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      let instanceRange = this._instance.range;
      if (options.allDay === true) {
        instanceRange = computeAlignedDayRange(instanceRange);
      }
      let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
      if (end) {
        let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
        if (durationsEqual(startDelta, endDelta)) {
          this.mutate({ datesDelta: startDelta, standardProps });
        } else {
          this.mutate({ startDelta, endDelta, standardProps });
        }
      } else {
        standardProps.hasEnd = false;
        this.mutate({ datesDelta: startDelta, standardProps });
      }
    }
  }
  moveStart(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ startDelta: delta });
    }
  }
  moveEnd(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ endDelta: delta });
    }
  }
  moveDates(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ datesDelta: delta });
    }
  }
  setAllDay(allDay, options = {}) {
    let standardProps = { allDay };
    let { maintainDuration } = options;
    if (maintainDuration == null) {
      maintainDuration = this._context.options.allDayMaintainDuration;
    }
    if (this._def.allDay !== allDay) {
      standardProps.hasEnd = maintainDuration;
    }
    this.mutate({ standardProps });
  }
  formatRange(formatInput) {
    let { dateEnv } = this._context;
    let instance = this._instance;
    let formatter = createFormatter(formatInput);
    if (this._def.hasEnd) {
      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
        forcedStartTzo: instance.forcedStartTzo,
        forcedEndTzo: instance.forcedEndTzo
      });
    }
    return dateEnv.format(instance.range.start, formatter, {
      forcedTzo: instance.forcedStartTzo
    });
  }
  mutate(mutation) {
    let instance = this._instance;
    if (instance) {
      let def = this._def;
      let context2 = this._context;
      let { eventStore } = context2.getCurrentData();
      let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);
      let eventConfigBase = {
        "": {
          display: "",
          startEditable: true,
          durationEditable: true,
          constraints: [],
          overlap: null,
          allows: [],
          backgroundColor: "",
          borderColor: "",
          textColor: "",
          classNames: []
        }
      };
      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context2);
      let oldEvent = new _EventImpl(context2, def, instance);
      this._def = relevantEvents.defs[def.defId];
      this._instance = relevantEvents.instances[instance.instanceId];
      context2.dispatch({
        type: "MERGE_EVENTS",
        eventStore: relevantEvents
      });
      context2.emitter.trigger("eventChange", {
        oldEvent,
        event: this,
        relatedEvents: buildEventApis(relevantEvents, context2, instance),
        revert() {
          context2.dispatch({
            type: "RESET_EVENTS",
            eventStore
            // the ORIGINAL store
          });
        }
      });
    }
  }
  remove() {
    let context2 = this._context;
    let asStore = eventApiToStore(this);
    context2.dispatch({
      type: "REMOVE_EVENTS",
      eventStore: asStore
    });
    context2.emitter.trigger("eventRemove", {
      event: this,
      relatedEvents: [],
      revert() {
        context2.dispatch({
          type: "MERGE_EVENTS",
          eventStore: asStore
        });
      }
    });
  }
  get source() {
    let { sourceId } = this._def;
    if (sourceId) {
      return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);
    }
    return null;
  }
  get start() {
    return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
  }
  get end() {
    return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
  }
  get startStr() {
    let instance = this._instance;
    if (instance) {
      return this._context.dateEnv.formatIso(instance.range.start, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedStartTzo
      });
    }
    return "";
  }
  get endStr() {
    let instance = this._instance;
    if (instance && this._def.hasEnd) {
      return this._context.dateEnv.formatIso(instance.range.end, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedEndTzo
      });
    }
    return "";
  }
  // computable props that all access the def
  // TODO: find a TypeScript-compatible way to do this at scale
  get id() {
    return this._def.publicId;
  }
  get groupId() {
    return this._def.groupId;
  }
  get allDay() {
    return this._def.allDay;
  }
  get title() {
    return this._def.title;
  }
  get url() {
    return this._def.url;
  }
  get display() {
    return this._def.ui.display || "auto";
  }
  // bad. just normalize the type earlier
  get startEditable() {
    return this._def.ui.startEditable;
  }
  get durationEditable() {
    return this._def.ui.durationEditable;
  }
  get constraint() {
    return this._def.ui.constraints[0] || null;
  }
  get overlap() {
    return this._def.ui.overlap;
  }
  get allow() {
    return this._def.ui.allows[0] || null;
  }
  get backgroundColor() {
    return this._def.ui.backgroundColor;
  }
  get borderColor() {
    return this._def.ui.borderColor;
  }
  get textColor() {
    return this._def.ui.textColor;
  }
  // NOTE: user can't modify these because Object.freeze was called in event-def parsing
  get classNames() {
    return this._def.ui.classNames;
  }
  get extendedProps() {
    return this._def.extendedProps;
  }
  toPlainObject(settings = {}) {
    let def = this._def;
    let { ui } = def;
    let { startStr, endStr } = this;
    let res = {
      allDay: def.allDay
    };
    if (def.title) {
      res.title = def.title;
    }
    if (startStr) {
      res.start = startStr;
    }
    if (endStr) {
      res.end = endStr;
    }
    if (def.publicId) {
      res.id = def.publicId;
    }
    if (def.groupId) {
      res.groupId = def.groupId;
    }
    if (def.url) {
      res.url = def.url;
    }
    if (ui.display && ui.display !== "auto") {
      res.display = ui.display;
    }
    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
      res.color = ui.backgroundColor;
    } else {
      if (ui.backgroundColor) {
        res.backgroundColor = ui.backgroundColor;
      }
      if (ui.borderColor) {
        res.borderColor = ui.borderColor;
      }
    }
    if (ui.textColor) {
      res.textColor = ui.textColor;
    }
    if (ui.classNames.length) {
      res.classNames = ui.classNames;
    }
    if (Object.keys(def.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        Object.assign(res, def.extendedProps);
      } else {
        res.extendedProps = def.extendedProps;
      }
    }
    return res;
  }
  toJSON() {
    return this.toPlainObject();
  }
};
function eventApiToStore(eventApi) {
  let def = eventApi._def;
  let instance = eventApi._instance;
  return {
    defs: { [def.defId]: def },
    instances: instance ? { [instance.instanceId]: instance } : {}
  };
}
function buildEventApis(eventStore, context2, excludeInstance) {
  let { defs, instances } = eventStore;
  let eventApis = [];
  let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : "";
  for (let id in instances) {
    let instance = instances[id];
    let def = defs[instance.defId];
    if (instance.instanceId !== excludeInstanceId) {
      eventApis.push(new EventImpl(context2, def, instance));
    }
  }
  return eventApis;
}
function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
  let inverseBgByGroupId = {};
  let inverseBgByDefId = {};
  let defByGroupId = {};
  let bgRanges = [];
  let fgRanges = [];
  let eventUis = compileEventUis(eventStore.defs, eventUiBases);
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    let ui = eventUis[def.defId];
    if (ui.display === "inverse-background") {
      if (def.groupId) {
        inverseBgByGroupId[def.groupId] = [];
        if (!defByGroupId[def.groupId]) {
          defByGroupId[def.groupId] = def;
        }
      } else {
        inverseBgByDefId[defId] = [];
      }
    }
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = eventStore.defs[instance.defId];
    let ui = eventUis[def.defId];
    let origRange = instance.range;
    let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
    let slicedRange = intersectRanges(normalRange, framingRange);
    if (slicedRange) {
      if (ui.display === "inverse-background") {
        if (def.groupId) {
          inverseBgByGroupId[def.groupId].push(slicedRange);
        } else {
          inverseBgByDefId[instance.defId].push(slicedRange);
        }
      } else if (ui.display !== "none") {
        (ui.display === "background" ? bgRanges : fgRanges).push({
          def,
          ui,
          instance,
          range: slicedRange,
          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
        });
      }
    }
  }
  for (let groupId in inverseBgByGroupId) {
    let ranges = inverseBgByGroupId[groupId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      let def = defByGroupId[groupId];
      let ui = eventUis[def.defId];
      bgRanges.push({
        def,
        ui,
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  for (let defId in inverseBgByDefId) {
    let ranges = inverseBgByDefId[defId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      bgRanges.push({
        def: eventStore.defs[defId],
        ui: eventUis[defId],
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  return { bg: bgRanges, fg: fgRanges };
}
function setElSeg(el, seg) {
  el.fcSeg = seg;
}
function getElSeg(el) {
  return el.fcSeg || el.parentNode.fcSeg || // for the harness
  null;
}
function compileEventUis(eventDefs, eventUiBases) {
  return mapHash(eventDefs, (eventDef) => compileEventUi(eventDef, eventUiBases));
}
function compileEventUi(eventDef, eventUiBases) {
  let uis = [];
  if (eventUiBases[""]) {
    uis.push(eventUiBases[""]);
  }
  if (eventUiBases[eventDef.defId]) {
    uis.push(eventUiBases[eventDef.defId]);
  }
  uis.push(eventDef.ui);
  return combineEventUis(uis);
}
function sortEventSegs(segs, eventOrderSpecs) {
  let objs = segs.map(buildSegCompareObj);
  objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, eventOrderSpecs));
  return objs.map((c3) => c3._seg);
}
function buildSegCompareObj(seg) {
  let { eventRange } = seg;
  let eventDef = eventRange.def;
  let range = eventRange.instance ? eventRange.instance.range : eventRange.range;
  let start = range.start ? range.start.valueOf() : 0;
  let end = range.end ? range.end.valueOf() : 0;
  return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {
    id: eventDef.publicId,
    start,
    end,
    duration: end - start,
    allDay: Number(eventDef.allDay),
    _seg: seg
  });
}
function computeSegDraggable(seg, context2) {
  let { pluginHooks } = context2;
  let transformers = pluginHooks.isDraggableTransformers;
  let { def, ui } = seg.eventRange;
  let val = ui.startEditable;
  for (let transformer of transformers) {
    val = transformer(val, def, ui, context2);
  }
  return val;
}
function computeSegStartResizable(seg, context2) {
  return seg.isStart && seg.eventRange.ui.durationEditable && context2.options.eventResizableFromStart;
}
function computeSegEndResizable(seg, context2) {
  return seg.isEnd && seg.eventRange.ui.durationEditable;
}
function buildSegTimeText(seg, timeFormat, context2, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {
  let { dateEnv, options } = context2;
  let { displayEventTime, displayEventEnd } = options;
  let eventDef = seg.eventRange.def;
  let eventInstance = seg.eventRange.instance;
  if (displayEventTime == null) {
    displayEventTime = defaultDisplayEventTime !== false;
  }
  if (displayEventEnd == null) {
    displayEventEnd = defaultDisplayEventEnd !== false;
  }
  let wholeEventStart = eventInstance.range.start;
  let wholeEventEnd = eventInstance.range.end;
  let segStart = startOverride || seg.start || seg.eventRange.range.start;
  let segEnd = endOverride || seg.end || seg.eventRange.range.end;
  let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
  let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();
  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
    segStart = isStartDay ? wholeEventStart : segStart;
    segEnd = isEndDay ? wholeEventEnd : segEnd;
    if (displayEventEnd && eventDef.hasEnd) {
      return dateEnv.formatRange(segStart, segEnd, timeFormat, {
        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
      });
    }
    return dateEnv.format(segStart, timeFormat, {
      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo
      // nooooo, same
    });
  }
  return "";
}
function getSegMeta(seg, todayRange, nowDate) {
  let segRange = seg.eventRange.range;
  return {
    isPast: segRange.end <= (nowDate || todayRange.start),
    isFuture: segRange.start >= (nowDate || todayRange.end),
    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
  };
}
function getEventClassNames(props) {
  let classNames = ["fc-event"];
  if (props.isMirror) {
    classNames.push("fc-event-mirror");
  }
  if (props.isDraggable) {
    classNames.push("fc-event-draggable");
  }
  if (props.isStartResizable || props.isEndResizable) {
    classNames.push("fc-event-resizable");
  }
  if (props.isDragging) {
    classNames.push("fc-event-dragging");
  }
  if (props.isResizing) {
    classNames.push("fc-event-resizing");
  }
  if (props.isSelected) {
    classNames.push("fc-event-selected");
  }
  if (props.isStart) {
    classNames.push("fc-event-start");
  }
  if (props.isEnd) {
    classNames.push("fc-event-end");
  }
  if (props.isPast) {
    classNames.push("fc-event-past");
  }
  if (props.isToday) {
    classNames.push("fc-event-today");
  }
  if (props.isFuture) {
    classNames.push("fc-event-future");
  }
  return classNames;
}
function buildEventRangeKey(eventRange) {
  return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;
}
function getSegAnchorAttrs(seg, context2) {
  let { def, instance } = seg.eventRange;
  let { url } = def;
  if (url) {
    return { href: url };
  }
  let { emitter, options } = context2;
  let { eventInteractive } = options;
  if (eventInteractive == null) {
    eventInteractive = def.interactive;
    if (eventInteractive == null) {
      eventInteractive = Boolean(emitter.hasHandlers("eventClick"));
    }
  }
  if (eventInteractive) {
    return createAriaKeyboardAttrs((ev) => {
      emitter.trigger("eventClick", {
        el: ev.target,
        event: new EventImpl(context2, def, instance),
        jsEvent: ev,
        view: context2.viewApi
      });
    });
  }
  return {};
}
var STANDARD_PROPS = {
  start: identity2,
  end: identity2,
  allDay: Boolean
};
function parseDateSpan(raw, dateEnv, defaultDuration) {
  let span = parseOpenDateSpan(raw, dateEnv);
  let { range } = span;
  if (!range.start) {
    return null;
  }
  if (!range.end) {
    if (defaultDuration == null) {
      return null;
    }
    range.end = dateEnv.add(range.start, defaultDuration);
  }
  return span;
}
function parseOpenDateSpan(raw, dateEnv) {
  let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);
  let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
  let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
  let { allDay } = standardProps;
  if (allDay == null) {
    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
  }
  return Object.assign({ range: {
    start: startMeta ? startMeta.marker : null,
    end: endMeta ? endMeta.marker : null
  }, allDay }, extra);
}
function isDateSpansEqual(span0, span1) {
  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
}
function isSpanPropsEqual(span0, span1) {
  for (let propName in span1) {
    if (propName !== "range" && propName !== "allDay") {
      if (span0[propName] !== span1[propName]) {
        return false;
      }
    }
  }
  for (let propName in span0) {
    if (!(propName in span1)) {
      return false;
    }
  }
  return true;
}
function buildDateSpanApi(span, dateEnv) {
  return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });
}
function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {
  return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });
}
function buildRangeApi(range, dateEnv, omitTime) {
  return {
    start: dateEnv.toDate(range.start),
    end: dateEnv.toDate(range.end),
    startStr: dateEnv.formatIso(range.start, { omitTime }),
    endStr: dateEnv.formatIso(range.end, { omitTime })
  };
}
function fabricateEventRange(dateSpan, eventUiBases, context2) {
  let res = refineEventDef({ editable: false }, context2);
  let def = parseEventDef(
    res.refined,
    res.extra,
    "",
    // sourceId
    dateSpan.allDay,
    true,
    // hasEnd
    context2
  );
  return {
    def,
    ui: compileEventUi(def, eventUiBases),
    instance: createEventInstance(def.defId, dateSpan.range),
    range: dateSpan.range,
    isStart: true,
    isEnd: true
  };
}
function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {
  let isResolved = false;
  let wrappedSuccess = function(res2) {
    if (!isResolved) {
      isResolved = true;
      normalizedSuccessCallback(res2);
    }
  };
  let wrappedFailure = function(error) {
    if (!isResolved) {
      isResolved = true;
      normalizedFailureCallback(error);
    }
  };
  let res = func(wrappedSuccess, wrappedFailure);
  if (res && typeof res.then === "function") {
    res.then(wrappedSuccess, wrappedFailure);
  }
}
var JsonRequestError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
function requestJson(method, url, params) {
  method = method.toUpperCase();
  const fetchOptions = {
    method
  };
  if (method === "GET") {
    url += (url.indexOf("?") === -1 ? "?" : "&") + new URLSearchParams(params);
  } else {
    fetchOptions.body = new URLSearchParams(params);
    fetchOptions.headers = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
  }
  return fetch(url, fetchOptions).then((fetchRes) => {
    if (fetchRes.ok) {
      return fetchRes.json().then((parsedResponse) => {
        return [parsedResponse, fetchRes];
      }, () => {
        throw new JsonRequestError("Failure parsing JSON", fetchRes);
      });
    } else {
      throw new JsonRequestError("Request failed", fetchRes);
    }
  });
}
var canVGrowWithinCell;
function getCanVGrowWithinCell() {
  if (canVGrowWithinCell == null) {
    canVGrowWithinCell = computeCanVGrowWithinCell();
  }
  return canVGrowWithinCell;
}
function computeCanVGrowWithinCell() {
  if (typeof document === "undefined") {
    return true;
  }
  let el = document.createElement("div");
  el.style.position = "absolute";
  el.style.top = "0px";
  el.style.left = "0px";
  el.innerHTML = "<table><tr><td><div></div></td></tr></table>";
  el.querySelector("table").style.height = "100px";
  el.querySelector("div").style.height = "100%";
  document.body.appendChild(el);
  let div = el.querySelector("div");
  let possible = div.offsetHeight > 0;
  document.body.removeChild(el);
  return possible;
}
var CalendarRoot = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      forPrint: false
    };
    this.handleBeforePrint = () => {
      flushSync(() => {
        this.setState({ forPrint: true });
      });
    };
    this.handleAfterPrint = () => {
      flushSync(() => {
        this.setState({ forPrint: false });
      });
    };
  }
  render() {
    let { props } = this;
    let { options } = props;
    let { forPrint } = this.state;
    let isHeightAuto = forPrint || options.height === "auto" || options.contentHeight === "auto";
    let height = !isHeightAuto && options.height != null ? options.height : "";
    let classNames = [
      "fc",
      forPrint ? "fc-media-print" : "fc-media-screen",
      `fc-direction-${options.direction}`,
      props.theme.getClass("root")
    ];
    if (!getCanVGrowWithinCell()) {
      classNames.push("fc-liquid-hack");
    }
    return props.children(classNames, height, isHeightAuto, forPrint);
  }
  componentDidMount() {
    let { emitter } = this.props;
    emitter.on("_beforeprint", this.handleBeforePrint);
    emitter.on("_afterprint", this.handleAfterPrint);
  }
  componentWillUnmount() {
    let { emitter } = this.props;
    emitter.off("_beforeprint", this.handleBeforePrint);
    emitter.off("_afterprint", this.handleAfterPrint);
  }
};
var Interaction = class {
  constructor(settings) {
    this.component = settings.component;
    this.isHitComboAllowed = settings.isHitComboAllowed || null;
  }
  destroy() {
  }
};
function parseInteractionSettings(component, input2) {
  return {
    component,
    el: input2.el,
    useEventCenter: input2.useEventCenter != null ? input2.useEventCenter : true,
    isHitComboAllowed: input2.isHitComboAllowed || null
  };
}
function interactionSettingsToStore(settings) {
  return {
    [settings.component.uid]: settings
  };
}
var interactionSettingsStore = {};
var CalendarImpl = class {
  getCurrentData() {
    return this.currentDataManager.getCurrentData();
  }
  dispatch(action) {
    this.currentDataManager.dispatch(action);
  }
  get view() {
    return this.getCurrentData().viewApi;
  }
  batchRendering(callback) {
    callback();
  }
  updateSize() {
    this.trigger("_resize", true);
  }
  // Options
  // -----------------------------------------------------------------------------------------------------------------
  setOption(name, val) {
    this.dispatch({
      type: "SET_OPTION",
      optionName: name,
      rawOptionValue: val
    });
  }
  getOption(name) {
    return this.currentDataManager.currentCalendarOptionsInput[name];
  }
  getAvailableLocaleCodes() {
    return Object.keys(this.getCurrentData().availableRawLocales);
  }
  // Trigger
  // -----------------------------------------------------------------------------------------------------------------
  on(handlerName, handler) {
    let { currentDataManager } = this;
    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
      currentDataManager.emitter.on(handlerName, handler);
    } else {
      console.warn(`Unknown listener name '${handlerName}'`);
    }
  }
  off(handlerName, handler) {
    this.currentDataManager.emitter.off(handlerName, handler);
  }
  // not meant for public use
  trigger(handlerName, ...args) {
    this.currentDataManager.emitter.trigger(handlerName, ...args);
  }
  // View
  // -----------------------------------------------------------------------------------------------------------------
  changeView(viewType, dateOrRange) {
    this.batchRendering(() => {
      this.unselect();
      if (dateOrRange) {
        if (dateOrRange.start && dateOrRange.end) {
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType
          });
          this.dispatch({
            type: "SET_OPTION",
            optionName: "visibleRange",
            rawOptionValue: dateOrRange
          });
        } else {
          let { dateEnv } = this.getCurrentData();
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType,
            dateMarker: dateEnv.createMarker(dateOrRange)
          });
        }
      } else {
        this.dispatch({
          type: "CHANGE_VIEW_TYPE",
          viewType
        });
      }
    });
  }
  // Forces navigation to a view for the given date.
  // `viewType` can be a specific view name or a generic one like "week" or "day".
  // needs to change
  zoomTo(dateMarker, viewType) {
    let state = this.getCurrentData();
    let spec;
    viewType = viewType || "day";
    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
    this.unselect();
    if (spec) {
      this.dispatch({
        type: "CHANGE_VIEW_TYPE",
        viewType: spec.type,
        dateMarker
      });
    } else {
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker
      });
    }
  }
  // Given a duration singular unit, like "week" or "day", finds a matching view spec.
  // Preference is given to views that have corresponding buttons.
  getUnitViewSpec(unit) {
    let { viewSpecs, toolbarConfig } = this.getCurrentData();
    let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
    let i3;
    let spec;
    for (let viewType in viewSpecs) {
      viewTypes.push(viewType);
    }
    for (i3 = 0; i3 < viewTypes.length; i3 += 1) {
      spec = viewSpecs[viewTypes[i3]];
      if (spec) {
        if (spec.singleUnit === unit) {
          return spec;
        }
      }
    }
    return null;
  }
  // Current Date
  // -----------------------------------------------------------------------------------------------------------------
  prev() {
    this.unselect();
    this.dispatch({ type: "PREV" });
  }
  next() {
    this.unselect();
    this.dispatch({ type: "NEXT" });
  }
  prevYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, -1)
    });
  }
  nextYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, 1)
    });
  }
  today() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)
    });
  }
  gotoDate(zonedDateInput) {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.createMarker(zonedDateInput)
    });
  }
  incrementDate(deltaInput) {
    let state = this.getCurrentData();
    let delta = createDuration(deltaInput);
    if (delta) {
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.dateEnv.add(state.currentDate, delta)
      });
    }
  }
  getDate() {
    let state = this.getCurrentData();
    return state.dateEnv.toDate(state.currentDate);
  }
  // Date Formatting Utils
  // -----------------------------------------------------------------------------------------------------------------
  formatDate(d2, formatter) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.format(dateEnv.createMarker(d2), createFormatter(formatter));
  }
  // `settings` is for formatter AND isEndExclusive
  formatRange(d0, d1, settings) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
  }
  formatIso(d2, omitTime) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatIso(dateEnv.createMarker(d2), { omitTime });
  }
  // Date Selection / Event Selection / DayClick
  // -----------------------------------------------------------------------------------------------------------------
  select(dateOrObj, endDate) {
    let selectionInput;
    if (endDate == null) {
      if (dateOrObj.start != null) {
        selectionInput = dateOrObj;
      } else {
        selectionInput = {
          start: dateOrObj,
          end: null
        };
      }
    } else {
      selectionInput = {
        start: dateOrObj,
        end: endDate
      };
    }
    let state = this.getCurrentData();
    let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));
    if (selection) {
      this.dispatch({ type: "SELECT_DATES", selection });
      triggerDateSelect(selection, null, state);
    }
  }
  unselect(pev) {
    let state = this.getCurrentData();
    if (state.dateSelection) {
      this.dispatch({ type: "UNSELECT_DATES" });
      triggerDateUnselect(pev, state);
    }
  }
  // Public Events API
  // -----------------------------------------------------------------------------------------------------------------
  addEvent(eventInput, sourceInput) {
    if (eventInput instanceof EventImpl) {
      let def = eventInput._def;
      let instance = eventInput._instance;
      let currentData = this.getCurrentData();
      if (!currentData.eventStore.defs[def.defId]) {
        this.dispatch({
          type: "ADD_EVENTS",
          eventStore: eventTupleToStore({ def, instance })
          // TODO: better util for two args?
        });
        this.triggerEventAdd(eventInput);
      }
      return eventInput;
    }
    let state = this.getCurrentData();
    let eventSource;
    if (sourceInput instanceof EventSourceImpl) {
      eventSource = sourceInput.internalEventSource;
    } else if (typeof sourceInput === "boolean") {
      if (sourceInput) {
        [eventSource] = hashValuesToArray(state.eventSources);
      }
    } else if (sourceInput != null) {
      let sourceApi = this.getEventSourceById(sourceInput);
      if (!sourceApi) {
        console.warn(`Could not find an event source with ID "${sourceInput}"`);
        return null;
      }
      eventSource = sourceApi.internalEventSource;
    }
    let tuple = parseEvent(eventInput, eventSource, state, false);
    if (tuple) {
      let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
      this.dispatch({
        type: "ADD_EVENTS",
        eventStore: eventTupleToStore(tuple)
      });
      this.triggerEventAdd(newEventApi);
      return newEventApi;
    }
    return null;
  }
  triggerEventAdd(eventApi) {
    let { emitter } = this.getCurrentData();
    emitter.trigger("eventAdd", {
      event: eventApi,
      relatedEvents: [],
      revert: () => {
        this.dispatch({
          type: "REMOVE_EVENTS",
          eventStore: eventApiToStore(eventApi)
        });
      }
    });
  }
  // TODO: optimize
  getEventById(id) {
    let state = this.getCurrentData();
    let { defs, instances } = state.eventStore;
    id = String(id);
    for (let defId in defs) {
      let def = defs[defId];
      if (def.publicId === id) {
        if (def.recurringDef) {
          return new EventImpl(state, def, null);
        }
        for (let instanceId in instances) {
          let instance = instances[instanceId];
          if (instance.defId === def.defId) {
            return new EventImpl(state, def, instance);
          }
        }
      }
    }
    return null;
  }
  getEvents() {
    let currentData = this.getCurrentData();
    return buildEventApis(currentData.eventStore, currentData);
  }
  removeAllEvents() {
    this.dispatch({ type: "REMOVE_ALL_EVENTS" });
  }
  // Public Event Sources API
  // -----------------------------------------------------------------------------------------------------------------
  getEventSources() {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    let sourceApis = [];
    for (let internalId in sourceHash) {
      sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));
    }
    return sourceApis;
  }
  getEventSourceById(id) {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    id = String(id);
    for (let sourceId in sourceHash) {
      if (sourceHash[sourceId].publicId === id) {
        return new EventSourceImpl(state, sourceHash[sourceId]);
      }
    }
    return null;
  }
  addEventSource(sourceInput) {
    let state = this.getCurrentData();
    if (sourceInput instanceof EventSourceImpl) {
      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
        this.dispatch({
          type: "ADD_EVENT_SOURCES",
          sources: [sourceInput.internalEventSource]
        });
      }
      return sourceInput;
    }
    let eventSource = parseEventSource(sourceInput, state);
    if (eventSource) {
      this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [eventSource] });
      return new EventSourceImpl(state, eventSource);
    }
    return null;
  }
  removeAllEventSources() {
    this.dispatch({ type: "REMOVE_ALL_EVENT_SOURCES" });
  }
  refetchEvents() {
    this.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: true });
  }
  // Scroll
  // -----------------------------------------------------------------------------------------------------------------
  scrollToTime(timeInput) {
    let time = createDuration(timeInput);
    if (time) {
      this.trigger("_scrollRequest", { time });
    }
  }
};
function pointInsideRect(point, rect) {
  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
}
function intersectRects(rect1, rect2) {
  let res = {
    left: Math.max(rect1.left, rect2.left),
    right: Math.min(rect1.right, rect2.right),
    top: Math.max(rect1.top, rect2.top),
    bottom: Math.min(rect1.bottom, rect2.bottom)
  };
  if (res.left < res.right && res.top < res.bottom) {
    return res;
  }
  return false;
}
function constrainPoint(point, rect) {
  return {
    left: Math.min(Math.max(point.left, rect.left), rect.right),
    top: Math.min(Math.max(point.top, rect.top), rect.bottom)
  };
}
function getRectCenter(rect) {
  return {
    left: (rect.left + rect.right) / 2,
    top: (rect.top + rect.bottom) / 2
  };
}
function diffPoints(point1, point2) {
  return {
    left: point1.left - point2.left,
    top: point1.top - point2.top
  };
}
var EMPTY_EVENT_STORE = createEmptyEventStore();
function getDateMeta(date, todayRange, nowDate, dateProfile) {
  return {
    dow: date.getUTCDay(),
    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
  };
}
function getDayClassNames(meta, theme) {
  let classNames = [
    "fc-day",
    `fc-day-${DAY_IDS[meta.dow]}`
  ];
  if (meta.isDisabled) {
    classNames.push("fc-day-disabled");
  } else {
    if (meta.isToday) {
      classNames.push("fc-day-today");
      classNames.push(theme.getClass("today"));
    }
    if (meta.isPast) {
      classNames.push("fc-day-past");
    }
    if (meta.isFuture) {
      classNames.push("fc-day-future");
    }
    if (meta.isOther) {
      classNames.push("fc-day-other");
    }
  }
  return classNames;
}
var DAY_FORMAT = createFormatter({ year: "numeric", month: "long", day: "numeric" });
var WEEK_FORMAT = createFormatter({ week: "long" });
function buildNavLinkAttrs(context2, dateMarker, viewType = "day", isTabbable = true) {
  const { dateEnv, options, calendarApi } = context2;
  let dateStr = dateEnv.format(dateMarker, viewType === "week" ? WEEK_FORMAT : DAY_FORMAT);
  if (options.navLinks) {
    let zonedDate = dateEnv.toDate(dateMarker);
    const handleInteraction = (ev) => {
      let customAction = viewType === "day" ? options.navLinkDayClick : viewType === "week" ? options.navLinkWeekClick : null;
      if (typeof customAction === "function") {
        customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
      } else {
        if (typeof customAction === "string") {
          viewType = customAction;
        }
        calendarApi.zoomTo(dateMarker, viewType);
      }
    };
    return Object.assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), "data-navlink": "" }, isTabbable ? createAriaClickAttrs(handleInteraction) : { onClick: handleInteraction });
  }
  return { "aria-label": dateStr };
}
var _isRtlScrollbarOnLeft = null;
function getIsRtlScrollbarOnLeft() {
  if (_isRtlScrollbarOnLeft === null) {
    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
  }
  return _isRtlScrollbarOnLeft;
}
function computeIsRtlScrollbarOnLeft() {
  let outerEl = document.createElement("div");
  applyStyle(outerEl, {
    position: "absolute",
    top: -1e3,
    left: 0,
    border: 0,
    padding: 0,
    overflow: "scroll",
    direction: "rtl"
  });
  outerEl.innerHTML = "<div></div>";
  document.body.appendChild(outerEl);
  let innerEl = outerEl.firstChild;
  let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
  removeElement(outerEl);
  return res;
}
var _scrollbarWidths;
function getScrollbarWidths() {
  if (!_scrollbarWidths) {
    _scrollbarWidths = computeScrollbarWidths();
  }
  return _scrollbarWidths;
}
function computeScrollbarWidths() {
  let el = document.createElement("div");
  el.style.overflow = "scroll";
  el.style.position = "absolute";
  el.style.top = "-9999px";
  el.style.left = "-9999px";
  document.body.appendChild(el);
  let res = computeScrollbarWidthsForEl(el);
  document.body.removeChild(el);
  return res;
}
function computeScrollbarWidthsForEl(el) {
  return {
    x: el.offsetHeight - el.clientHeight,
    y: el.offsetWidth - el.clientWidth
  };
}
function computeEdges(el, getPadding = false) {
  let computedStyle = window.getComputedStyle(el);
  let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
  let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
  let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
  let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
  let badScrollbarWidths = computeScrollbarWidthsForEl(el);
  let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
  let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
  let res = {
    borderLeft,
    borderRight,
    borderTop,
    borderBottom,
    scrollbarBottom,
    scrollbarLeft: 0,
    scrollbarRight: 0
  };
  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === "rtl") {
    res.scrollbarLeft = scrollbarLeftRight;
  } else {
    res.scrollbarRight = scrollbarLeftRight;
  }
  if (getPadding) {
    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
  }
  return res;
}
function computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {
  let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
  let edges = computeEdges(el, goWithinPadding);
  let res = {
    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
    right: outerRect.right - edges.borderRight - edges.scrollbarRight,
    top: outerRect.top + edges.borderTop,
    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
  };
  if (goWithinPadding) {
    res.left += edges.paddingLeft;
    res.right -= edges.paddingRight;
    res.top += edges.paddingTop;
    res.bottom -= edges.paddingBottom;
  }
  return res;
}
function computeRect(el) {
  let rect = el.getBoundingClientRect();
  return {
    left: rect.left + window.scrollX,
    top: rect.top + window.scrollY,
    right: rect.right + window.scrollX,
    bottom: rect.bottom + window.scrollY
  };
}
function computeClippedClientRect(el) {
  let clippingParents = getClippingParents(el);
  let rect = el.getBoundingClientRect();
  for (let clippingParent of clippingParents) {
    let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());
    if (intersection) {
      rect = intersection;
    } else {
      return null;
    }
  }
  return rect;
}
function getClippingParents(el) {
  let parents = [];
  while (el instanceof HTMLElement) {
    let computedStyle = window.getComputedStyle(el);
    if (computedStyle.position === "fixed") {
      break;
    }
    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
      parents.push(el);
    }
    el = el.parentNode;
  }
  return parents;
}
var PositionCache = class {
  constructor(originEl, els, isHorizontal, isVertical) {
    this.els = els;
    let originClientRect = this.originClientRect = originEl.getBoundingClientRect();
    if (isHorizontal) {
      this.buildElHorizontals(originClientRect.left);
    }
    if (isVertical) {
      this.buildElVerticals(originClientRect.top);
    }
  }
  // Populates the left/right internal coordinate arrays
  buildElHorizontals(originClientLeft) {
    let lefts = [];
    let rights = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      lefts.push(rect.left - originClientLeft);
      rights.push(rect.right - originClientLeft);
    }
    this.lefts = lefts;
    this.rights = rights;
  }
  // Populates the top/bottom internal coordinate arrays
  buildElVerticals(originClientTop) {
    let tops = [];
    let bottoms = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      tops.push(rect.top - originClientTop);
      bottoms.push(rect.bottom - originClientTop);
    }
    this.tops = tops;
    this.bottoms = bottoms;
  }
  // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
  // If no intersection is made, returns undefined.
  leftToIndex(leftPosition) {
    let { lefts, rights } = this;
    let len = lefts.length;
    let i3;
    for (i3 = 0; i3 < len; i3 += 1) {
      if (leftPosition >= lefts[i3] && leftPosition < rights[i3]) {
        return i3;
      }
    }
    return void 0;
  }
  // Given a top offset (from document top), returns the index of the el that it vertically intersects.
  // If no intersection is made, returns undefined.
  topToIndex(topPosition) {
    let { tops, bottoms } = this;
    let len = tops.length;
    let i3;
    for (i3 = 0; i3 < len; i3 += 1) {
      if (topPosition >= tops[i3] && topPosition < bottoms[i3]) {
        return i3;
      }
    }
    return void 0;
  }
  // Gets the width of the element at the given index
  getWidth(leftIndex) {
    return this.rights[leftIndex] - this.lefts[leftIndex];
  }
  // Gets the height of the element at the given index
  getHeight(topIndex) {
    return this.bottoms[topIndex] - this.tops[topIndex];
  }
  similarTo(otherCache) {
    return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);
  }
};
function similarNumArrays(a3, b3) {
  const len = a3.length;
  if (len !== b3.length) {
    return false;
  }
  for (let i3 = 0; i3 < len; i3++) {
    if (Math.round(a3[i3]) !== Math.round(b3[i3])) {
      return false;
    }
  }
  return true;
}
var ScrollController = class {
  getMaxScrollTop() {
    return this.getScrollHeight() - this.getClientHeight();
  }
  getMaxScrollLeft() {
    return this.getScrollWidth() - this.getClientWidth();
  }
  canScrollVertically() {
    return this.getMaxScrollTop() > 0;
  }
  canScrollHorizontally() {
    return this.getMaxScrollLeft() > 0;
  }
  canScrollUp() {
    return this.getScrollTop() > 0;
  }
  canScrollDown() {
    return this.getScrollTop() < this.getMaxScrollTop();
  }
  canScrollLeft() {
    return this.getScrollLeft() > 0;
  }
  canScrollRight() {
    return this.getScrollLeft() < this.getMaxScrollLeft();
  }
};
var ElementScrollController = class extends ScrollController {
  constructor(el) {
    super();
    this.el = el;
  }
  getScrollTop() {
    return this.el.scrollTop;
  }
  getScrollLeft() {
    return this.el.scrollLeft;
  }
  setScrollTop(top) {
    this.el.scrollTop = top;
  }
  setScrollLeft(left) {
    this.el.scrollLeft = left;
  }
  getScrollWidth() {
    return this.el.scrollWidth;
  }
  getScrollHeight() {
    return this.el.scrollHeight;
  }
  getClientHeight() {
    return this.el.clientHeight;
  }
  getClientWidth() {
    return this.el.clientWidth;
  }
};
var WindowScrollController = class extends ScrollController {
  getScrollTop() {
    return window.scrollY;
  }
  getScrollLeft() {
    return window.scrollX;
  }
  setScrollTop(n2) {
    window.scroll(window.scrollX, n2);
  }
  setScrollLeft(n2) {
    window.scroll(n2, window.scrollY);
  }
  getScrollWidth() {
    return document.documentElement.scrollWidth;
  }
  getScrollHeight() {
    return document.documentElement.scrollHeight;
  }
  getClientHeight() {
    return document.documentElement.clientHeight;
  }
  getClientWidth() {
    return document.documentElement.clientWidth;
  }
};
var DateComponent = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.uid = guid();
  }
  // Hit System
  // -----------------------------------------------------------------------------------------------------------------
  prepareHits() {
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    return null;
  }
  // Pointer Interaction Utils
  // -----------------------------------------------------------------------------------------------------------------
  isValidSegDownEl(el) {
    return !this.props.eventDrag && // HACK
    !this.props.eventResize && // HACK
    !elementClosest(el, ".fc-event-mirror");
  }
  isValidDateDownEl(el) {
    return !elementClosest(el, ".fc-event:not(.fc-bg-event)") && !elementClosest(el, ".fc-more-link") && // a "more.." link
    !elementClosest(el, "a[data-navlink]") && // a clickable nav link
    !elementClosest(el, ".fc-popover");
  }
};
var SegHierarchy = class {
  constructor(getEntryThickness = (entry) => {
    return entry.thickness || 1;
  }) {
    this.getEntryThickness = getEntryThickness;
    this.strictOrder = false;
    this.allowReslicing = false;
    this.maxCoord = -1;
    this.maxStackCnt = -1;
    this.levelCoords = [];
    this.entriesByLevel = [];
    this.stackCnts = {};
  }
  addSegs(inputs) {
    let hiddenEntries = [];
    for (let input2 of inputs) {
      this.insertEntry(input2, hiddenEntries);
    }
    return hiddenEntries;
  }
  insertEntry(entry, hiddenEntries) {
    let insertion = this.findInsertion(entry);
    if (this.isInsertionValid(insertion, entry)) {
      this.insertEntryAt(entry, insertion);
    } else {
      this.handleInvalidInsertion(insertion, entry, hiddenEntries);
    }
  }
  isInsertionValid(insertion, entry) {
    return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    if (this.allowReslicing && insertion.touchingEntry) {
      const hiddenEntry = Object.assign(Object.assign({}, entry), { span: intersectSpans(entry.span, insertion.touchingEntry.span) });
      hiddenEntries.push(hiddenEntry);
      this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
    } else {
      hiddenEntries.push(entry);
    }
  }
  /*
  Does NOT add what hit the `barrier` into hiddenEntries. Should already be done.
  */
  splitEntry(entry, barrier, hiddenEntries) {
    let entrySpan = entry.span;
    let barrierSpan = barrier.span;
    if (entrySpan.start < barrierSpan.start) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: entrySpan.start, end: barrierSpan.start }
      }, hiddenEntries);
    }
    if (entrySpan.end > barrierSpan.end) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: barrierSpan.end, end: entrySpan.end }
      }, hiddenEntries);
    }
  }
  insertEntryAt(entry, insertion) {
    let { entriesByLevel, levelCoords } = this;
    if (insertion.lateral === -1) {
      insertAt(levelCoords, insertion.level, insertion.levelCoord);
      insertAt(entriesByLevel, insertion.level, [entry]);
    } else {
      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
    }
    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
  }
  /*
  does not care about limits
  */
  findInsertion(newEntry) {
    let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;
    let levelCnt = levelCoords.length;
    let candidateCoord = 0;
    let touchingLevel = -1;
    let touchingLateral = -1;
    let touchingEntry = null;
    let stackCnt = 0;
    for (let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
      const trackingCoord = levelCoords[trackingLevel];
      if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {
        break;
      }
      let trackingEntries = entriesByLevel[trackingLevel];
      let trackingEntry;
      let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd);
      let lateralIndex = searchRes[0] + searchRes[1];
      while (
        // loop through entries that horizontally intersect
        (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
        trackingEntry.span.start < newEntry.span.end
      ) {
        let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);
        if (trackingEntryBottom > candidateCoord) {
          candidateCoord = trackingEntryBottom;
          touchingEntry = trackingEntry;
          touchingLevel = trackingLevel;
          touchingLateral = lateralIndex;
        }
        if (trackingEntryBottom === candidateCoord) {
          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
        }
        lateralIndex += 1;
      }
    }
    let destLevel = 0;
    if (touchingEntry) {
      destLevel = touchingLevel + 1;
      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
        destLevel += 1;
      }
    }
    let destLateral = -1;
    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
    }
    return {
      touchingLevel,
      touchingLateral,
      touchingEntry,
      stackCnt,
      levelCoord: candidateCoord,
      level: destLevel,
      lateral: destLateral
    };
  }
  // sorted by levelCoord (lowest to highest)
  toRects() {
    let { entriesByLevel, levelCoords } = this;
    let levelCnt = entriesByLevel.length;
    let rects = [];
    for (let level = 0; level < levelCnt; level += 1) {
      let entries = entriesByLevel[level];
      let levelCoord = levelCoords[level];
      for (let entry of entries) {
        rects.push(Object.assign(Object.assign({}, entry), { thickness: this.getEntryThickness(entry), levelCoord }));
      }
    }
    return rects;
  }
};
function getEntrySpanEnd(entry) {
  return entry.span.end;
}
function buildEntryKey(entry) {
  return entry.index + ":" + entry.span.start;
}
function intersectSpans(span0, span1) {
  let start = Math.max(span0.start, span1.start);
  let end = Math.min(span0.end, span1.end);
  if (start < end) {
    return { start, end };
  }
  return null;
}
function insertAt(arr, index3, item) {
  arr.splice(index3, 0, item);
}
function binarySearch(a3, searchVal, getItemVal) {
  let startIndex = 0;
  let endIndex = a3.length;
  if (!endIndex || searchVal < getItemVal(a3[startIndex])) {
    return [0, 0];
  }
  if (searchVal > getItemVal(a3[endIndex - 1])) {
    return [endIndex, 0];
  }
  while (startIndex < endIndex) {
    let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
    let middleVal = getItemVal(a3[middleIndex]);
    if (searchVal < middleVal) {
      endIndex = middleIndex;
    } else if (searchVal > middleVal) {
      startIndex = middleIndex + 1;
    } else {
      return [middleIndex, 1];
    }
  }
  return [startIndex, 0];
}
var ElementDragging = class {
  constructor(el, selector) {
    this.emitter = new Emitter();
  }
  destroy() {
  }
  setMirrorIsVisible(bool) {
  }
  setMirrorNeedsRevert(bool) {
  }
  setAutoScrollEnabled(bool) {
  }
};
var config2 = {};
function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
  if (!datesRepDistinctDays || dayCnt > 10) {
    return createFormatter({ weekday: "short" });
  }
  if (dayCnt > 1) {
    return createFormatter({ weekday: "short", month: "numeric", day: "numeric", omitCommas: true });
  }
  return createFormatter({ weekday: "long" });
}
var CLASS_NAME = "fc-col-header-cell";
function renderInner$1(renderProps) {
  return renderProps.text;
}
var TableDateCell = class extends BaseComponent {
  render() {
    let { dateEnv, options, theme, viewApi } = this.context;
    let { props } = this;
    let { date, dateProfile } = props;
    let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
    let classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};
    let renderProps = Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: viewApi }, props.extraRenderProps), { text }), dayMeta);
    return y(ContentContainer, { elTag: "th", elClasses: classNames, elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan, "data-date": !dayMeta.isDisabled ? formatDayString(date) : void 0 }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContainer) => y("div", { className: "fc-scrollgrid-sync-inner" }, !dayMeta.isDisabled && y(InnerContainer, { elTag: "a", elAttrs: navLinkAttrs, elClasses: [
      "fc-col-header-cell-cushion",
      props.isSticky && "fc-sticky"
    ] })));
  }
};
var WEEKDAY_FORMAT = createFormatter({ weekday: "long" });
var TableDowCell = class extends BaseComponent {
  render() {
    let { props } = this;
    let { dateEnv, theme, viewApi, options } = this.context;
    let date = addDays(/* @__PURE__ */ new Date(2592e5), props.dow);
    let dateMeta = {
      dow: props.dow,
      isDisabled: false,
      isFuture: false,
      isPast: false,
      isToday: false,
      isOther: false
    };
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({
      // TODO: make this public?
      date
    }, dateMeta), { view: viewApi }), props.extraRenderProps), { text });
    return y(ContentContainer, { elTag: "th", elClasses: [
      CLASS_NAME,
      ...getDayClassNames(dateMeta, theme),
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-scrollgrid-sync-inner" },
      y(InnerContent, { elTag: "a", elClasses: [
        "fc-col-header-cell-cushion",
        props.isSticky && "fc-sticky"
      ], elAttrs: {
        "aria-label": dateEnv.format(date, WEEKDAY_FORMAT)
      } })
    ));
  }
};
var NowTimer = class extends x {
  constructor(props, context2) {
    super(props, context2);
    this.initialNowDate = getNow(context2.options.now, context2.dateEnv);
    this.initialNowQueriedMs = (/* @__PURE__ */ new Date()).valueOf();
    this.state = this.computeTiming().currentState;
  }
  render() {
    let { props, state } = this;
    return props.children(state.nowDate, state.todayRange);
  }
  componentDidMount() {
    this.setTimeout();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.unit !== this.props.unit) {
      this.clearTimeout();
      this.setTimeout();
    }
  }
  componentWillUnmount() {
    this.clearTimeout();
  }
  computeTiming() {
    let { props, context: context2 } = this;
    let unroundedNow = addMs(this.initialNowDate, (/* @__PURE__ */ new Date()).valueOf() - this.initialNowQueriedMs);
    let currentUnitStart = context2.dateEnv.startOf(unroundedNow, props.unit);
    let nextUnitStart = context2.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
    let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
    waitMs = Math.min(1e3 * 60 * 60 * 24, waitMs);
    return {
      currentState: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },
      nextState: { nowDate: nextUnitStart, todayRange: buildDayRange(nextUnitStart) },
      waitMs
    };
  }
  setTimeout() {
    let { nextState, waitMs } = this.computeTiming();
    this.timeoutId = setTimeout(() => {
      this.setState(nextState, () => {
        this.setTimeout();
      });
    }, waitMs);
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
  }
};
NowTimer.contextType = ViewContextType;
function buildDayRange(date) {
  let start = startOfDay(date);
  let end = addDays(start, 1);
  return { start, end };
}
var DayHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
  }
  render() {
    let { context: context2 } = this;
    let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;
    let dayHeaderFormat = this.createDayHeaderFormatter(context2.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(
      "tr",
      { role: "row" },
      renderIntro && renderIntro("day"),
      dates.map((date) => datesRepDistinctDays ? y(TableDateCell, { key: date.toISOString(), date, dateProfile, todayRange, colCnt: dates.length, dayHeaderFormat }) : y(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat }))
    ));
  }
};
function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
}
var DaySeriesModel = class {
  constructor(range, dateProfileGenerator) {
    let date = range.start;
    let { end } = range;
    let indices = [];
    let dates = [];
    let dayIndex = -1;
    while (date < end) {
      if (dateProfileGenerator.isHiddenDay(date)) {
        indices.push(dayIndex + 0.5);
      } else {
        dayIndex += 1;
        indices.push(dayIndex);
        dates.push(date);
      }
      date = addDays(date, 1);
    }
    this.dates = dates;
    this.indices = indices;
    this.cnt = dates.length;
  }
  sliceRange(range) {
    let firstIndex = this.getDateDayIndex(range.start);
    let lastIndex = this.getDateDayIndex(addDays(range.end, -1));
    let clippedFirstIndex = Math.max(0, firstIndex);
    let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
    clippedFirstIndex = Math.ceil(clippedFirstIndex);
    clippedLastIndex = Math.floor(clippedLastIndex);
    if (clippedFirstIndex <= clippedLastIndex) {
      return {
        firstIndex: clippedFirstIndex,
        lastIndex: clippedLastIndex,
        isStart: firstIndex === clippedFirstIndex,
        isEnd: lastIndex === clippedLastIndex
      };
    }
    return null;
  }
  // Given a date, returns its chronolocial cell-index from the first cell of the grid.
  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
  // If before the first offset, returns a negative number.
  // If after the last offset, returns an offset past the last cell offset.
  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
  getDateDayIndex(date) {
    let { indices } = this;
    let dayOffset = Math.floor(diffDays(this.dates[0], date));
    if (dayOffset < 0) {
      return indices[0] - 1;
    }
    if (dayOffset >= indices.length) {
      return indices[indices.length - 1] + 1;
    }
    return indices[dayOffset];
  }
};
var DayTableModel = class {
  constructor(daySeries, breakOnWeeks) {
    let { dates } = daySeries;
    let daysPerRow;
    let firstDay;
    let rowCnt;
    if (breakOnWeeks) {
      firstDay = dates[0].getUTCDay();
      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
        if (dates[daysPerRow].getUTCDay() === firstDay) {
          break;
        }
      }
      rowCnt = Math.ceil(dates.length / daysPerRow);
    } else {
      rowCnt = 1;
      daysPerRow = dates.length;
    }
    this.rowCnt = rowCnt;
    this.colCnt = daysPerRow;
    this.daySeries = daySeries;
    this.cells = this.buildCells();
    this.headerDates = this.buildHeaderDates();
  }
  buildCells() {
    let rows = [];
    for (let row = 0; row < this.rowCnt; row += 1) {
      let cells = [];
      for (let col = 0; col < this.colCnt; col += 1) {
        cells.push(this.buildCell(row, col));
      }
      rows.push(cells);
    }
    return rows;
  }
  buildCell(row, col) {
    let date = this.daySeries.dates[row * this.colCnt + col];
    return {
      key: date.toISOString(),
      date
    };
  }
  buildHeaderDates() {
    let dates = [];
    for (let col = 0; col < this.colCnt; col += 1) {
      dates.push(this.cells[0][col].date);
    }
    return dates;
  }
  sliceRange(range) {
    let { colCnt } = this;
    let seriesSeg = this.daySeries.sliceRange(range);
    let segs = [];
    if (seriesSeg) {
      let { firstIndex, lastIndex } = seriesSeg;
      let index3 = firstIndex;
      while (index3 <= lastIndex) {
        let row = Math.floor(index3 / colCnt);
        let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
        segs.push({
          row,
          firstCol: index3 % colCnt,
          lastCol: (nextIndex - 1) % colCnt,
          isStart: seriesSeg.isStart && index3 === firstIndex,
          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
        });
        index3 = nextIndex;
      }
    }
    return segs;
  }
};
var Slicer = class {
  constructor() {
    this.sliceBusinessHours = memoize(this._sliceBusinessHours);
    this.sliceDateSelection = memoize(this._sliceDateSpan);
    this.sliceEventStore = memoize(this._sliceEventStore);
    this.sliceEventDrag = memoize(this._sliceInteraction);
    this.sliceEventResize = memoize(this._sliceInteraction);
    this.forceDayIfListItem = false;
  }
  sliceProps(props, dateProfile, nextDayThreshold, context2, ...extraArgs) {
    let { eventUiBases } = props;
    let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);
    return {
      dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context2, ...extraArgs),
      businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context2, ...extraArgs),
      fgEventSegs: eventSegs.fg,
      bgEventSegs: eventSegs.bg,
      eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventSelection: props.eventSelection
    };
  }
  sliceNowDate(date, dateProfile, nextDayThreshold, context2, ...extraArgs) {
    return this._sliceDateSpan(
      { range: { start: date, end: addMs(date, 1) }, allDay: false },
      // add 1 ms, protect against null range
      dateProfile,
      nextDayThreshold,
      {},
      context2,
      ...extraArgs
    );
  }
  _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context2, ...extraArgs) {
    if (!businessHours) {
      return [];
    }
    return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context2), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;
  }
  _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (eventStore) {
      let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
      return {
        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
      };
    }
    return { bg: [], fg: [] };
  }
  _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (!interaction) {
      return null;
    }
    let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
    return {
      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
      affectedInstances: interaction.affectedEvents.instances,
      isEvent: interaction.isEvent
    };
  }
  _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context2, ...extraArgs) {
    if (!dateSpan) {
      return [];
    }
    let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));
    let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);
    if (activeDateSpanRange) {
      dateSpan = Object.assign(Object.assign({}, dateSpan), { range: activeDateSpanRange });
      let eventRange = fabricateEventRange(dateSpan, eventUiBases, context2);
      let segs = this.sliceRange(dateSpan.range, ...extraArgs);
      for (let seg of segs) {
        seg.eventRange = eventRange;
      }
      return segs;
    }
    return [];
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRanges(eventRanges, extraArgs) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.sliceEventRange(eventRange, extraArgs));
    }
    return segs;
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRange(eventRange, extraArgs) {
    let dateRange = eventRange.range;
    if (this.forceDayIfListItem && eventRange.ui.display === "list-item") {
      dateRange = {
        start: dateRange.start,
        end: addDays(dateRange.start, 1)
      };
    }
    let segs = this.sliceRange(dateRange, ...extraArgs);
    for (let seg of segs) {
      seg.eventRange = eventRange;
      seg.isStart = eventRange.isStart && seg.isStart;
      seg.isEnd = eventRange.isEnd && seg.isEnd;
    }
    return segs;
  }
};
function computeActiveRange(dateProfile, isComponentAllDay) {
  let range = dateProfile.activeRange;
  if (isComponentAllDay) {
    return range;
  }
  return {
    start: addMs(range.start, dateProfile.slotMinTime.milliseconds),
    end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)
    // 864e5 = ms in a day
  };
}
function isInteractionValid(interaction, dateProfile, context2) {
  let { instances } = interaction.mutatedEvents;
  for (let instanceId in instances) {
    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
      return false;
    }
  }
  return isNewPropsValid({ eventDrag: interaction }, context2);
}
function isDateSelectionValid(dateSelection, dateProfile, context2) {
  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
    return false;
  }
  return isNewPropsValid({ dateSelection }, context2);
}
function isNewPropsValid(newProps, context2) {
  let calendarState = context2.getCurrentData();
  let props = Object.assign({ businessHours: calendarState.businessHours, dateSelection: "", eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: "", eventDrag: null, eventResize: null }, newProps);
  return (context2.pluginHooks.isPropsValid || isPropsValid)(props, context2);
}
function isPropsValid(state, context2, dateSpanMeta = {}, filterConfig) {
  if (state.eventDrag && !isInteractionPropsValid(state, context2, dateSpanMeta, filterConfig)) {
    return false;
  }
  if (state.dateSelection && !isDateSelectionPropsValid(state, context2, dateSpanMeta, filterConfig)) {
    return false;
  }
  return true;
}
function isInteractionPropsValid(state, context2, dateSpanMeta, filterConfig) {
  let currentState = context2.getCurrentData();
  let interaction = state.eventDrag;
  let subjectEventStore = interaction.mutatedEvents;
  let subjectDefs = subjectEventStore.defs;
  let subjectInstances = subjectEventStore.instances;
  let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : { "": currentState.selectionConfig });
  if (filterConfig) {
    subjectConfigs = mapHash(subjectConfigs, filterConfig);
  }
  let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
  let otherDefs = otherEventStore.defs;
  let otherInstances = otherEventStore.instances;
  let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
  for (let subjectInstanceId in subjectInstances) {
    let subjectInstance = subjectInstances[subjectInstanceId];
    let subjectRange = subjectInstance.range;
    let subjectConfig = subjectConfigs[subjectInstance.defId];
    let subjectDef = subjectDefs[subjectInstance.defId];
    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context2)) {
      return false;
    }
    let { eventOverlap } = context2.options;
    let eventOverlapFunc = typeof eventOverlap === "function" ? eventOverlap : null;
    for (let otherInstanceId in otherInstances) {
      let otherInstance = otherInstances[otherInstanceId];
      if (rangesIntersect(subjectRange, otherInstance.range)) {
        let otherOverlap = otherConfigs[otherInstance.defId].overlap;
        if (otherOverlap === false && interaction.isEvent) {
          return false;
        }
        if (subjectConfig.overlap === false) {
          return false;
        }
        if (eventOverlapFunc && !eventOverlapFunc(
          new EventImpl(context2, otherDefs[otherInstance.defId], otherInstance),
          // still event
          new EventImpl(context2, subjectDef, subjectInstance)
        )) {
          return false;
        }
      }
    }
    let calendarEventStore = currentState.eventStore;
    for (let subjectAllow of subjectConfig.allows) {
      let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });
      let origDef = calendarEventStore.defs[subjectDef.defId];
      let origInstance = calendarEventStore.instances[subjectInstanceId];
      let eventApi;
      if (origDef) {
        eventApi = new EventImpl(context2, origDef, origInstance);
      } else {
        eventApi = new EventImpl(context2, subjectDef);
      }
      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context2), eventApi)) {
        return false;
      }
    }
  }
  return true;
}
function isDateSelectionPropsValid(state, context2, dateSpanMeta, filterConfig) {
  let relevantEventStore = state.eventStore;
  let relevantDefs = relevantEventStore.defs;
  let relevantInstances = relevantEventStore.instances;
  let selection = state.dateSelection;
  let selectionRange = selection.range;
  let { selectionConfig } = context2.getCurrentData();
  if (filterConfig) {
    selectionConfig = filterConfig(selectionConfig);
  }
  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context2)) {
    return false;
  }
  let { selectOverlap } = context2.options;
  let selectOverlapFunc = typeof selectOverlap === "function" ? selectOverlap : null;
  for (let relevantInstanceId in relevantInstances) {
    let relevantInstance = relevantInstances[relevantInstanceId];
    if (rangesIntersect(selectionRange, relevantInstance.range)) {
      if (selectionConfig.overlap === false) {
        return false;
      }
      if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context2, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
        return false;
      }
    }
  }
  for (let selectionAllow of selectionConfig.allows) {
    let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);
    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context2), null)) {
      return false;
    }
  }
  return true;
}
function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context2) {
  for (let constraint of constraints) {
    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context2), subjectRange)) {
      return false;
    }
  }
  return true;
}
function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context2) {
  if (constraint === "businessHours") {
    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context2));
  }
  if (typeof constraint === "string") {
    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef) => eventDef.groupId === constraint));
  }
  if (typeof constraint === "object" && constraint) {
    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context2));
  }
  return [];
}
function eventStoreToRanges(eventStore) {
  let { instances } = eventStore;
  let ranges = [];
  for (let instanceId in instances) {
    ranges.push(instances[instanceId].range);
  }
  return ranges;
}
function anyRangesContainRange(outerRanges, innerRange) {
  for (let outerRange of outerRanges) {
    if (rangeContainsRange(outerRange, innerRange)) {
      return true;
    }
  }
  return false;
}
var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;
var Scroller = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { props } = this;
    let { liquid, liquidIsAbsolute } = props;
    let isAbsolute = liquid && liquidIsAbsolute;
    let className = ["fc-scroller"];
    if (liquid) {
      if (liquidIsAbsolute) {
        className.push("fc-scroller-liquid-absolute");
      } else {
        className.push("fc-scroller-liquid");
      }
    }
    return y("div", { ref: this.handleEl, className: className.join(" "), style: {
      overflowX: props.overflowX,
      overflowY: props.overflowY,
      left: isAbsolute && -(props.overcomeLeft || 0) || "",
      right: isAbsolute && -(props.overcomeRight || 0) || "",
      bottom: isAbsolute && -(props.overcomeBottom || 0) || "",
      marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || "",
      marginRight: !isAbsolute && -(props.overcomeRight || 0) || "",
      marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || "",
      maxHeight: props.maxHeight || ""
    } }, props.children);
  }
  needsXScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return false;
    }
    let { el } = this;
    let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
    let { children } = el;
    for (let i3 = 0; i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().width > realClientWidth) {
        return true;
      }
    }
    return false;
  }
  needsYScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return false;
    }
    let { el } = this;
    let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
    let { children } = el;
    for (let i3 = 0; i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().height > realClientHeight) {
        return true;
      }
    }
    return false;
  }
  getXScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return 0;
    }
    return this.el.offsetHeight - this.el.clientHeight;
  }
  getYScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return 0;
    }
    return this.el.offsetWidth - this.el.clientWidth;
  }
};
var RefMap = class {
  constructor(masterCallback) {
    this.masterCallback = masterCallback;
    this.currentMap = {};
    this.depths = {};
    this.callbackMap = {};
    this.handleValue = (val, key) => {
      let { depths, currentMap } = this;
      let removed = false;
      let added = false;
      if (val !== null) {
        removed = key in currentMap;
        currentMap[key] = val;
        depths[key] = (depths[key] || 0) + 1;
        added = true;
      } else {
        depths[key] -= 1;
        if (!depths[key]) {
          delete currentMap[key];
          delete this.callbackMap[key];
          removed = true;
        }
      }
      if (this.masterCallback) {
        if (removed) {
          this.masterCallback(null, String(key));
        }
        if (added) {
          this.masterCallback(val, String(key));
        }
      }
    };
  }
  createRef(key) {
    let refCallback = this.callbackMap[key];
    if (!refCallback) {
      refCallback = this.callbackMap[key] = (val) => {
        this.handleValue(val, String(key));
      };
    }
    return refCallback;
  }
  // TODO: check callers that don't care about order. should use getAll instead
  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"
  collect(startIndex, endIndex, step) {
    return collectFromHash(this.currentMap, startIndex, endIndex, step);
  }
  getAll() {
    return hashValuesToArray(this.currentMap);
  }
};
function computeShrinkWidth(chunkEls) {
  let shrinkCells = findElements(chunkEls, ".fc-scrollgrid-shrink");
  let largestWidth = 0;
  for (let shrinkCell of shrinkCells) {
    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
  }
  return Math.ceil(largestWidth);
}
function getSectionHasLiquidHeight(props, sectionConfig) {
  return props.liquid && sectionConfig.liquid;
}
function getAllowYScrolling(props, sectionConfig) {
  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
  getSectionHasLiquidHeight(props, sectionConfig);
}
function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
  let { expandRows } = arg;
  let content = typeof chunkConfig.content === "function" ? chunkConfig.content(arg) : y("table", {
    role: "presentation",
    className: [
      chunkConfig.tableClassName,
      sectionConfig.syncRowHeights ? "fc-scrollgrid-sync-table" : ""
    ].join(" "),
    style: {
      minWidth: arg.tableMinWidth,
      width: arg.clientWidth,
      height: expandRows ? arg.clientHeight : ""
      // css `height` on a <table> serves as a min-height
    }
  }, arg.tableColGroupNode, y(isHeader ? "thead" : "tbody", {
    role: "presentation"
  }, typeof chunkConfig.rowContent === "function" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
  return content;
}
function isColPropsEqual(cols0, cols1) {
  return isArraysEqual(cols0, cols1, isPropsEqual);
}
function renderMicroColGroup(cols, shrinkWidth) {
  let colNodes = [];
  for (let colProps of cols) {
    let span = colProps.span || 1;
    for (let i3 = 0; i3 < span; i3 += 1) {
      colNodes.push(y("col", { style: {
        width: colProps.width === "shrink" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || "",
        minWidth: colProps.minWidth || ""
      } }));
    }
  }
  return y("colgroup", {}, ...colNodes);
}
function sanitizeShrinkWidth(shrinkWidth) {
  return shrinkWidth == null ? 4 : shrinkWidth;
}
function hasShrinkWidth(cols) {
  for (let col of cols) {
    if (col.width === "shrink") {
      return true;
    }
  }
  return false;
}
function getScrollGridClassNames(liquid, context2) {
  let classNames = [
    "fc-scrollgrid",
    context2.theme.getClass("table")
  ];
  if (liquid) {
    classNames.push("fc-scrollgrid-liquid");
  }
  return classNames;
}
function getSectionClassNames(sectionConfig, wholeTableVGrow) {
  let classNames = [
    "fc-scrollgrid-section",
    `fc-scrollgrid-section-${sectionConfig.type}`,
    sectionConfig.className
    // used?
  ];
  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
    classNames.push("fc-scrollgrid-section-liquid");
  }
  if (sectionConfig.isSticky) {
    classNames.push("fc-scrollgrid-section-sticky");
  }
  return classNames;
}
function renderScrollShim(arg) {
  return y("div", { className: "fc-scrollgrid-sticky-shim", style: {
    width: arg.clientWidth,
    minWidth: arg.tableMinWidth
  } });
}
function getStickyHeaderDates(options) {
  let { stickyHeaderDates } = options;
  if (stickyHeaderDates == null || stickyHeaderDates === "auto") {
    stickyHeaderDates = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyHeaderDates;
}
function getStickyFooterScrollbar(options) {
  let { stickyFooterScrollbar } = options;
  if (stickyFooterScrollbar == null || stickyFooterScrollbar === "auto") {
    stickyFooterScrollbar = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyFooterScrollbar;
}
var SimpleScrollGrid = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.processCols = memoize((a3) => a3, isColPropsEqual);
    this.renderMicroColGroup = memoize(renderMicroColGroup);
    this.scrollerRefs = new RefMap();
    this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));
    this.state = {
      shrinkWidth: null,
      forceYScrollbars: false,
      scrollerClientWidths: {},
      scrollerClientHeights: {}
    };
    this.handleSizing = () => {
      this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims()));
    };
  }
  render() {
    let { props, state, context: context2 } = this;
    let sectionConfigs = props.sections || [];
    let cols = this.processCols(props.cols);
    let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
    let classNames = getScrollGridClassNames(props.liquid, context2);
    if (props.collapsibleWidth) {
      classNames.push("fc-scrollgrid-collapsible");
    }
    let configCnt = sectionConfigs.length;
    let configI = 0;
    let currentConfig;
    let headSectionNodes = [];
    let bodySectionNodes = [];
    let footSectionNodes = [];
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "header") {
      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "body") {
      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "footer") {
      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    let isBuggy = !getCanVGrowWithinCell();
    const roleAttrs = { role: "rowgroup" };
    return y("table", {
      role: "grid",
      className: classNames.join(" "),
      style: { height: props.height }
    }, Boolean(!isBuggy && headSectionNodes.length) && y("thead", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y("tbody", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y("tfoot", roleAttrs, ...footSectionNodes), isBuggy && y("tbody", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));
  }
  renderSection(sectionConfig, microColGroupNode, isHeader) {
    if ("outerContent" in sectionConfig) {
      return y(_, { key: sectionConfig.key }, sectionConfig.outerContent);
    }
    return y("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(" ") }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));
  }
  renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {
    if ("outerContent" in chunkConfig) {
      return chunkConfig.outerContent;
    }
    let { props } = this;
    let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;
    let needsYScrolling = getAllowYScrolling(props, sectionConfig);
    let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
    let overflowY = !props.liquid ? "visible" : forceYScrollbars ? "scroll" : !needsYScrolling ? "hidden" : "auto";
    let sectionKey = sectionConfig.key;
    let content = renderChunkContent(sectionConfig, chunkConfig, {
      tableColGroupNode: microColGroupNode,
      tableMinWidth: "",
      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== void 0 ? scrollerClientWidths[sectionKey] : null,
      clientHeight: scrollerClientHeights[sectionKey] !== void 0 ? scrollerClientHeights[sectionKey] : null,
      expandRows: sectionConfig.expandRows,
      syncRowHeights: false,
      rowSyncHeights: [],
      reportRowHeightChange: () => {
      }
    }, isHeader);
    return y(isHeader ? "th" : "td", {
      ref: chunkConfig.elRef,
      role: "presentation"
    }, y(
      "div",
      { className: `fc-scroller-harness${isLiquid ? " fc-scroller-harness-liquid" : ""}` },
      y(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY, overflowX: !props.liquid ? "visible" : "hidden", maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute: true }, content)
    ));
  }
  _handleScrollerEl(scrollerEl, key) {
    let section = getSectionByKey(this.props.sections, key);
    if (section) {
      setRef(section.chunk.scrollerElRef, scrollerEl);
    }
  }
  componentDidMount() {
    this.handleSizing();
    this.context.addResizeHandler(this.handleSizing);
  }
  componentDidUpdate() {
    this.handleSizing();
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleSizing);
  }
  computeShrinkWidth() {
    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
  }
  computeScrollerDims() {
    let scrollbarWidth = getScrollbarWidths();
    let { scrollerRefs, scrollerElRefs } = this;
    let forceYScrollbars = false;
    let scrollerClientWidths = {};
    let scrollerClientHeights = {};
    for (let sectionKey in scrollerRefs.currentMap) {
      let scroller = scrollerRefs.currentMap[sectionKey];
      if (scroller && scroller.needsYScrolling()) {
        forceYScrollbars = true;
        break;
      }
    }
    for (let section of this.props.sections) {
      let sectionKey = section.key;
      let scrollerEl = scrollerElRefs.currentMap[sectionKey];
      if (scrollerEl) {
        let harnessEl = scrollerEl.parentNode;
        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y : 0));
        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
      }
    }
    return { forceYScrollbars, scrollerClientWidths, scrollerClientHeights };
  }
};
SimpleScrollGrid.addStateEquality({
  scrollerClientWidths: isPropsEqual,
  scrollerClientHeights: isPropsEqual
});
function getSectionByKey(sections, key) {
  for (let section of sections) {
    if (section.key === key) {
      return section;
    }
  }
  return null;
}
var EventContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      if (el) {
        setElSeg(el, this.props.seg);
      }
    };
  }
  render() {
    const { props, context: context2 } = this;
    const { options } = context2;
    const { seg } = props;
    const { eventRange } = seg;
    const { ui } = eventRange;
    const renderProps = {
      event: new EventImpl(context2, eventRange.def, eventRange.instance),
      view: context2.viewApi,
      timeText: props.timeText,
      textColor: ui.textColor,
      backgroundColor: ui.backgroundColor,
      borderColor: ui.borderColor,
      isDraggable: !props.disableDragging && computeSegDraggable(seg, context2),
      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context2),
      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
      isStart: Boolean(seg.isStart),
      isEnd: Boolean(seg.isEnd),
      isPast: Boolean(props.isPast),
      isFuture: Boolean(props.isFuture),
      isToday: Boolean(props.isToday),
      isSelected: Boolean(props.isSelected),
      isDragging: Boolean(props.isDragging),
      isResizing: Boolean(props.isResizing)
    };
    return y(ContentContainer, Object.assign({}, props, { elRef: this.handleEl, elClasses: [
      ...getEventClassNames(renderProps),
      ...seg.eventRange.ui.classNames,
      ...props.elClasses || []
    ], renderProps, generatorName: "eventContent", customGenerator: options.eventContent, defaultGenerator: props.defaultGenerator, classNameGenerator: options.eventClassNames, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount }));
  }
  componentDidUpdate(prevProps) {
    if (this.el && this.props.seg !== prevProps.seg) {
      setElSeg(this.el, this.props.seg);
    }
  }
};
var StandardEvent = class extends BaseComponent {
  render() {
    let { props, context: context2 } = this;
    let { options } = context2;
    let { seg } = props;
    let { ui } = seg.eventRange;
    let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;
    let timeText = buildSegTimeText(seg, timeFormat, context2, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elStyle: {
      borderColor: ui.borderColor,
      backgroundColor: ui.backgroundColor
    }, elAttrs: getSegAnchorAttrs(seg, context2), defaultGenerator: renderInnerContent$1, timeText }), (InnerContent, eventContentArg) => y(
      _,
      null,
      y(InnerContent, { elTag: "div", elClasses: ["fc-event-main"], elStyle: { color: eventContentArg.textColor } }),
      Boolean(eventContentArg.isStartResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-start" }),
      Boolean(eventContentArg.isEndResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-end" })
    ));
  }
};
function renderInnerContent$1(innerProps) {
  return y(
    "div",
    { className: "fc-event-main-frame" },
    innerProps.timeText && y("div", { className: "fc-event-time" }, innerProps.timeText),
    y(
      "div",
      { className: "fc-event-title-container" },
      y("div", { className: "fc-event-title fc-sticky" }, innerProps.event.title || y(_, null, "\xA0"))
    )
  );
}
var DAY_NUM_FORMAT = createFormatter({ day: "numeric" });
var DayCellContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
  }
  render() {
    let { props, context: context2 } = this;
    let { options } = context2;
    let renderProps = this.refineRenderProps({
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      isMonthStart: props.isMonthStart || false,
      showDayNumber: props.showDayNumber,
      extraRenderProps: props.extraRenderProps,
      viewApi: context2.viewApi,
      dateEnv: context2.dateEnv,
      monthStartFormat: options.monthStartFormat
    });
    return y(ContentContainer, Object.assign({}, props, { elClasses: [
      ...getDayClassNames(renderProps, context2.theme),
      ...props.elClasses || []
    ], elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : { "data-date": formatDayString(props.date) }), renderProps, generatorName: "dayCellContent", customGenerator: options.dayCellContent, defaultGenerator: props.defaultGenerator, classNameGenerator: (
      // don't use custom classNames if disabled
      renderProps.isDisabled ? void 0 : options.dayCellClassNames
    ), didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount }));
  }
};
function hasCustomDayCellContent(options) {
  return Boolean(options.dayCellContent || hasCustomRenderingHandler("dayCellContent", options));
}
function refineRenderProps(raw) {
  let { date, dateEnv, dateProfile, isMonthStart } = raw;
  let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);
  let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : "";
  return Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), {
    isMonthStart,
    dayNumberText
  }), raw.extraRenderProps);
}
var BgEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    let { seg } = props;
    return y(EventContainer, { elTag: "div", elClasses: ["fc-bg-event"], elStyle: { backgroundColor: seg.eventRange.ui.backgroundColor }, defaultGenerator: renderInnerContent, seg, timeText: "", isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, disableDragging: true, disableResizing: true });
  }
};
function renderInnerContent(props) {
  let { title } = props.event;
  return title && y("div", { className: "fc-event-title" }, props.event.title);
}
function renderFill(fillType) {
  return y("div", { className: `fc-${fillType}` });
}
var WeekNumberContainer = (props) => y(ViewContextType.Consumer, null, (context2) => {
  let { dateEnv, options } = context2;
  let { date } = props;
  let format = options.weekNumberFormat || props.defaultFormat;
  let num = dateEnv.computeWeekNumber(date);
  let text = dateEnv.format(date, format);
  let renderProps = { num, text, date };
  return y(
    ContentContainer,
    Object.assign({}, props, { renderProps, generatorName: "weekNumberContent", customGenerator: options.weekNumberContent, defaultGenerator: renderInner, classNameGenerator: options.weekNumberClassNames, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount })
  );
});
function renderInner(innerProps) {
  return innerProps.text;
}
var PADDING_FROM_VIEWPORT = 10;
var Popover = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      titleId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      this.rootEl = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
    this.handleDocumentMouseDown = (ev) => {
      const target = getEventTargetViaRoot(ev);
      if (!this.rootEl.contains(target)) {
        this.handleCloseClick();
      }
    };
    this.handleDocumentKeyDown = (ev) => {
      if (ev.key === "Escape") {
        this.handleCloseClick();
      }
    };
    this.handleCloseClick = () => {
      let { onClose } = this.props;
      if (onClose) {
        onClose();
      }
    };
  }
  render() {
    let { theme, options } = this.context;
    let { props, state } = this;
    let classNames = [
      "fc-popover",
      theme.getClass("popover")
    ].concat(props.extraClassNames || []);
    return j3(y(
      "div",
      Object.assign({}, props.extraAttrs, { id: props.id, className: classNames.join(" "), "aria-labelledby": state.titleId, ref: this.handleRootEl }),
      y(
        "div",
        { className: "fc-popover-header " + theme.getClass("popoverHeader") },
        y("span", { className: "fc-popover-title", id: state.titleId }, props.title),
        y("span", { className: "fc-popover-close " + theme.getIconClass("close"), title: options.closeHint, onClick: this.handleCloseClick })
      ),
      y("div", { className: "fc-popover-body " + theme.getClass("popoverContent") }, props.children)
    ), props.parentEl);
  }
  componentDidMount() {
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    this.updateSize();
  }
  componentWillUnmount() {
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  updateSize() {
    let { isRtl } = this.context;
    let { alignmentEl, alignGridTop } = this.props;
    let { rootEl } = this;
    let alignmentRect = computeClippedClientRect(alignmentEl);
    if (alignmentRect) {
      let popoverDims = rootEl.getBoundingClientRect();
      let popoverTop = alignGridTop ? elementClosest(alignmentEl, ".fc-scrollgrid").getBoundingClientRect().top : alignmentRect.top;
      let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
      let origin = rootEl.offsetParent.getBoundingClientRect();
      applyStyle(rootEl, {
        top: popoverTop - origin.top,
        left: popoverLeft - origin.left
      });
    }
  }
};
var MorePopover = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.handleRootEl = (rootEl) => {
      this.rootEl = rootEl;
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          useEventCenter: false
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { options, dateEnv } = this.context;
    let { props } = this;
    let { startDate, todayRange, dateProfile } = props;
    let title = dateEnv.format(startDate, options.dayPopoverFormat);
    return y(DayCellContainer, { elRef: this.handleRootEl, date: startDate, dateProfile, todayRange }, (InnerContent, renderProps, elAttrs) => y(
      Popover,
      { elRef: elAttrs.ref, id: props.id, title, extraClassNames: ["fc-more-popover"].concat(elAttrs.className || []), extraAttrs: elAttrs, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose },
      hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-more-popover-misc"] }),
      props.children
    ));
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    let { rootEl, props } = this;
    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {
      return {
        dateProfile: props.dateProfile,
        dateSpan: Object.assign({ allDay: !props.forceTimed, range: {
          start: props.startDate,
          end: props.endDate
        } }, props.extraDateSpan),
        dayEl: rootEl,
        rect: {
          left: 0,
          top: 0,
          right: elWidth,
          bottom: elHeight
        },
        layer: 1
        // important when comparing with hits from other components
      };
    }
    return null;
  }
};
var MoreLinkContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isPopoverOpen: false,
      popoverId: getUniqueDomId()
    };
    this.handleLinkEl = (linkEl) => {
      this.linkEl = linkEl;
      if (this.props.elRef) {
        setRef(this.props.elRef, linkEl);
      }
    };
    this.handleClick = (ev) => {
      let { props, context: context2 } = this;
      let { moreLinkClick } = context2.options;
      let date = computeRange(props).start;
      function buildPublicSeg(seg) {
        let { def, instance, range } = seg.eventRange;
        return {
          event: new EventImpl(context2, def, instance),
          start: context2.dateEnv.toDate(range.start),
          end: context2.dateEnv.toDate(range.end),
          isStart: seg.isStart,
          isEnd: seg.isEnd
        };
      }
      if (typeof moreLinkClick === "function") {
        moreLinkClick = moreLinkClick({
          date,
          allDay: Boolean(props.allDayDate),
          allSegs: props.allSegs.map(buildPublicSeg),
          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
          jsEvent: ev,
          view: context2.viewApi
        });
      }
      if (!moreLinkClick || moreLinkClick === "popover") {
        this.setState({ isPopoverOpen: true });
      } else if (typeof moreLinkClick === "string") {
        context2.calendarApi.zoomTo(date, moreLinkClick);
      }
    };
    this.handlePopoverClose = () => {
      this.setState({ isPopoverOpen: false });
    };
  }
  render() {
    let { props, state } = this;
    return y(ViewContextType.Consumer, null, (context2) => {
      let { viewApi, options, calendarApi } = context2;
      let { moreLinkText } = options;
      let { moreCnt } = props;
      let range = computeRange(props);
      let text = typeof moreLinkText === "function" ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;
      let hint = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
      let renderProps = {
        num: moreCnt,
        shortText: `+${moreCnt}`,
        text,
        view: viewApi
      };
      return y(
        _,
        null,
        Boolean(props.moreCnt) && y(ContentContainer, { elTag: props.elTag || "a", elRef: this.handleLinkEl, elClasses: [
          ...props.elClasses || [],
          "fc-more-link"
        ], elStyle: props.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), { title: hint, "aria-expanded": state.isPopoverOpen, "aria-controls": state.isPopoverOpen ? state.popoverId : "" }), renderProps, generatorName: "moreLinkContent", customGenerator: options.moreLinkContent, defaultGenerator: props.defaultGenerator || renderMoreLinkInner, classNameGenerator: options.moreLinkClassNames, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, props.children),
        state.isPopoverOpen && y(MorePopover, { id: state.popoverId, startDate: range.start, endDate: range.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: this.parentEl, alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl, alignGridTop: props.alignGridTop, forceTimed: props.forceTimed, onClose: this.handlePopoverClose }, props.popoverContent())
      );
    });
  }
  componentDidMount() {
    this.updateParentEl();
  }
  componentDidUpdate() {
    this.updateParentEl();
  }
  updateParentEl() {
    if (this.linkEl) {
      this.parentEl = elementClosest(this.linkEl, ".fc-view-harness");
    }
  }
};
function renderMoreLinkInner(props) {
  return props.text;
}
function computeRange(props) {
  if (props.allDayDate) {
    return {
      start: props.allDayDate,
      end: addDays(props.allDayDate, 1)
    };
  }
  let { hiddenSegs } = props;
  return {
    start: computeEarliestSegStart(hiddenSegs),
    end: computeLatestSegEnd(hiddenSegs)
  };
}
function computeEarliestSegStart(segs) {
  return segs.reduce(pickEarliestStart).eventRange.range.start;
}
function pickEarliestStart(seg0, seg1) {
  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
}
function computeLatestSegEnd(segs) {
  return segs.reduce(pickLatestEnd).eventRange.range.end;
}
function pickLatestEnd(seg0, seg1) {
  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
}
var Store = class {
  constructor() {
    this.handlers = [];
  }
  set(value) {
    this.currentValue = value;
    for (let handler of this.handlers) {
      handler(value);
    }
  }
  subscribe(handler) {
    this.handlers.push(handler);
    if (this.currentValue !== void 0) {
      handler(this.currentValue);
    }
  }
};
var CustomRenderingStore = class extends Store {
  constructor() {
    super(...arguments);
    this.map = /* @__PURE__ */ new Map();
  }
  // for consistent order
  handle(customRendering) {
    const { map: map2 } = this;
    let updated = false;
    if (customRendering.isActive) {
      map2.set(customRendering.id, customRendering);
      updated = true;
    } else if (map2.has(customRendering.id)) {
      map2.delete(customRendering.id);
      updated = true;
    }
    if (updated) {
      this.set(map2);
    }
  }
};

// node_modules/@fullcalendar/core/index.js
var globalLocales = [];
var MINIMAL_RAW_EN_LOCALE = {
  code: "en",
  week: {
    dow: 0,
    doy: 4
    // 4 days need to be within the year to be considered the first week
  },
  direction: "ltr",
  buttonText: {
    prev: "prev",
    next: "next",
    prevYear: "prev year",
    nextYear: "next year",
    year: "year",
    today: "today",
    month: "month",
    week: "week",
    day: "day",
    list: "list"
  },
  weekText: "W",
  weekTextLong: "Week",
  closeHint: "Close",
  timeHint: "Time",
  eventHint: "Event",
  allDayText: "all-day",
  moreLinkText: "more",
  noEventsText: "No events to display"
};
var RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {
  // Includes things we don't want other locales to inherit,
  // things that derive from other translatable strings.
  buttonHints: {
    prev: "Previous $0",
    next: "Next $0",
    today(buttonText, unit) {
      return unit === "day" ? "Today" : `This ${buttonText}`;
    }
  },
  viewHint: "$0 view",
  navLinkHint: "Go to $0",
  moreLinkHint(eventCnt) {
    return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
  }
});
function organizeRawLocales(explicitRawLocales) {
  let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : "en";
  let allRawLocales = globalLocales.concat(explicitRawLocales);
  let rawLocaleMap = {
    en: RAW_EN_LOCALE
  };
  for (let rawLocale of allRawLocales) {
    rawLocaleMap[rawLocale.code] = rawLocale;
  }
  return {
    map: rawLocaleMap,
    defaultCode
  };
}
function buildLocale(inputSingular, available) {
  if (typeof inputSingular === "object" && !Array.isArray(inputSingular)) {
    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
  }
  return queryLocale(inputSingular, available);
}
function queryLocale(codeArg, available) {
  let codes = [].concat(codeArg || []);
  let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
  return parseLocale(codeArg, codes, raw);
}
function queryRawLocale(codes, available) {
  for (let i3 = 0; i3 < codes.length; i3 += 1) {
    let parts = codes[i3].toLocaleLowerCase().split("-");
    for (let j4 = parts.length; j4 > 0; j4 -= 1) {
      let simpleId = parts.slice(0, j4).join("-");
      if (available[simpleId]) {
        return available[simpleId];
      }
    }
  }
  return null;
}
function parseLocale(codeArg, codes, raw) {
  let merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ["buttonText"]);
  delete merged.code;
  let { week } = merged;
  delete merged.week;
  return {
    codeArg,
    codes,
    week,
    simpleNumberFormat: new Intl.NumberFormat(codeArg),
    options: merged
  };
}
function createPlugin(input2) {
  return {
    id: guid(),
    name: input2.name,
    premiumReleaseDate: input2.premiumReleaseDate ? new Date(input2.premiumReleaseDate) : void 0,
    deps: input2.deps || [],
    reducers: input2.reducers || [],
    isLoadingFuncs: input2.isLoadingFuncs || [],
    contextInit: [].concat(input2.contextInit || []),
    eventRefiners: input2.eventRefiners || {},
    eventDefMemberAdders: input2.eventDefMemberAdders || [],
    eventSourceRefiners: input2.eventSourceRefiners || {},
    isDraggableTransformers: input2.isDraggableTransformers || [],
    eventDragMutationMassagers: input2.eventDragMutationMassagers || [],
    eventDefMutationAppliers: input2.eventDefMutationAppliers || [],
    dateSelectionTransformers: input2.dateSelectionTransformers || [],
    datePointTransforms: input2.datePointTransforms || [],
    dateSpanTransforms: input2.dateSpanTransforms || [],
    views: input2.views || {},
    viewPropsTransformers: input2.viewPropsTransformers || [],
    isPropsValid: input2.isPropsValid || null,
    externalDefTransforms: input2.externalDefTransforms || [],
    viewContainerAppends: input2.viewContainerAppends || [],
    eventDropTransformers: input2.eventDropTransformers || [],
    componentInteractions: input2.componentInteractions || [],
    calendarInteractions: input2.calendarInteractions || [],
    themeClasses: input2.themeClasses || {},
    eventSourceDefs: input2.eventSourceDefs || [],
    cmdFormatter: input2.cmdFormatter,
    recurringTypes: input2.recurringTypes || [],
    namedTimeZonedImpl: input2.namedTimeZonedImpl,
    initialView: input2.initialView || "",
    elementDraggingImpl: input2.elementDraggingImpl,
    optionChangeHandlers: input2.optionChangeHandlers || {},
    scrollGridImpl: input2.scrollGridImpl || null,
    listenerRefiners: input2.listenerRefiners || {},
    optionRefiners: input2.optionRefiners || {},
    propSetHandlers: input2.propSetHandlers || {}
  };
}
function buildPluginHooks(pluginDefs, globalDefs) {
  let currentPluginIds = {};
  let hooks = {
    premiumReleaseDate: void 0,
    reducers: [],
    isLoadingFuncs: [],
    contextInit: [],
    eventRefiners: {},
    eventDefMemberAdders: [],
    eventSourceRefiners: {},
    isDraggableTransformers: [],
    eventDragMutationMassagers: [],
    eventDefMutationAppliers: [],
    dateSelectionTransformers: [],
    datePointTransforms: [],
    dateSpanTransforms: [],
    views: {},
    viewPropsTransformers: [],
    isPropsValid: null,
    externalDefTransforms: [],
    viewContainerAppends: [],
    eventDropTransformers: [],
    componentInteractions: [],
    calendarInteractions: [],
    themeClasses: {},
    eventSourceDefs: [],
    cmdFormatter: null,
    recurringTypes: [],
    namedTimeZonedImpl: null,
    initialView: "",
    elementDraggingImpl: null,
    optionChangeHandlers: {},
    scrollGridImpl: null,
    listenerRefiners: {},
    optionRefiners: {},
    propSetHandlers: {}
  };
  function addDefs(defs) {
    for (let def of defs) {
      const pluginName = def.name;
      const currentId = currentPluginIds[pluginName];
      if (currentId === void 0) {
        currentPluginIds[pluginName] = def.id;
        addDefs(def.deps);
        hooks = combineHooks(hooks, def);
      } else if (currentId !== def.id) {
        console.warn(`Duplicate plugin '${pluginName}'`);
      }
    }
  }
  if (pluginDefs) {
    addDefs(pluginDefs);
  }
  addDefs(globalDefs);
  return hooks;
}
function buildBuildPluginHooks() {
  let currentOverrideDefs = [];
  let currentGlobalDefs = [];
  let currentHooks;
  return (overrideDefs, globalDefs) => {
    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
      currentHooks = buildPluginHooks(overrideDefs, globalDefs);
    }
    currentOverrideDefs = overrideDefs;
    currentGlobalDefs = globalDefs;
    return currentHooks;
  };
}
function combineHooks(hooks0, hooks1) {
  return {
    premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),
    reducers: hooks0.reducers.concat(hooks1.reducers),
    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
    contextInit: hooks0.contextInit.concat(hooks1.contextInit),
    eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
    eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
    views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),
    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
    themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),
    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
    initialView: hooks0.initialView || hooks1.initialView,
    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
    optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
    listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
    optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
    propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
  };
}
function compareOptionalDates(date0, date1) {
  if (date0 === void 0) {
    return date1;
  }
  if (date1 === void 0) {
    return date0;
  }
  return new Date(Math.max(date0.valueOf(), date1.valueOf()));
}
var StandardTheme = class extends Theme {
};
StandardTheme.prototype.classes = {
  root: "fc-theme-standard",
  tableCellShaded: "fc-cell-shaded",
  buttonGroup: "fc-button-group",
  button: "fc-button fc-button-primary",
  buttonActive: "fc-button-active"
};
StandardTheme.prototype.baseIconClass = "fc-icon";
StandardTheme.prototype.iconClasses = {
  close: "fc-icon-x",
  prev: "fc-icon-chevron-left",
  next: "fc-icon-chevron-right",
  prevYear: "fc-icon-chevrons-left",
  nextYear: "fc-icon-chevrons-right"
};
StandardTheme.prototype.rtlIconClasses = {
  prev: "fc-icon-chevron-right",
  next: "fc-icon-chevron-left",
  prevYear: "fc-icon-chevrons-right",
  nextYear: "fc-icon-chevrons-left"
};
StandardTheme.prototype.iconOverrideOption = "buttonIcons";
StandardTheme.prototype.iconOverrideCustomButtonOption = "icon";
StandardTheme.prototype.iconOverridePrefix = "fc-icon-";
function compileViewDefs(defaultConfigs, overrideConfigs) {
  let hash = {};
  let viewType;
  for (viewType in defaultConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  for (viewType in overrideConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  return hash;
}
function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  if (hash[viewType]) {
    return hash[viewType];
  }
  let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  if (viewDef) {
    hash[viewType] = viewDef;
  }
  return viewDef;
}
function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  let defaultConfig = defaultConfigs[viewType];
  let overrideConfig = overrideConfigs[viewType];
  let queryProp = (name) => defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
  let theComponent = queryProp("component");
  let superType = queryProp("superType");
  let superDef = null;
  if (superType) {
    if (superType === viewType) {
      throw new Error("Can't have a custom view type that references itself");
    }
    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
  }
  if (!theComponent && superDef) {
    theComponent = superDef.component;
  }
  if (!theComponent) {
    return null;
  }
  return {
    type: viewType,
    component: theComponent,
    defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
    overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
  };
}
function parseViewConfigs(inputs) {
  return mapHash(inputs, parseViewConfig);
}
function parseViewConfig(input2) {
  let rawOptions = typeof input2 === "function" ? { component: input2 } : input2;
  let { component } = rawOptions;
  if (rawOptions.content) {
    component = createViewHookComponent(rawOptions);
  } else if (component && !(component.prototype instanceof BaseComponent)) {
    component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), { content: component }));
  }
  return {
    superType: rawOptions.type,
    component,
    rawOptions
    // includes type and component too :(
  };
}
function createViewHookComponent(options) {
  return (viewProps) => y(ViewContextType.Consumer, null, (context2) => y(ContentContainer, { elTag: "div", elClasses: buildViewClassNames(context2.viewSpec), renderProps: Object.assign(Object.assign({}, viewProps), { nextDayThreshold: context2.options.nextDayThreshold }), generatorName: void 0, customGenerator: options.content, classNameGenerator: options.classNames, didMount: options.didMount, willUnmount: options.willUnmount }));
}
function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let defaultConfigs = parseViewConfigs(defaultInputs);
  let overrideConfigs = parseViewConfigs(optionOverrides.views);
  let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
  return mapHash(viewDefs, (viewDef) => buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));
}
function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
  let duration = null;
  let durationUnit = "";
  let singleUnit = "";
  let singleUnitOverrides = {};
  if (durationInput) {
    duration = createDurationCached(durationInput);
    if (duration) {
      let denom = greatestDurationDenominator(duration);
      durationUnit = denom.unit;
      if (denom.value === 1) {
        singleUnit = durationUnit;
        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
      }
    }
  }
  let queryButtonText = (optionsSubset) => {
    let buttonTextMap = optionsSubset.buttonText || {};
    let buttonTextKey = viewDef.defaults.buttonTextKey;
    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
      return buttonTextMap[buttonTextKey];
    }
    if (buttonTextMap[viewDef.type] != null) {
      return buttonTextMap[viewDef.type];
    }
    if (buttonTextMap[singleUnit] != null) {
      return buttonTextMap[singleUnit];
    }
    return null;
  };
  let queryButtonTitle = (optionsSubset) => {
    let buttonHints = optionsSubset.buttonHints || {};
    let buttonKey = viewDef.defaults.buttonTextKey;
    if (buttonKey != null && buttonHints[buttonKey] != null) {
      return buttonHints[buttonKey];
    }
    if (buttonHints[viewDef.type] != null) {
      return buttonHints[viewDef.type];
    }
    if (buttonHints[singleUnit] != null) {
      return buttonHints[singleUnit];
    }
    return null;
  };
  return {
    type: viewDef.type,
    component: viewDef.component,
    duration,
    durationUnit,
    singleUnit,
    optionDefaults: viewDef.defaults,
    optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),
    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
    viewDef.overrides.buttonText,
    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,
    // not DRY
    buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,
    buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)
    // will eventually fall back to buttonText
  };
}
var durationInputMap = {};
function createDurationCached(durationInput) {
  let json = JSON.stringify(durationInput);
  let res = durationInputMap[json];
  if (res === void 0) {
    res = createDuration(durationInput);
    durationInputMap[json] = res;
  }
  return res;
}
function reduceViewType(viewType, action) {
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      viewType = action.viewType;
  }
  return viewType;
}
function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
  switch (action.type) {
    case "SET_OPTION":
      return Object.assign(Object.assign({}, dynamicOptionOverrides), { [action.optionName]: action.rawOptionValue });
    default:
      return dynamicOptionOverrides;
  }
}
function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
  let dp;
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      return dateProfileGenerator.build(action.dateMarker || currentDate);
    case "CHANGE_DATE":
      return dateProfileGenerator.build(action.dateMarker);
    case "PREV":
      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
    case "NEXT":
      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
  }
  return currentDateProfile;
}
function initEventSources(calendarOptions, dateProfile, context2) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return addSources({}, parseInitialSources(calendarOptions, context2), activeRange, context2);
}
function reduceEventSources(eventSources, action, dateProfile, context2) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  switch (action.type) {
    case "ADD_EVENT_SOURCES":
      return addSources(eventSources, action.sources, activeRange, context2);
    case "REMOVE_EVENT_SOURCE":
      return removeSource(eventSources, action.sourceId);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return fetchDirtySources(eventSources, activeRange, context2);
      }
      return eventSources;
    case "FETCH_EVENT_SOURCES":
      return fetchSourcesByIds(eventSources, action.sourceIds ? (
        // why no type?
        arrayToHash(action.sourceIds)
      ) : excludeStaticSources(eventSources, context2), activeRange, action.isRefetch || false, context2);
    case "RECEIVE_EVENTS":
    case "RECEIVE_EVENT_ERROR":
      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
    case "REMOVE_ALL_EVENT_SOURCES":
      return {};
    default:
      return eventSources;
  }
}
function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context2) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context2), activeRange, true, context2);
}
function computeEventSourcesLoading(eventSources) {
  for (let sourceId in eventSources) {
    if (eventSources[sourceId].isFetching) {
      return true;
    }
  }
  return false;
}
function addSources(eventSourceHash, sources, fetchRange, context2) {
  let hash = {};
  for (let source of sources) {
    hash[source.sourceId] = source;
  }
  if (fetchRange) {
    hash = fetchDirtySources(hash, fetchRange, context2);
  }
  return Object.assign(Object.assign({}, eventSourceHash), hash);
}
function removeSource(eventSourceHash, sourceId) {
  return filterHash(eventSourceHash, (eventSource) => eventSource.sourceId !== sourceId);
}
function fetchDirtySources(sourceHash, fetchRange, context2) {
  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource) => isSourceDirty(eventSource, fetchRange, context2)), fetchRange, false, context2);
}
function isSourceDirty(eventSource, fetchRange, context2) {
  if (!doesSourceNeedRange(eventSource, context2)) {
    return !eventSource.latestFetchId;
  }
  return !context2.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches
  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
}
function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context2) {
  let nextSources = {};
  for (let sourceId in prevSources) {
    let source = prevSources[sourceId];
    if (sourceIdHash[sourceId]) {
      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context2);
    } else {
      nextSources[sourceId] = source;
    }
  }
  return nextSources;
}
function fetchSource(eventSource, fetchRange, isRefetch, context2) {
  let { options, calendarApi } = context2;
  let sourceDef = context2.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
  let fetchId = guid();
  sourceDef.fetch({
    eventSource,
    range: fetchRange,
    isRefetch,
    context: context2
  }, (res) => {
    let { rawEvents } = res;
    if (options.eventSourceSuccess) {
      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    if (eventSource.success) {
      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    context2.dispatch({
      type: "RECEIVE_EVENTS",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      rawEvents
    });
  }, (error) => {
    let errorHandled = false;
    if (options.eventSourceFailure) {
      options.eventSourceFailure.call(calendarApi, error);
      errorHandled = true;
    }
    if (eventSource.failure) {
      eventSource.failure(error);
      errorHandled = true;
    }
    if (!errorHandled) {
      console.warn(error.message, error);
    }
    context2.dispatch({
      type: "RECEIVE_EVENT_ERROR",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      error
    });
  });
  return Object.assign(Object.assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });
}
function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
  let eventSource = sourceHash[sourceId];
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    return Object.assign(Object.assign({}, sourceHash), { [sourceId]: Object.assign(Object.assign({}, eventSource), { isFetching: false, fetchRange }) });
  }
  return sourceHash;
}
function excludeStaticSources(eventSources, context2) {
  return filterHash(eventSources, (eventSource) => doesSourceNeedRange(eventSource, context2));
}
function parseInitialSources(rawOptions, context2) {
  let refiners = buildEventSourceRefiners(context2);
  let rawSources = [].concat(rawOptions.eventSources || []);
  let sources = [];
  if (rawOptions.initialEvents) {
    rawSources.unshift(rawOptions.initialEvents);
  }
  if (rawOptions.events) {
    rawSources.unshift(rawOptions.events);
  }
  for (let rawSource of rawSources) {
    let source = parseEventSource(rawSource, context2, refiners);
    if (source) {
      sources.push(source);
    }
  }
  return sources;
}
function doesSourceNeedRange(eventSource, context2) {
  let defs = context2.pluginHooks.eventSourceDefs;
  return !defs[eventSource.sourceDefId].ignoreRange;
}
function reduceDateSelection(currentSelection, action) {
  switch (action.type) {
    case "UNSELECT_DATES":
      return null;
    case "SELECT_DATES":
      return action.selection;
    default:
      return currentSelection;
  }
}
function reduceSelectedEvent(currentInstanceId, action) {
  switch (action.type) {
    case "UNSELECT_EVENT":
      return "";
    case "SELECT_EVENT":
      return action.eventInstanceId;
    default:
      return currentInstanceId;
  }
}
function reduceEventDrag(currentDrag, action) {
  let newDrag;
  switch (action.type) {
    case "UNSET_EVENT_DRAG":
      return null;
    case "SET_EVENT_DRAG":
      newDrag = action.state;
      return {
        affectedEvents: newDrag.affectedEvents,
        mutatedEvents: newDrag.mutatedEvents,
        isEvent: newDrag.isEvent
      };
    default:
      return currentDrag;
  }
}
function reduceEventResize(currentResize, action) {
  let newResize;
  switch (action.type) {
    case "UNSET_EVENT_RESIZE":
      return null;
    case "SET_EVENT_RESIZE":
      newResize = action.state;
      return {
        affectedEvents: newResize.affectedEvents,
        mutatedEvents: newResize.mutatedEvents,
        isEvent: newResize.isEvent
      };
    default:
      return currentResize;
  }
}
function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  return { header, footer };
}
function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let sectionWidgets = {};
  let viewsWithButtons = [];
  let hasTitle = false;
  for (let sectionName in sectionStrHash) {
    let sectionStr = sectionStrHash[sectionName];
    let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
    sectionWidgets[sectionName] = sectionRes.widgets;
    viewsWithButtons.push(...sectionRes.viewsWithButtons);
    hasTitle = hasTitle || sectionRes.hasTitle;
  }
  return { sectionWidgets, viewsWithButtons, hasTitle };
}
function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let isRtl = calendarOptions.direction === "rtl";
  let calendarCustomButtons = calendarOptions.customButtons || {};
  let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
  let calendarButtonText = calendarOptions.buttonText || {};
  let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
  let calendarButtonHints = calendarOptions.buttonHints || {};
  let sectionSubstrs = sectionStr ? sectionStr.split(" ") : [];
  let viewsWithButtons = [];
  let hasTitle = false;
  let widgets = sectionSubstrs.map((buttonGroupStr) => buttonGroupStr.split(",").map((buttonName) => {
    if (buttonName === "title") {
      hasTitle = true;
      return { buttonName };
    }
    let customButtonProps;
    let viewSpec;
    let buttonClick;
    let buttonIcon;
    let buttonText;
    let buttonHint;
    if (customButtonProps = calendarCustomButtons[buttonName]) {
      buttonClick = (ev) => {
        if (customButtonProps.click) {
          customButtonProps.click.call(ev.target, ev, ev.target);
        }
      };
      (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
      buttonHint = customButtonProps.hint || customButtonProps.text;
    } else if (viewSpec = viewSpecs[buttonName]) {
      viewsWithButtons.push(buttonName);
      buttonClick = () => {
        calendarApi.changeView(buttonName);
      };
      (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
      let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;
      buttonHint = formatWithOrdinals(
        viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint,
        [textFallback, buttonName],
        // view-name = buttonName
        textFallback
      );
    } else if (calendarApi[buttonName]) {
      buttonClick = () => {
        calendarApi[buttonName]();
      };
      (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]);
      if (buttonName === "prevYear" || buttonName === "nextYear") {
        let prevOrNext = buttonName === "prevYear" ? "prev" : "next";
        buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [
          calendarButtonText.year || "year",
          "year"
        ], calendarButtonText[buttonName]);
      } else {
        buttonHint = (navUnit) => formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [
          calendarButtonText[navUnit] || navUnit,
          navUnit
        ], calendarButtonText[buttonName]);
      }
    }
    return { buttonName, buttonClick, buttonIcon, buttonText, buttonHint };
  }));
  return { widgets, viewsWithButtons, hasTitle };
}
var ViewImpl = class {
  constructor(type, getCurrentData, dateEnv) {
    this.type = type;
    this.getCurrentData = getCurrentData;
    this.dateEnv = dateEnv;
  }
  get calendar() {
    return this.getCurrentData().calendarApi;
  }
  get title() {
    return this.getCurrentData().viewTitle;
  }
  get activeStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
  }
  get activeEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
  }
  get currentStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
  }
  get currentEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
  }
  getOption(name) {
    return this.getCurrentData().options[name];
  }
};
var eventSourceDef$2 = {
  ignoreRange: true,
  parseMeta(refined) {
    if (Array.isArray(refined.events)) {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback) {
    successCallback({
      rawEvents: arg.eventSource.meta
    });
  }
};
var arrayEventSourcePlugin = createPlugin({
  name: "array-event-source",
  eventSourceDefs: [eventSourceDef$2]
});
var eventSourceDef$1 = {
  parseMeta(refined) {
    if (typeof refined.events === "function") {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { dateEnv } = arg.context;
    const func = arg.eventSource.meta;
    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents) => successCallback({ rawEvents }), errorCallback);
  }
};
var funcEventSourcePlugin = createPlugin({
  name: "func-event-source",
  eventSourceDefs: [eventSourceDef$1]
});
var JSON_FEED_EVENT_SOURCE_REFINERS = {
  method: String,
  extraParams: identity2,
  startParam: String,
  endParam: String,
  timeZoneParam: String
};
var eventSourceDef = {
  parseMeta(refined) {
    if (refined.url && (refined.format === "json" || !refined.format)) {
      return {
        url: refined.url,
        format: "json",
        method: (refined.method || "GET").toUpperCase(),
        extraParams: refined.extraParams,
        startParam: refined.startParam,
        endParam: refined.endParam,
        timeZoneParam: refined.timeZoneParam
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { meta } = arg.eventSource;
    const requestParams = buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams).then(([rawEvents, response]) => {
      successCallback({ rawEvents, response });
    }, errorCallback);
  }
};
var jsonFeedEventSourcePlugin = createPlugin({
  name: "json-event-source",
  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
  eventSourceDefs: [eventSourceDef]
});
function buildRequestParams(meta, range, context2) {
  let { dateEnv, options } = context2;
  let startParam;
  let endParam;
  let timeZoneParam;
  let customRequestParams;
  let params = {};
  startParam = meta.startParam;
  if (startParam == null) {
    startParam = options.startParam;
  }
  endParam = meta.endParam;
  if (endParam == null) {
    endParam = options.endParam;
  }
  timeZoneParam = meta.timeZoneParam;
  if (timeZoneParam == null) {
    timeZoneParam = options.timeZoneParam;
  }
  if (typeof meta.extraParams === "function") {
    customRequestParams = meta.extraParams();
  } else {
    customRequestParams = meta.extraParams || {};
  }
  Object.assign(params, customRequestParams);
  params[startParam] = dateEnv.formatIso(range.start);
  params[endParam] = dateEnv.formatIso(range.end);
  if (dateEnv.timeZone !== "local") {
    params[timeZoneParam] = dateEnv.timeZone;
  }
  return params;
}
var SIMPLE_RECURRING_REFINERS = {
  daysOfWeek: identity2,
  startTime: createDuration,
  endTime: createDuration,
  duration: createDuration,
  startRecur: identity2,
  endRecur: identity2
};
var recurring = {
  parse(refined, dateEnv) {
    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
      let recurringData = {
        daysOfWeek: refined.daysOfWeek || null,
        startTime: refined.startTime || null,
        endTime: refined.endTime || null,
        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null
      };
      let duration;
      if (refined.duration) {
        duration = refined.duration;
      }
      if (!duration && refined.startTime && refined.endTime) {
        duration = subtractDurations(refined.endTime, refined.startTime);
      }
      return {
        allDayGuess: Boolean(!refined.startTime && !refined.endTime),
        duration,
        typeData: recurringData
        // doesn't need endTime anymore but oh well
      };
    }
    return null;
  },
  expand(typeData, framingRange, dateEnv) {
    let clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
    if (clippedFramingRange) {
      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
    }
    return [];
  }
};
var simpleRecurringEventsPlugin = createPlugin({
  name: "simple-recurring-event",
  recurringTypes: [recurring],
  eventRefiners: SIMPLE_RECURRING_REFINERS
});
function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {
  let dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
  let dayMarker = startOfDay(framingRange.start);
  let endMarker = framingRange.end;
  let instanceStarts = [];
  while (dayMarker < endMarker) {
    let instanceStart;
    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
      if (startTime) {
        instanceStart = dateEnv.add(dayMarker, startTime);
      } else {
        instanceStart = dayMarker;
      }
      instanceStarts.push(instanceStart);
    }
    dayMarker = addDays(dayMarker, 1);
  }
  return instanceStarts;
}
var changeHandlerPlugin = createPlugin({
  name: "change-handler",
  optionChangeHandlers: {
    events(events, context2) {
      handleEventSources([events], context2);
    },
    eventSources: handleEventSources
  }
});
function handleEventSources(inputs, context2) {
  let unfoundSources = hashValuesToArray(context2.getCurrentData().eventSources);
  if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {
    context2.dispatch({
      type: "RESET_RAW_EVENTS",
      sourceId: unfoundSources[0].sourceId,
      rawEvents: inputs[0]
    });
    return;
  }
  let newInputs = [];
  for (let input2 of inputs) {
    let inputFound = false;
    for (let i3 = 0; i3 < unfoundSources.length; i3 += 1) {
      if (unfoundSources[i3]._raw === input2) {
        unfoundSources.splice(i3, 1);
        inputFound = true;
        break;
      }
    }
    if (!inputFound) {
      newInputs.push(input2);
    }
  }
  for (let unfoundSource of unfoundSources) {
    context2.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: unfoundSource.sourceId
    });
  }
  for (let newInput of newInputs) {
    context2.calendarApi.addEventSource(newInput);
  }
}
function handleDateProfile(dateProfile, context2) {
  context2.emitter.trigger("datesSet", Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context2.dateEnv)), { view: context2.viewApi }));
}
function handleEventStore(eventStore, context2) {
  let { emitter } = context2;
  if (emitter.hasHandlers("eventsSet")) {
    emitter.trigger("eventsSet", buildEventApis(eventStore, context2));
  }
}
var globalPlugins = [
  arrayEventSourcePlugin,
  funcEventSourcePlugin,
  jsonFeedEventSourcePlugin,
  simpleRecurringEventsPlugin,
  changeHandlerPlugin,
  createPlugin({
    name: "misc",
    isLoadingFuncs: [
      (state) => computeEventSourcesLoading(state.eventSources)
    ],
    propSetHandlers: {
      dateProfile: handleDateProfile,
      eventStore: handleEventStore
    }
  })
];
var TaskRunner = class {
  constructor(runTaskOption, drainedOption) {
    this.runTaskOption = runTaskOption;
    this.drainedOption = drainedOption;
    this.queue = [];
    this.delayedRunner = new DelayedRunner(this.drain.bind(this));
  }
  request(task, delay) {
    this.queue.push(task);
    this.delayedRunner.request(delay);
  }
  pause(scope) {
    this.delayedRunner.pause(scope);
  }
  resume(scope, force) {
    this.delayedRunner.resume(scope, force);
  }
  drain() {
    let { queue } = this;
    while (queue.length) {
      let completedTasks = [];
      let task;
      while (task = queue.shift()) {
        this.runTask(task);
        completedTasks.push(task);
      }
      this.drained(completedTasks);
    }
  }
  runTask(task) {
    if (this.runTaskOption) {
      this.runTaskOption(task);
    }
  }
  drained(completedTasks) {
    if (this.drainedOption) {
      this.drainedOption(completedTasks);
    }
  }
};
function buildTitle(dateProfile, viewOptions, dateEnv) {
  let range;
  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
    range = dateProfile.currentRange;
  } else {
    range = dateProfile.activeRange;
  }
  return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
    isEndExclusive: dateProfile.isRangeAllDay,
    defaultSeparator: viewOptions.titleRangeSeparator
  });
}
function buildTitleFormat(dateProfile) {
  let { currentRangeUnit } = dateProfile;
  if (currentRangeUnit === "year") {
    return { year: "numeric" };
  }
  if (currentRangeUnit === "month") {
    return { year: "numeric", month: "long" };
  }
  let days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
  if (days !== null && days > 1) {
    return { year: "numeric", month: "short", day: "numeric" };
  }
  return { year: "numeric", month: "long", day: "numeric" };
}
var CalendarDataManager = class {
  constructor(props) {
    this.computeCurrentViewData = memoize(this._computeCurrentViewData);
    this.organizeRawLocales = memoize(organizeRawLocales);
    this.buildLocale = memoize(buildLocale);
    this.buildPluginHooks = buildBuildPluginHooks();
    this.buildDateEnv = memoize(buildDateEnv$1);
    this.buildTheme = memoize(buildTheme);
    this.parseToolbars = memoize(parseToolbars);
    this.buildViewSpecs = memoize(buildViewSpecs);
    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
    this.buildViewApi = memoize(buildViewApi);
    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
    this.buildEventUiBases = memoize(buildEventUiBases);
    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
    this.buildTitle = memoize(buildTitle);
    this.emitter = new Emitter();
    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
    this.currentCalendarOptionsInput = {};
    this.currentCalendarOptionsRefined = {};
    this.currentViewOptionsInput = {};
    this.currentViewOptionsRefined = {};
    this.currentCalendarOptionsRefiners = {};
    this.optionsForRefining = [];
    this.optionsForHandling = [];
    this.getCurrentData = () => this.data;
    this.dispatch = (action) => {
      this.actionRunner.request(action);
    };
    this.props = props;
    this.actionRunner.pause();
    let dynamicOptionOverrides = {};
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    this.emitter.setThisContext(props.calendarApi);
    this.emitter.setOptions(currentViewData.options);
    let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
    let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter: this.emitter,
      getCurrentData: this.getCurrentData
    };
    for (let callback of optionsData.pluginHooks.contextInit) {
      callback(calendarContext);
    }
    let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
    let initialState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      businessHours: this.parseContextBusinessHours(calendarContext),
      eventSources,
      eventUiBases: {},
      eventStore: createEmptyEventStore(),
      renderableEventStore: createEmptyEventStore(),
      dateSelection: null,
      eventSelection: "",
      eventDrag: null,
      eventResize: null,
      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(initialState, reducer(null, null, contextAndState));
    }
    if (computeIsLoading(initialState, calendarContext)) {
      this.emitter.trigger("loading", true);
    }
    this.state = initialState;
    this.updateData();
    this.actionRunner.resume();
  }
  resetOptions(optionOverrides, changedOptionNames) {
    let { props } = this;
    if (changedOptionNames === void 0) {
      props.optionOverrides = optionOverrides;
    } else {
      props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);
      this.optionsForRefining.push(...changedOptionNames);
    }
    if (changedOptionNames === void 0 || changedOptionNames.length) {
      this.actionRunner.request({
        type: "NOTHING"
      });
    }
  }
  _handleAction(action) {
    let { props, state, emitter } = this;
    let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = reduceViewType(state.currentViewType, action);
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    emitter.setThisContext(props.calendarApi);
    emitter.setOptions(currentViewData.options);
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter,
      getCurrentData: this.getCurrentData
    };
    let { currentDate, dateProfile } = state;
    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {
      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    }
    currentDate = reduceCurrentDate(currentDate, action);
    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
    if (action.type === "PREV" || // TODO: move this logic into DateProfileGenerator
    action.type === "NEXT" || // "
    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
    let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
    let isEventsLoading = computeEventSourcesLoading(eventSources);
    let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : (
      // try from previous state
      eventStore
    );
    let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext);
    let eventUiBySource = this.buildEventUiBySource(eventSources);
    let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
    let newState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      eventSources,
      eventStore,
      renderableEventStore,
      selectionConfig,
      eventUiBases,
      businessHours: this.parseContextBusinessHours(calendarContext),
      dateSelection: reduceDateSelection(state.dateSelection, action),
      eventSelection: reduceSelectedEvent(state.eventSelection, action),
      eventDrag: reduceEventDrag(state.eventDrag, action),
      eventResize: reduceEventResize(state.eventResize, action)
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(newState, reducer(state, action, contextAndState));
    }
    let wasLoading = computeIsLoading(state, calendarContext);
    let isLoading = computeIsLoading(newState, calendarContext);
    if (!wasLoading && isLoading) {
      emitter.trigger("loading", true);
    } else if (wasLoading && !isLoading) {
      emitter.trigger("loading", false);
    }
    this.state = newState;
    if (props.onAction) {
      props.onAction(action);
    }
  }
  updateData() {
    let { props, state } = this;
    let oldData = this.data;
    let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
    let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
    let data = this.data = Object.assign(Object.assign(Object.assign({ viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);
    let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
    let oldCalendarOptions = oldData && oldData.calendarOptions;
    let newCalendarOptions = optionsData.calendarOptions;
    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
        state.renderableEventStore = data.renderableEventStore = rezoneEventStoreDates(data.renderableEventStore, oldData.dateEnv, data.dateEnv);
      }
      for (let optionName in changeHandlers) {
        if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
          changeHandlers[optionName](newCalendarOptions[optionName], data);
        }
      }
    }
    this.optionsForHandling = [];
    if (props.onData) {
      props.onData(data);
    }
  }
  computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {
    if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {
      return this.stableCalendarOptionsData;
    }
    let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
    let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);
    let theme = this.buildTheme(refinedOptions, pluginHooks);
    let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);
    return this.stableCalendarOptionsData = {
      calendarOptions: refinedOptions,
      pluginHooks,
      dateEnv,
      viewSpecs,
      theme,
      toolbarConfig,
      localeDefaults,
      availableRawLocales: availableLocaleData.map
    };
  }
  // always called from behind a memoizer
  processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {
    let { locales, locale } = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let availableLocaleData = this.organizeRawLocales(locales);
    let availableRawLocales = availableLocaleData.map;
    let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
    let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
    let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let extra = {};
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      localeDefaults,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let refined = {};
    let currentRaw = this.currentCalendarOptionsInput;
    let currentRefined = this.currentCalendarOptionsRefined;
    let anyChanges = false;
    for (let optionName in raw) {
      if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {
        refined[optionName] = currentRefined[optionName];
      } else if (refiners[optionName]) {
        refined[optionName] = refiners[optionName](raw[optionName]);
        anyChanges = true;
      } else {
        extra[optionName] = currentRaw[optionName];
      }
    }
    if (anyChanges) {
      this.currentCalendarOptionsInput = raw;
      this.currentCalendarOptionsRefined = refined;
      this.stableOptionOverrides = optionOverrides;
      this.stableDynamicOptionOverrides = dynamicOptionOverrides;
    }
    this.optionsForHandling.push(...this.optionsForRefining);
    this.optionsForRefining = [];
    return {
      rawOptions: this.currentCalendarOptionsInput,
      refinedOptions: this.currentCalendarOptionsRefined,
      pluginHooks,
      availableLocaleData,
      localeDefaults,
      extra
    };
  }
  _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
    let viewSpec = optionsData.viewSpecs[viewType];
    if (!viewSpec) {
      throw new Error(`viewType "${viewType}" is not available. Please make sure you've loaded all neccessary plugins`);
    }
    let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateProfileGenerator = this.buildDateProfileGenerator({
      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
      duration: viewSpec.duration,
      durationUnit: viewSpec.durationUnit,
      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
      dateEnv: optionsData.dateEnv,
      calendarApi: this.props.calendarApi,
      slotMinTime: refinedOptions.slotMinTime,
      slotMaxTime: refinedOptions.slotMaxTime,
      showNonCurrentDates: refinedOptions.showNonCurrentDates,
      dayCount: refinedOptions.dayCount,
      dateAlignment: refinedOptions.dateAlignment,
      dateIncrement: refinedOptions.dateIncrement,
      hiddenDays: refinedOptions.hiddenDays,
      weekends: refinedOptions.weekends,
      nowInput: refinedOptions.now,
      validRangeInput: refinedOptions.validRange,
      visibleRangeInput: refinedOptions.visibleRange,
      fixedWeekCount: refinedOptions.fixedWeekCount
    });
    let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
    return { viewSpec, options: refinedOptions, dateProfileGenerator, viewApi };
  }
  processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      viewSpec.optionDefaults,
      localeDefaults,
      optionOverrides,
      viewSpec.optionOverrides,
      dynamicOptionOverrides
    ]);
    let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let refined = {};
    let currentRaw = this.currentViewOptionsInput;
    let currentRefined = this.currentViewOptionsRefined;
    let anyChanges = false;
    let extra = {};
    for (let optionName in raw) {
      if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {
        refined[optionName] = currentRefined[optionName];
      } else {
        if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {
          if (optionName in this.currentCalendarOptionsRefined) {
            refined[optionName] = this.currentCalendarOptionsRefined[optionName];
          }
        } else if (refiners[optionName]) {
          refined[optionName] = refiners[optionName](raw[optionName]);
        } else {
          extra[optionName] = raw[optionName];
        }
        anyChanges = true;
      }
    }
    if (anyChanges) {
      this.currentViewOptionsInput = raw;
      this.currentViewOptionsRefined = refined;
    }
    return {
      rawOptions: this.currentViewOptionsInput,
      refinedOptions: this.currentViewOptionsRefined,
      extra
    };
  }
};
function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
  let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
  return new DateEnv({
    calendarSystem: "gregory",
    timeZone,
    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
    locale,
    weekNumberCalculation,
    firstDay,
    weekText,
    cmdFormatter: pluginHooks.cmdFormatter,
    defaultSeparator
  });
}
function buildTheme(options, pluginHooks) {
  let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
  return new ThemeClass(options);
}
function buildDateProfileGenerator(props) {
  let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
  return new DateProfileGeneratorClass(props);
}
function buildViewApi(type, getCurrentData, dateEnv) {
  return new ViewImpl(type, getCurrentData, dateEnv);
}
function buildEventUiBySource(eventSources) {
  return mapHash(eventSources, (eventSource) => eventSource.ui);
}
function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
  let eventUiBases = { "": eventUiSingleBase };
  for (let defId in eventDefs) {
    let def = eventDefs[defId];
    if (def.sourceId && eventUiBySource[def.sourceId]) {
      eventUiBases[defId] = eventUiBySource[def.sourceId];
    }
  }
  return eventUiBases;
}
function buildViewUiProps(calendarContext) {
  let { options } = calendarContext;
  return {
    eventUiSingleBase: createEventUi({
      display: options.eventDisplay,
      editable: options.editable,
      startEditable: options.eventStartEditable,
      durationEditable: options.eventDurationEditable,
      constraint: options.eventConstraint,
      overlap: typeof options.eventOverlap === "boolean" ? options.eventOverlap : void 0,
      allow: options.eventAllow,
      backgroundColor: options.eventBackgroundColor,
      borderColor: options.eventBorderColor,
      textColor: options.eventTextColor,
      color: options.eventColor
      // classNames: options.eventClassNames // render hook will handle this
    }, calendarContext),
    selectionConfig: createEventUi({
      constraint: options.selectConstraint,
      overlap: typeof options.selectOverlap === "boolean" ? options.selectOverlap : void 0,
      allow: options.selectAllow
    }, calendarContext)
  };
}
function computeIsLoading(state, context2) {
  for (let isLoadingFunc of context2.pluginHooks.isLoadingFuncs) {
    if (isLoadingFunc(state)) {
      return true;
    }
  }
  return false;
}
function parseContextBusinessHours(calendarContext) {
  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
}
function warnUnknownOptions(options, viewName) {
  for (let optionName in options) {
    console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : ""));
  }
}
var ToolbarSection = class extends BaseComponent {
  render() {
    let children = this.props.widgetGroups.map((widgetGroup) => this.renderWidgetGroup(widgetGroup));
    return y("div", { className: "fc-toolbar-chunk" }, ...children);
  }
  renderWidgetGroup(widgetGroup) {
    let { props } = this;
    let { theme } = this.context;
    let children = [];
    let isOnlyButtons = true;
    for (let widget of widgetGroup) {
      let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;
      if (buttonName === "title") {
        isOnlyButtons = false;
        children.push(y("h2", { className: "fc-toolbar-title", id: props.titleId }, props.title));
      } else {
        let isPressed = buttonName === props.activeButton;
        let isDisabled = !props.isTodayEnabled && buttonName === "today" || !props.isPrevEnabled && buttonName === "prev" || !props.isNextEnabled && buttonName === "next";
        let buttonClasses = [`fc-${buttonName}-button`, theme.getClass("button")];
        if (isPressed) {
          buttonClasses.push(theme.getClass("buttonActive"));
        }
        children.push(y("button", { type: "button", title: typeof buttonHint === "function" ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, "aria-pressed": isPressed, className: buttonClasses.join(" "), onClick: buttonClick }, buttonText || (buttonIcon ? y("span", { className: buttonIcon, role: "img" }) : "")));
      }
    }
    if (children.length > 1) {
      let groupClassName = isOnlyButtons && theme.getClass("buttonGroup") || "";
      return y("div", { className: groupClassName }, ...children);
    }
    return children[0];
  }
};
var Toolbar = class extends BaseComponent {
  render() {
    let { model: model2, extraClassName } = this.props;
    let forceLtr = false;
    let startContent;
    let endContent;
    let sectionWidgets = model2.sectionWidgets;
    let centerContent = sectionWidgets.center;
    if (sectionWidgets.left) {
      forceLtr = true;
      startContent = sectionWidgets.left;
    } else {
      startContent = sectionWidgets.start;
    }
    if (sectionWidgets.right) {
      forceLtr = true;
      endContent = sectionWidgets.right;
    } else {
      endContent = sectionWidgets.end;
    }
    let classNames = [
      extraClassName || "",
      "fc-toolbar",
      forceLtr ? "fc-toolbar-ltr" : ""
    ];
    return y(
      "div",
      { className: classNames.join(" ") },
      this.renderSection("start", startContent || []),
      this.renderSection("center", centerContent || []),
      this.renderSection("end", endContent || [])
    );
  }
  renderSection(key, widgetGroups) {
    let { props } = this;
    return y(ToolbarSection, { key, widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId });
  }
};
var ViewHarness = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      availableWidth: null
    };
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
      this.updateAvailableWidth();
    };
    this.handleResize = () => {
      this.updateAvailableWidth();
    };
  }
  render() {
    let { props, state } = this;
    let { aspectRatio } = props;
    let classNames = [
      "fc-view-harness",
      aspectRatio || props.liquid || props.height ? "fc-view-harness-active" : "fc-view-harness-passive"
      // let the view do the height
    ];
    let height = "";
    let paddingBottom = "";
    if (aspectRatio) {
      if (state.availableWidth !== null) {
        height = state.availableWidth / aspectRatio;
      } else {
        paddingBottom = `${1 / aspectRatio * 100}%`;
      }
    } else {
      height = props.height || "";
    }
    return y("div", { "aria-labelledby": props.labeledById, ref: this.handleEl, className: classNames.join(" "), style: { height, paddingBottom } }, props.children);
  }
  componentDidMount() {
    this.context.addResizeHandler(this.handleResize);
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  updateAvailableWidth() {
    if (this.el && // needed. but why?
    this.props.aspectRatio) {
      this.setState({ availableWidth: this.el.offsetWidth });
    }
  }
};
var EventClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleSegClick = (ev, segEl) => {
      let { component } = this;
      let { context: context2 } = component;
      let seg = getElSeg(segEl);
      if (seg && // might be the <div> surrounding the more link
      component.isValidSegDownEl(ev.target)) {
        let hasUrlContainer = elementClosest(ev.target, ".fc-event-forced-url");
        let url = hasUrlContainer ? hasUrlContainer.querySelector("a[href]").href : "";
        context2.emitter.trigger("eventClick", {
          el: segEl,
          event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),
          jsEvent: ev,
          view: context2.viewApi
        });
        if (url && !ev.defaultPrevented) {
          window.location.href = url;
        }
      }
    };
    this.destroy = listenBySelector(
      settings.el,
      "click",
      ".fc-event",
      // on both fg and bg events
      this.handleSegClick
    );
  }
};
var EventHovering = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleEventElRemove = (el) => {
      if (el === this.currentSegEl) {
        this.handleSegLeave(null, this.currentSegEl);
      }
    };
    this.handleSegEnter = (ev, segEl) => {
      if (getElSeg(segEl)) {
        this.currentSegEl = segEl;
        this.triggerEvent("eventMouseEnter", ev, segEl);
      }
    };
    this.handleSegLeave = (ev, segEl) => {
      if (this.currentSegEl) {
        this.currentSegEl = null;
        this.triggerEvent("eventMouseLeave", ev, segEl);
      }
    };
    this.removeHoverListeners = listenToHoverBySelector(
      settings.el,
      ".fc-event",
      // on both fg and bg events
      this.handleSegEnter,
      this.handleSegLeave
    );
  }
  destroy() {
    this.removeHoverListeners();
  }
  triggerEvent(publicEvName, ev, segEl) {
    let { component } = this;
    let { context: context2 } = component;
    let seg = getElSeg(segEl);
    if (!ev || component.isValidSegDownEl(ev.target)) {
      context2.emitter.trigger(publicEvName, {
        el: segEl,
        event: new EventImpl(context2, seg.eventRange.def, seg.eventRange.instance),
        jsEvent: ev,
        view: context2.viewApi
      });
    }
  }
};
var CalendarContent = class extends PureComponent {
  constructor() {
    super(...arguments);
    this.buildViewContext = memoize(buildViewContext);
    this.buildViewPropTransformers = memoize(buildViewPropTransformers);
    this.buildToolbarProps = memoize(buildToolbarProps);
    this.headerRef = d();
    this.footerRef = d();
    this.interactionsStore = {};
    this.state = {
      viewLabelId: getUniqueDomId()
    };
    this.registerInteractiveComponent = (component, settingsInput) => {
      let settings = parseInteractionSettings(component, settingsInput);
      let DEFAULT_INTERACTIONS = [
        EventClicking,
        EventHovering
      ];
      let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);
      let interactions = interactionClasses.map((TheInteractionClass) => new TheInteractionClass(settings));
      this.interactionsStore[component.uid] = interactions;
      interactionSettingsStore[component.uid] = settings;
    };
    this.unregisterInteractiveComponent = (component) => {
      let listeners = this.interactionsStore[component.uid];
      if (listeners) {
        for (let listener of listeners) {
          listener.destroy();
        }
        delete this.interactionsStore[component.uid];
      }
      delete interactionSettingsStore[component.uid];
    };
    this.resizeRunner = new DelayedRunner(() => {
      this.props.emitter.trigger("_resize", true);
      this.props.emitter.trigger("windowResize", { view: this.props.viewApi });
    });
    this.handleWindowResize = (ev) => {
      let { options } = this.props;
      if (options.handleWindowResize && ev.target === window) {
        this.resizeRunner.request(options.windowResizeDelay);
      }
    };
  }
  /*
  renders INSIDE of an outer div
  */
  render() {
    let { props } = this;
    let { toolbarConfig, options } = props;
    let toolbarProps = this.buildToolbarProps(
      props.viewSpec,
      props.dateProfile,
      props.dateProfileGenerator,
      props.currentDate,
      getNow(props.options.now, props.dateEnv),
      // TODO: use NowTimer????
      props.viewTitle
    );
    let viewVGrow = false;
    let viewHeight = "";
    let viewAspectRatio;
    if (props.isHeightAuto || props.forPrint) {
      viewHeight = "";
    } else if (options.height != null) {
      viewVGrow = true;
    } else if (options.contentHeight != null) {
      viewHeight = options.contentHeight;
    } else {
      viewAspectRatio = Math.max(options.aspectRatio, 0.5);
    }
    let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
    let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : void 0;
    return y(
      ViewContextType.Provider,
      { value: viewContext },
      toolbarConfig.header && y(Toolbar, Object.assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps)),
      y(
        ViewHarness,
        { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId },
        this.renderView(props),
        this.buildAppendContent()
      ),
      toolbarConfig.footer && y(Toolbar, Object.assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: toolbarConfig.footer, titleId: "" }, toolbarProps))
    );
  }
  componentDidMount() {
    let { props } = this;
    this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass) => new CalendarInteractionClass(props));
    window.addEventListener("resize", this.handleWindowResize);
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      propSetHandlers[propName](props[propName], props);
    }
  }
  componentDidUpdate(prevProps) {
    let { props } = this;
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      if (props[propName] !== prevProps[propName]) {
        propSetHandlers[propName](props[propName], props);
      }
    }
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.handleWindowResize);
    this.resizeRunner.clear();
    for (let interaction of this.calendarInteractions) {
      interaction.destroy();
    }
    this.props.emitter.trigger("_unmount");
  }
  buildAppendContent() {
    let { props } = this;
    let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent) => buildAppendContent(props));
    return y(_, {}, ...children);
  }
  renderView(props) {
    let { pluginHooks } = props;
    let { viewSpec } = props;
    let viewProps = {
      dateProfile: props.dateProfile,
      businessHours: props.businessHours,
      eventStore: props.renderableEventStore,
      eventUiBases: props.eventUiBases,
      dateSelection: props.dateSelection,
      eventSelection: props.eventSelection,
      eventDrag: props.eventDrag,
      eventResize: props.eventResize,
      isHeightAuto: props.isHeightAuto,
      forPrint: props.forPrint
    };
    let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
    for (let transformer of transformers) {
      Object.assign(viewProps, transformer.transform(viewProps, props));
    }
    let ViewComponent = viewSpec.component;
    return y(ViewComponent, Object.assign({}, viewProps));
  }
};
function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
  let todayInfo = dateProfileGenerator.build(now, void 0, false);
  let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
  let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
  return {
    title,
    activeButton: viewSpec.type,
    navUnit: viewSpec.singleUnit,
    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
    isPrevEnabled: prevInfo.isValid,
    isNextEnabled: nextInfo.isValid
  };
}
function buildViewPropTransformers(theClasses) {
  return theClasses.map((TheClass) => new TheClass());
}
var Calendar = class extends CalendarImpl {
  constructor(el, optionOverrides = {}) {
    super();
    this.isRendering = false;
    this.isRendered = false;
    this.currentClassNames = [];
    this.customContentRenderId = 0;
    this.handleAction = (action) => {
      switch (action.type) {
        case "SET_EVENT_DRAG":
        case "SET_EVENT_RESIZE":
          this.renderRunner.tryDrain();
      }
    };
    this.handleData = (data) => {
      this.currentData = data;
      this.renderRunner.request(data.calendarOptions.rerenderDelay);
    };
    this.handleRenderRequest = () => {
      if (this.isRendering) {
        this.isRendered = true;
        let { currentData } = this;
        flushSync(() => {
          D(y(CalendarRoot, { options: currentData.calendarOptions, theme: currentData.theme, emitter: currentData.emitter }, (classNames, height, isHeightAuto, forPrint) => {
            this.setClassNames(classNames);
            this.setHeight(height);
            return y(
              RenderId.Provider,
              { value: this.customContentRenderId },
              y(CalendarContent, Object.assign({ isHeightAuto, forPrint }, currentData))
            );
          }), this.el);
        });
      } else if (this.isRendered) {
        this.isRendered = false;
        D(null, this.el);
        this.setClassNames([]);
        this.setHeight("");
      }
    };
    ensureElHasStyles(el);
    this.el = el;
    this.renderRunner = new DelayedRunner(this.handleRenderRequest);
    new CalendarDataManager({
      optionOverrides,
      calendarApi: this,
      onAction: this.handleAction,
      onData: this.handleData
    });
  }
  render() {
    let wasRendering = this.isRendering;
    if (!wasRendering) {
      this.isRendering = true;
    } else {
      this.customContentRenderId += 1;
    }
    this.renderRunner.request();
    if (wasRendering) {
      this.updateSize();
    }
  }
  destroy() {
    if (this.isRendering) {
      this.isRendering = false;
      this.renderRunner.request();
    }
  }
  updateSize() {
    flushSync(() => {
      super.updateSize();
    });
  }
  batchRendering(func) {
    this.renderRunner.pause("batchRendering");
    func();
    this.renderRunner.resume("batchRendering");
  }
  pauseRendering() {
    this.renderRunner.pause("pauseRendering");
  }
  resumeRendering() {
    this.renderRunner.resume("pauseRendering", true);
  }
  resetOptions(optionOverrides, changedOptionNames) {
    this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);
  }
  setClassNames(classNames) {
    if (!isArraysEqual(classNames, this.currentClassNames)) {
      let { classList } = this.el;
      for (let className of this.currentClassNames) {
        classList.remove(className);
      }
      for (let className of classNames) {
        classList.add(className);
      }
      this.currentClassNames = classNames;
    }
  }
  setHeight(height) {
    applyStyleProp(this.el, "height", height);
  }
};

// node_modules/@fullcalendar/angular/fesm2020/fullcalendar-angular.mjs
var _c02 = ["*"];
var _c1 = ["rootEl"];
var _c2 = (a0) => ({
  $implicit: a0
});
function TransportContainerComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2, 0);
    \u0275\u0275elementContainer(2, 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", ctx_r0.elClasses || "")("ngStyle", ctx_r0.elStyle || null);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c2, ctx_r0.renderProps));
  }
}
function TransportContainerComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 2, 0);
    \u0275\u0275elementContainer(2, 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", ctx_r0.elClasses || "")("ngStyle", ctx_r0.elStyle || null);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c2, ctx_r0.renderProps));
  }
}
function TransportContainerComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 2, 0);
    \u0275\u0275elementContainer(2, 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", ctx_r0.elClasses || "")("ngStyle", ctx_r0.elStyle || null);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c2, ctx_r0.renderProps));
  }
}
function TransportContainerComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 2, 0);
    \u0275\u0275elementContainer(2, 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", ctx_r0.elClasses || "")("ngStyle", ctx_r0.elStyle || null);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c2, ctx_r0.renderProps));
  }
}
function TransportContainerComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "th", 2, 0);
    \u0275\u0275elementContainer(2, 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", ctx_r0.elClasses || "")("ngStyle", ctx_r0.elStyle || null);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c2, ctx_r0.renderProps));
  }
}
function TransportContainerComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "td", 2, 0);
    \u0275\u0275elementContainer(2, 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", ctx_r0.elClasses || "")("ngStyle", ctx_r0.elStyle || null);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c2, ctx_r0.renderProps));
  }
}
var _c3 = ["dayHeaderContent"];
var _c4 = ["dayCellContent"];
var _c5 = ["weekNumberContent"];
var _c6 = ["nowIndicatorContent"];
var _c7 = ["eventContent"];
var _c8 = ["slotLaneContent"];
var _c9 = ["slotLabelContent"];
var _c10 = ["allDayContent"];
var _c11 = ["moreLinkContent"];
var _c12 = ["noEventsContent"];
var _c13 = ["resourceAreaHeaderContent"];
var _c14 = ["resourceGroupLabelContent"];
var _c15 = ["resourceLabelContent"];
var _c16 = ["resourceLaneContent"];
var _c17 = ["resourceGroupLaneContent"];
function FullCalendarComponent_transport_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "transport-container", 1);
  }
  if (rf & 2) {
    const customRendering_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("inPlaceOf", customRendering_r1.containerEl)("reportEl", customRendering_r1.reportNewContainerEl)("elTag", customRendering_r1.elTag)("elClasses", customRendering_r1.elClasses)("elStyle", customRendering_r1.elStyle)("elAttrs", customRendering_r1.elAttrs)("template", ctx_r1.templateMap[customRendering_r1.generatorName])("renderProps", customRendering_r1.renderProps);
  }
}
var OPTION_IS_DEEP = {
  headerToolbar: true,
  footerToolbar: true,
  events: true,
  eventSources: true,
  resources: true
};
var OPTION_INPUT_NAMES = ["events", "eventSources", "resources"];
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
function deepCopy(input2) {
  if (Array.isArray(input2)) {
    return input2.map(deepCopy);
  } else if (input2 instanceof Date) {
    return new Date(input2.valueOf());
  } else if (typeof input2 === "object" && input2) {
    return mapHash2(input2, deepCopy);
  } else {
    return input2;
  }
}
function mapHash2(input2, func) {
  const output = {};
  for (const key in input2) {
    if (hasOwnProperty2.call(input2, key)) {
      output[key] = func(input2[key], key);
    }
  }
  return output;
}
function deepEqual(a3, b3) {
  if (a3 === b3) return true;
  if (a3 && b3 && typeof a3 == "object" && typeof b3 == "object") {
    if (a3.constructor !== b3.constructor) return false;
    var length, i3, keys;
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length != b3.length) return false;
      for (i3 = length; i3-- !== 0; ) if (!deepEqual(a3[i3], b3[i3])) return false;
      return true;
    }
    if (a3.constructor === RegExp) return a3.source === b3.source && a3.flags === b3.flags;
    if (a3.valueOf !== Object.prototype.valueOf) return a3.valueOf() === b3.valueOf();
    if (a3.toString !== Object.prototype.toString) return a3.toString() === b3.toString();
    keys = Object.keys(a3);
    length = keys.length;
    if (length !== Object.keys(b3).length) return false;
    for (i3 = length; i3-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b3, keys[i3])) return false;
    for (i3 = length; i3-- !== 0; ) {
      var key = keys[i3];
      if (!deepEqual(a3[key], b3[key])) return false;
    }
    return true;
  }
  return a3 !== a3 && b3 !== b3;
}
var dummyContainer$1 = typeof document !== "undefined" ? document.createDocumentFragment() : null;
var OffscreenFragmentComponent = class {
  constructor(element) {
    this.element = element;
  }
  ngAfterViewInit() {
    if (dummyContainer$1) {
      dummyContainer$1.appendChild(this.element.nativeElement);
    }
  }
  // invoked BEFORE component removed from DOM
  ngOnDestroy() {
    if (dummyContainer$1) {
      dummyContainer$1.removeChild(this.element.nativeElement);
    }
  }
};
OffscreenFragmentComponent.\u0275fac = function OffscreenFragmentComponent_Factory(t3) {
  return new (t3 || OffscreenFragmentComponent)(\u0275\u0275directiveInject(ElementRef));
};
OffscreenFragmentComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: OffscreenFragmentComponent,
  selectors: [["offscreen-fragment"]],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function OffscreenFragmentComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OffscreenFragmentComponent, [{
    type: Component,
    args: [{
      selector: "offscreen-fragment",
      template: "<ng-content></ng-content>",
      encapsulation: ViewEncapsulation$1.None
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var dummyContainer = typeof document !== "undefined" ? document.createDocumentFragment() : null;
var TransportContainerComponent = class {
  ngAfterViewInit() {
    const rootEl = this.rootElRef?.nativeElement;
    replaceEl(rootEl, this.inPlaceOf);
    applyElAttrs(rootEl, void 0, this.elAttrs);
    this.inPlaceOf.style.display = "none";
    this.reportEl(rootEl);
  }
  ngOnChanges(changes) {
    const rootEl = this.rootElRef?.nativeElement;
    if (rootEl) {
      if (this.inPlaceOf.parentNode !== dummyContainer) {
        replaceEl(rootEl, this.inPlaceOf);
        applyElAttrs(rootEl, void 0, this.elAttrs);
        this.reportEl(rootEl);
      } else {
        const elAttrsChange = changes["elAttrs"];
        if (elAttrsChange) {
          applyElAttrs(rootEl, elAttrsChange.previousValue, elAttrsChange.currentValue);
        }
      }
    }
  }
  // invoked BEFORE component removed from DOM
  ngOnDestroy() {
    if (
      // protect against Preact recreating and rerooting inPlaceOf element
      this.inPlaceOf.parentNode === dummyContainer && dummyContainer
    ) {
      dummyContainer.removeChild(this.inPlaceOf);
    }
    this.reportEl(null);
  }
};
TransportContainerComponent.\u0275fac = function TransportContainerComponent_Factory(t3) {
  return new (t3 || TransportContainerComponent)();
};
TransportContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: TransportContainerComponent,
  selectors: [["transport-container"]],
  viewQuery: function TransportContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c1, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.rootElRef = _t.first);
    }
  },
  inputs: {
    inPlaceOf: "inPlaceOf",
    reportEl: "reportEl",
    elTag: "elTag",
    elClasses: "elClasses",
    elStyle: "elStyle",
    elAttrs: "elAttrs",
    template: "template",
    renderProps: "renderProps"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 6,
  vars: 6,
  consts: [["rootEl", ""], [3, "ngIf"], [3, "ngClass", "ngStyle"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function TransportContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, TransportContainerComponent_ng_template_0_Template, 3, 6, "ng-template", 1)(1, TransportContainerComponent_ng_template_1_Template, 3, 6, "ng-template", 1)(2, TransportContainerComponent_ng_template_2_Template, 3, 6, "ng-template", 1)(3, TransportContainerComponent_ng_template_3_Template, 3, 6, "ng-template", 1)(4, TransportContainerComponent_ng_template_4_Template, 3, 6, "ng-template", 1)(5, TransportContainerComponent_ng_template_5_Template, 3, 6, "ng-template", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.elTag == "div");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.elTag == "span");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.elTag == "a");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.elTag == "tr");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.elTag == "th");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.elTag == "td");
    }
  },
  dependencies: [NgIf, NgClass, NgStyle, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TransportContainerComponent, [{
    type: Component,
    args: [{
      selector: "transport-container",
      encapsulation: ViewEncapsulation$1.None,
      template: `<ng-template [ngIf]="elTag == 'div'">
  <div #rootEl [ngClass]="elClasses || ''" [ngStyle]="elStyle || null">
    <ng-container
      [ngTemplateOutlet]="template"
      [ngTemplateOutletContext]="{ $implicit: renderProps }"
    ></ng-container>
  </div>
</ng-template>
<ng-template [ngIf]="elTag == 'span'">
  <span #rootEl [ngClass]="elClasses || ''" [ngStyle]="elStyle || null">
    <ng-container
      [ngTemplateOutlet]="template"
      [ngTemplateOutletContext]="{ $implicit: renderProps }"
    ></ng-container>
  </span>
</ng-template>
<ng-template [ngIf]="elTag == 'a'">
  <a #rootEl [ngClass]="elClasses || ''" [ngStyle]="elStyle || null">
    <ng-container
      [ngTemplateOutlet]="template"
      [ngTemplateOutletContext]="{ $implicit: renderProps }"
    ></ng-container>
  </a>
</ng-template>
<ng-template [ngIf]="elTag == 'tr'">
  <tr #rootEl [ngClass]="elClasses || ''" [ngStyle]="elStyle || null">
    <ng-container
      [ngTemplateOutlet]="template"
      [ngTemplateOutletContext]="{ $implicit: renderProps }"
    ></ng-container>
  </tr>
</ng-template>
<ng-template [ngIf]="elTag == 'th'">
  <th #rootEl [ngClass]="elClasses || ''" [ngStyle]="elStyle || null">
    <ng-container
      [ngTemplateOutlet]="template"
      [ngTemplateOutletContext]="{ $implicit: renderProps }"
    ></ng-container>
  </th>
</ng-template>
<ng-template [ngIf]="elTag == 'td'">
  <td #rootEl [ngClass]="elClasses || ''" [ngStyle]="elStyle || null">
    <ng-container
      [ngTemplateOutlet]="template"
      [ngTemplateOutletContext]="{ $implicit: renderProps }"
    ></ng-container>
  </td>
</ng-template>
`
    }]
  }], null, {
    inPlaceOf: [{
      type: Input
    }],
    reportEl: [{
      type: Input
    }],
    elTag: [{
      type: Input
    }],
    elClasses: [{
      type: Input
    }],
    elStyle: [{
      type: Input
    }],
    elAttrs: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    renderProps: [{
      type: Input
    }],
    rootElRef: [{
      type: ViewChild,
      args: ["rootEl"]
    }]
  });
})();
function replaceEl(subject, inPlaceOf) {
  inPlaceOf.parentNode?.insertBefore(subject, inPlaceOf.nextSibling);
  if (dummyContainer) {
    dummyContainer.appendChild(inPlaceOf);
  }
}
function applyElAttrs(el, previousAttrs = {}, currentAttrs = {}) {
  for (const attrName in previousAttrs) {
    if (!(attrName in currentAttrs)) {
      el[attrName] = null;
    }
  }
  for (const attrName in currentAttrs) {
    el[attrName] = currentAttrs[attrName];
  }
}
var FullCalendarComponent = class {
  constructor(element, changeDetector) {
    this.element = element;
    this.calendar = null;
    this.optionSnapshot = {};
    this.customRenderingMap = /* @__PURE__ */ new Map();
    this.templateMap = {};
    const customRenderingStore = new CustomRenderingStore();
    customRenderingStore.subscribe((customRenderingMap) => {
      this.customRenderingMap = customRenderingMap;
      this.customRenderingArray = void 0;
      changeDetector.detectChanges();
    });
    this.handleCustomRendering = customRenderingStore.handle.bind(customRenderingStore);
    this.templateMap = this;
  }
  ngAfterViewInit() {
    const {
      deepChangeDetection
    } = this;
    const options = __spreadValues(__spreadValues({}, this.options), this.buildInputOptions());
    this.optionSnapshot = mapHash2(options, (optionVal, optionName) => deepChangeDetection && OPTION_IS_DEEP[optionName] ? deepCopy(optionVal) : optionVal);
    const calendarEl = this.element.nativeElement;
    const calendar = this.calendar = new Calendar(calendarEl, __spreadValues(__spreadValues({}, options), this.buildExtraOptions()));
    const ionContent = calendarEl.closest("ion-content");
    if (ionContent && ionContent.componentOnReady) {
      ionContent.componentOnReady().then(() => {
        window.requestAnimationFrame(() => {
          calendar.render();
        });
      });
    } else {
      calendar.render();
    }
  }
  /*
  allows us to manually detect complex input changes, internal mutations to certain options.
  called before ngOnChanges. called much more often than ngOnChanges.
  */
  ngDoCheck() {
    if (this.calendar) {
      const {
        deepChangeDetection,
        optionSnapshot
      } = this;
      const newOptions = __spreadValues(__spreadValues({}, this.options), this.buildInputOptions());
      const newProcessedOptions = {};
      const changedOptionNames = [];
      for (const optionName in newOptions) {
        if (newOptions.hasOwnProperty(optionName)) {
          let optionVal = newOptions[optionName];
          if (deepChangeDetection && OPTION_IS_DEEP[optionName]) {
            if (!deepEqual(optionSnapshot[optionName], optionVal)) {
              optionSnapshot[optionName] = deepCopy(optionVal);
              changedOptionNames.push(optionName);
            }
          } else {
            if (optionSnapshot[optionName] !== optionVal) {
              optionSnapshot[optionName] = optionVal;
              changedOptionNames.push(optionName);
            }
          }
          newProcessedOptions[optionName] = optionVal;
        }
      }
      const oldOptionNames = Object.keys(optionSnapshot);
      for (const optionName of oldOptionNames) {
        if (!(optionName in newOptions)) {
          delete optionSnapshot[optionName];
          changedOptionNames.push(optionName);
        }
      }
      if (changedOptionNames.length) {
        this.calendar.pauseRendering();
        this.calendar.resetOptions(__spreadValues(__spreadValues({}, newProcessedOptions), this.buildExtraOptions()), changedOptionNames);
      }
    }
  }
  ngAfterContentChecked() {
    if (this.calendar) {
      this.calendar.resumeRendering();
    }
  }
  ngOnDestroy() {
    if (this.calendar) {
      this.calendar.destroy();
      this.calendar = null;
    }
  }
  get customRenderings() {
    return this.customRenderingArray || (this.customRenderingArray = [...this.customRenderingMap.values()]);
  }
  getApi() {
    return this.calendar;
  }
  buildInputOptions() {
    const options = {};
    for (const inputName of OPTION_INPUT_NAMES) {
      const inputValue = this[inputName];
      if (inputValue != null) {
        options[inputName] = inputValue;
      }
    }
    return options;
  }
  buildExtraOptions() {
    return {
      handleCustomRendering: this.handleCustomRendering,
      customRenderingMetaMap: this.templateMap,
      customRenderingReplaces: true
    };
  }
  // for `trackBy` in loop
  trackCustomRendering(index3, customRendering) {
    return customRendering.id;
  }
};
FullCalendarComponent.\u0275fac = function FullCalendarComponent_Factory(t3) {
  return new (t3 || FullCalendarComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef));
};
FullCalendarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: FullCalendarComponent,
  selectors: [["full-calendar"]],
  contentQueries: function FullCalendarComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c3, 7);
      \u0275\u0275contentQuery(dirIndex, _c4, 7);
      \u0275\u0275contentQuery(dirIndex, _c5, 7);
      \u0275\u0275contentQuery(dirIndex, _c6, 7);
      \u0275\u0275contentQuery(dirIndex, _c7, 7);
      \u0275\u0275contentQuery(dirIndex, _c8, 7);
      \u0275\u0275contentQuery(dirIndex, _c9, 7);
      \u0275\u0275contentQuery(dirIndex, _c10, 7);
      \u0275\u0275contentQuery(dirIndex, _c11, 7);
      \u0275\u0275contentQuery(dirIndex, _c12, 7);
      \u0275\u0275contentQuery(dirIndex, _c13, 7);
      \u0275\u0275contentQuery(dirIndex, _c14, 7);
      \u0275\u0275contentQuery(dirIndex, _c15, 7);
      \u0275\u0275contentQuery(dirIndex, _c16, 7);
      \u0275\u0275contentQuery(dirIndex, _c17, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.dayHeaderContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.dayCellContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.weekNumberContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nowIndicatorContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.eventContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.slotLaneContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.slotLabelContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.allDayContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.moreLinkContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.noEventsContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.resourceAreaHeaderContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.resourceGroupLabelContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.resourceLabelContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.resourceLaneContent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.resourceGroupLaneContent = _t.first);
    }
  },
  inputs: {
    options: "options",
    deepChangeDetection: "deepChangeDetection",
    events: "events",
    eventSources: "eventSources",
    resources: "resources"
  },
  decls: 2,
  vars: 2,
  consts: [[3, "inPlaceOf", "reportEl", "elTag", "elClasses", "elStyle", "elAttrs", "template", "renderProps", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "inPlaceOf", "reportEl", "elTag", "elClasses", "elStyle", "elAttrs", "template", "renderProps"]],
  template: function FullCalendarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "offscreen-fragment");
      \u0275\u0275template(1, FullCalendarComponent_transport_container_1_Template, 1, 8, "transport-container", 0);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.customRenderings)("ngForTrackBy", ctx.trackCustomRendering);
    }
  },
  dependencies: [OffscreenFragmentComponent, TransportContainerComponent, NgForOf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FullCalendarComponent, [{
    type: Component,
    args: [{
      selector: "full-calendar",
      encapsulation: ViewEncapsulation$1.None,
      template: '<offscreen-fragment>\n  <transport-container *ngFor="let customRendering of customRenderings; trackBy:trackCustomRendering"\n    [inPlaceOf]="customRendering.containerEl"\n    [reportEl]="customRendering.reportNewContainerEl"\n    [elTag]="customRendering.elTag"\n    [elClasses]="customRendering.elClasses"\n    [elStyle]="customRendering.elStyle"\n    [elAttrs]="customRendering.elAttrs"\n    [template]="templateMap[customRendering.generatorName]!"\n    [renderProps]="customRendering.renderProps"\n  ></transport-container>\n</offscreen-fragment>\n'
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    options: [{
      type: Input
    }],
    deepChangeDetection: [{
      type: Input
    }],
    events: [{
      type: Input
    }],
    eventSources: [{
      type: Input
    }],
    resources: [{
      type: Input
    }],
    dayHeaderContent: [{
      type: ContentChild,
      args: ["dayHeaderContent", {
        static: true
      }]
    }],
    dayCellContent: [{
      type: ContentChild,
      args: ["dayCellContent", {
        static: true
      }]
    }],
    weekNumberContent: [{
      type: ContentChild,
      args: ["weekNumberContent", {
        static: true
      }]
    }],
    nowIndicatorContent: [{
      type: ContentChild,
      args: ["nowIndicatorContent", {
        static: true
      }]
    }],
    eventContent: [{
      type: ContentChild,
      args: ["eventContent", {
        static: true
      }]
    }],
    slotLaneContent: [{
      type: ContentChild,
      args: ["slotLaneContent", {
        static: true
      }]
    }],
    slotLabelContent: [{
      type: ContentChild,
      args: ["slotLabelContent", {
        static: true
      }]
    }],
    allDayContent: [{
      type: ContentChild,
      args: ["allDayContent", {
        static: true
      }]
    }],
    moreLinkContent: [{
      type: ContentChild,
      args: ["moreLinkContent", {
        static: true
      }]
    }],
    noEventsContent: [{
      type: ContentChild,
      args: ["noEventsContent", {
        static: true
      }]
    }],
    resourceAreaHeaderContent: [{
      type: ContentChild,
      args: ["resourceAreaHeaderContent", {
        static: true
      }]
    }],
    resourceGroupLabelContent: [{
      type: ContentChild,
      args: ["resourceGroupLabelContent", {
        static: true
      }]
    }],
    resourceLabelContent: [{
      type: ContentChild,
      args: ["resourceLabelContent", {
        static: true
      }]
    }],
    resourceLaneContent: [{
      type: ContentChild,
      args: ["resourceLaneContent", {
        static: true
      }]
    }],
    resourceGroupLaneContent: [{
      type: ContentChild,
      args: ["resourceGroupLaneContent", {
        static: true
      }]
    }]
  });
})();
var FullCalendarModule = class {
};
FullCalendarModule.\u0275fac = function FullCalendarModule_Factory(t3) {
  return new (t3 || FullCalendarModule)();
};
FullCalendarModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: FullCalendarModule
});
FullCalendarModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [[CommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FullCalendarModule, [{
    type: NgModule,
    args: [{
      declarations: [FullCalendarComponent, OffscreenFragmentComponent, TransportContainerComponent],
      imports: [CommonModule],
      exports: [FullCalendarComponent]
    }]
  }], null, null);
})();

// node_modules/@fullcalendar/daygrid/internal.js
var TableView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.headerElRef = d();
  }
  renderSimpleLayout(headerRowContent, bodyContent) {
    let { props, context: context2 } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context2.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunk: { content: bodyContent }
    });
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context2.viewSpec },
      y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [], sections })
    );
  }
  renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { props, context: context2 } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context2.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context2.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunks: [{
          key: "main",
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }]
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunks: [{
        key: "main",
        content: bodyContent
      }]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [{
          key: "main",
          content: renderScrollShim
        }]
      });
    }
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context2.viewSpec },
      y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections })
    );
  }
};
function splitSegsByRow(segs, rowCnt) {
  let byRow = [];
  for (let i3 = 0; i3 < rowCnt; i3 += 1) {
    byRow[i3] = [];
  }
  for (let seg of segs) {
    byRow[seg.row].push(seg);
  }
  return byRow;
}
function splitSegsByFirstCol(segs, colCnt) {
  let byCol = [];
  for (let i3 = 0; i3 < colCnt; i3 += 1) {
    byCol[i3] = [];
  }
  for (let seg of segs) {
    byCol[seg.firstCol].push(seg);
  }
  return byCol;
}
function splitInteractionByRow(ui, rowCnt) {
  let byRow = [];
  if (!ui) {
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = null;
    }
  } else {
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (let seg of ui.segs) {
      byRow[seg.row].segs.push(seg);
    }
  }
  return byRow;
}
var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "narrow"
});
function hasListItemDisplay(seg) {
  let { display } = seg.eventRange.ui;
  return display === "list-item" || display === "auto" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day
  seg.isStart && // "
  seg.isEnd;
}
var TableBlockEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(StandardEvent, Object.assign({}, props, { elClasses: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay }));
  }
};
var TableListItemEvent = class extends BaseComponent {
  render() {
    let { props, context: context2 } = this;
    let { options } = context2;
    let { seg } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
    let timeText = buildSegTimeText(seg, timeFormat, context2, true, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elClasses: ["fc-daygrid-event", "fc-daygrid-dot-event"], elAttrs: getSegAnchorAttrs(props.seg, context2), defaultGenerator: renderInnerContent2, timeText, isResizing: false, isDateSelecting: false }));
  }
};
function renderInnerContent2(renderProps) {
  return y(
    _,
    null,
    y("div", { className: "fc-daygrid-event-dot", style: { borderColor: renderProps.borderColor || renderProps.backgroundColor } }),
    renderProps.timeText && y("div", { className: "fc-event-time" }, renderProps.timeText),
    y("div", { className: "fc-event-title" }, renderProps.event.title || y(_, null, "\xA0"))
  );
}
var TableCellMoreLink = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.compileSegs = memoize(compileSegs);
  }
  render() {
    let { props } = this;
    let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);
    return y(MoreLinkContainer, { elClasses: ["fc-daygrid-more-link"], dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: () => {
      let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
      return y(_, null, allSegs.map((seg) => {
        let instanceId = seg.eventRange.instance.instanceId;
        return y("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
          visibility: isForcedInvisible[instanceId] ? "hidden" : ""
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))));
      }));
    } });
  }
};
function compileSegs(singlePlacements) {
  let allSegs = [];
  let invisibleSegs = [];
  for (let placement of singlePlacements) {
    allSegs.push(placement.seg);
    if (!placement.isVisible) {
      invisibleSegs.push(placement.seg);
    }
  }
  return { allSegs, invisibleSegs };
}
var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: "narrow" });
var TableCell = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.state = {
      dayNumberId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      setRef(this.rootElRef, el);
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { context: context2, props, state, rootElRef } = this;
    let { options, dateEnv } = context2;
    let { date, dateProfile } = props;
    const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);
    return y(DayCellContainer, { elTag: "td", elRef: this.handleRootEl, elClasses: [
      "fc-daygrid-day",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? { "aria-labelledby": state.dayNumberId } : {}), { role: "gridcell" }), defaultGenerator: renderTopInner, date, dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, isMonthStart, extraRenderProps: props.extraRenderProps }, (InnerContent, renderProps) => y(
      "div",
      { ref: props.innerElRef, className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", style: { minHeight: props.minHeight } },
      props.showWeekNumber && y(WeekNumberContainer, { elTag: "a", elClasses: ["fc-daygrid-week-number"], elAttrs: buildNavLinkAttrs(context2, date, "week"), date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }),
      !renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? y(
        "div",
        { className: "fc-daygrid-day-top" },
        y(InnerContent, { elTag: "a", elClasses: [
          "fc-daygrid-day-number",
          isMonthStart && "fc-daygrid-month-start"
        ], elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context2, date)), { id: state.dayNumberId }) })
      ) : props.showDayNumber ? (
        // for creating correct amount of space (see issue #7162)
        y(
          "div",
          { className: "fc-daygrid-day-top", style: { visibility: "hidden" } },
          y("a", { className: "fc-daygrid-day-number" }, "\xA0")
        )
      ) : void 0,
      y(
        "div",
        { className: "fc-daygrid-day-events", ref: props.fgContentElRef },
        props.fgContent,
        y(
          "div",
          { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } },
          y(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange })
        )
      ),
      y("div", { className: "fc-daygrid-day-bg" }, props.bgContent)
    ));
  }
};
function renderTopInner(props) {
  return props.dayNumberText || y(_, null, "\xA0");
}
function shouldDisplayMonthStart(date, currentRange, dateEnv) {
  const { start: currentStart, end: currentEnd } = currentRange;
  const currentEndIncl = addMs(currentEnd, -1);
  const currentFirstYear = dateEnv.getYear(currentStart);
  const currentFirstMonth = dateEnv.getMonth(currentStart);
  const currentLastYear = dateEnv.getYear(currentEndIncl);
  const currentLastMonth = dateEnv.getMonth(currentEndIncl);
  return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(
    // first date in current view?
    date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?
    dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf()
  );
}
function generateSegKey(seg) {
  return seg.eventRange.instance.instanceId + ":" + seg.firstCol;
}
function generateSegUid(seg) {
  return generateSegKey(seg) + ":" + seg.lastCol;
}
function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {
  let hierarchy = new DayGridSegHierarchy((segEntry) => {
    let segUid = segs[segEntry.index].eventRange.instance.instanceId + ":" + segEntry.span.start + ":" + (segEntry.span.end - 1);
    return segHeights[segUid] || 1;
  });
  hierarchy.allowReslicing = true;
  hierarchy.strictOrder = strictOrder;
  if (dayMaxEvents === true || dayMaxEventRows === true) {
    hierarchy.maxCoord = maxContentHeight;
    hierarchy.hiddenConsumes = true;
  } else if (typeof dayMaxEvents === "number") {
    hierarchy.maxStackCnt = dayMaxEvents;
  } else if (typeof dayMaxEventRows === "number") {
    hierarchy.maxStackCnt = dayMaxEventRows;
    hierarchy.hiddenConsumes = true;
  }
  let segInputs = [];
  let unknownHeightSegs = [];
  for (let i3 = 0; i3 < segs.length; i3 += 1) {
    let seg = segs[i3];
    let segUid = generateSegUid(seg);
    let eventHeight = segHeights[segUid];
    if (eventHeight != null) {
      segInputs.push({
        index: i3,
        span: {
          start: seg.firstCol,
          end: seg.lastCol + 1
        }
      });
    } else {
      unknownHeightSegs.push(seg);
    }
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let segRects = hierarchy.toRects();
  let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);
  let moreCnts = [];
  let moreMarginTops = [];
  for (let seg of unknownHeightSegs) {
    multiColPlacements[seg.firstCol].push({
      seg,
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = seg.firstCol; col <= seg.lastCol; col += 1) {
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreCnts.push(0);
  }
  for (let hiddenEntry of hiddenEntries) {
    let seg = segs[hiddenEntry.index];
    let hiddenSpan = hiddenEntry.span;
    multiColPlacements[hiddenSpan.start].push({
      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
      moreCnts[col] += 1;
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreMarginTops.push(leftoverMargins[col]);
  }
  return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };
}
function placeRects(allRects, segs, cells) {
  let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
  let singleColPlacements = [];
  let multiColPlacements = [];
  let leftoverMargins = [];
  for (let col = 0; col < cells.length; col += 1) {
    let rects = rectsByEachCol[col];
    let singlePlacements = [];
    let currentHeight = 0;
    let currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      singlePlacements.push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: true,
        isAbsolute: false,
        absoluteTop: rect.levelCoord,
        marginTop: rect.levelCoord - currentHeight
      });
      currentHeight = rect.levelCoord + rect.thickness;
    }
    let multiPlacements = [];
    currentHeight = 0;
    currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      let isAbsolute = rect.span.end - rect.span.start > 1;
      let isFirstCol = rect.span.start === col;
      currentMarginTop += rect.levelCoord - currentHeight;
      currentHeight = rect.levelCoord + rect.thickness;
      if (isAbsolute) {
        currentMarginTop += rect.thickness;
        if (isFirstCol) {
          multiPlacements.push({
            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
            isVisible: true,
            isAbsolute: true,
            absoluteTop: rect.levelCoord,
            marginTop: 0
          });
        }
      } else if (isFirstCol) {
        multiPlacements.push({
          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
          isVisible: true,
          isAbsolute: false,
          absoluteTop: rect.levelCoord,
          marginTop: currentMarginTop
          // claim the margin
        });
        currentMarginTop = 0;
      }
    }
    singleColPlacements.push(singlePlacements);
    multiColPlacements.push(multiPlacements);
    leftoverMargins.push(currentMarginTop);
  }
  return { singleColPlacements, multiColPlacements, leftoverMargins };
}
function groupRectsByEachCol(rects, colCnt) {
  let rectsByEachCol = [];
  for (let col = 0; col < colCnt; col += 1) {
    rectsByEachCol.push([]);
  }
  for (let rect of rects) {
    for (let col = rect.span.start; col < rect.span.end; col += 1) {
      rectsByEachCol[col].push(rect);
    }
  }
  return rectsByEachCol;
}
function resliceSeg(seg, spanStart, spanEnd, cells) {
  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
    return seg;
  }
  let eventRange = seg.eventRange;
  let origRange = eventRange.range;
  let slicedRange = intersectRanges(origRange, {
    start: cells[spanStart].date,
    end: addDays(cells[spanEnd - 1].date, 1)
  });
  return Object.assign(Object.assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
    def: eventRange.def,
    ui: Object.assign(Object.assign({}, eventRange.ui), { durationEditable: false }),
    instance: eventRange.instance,
    range: slicedRange
  }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
}
var DayGridSegHierarchy = class extends SegHierarchy {
  constructor() {
    super(...arguments);
    this.hiddenConsumes = false;
    this.forceHidden = {};
  }
  addSegs(segInputs) {
    const hiddenSegs = super.addSegs(segInputs);
    const { entriesByLevel } = this;
    const excludeHidden = (entry) => !this.forceHidden[buildEntryKey(entry)];
    for (let level = 0; level < entriesByLevel.length; level += 1) {
      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
    }
    return hiddenSegs;
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    const { entriesByLevel, forceHidden } = this;
    const { touchingEntry, touchingLevel, touchingLateral } = insertion;
    if (this.hiddenConsumes && touchingEntry) {
      const touchingEntryId = buildEntryKey(touchingEntry);
      if (!forceHidden[touchingEntryId]) {
        if (this.allowReslicing) {
          const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
          const hiddenEntryId = buildEntryKey(hiddenEntry);
          forceHidden[hiddenEntryId] = true;
          entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;
          hiddenEntries.push(hiddenEntry);
          this.splitEntry(touchingEntry, entry, hiddenEntries);
        } else {
          forceHidden[touchingEntryId] = true;
          hiddenEntries.push(touchingEntry);
        }
      }
    }
    super.handleInvalidInsertion(insertion, entry, hiddenEntries);
  }
};
var TableRow = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.cellElRefs = new RefMap();
    this.frameElRefs = new RefMap();
    this.fgElRefs = new RefMap();
    this.segHarnessRefs = new RefMap();
    this.rootElRef = d();
    this.state = {
      framePositions: null,
      maxContentHeight: null,
      segHeights: {}
    };
    this.handleResize = (isForced) => {
      if (isForced) {
        this.updateSizing(true);
      }
    };
  }
  render() {
    let { props, state, context: context2 } = this;
    let { options } = context2;
    let colCnt = props.cells.length;
    let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
    let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
    let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
    let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
    let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);
    let isForcedInvisible = (
      // TODO: messy way to compute this
      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
    );
    return y(
      "tr",
      { ref: this.rootElRef, role: "row" },
      props.renderIntro && props.renderIntro(),
      props.cells.map((cell, col) => {
        let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
        let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
        return y(TableCell, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), innerElRef: this.frameElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: this.fgElRefs.createRef(cell.key), fgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            y(_, null, normalFgNodes),
            y(_, null, mirrorFgNodes)
          )
        ), bgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            this.renderFillSegs(highlightSegsByCol[col], "highlight"),
            this.renderFillSegs(businessHoursByCol[col], "non-business"),
            this.renderFillSegs(bgEventSegsByCol[col], "bg-event")
          )
        ), minHeight: props.cellMinHeight });
      })
    );
  }
  componentDidMount() {
    this.updateSizing(true);
    this.context.addResizeHandler(this.handleResize);
  }
  componentDidUpdate(prevProps, prevState) {
    let currentProps = this.props;
    this.updateSizing(!isPropsEqual(prevProps, currentProps));
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  getHighlightSegs() {
    let { props } = this;
    if (props.eventDrag && props.eventDrag.segs.length) {
      return props.eventDrag.segs;
    }
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return props.dateSelectionSegs;
  }
  getMirrorSegs() {
    let { props } = this;
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return [];
  }
  renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    let { context: context2 } = this;
    let { eventSelection } = this.props;
    let { framePositions } = this.state;
    let defaultDisplayEventEnd = this.props.cells.length === 1;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let nodes = [];
    if (framePositions) {
      for (let placement of segPlacements) {
        let { seg } = placement;
        let { instanceId } = seg.eventRange.instance;
        let isVisible = placement.isVisible && !isForcedInvisible[instanceId];
        let isAbsolute = placement.isAbsolute;
        let left = "";
        let right = "";
        if (isAbsolute) {
          if (context2.isRtl) {
            right = 0;
            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
          } else {
            left = 0;
            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
          }
        }
        nodes.push(y("div", { className: "fc-daygrid-event-harness" + (isAbsolute ? " fc-daygrid-event-harness-abs" : ""), key: generateSegKey(seg), ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)), style: {
          visibility: isVisible ? "" : "hidden",
          marginTop: isAbsolute ? "" : placement.marginTop,
          top: isAbsolute ? placement.absoluteTop : "",
          left,
          right
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))));
      }
    }
    return nodes;
  }
  renderFillSegs(segs, fillType) {
    let { isRtl } = this.context;
    let { todayRange } = this.props;
    let { framePositions } = this.state;
    let nodes = [];
    if (framePositions) {
      for (let seg of segs) {
        let leftRightCss = isRtl ? {
          right: 0,
          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
        } : {
          left: 0,
          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
        };
        nodes.push(y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
      }
    }
    return y(_, {}, ...nodes);
  }
  updateSizing(isExternalSizingChange) {
    let { props, state, frameElRefs } = this;
    if (!props.forPrint && props.clientWidth !== null) {
      if (isExternalSizingChange) {
        let frameEls = props.cells.map((cell) => frameElRefs.currentMap[cell.key]);
        if (frameEls.length) {
          let originEl = this.rootElRef.current;
          let newPositionCache = new PositionCache(
            originEl,
            frameEls,
            true,
            // isHorizontal
            false
          );
          if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {
            this.setState({
              framePositions: new PositionCache(
                originEl,
                frameEls,
                true,
                // isHorizontal
                false
              )
            });
          }
        }
      }
      const oldSegHeights = this.state.segHeights;
      const newSegHeights = this.querySegHeights();
      const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
      this.safeSetState({
        // HACK to prevent oscillations of events being shown/hidden from max-event-rows
        // Essentially, once you compute an element's height, never null-out.
        // TODO: always display all events, as visibility:hidden?
        segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),
        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
      });
    }
  }
  querySegHeights() {
    let segElMap = this.segHarnessRefs.currentMap;
    let segHeights = {};
    for (let segUid in segElMap) {
      let height = Math.round(segElMap[segUid].getBoundingClientRect().height);
      segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);
    }
    return segHeights;
  }
  computeMaxContentHeight() {
    let firstKey = this.props.cells[0].key;
    let cellEl = this.cellElRefs.currentMap[firstKey];
    let fcContainerEl = this.fgElRefs.currentMap[firstKey];
    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
  }
  getCellEls() {
    let elMap = this.cellElRefs.currentMap;
    return this.props.cells.map((cell) => elMap[cell.key]);
  }
};
TableRow.addStateEquality({
  segHeights: isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, colPlacements) {
  if (!mirrorSegs.length) {
    return [];
  }
  let topsByInstanceId = buildAbsoluteTopHash(colPlacements);
  return mirrorSegs.map((seg) => ({
    seg,
    isVisible: true,
    isAbsolute: true,
    absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
    marginTop: 0
  }));
}
function buildAbsoluteTopHash(colPlacements) {
  let topsByInstanceId = {};
  for (let placements of colPlacements) {
    for (let placement of placements) {
      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
    }
  }
  return topsByInstanceId;
}
var TableRows = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.splitBusinessHourSegs = memoize(splitSegsByRow);
    this.splitBgEventSegs = memoize(splitSegsByRow);
    this.splitFgEventSegs = memoize(splitSegsByRow);
    this.splitDateSelectionSegs = memoize(splitSegsByRow);
    this.splitEventDrag = memoize(splitInteractionByRow);
    this.splitEventResize = memoize(splitInteractionByRow);
    this.rowRefs = new RefMap();
  }
  render() {
    let { props, context: context2 } = this;
    let rowCnt = props.cells.length;
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
    let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context2.options.aspectRatio / 6 : null;
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(_, null, props.cells.map((cells, row) => y(TableRow, {
      ref: this.rowRefs.createRef(row),
      key: cells.length ? cells[0].date.toISOString() : row,
      showDayNumbers: rowCnt > 1,
      showWeekNumbers: props.showWeekNumbers,
      todayRange,
      dateProfile: props.dateProfile,
      cells,
      renderIntro: props.renderRowIntro,
      businessHourSegs: businessHourSegsByRow[row],
      eventSelection: props.eventSelection,
      bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),
      fgEventSegs: fgEventSegsByRow[row],
      dateSelectionSegs: dateSelectionSegsByRow[row],
      eventDrag: eventDragByRow[row],
      eventResize: eventResizeByRow[row],
      dayMaxEvents: props.dayMaxEvents,
      dayMaxEventRows: props.dayMaxEventRows,
      clientWidth: props.clientWidth,
      clientHeight: props.clientHeight,
      cellMinHeight,
      forPrint: props.forPrint
    }))));
  }
  componentDidMount() {
    this.registerInteractiveComponent();
  }
  componentDidUpdate() {
    this.registerInteractiveComponent();
  }
  registerInteractiveComponent() {
    if (!this.rootEl) {
      const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];
      const rootEl = firstCellEl ? firstCellEl.closest(".fc-daygrid-body") : null;
      if (rootEl) {
        this.rootEl = rootEl;
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      }
    }
  }
  componentWillUnmount() {
    if (this.rootEl) {
      this.context.unregisterInteractiveComponent(this);
      this.rootEl = null;
    }
  }
  // Hit System
  // ----------------------------------------------------------------------------------------------------
  prepareHits() {
    this.rowPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.collect().map((rowObj) => rowObj.getCellEls()[0]),
      // first cell el in each row. TODO: not optimal
      false,
      true
    );
    this.colPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.currentMap[0].getCellEls(),
      // cell els in first row
      true,
      // horizontal
      false
    );
  }
  queryHit(positionLeft, positionTop) {
    let { colPositions, rowPositions } = this;
    let col = colPositions.leftToIndex(positionLeft);
    let row = rowPositions.topToIndex(positionTop);
    if (row != null && col != null) {
      let cell = this.props.cells[row][col];
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: Object.assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
        dayEl: this.getCellEl(row, col),
        rect: {
          left: colPositions.lefts[col],
          right: colPositions.rights[col],
          top: rowPositions.tops[row],
          bottom: rowPositions.bottoms[row]
        },
        layer: 0
      };
    }
    return null;
  }
  getCellEl(row, col) {
    return this.rowRefs.currentMap[row].getCellEls()[col];
  }
  getCellRange(row, col) {
    let start = this.props.cells[row][col].date;
    let end = addDays(start, 1);
    return { start, end };
  }
};
function isSegAllDay(seg) {
  return seg.eventRange.def.allDay;
}
var Table = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.elRef = d();
    this.needsScrollReset = false;
  }
  render() {
    let { props } = this;
    let { dayMaxEventRows, dayMaxEvents, expandRows } = props;
    let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
    if (limitViaBalanced && !expandRows) {
      limitViaBalanced = false;
      dayMaxEventRows = null;
      dayMaxEvents = null;
    }
    let classNames = [
      "fc-daygrid-body",
      limitViaBalanced ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced",
      expandRows ? "" : "fc-daygrid-body-natural"
      // will height of one row depend on the others?
    ];
    return y(
      "div",
      { ref: this.elRef, className: classNames.join(" "), style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      } },
      y(
        "table",
        { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
          width: props.clientWidth,
          minWidth: props.tableMinWidth,
          height: expandRows ? props.clientHeight : ""
        } },
        props.colGroupNode,
        y(
          "tbody",
          { role: "presentation" },
          y(TableRows, { dateProfile: props.dateProfile, cells: props.cells, renderRowIntro: props.renderRowIntro, showWeekNumbers: props.showWeekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, dayMaxEvents, dayMaxEventRows, forPrint: props.forPrint, isHitComboAllowed: props.isHitComboAllowed })
        )
      )
    );
  }
  componentDidMount() {
    this.requestScrollReset();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dateProfile !== this.props.dateProfile) {
      this.requestScrollReset();
    } else {
      this.flushScrollReset();
    }
  }
  requestScrollReset() {
    this.needsScrollReset = true;
    this.flushScrollReset();
  }
  flushScrollReset() {
    if (this.needsScrollReset && this.props.clientWidth) {
      const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);
      if (subjectEl) {
        const originEl = subjectEl.closest(".fc-daygrid-body");
        const scrollEl = originEl.closest(".fc-scroller");
        const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;
        scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0;
      }
      this.needsScrollReset = false;
    }
  }
};
function getScrollSubjectEl(containerEl, dateProfile) {
  let el;
  if (dateProfile.currentRangeUnit.match(/year|month/)) {
    el = containerEl.querySelector(`[data-date="${formatIsoMonthStr(dateProfile.currentDate)}-01"]`);
  }
  if (!el) {
    el = containerEl.querySelector(`[data-date="${formatDayString(dateProfile.currentDate)}"]`);
  }
  return el;
}
var DayTableSlicer = class extends Slicer {
  constructor() {
    super(...arguments);
    this.forceDayIfListItem = true;
  }
  sliceRange(dateRange, dayTableModel) {
    return dayTableModel.sliceRange(dateRange);
  }
};
var DayTable = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.slicer = new DayTableSlicer();
    this.tableRef = d();
  }
  render() {
    let { props, context: context2 } = this;
    return y(Table, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context2, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint }));
  }
};
var DayTableView = class extends TableView {
  constructor() {
    super(...arguments);
    this.buildDayTableModel = memoize(buildDayTableModel);
    this.headerRef = d();
    this.tableRef = d();
  }
  render() {
    let { options, dateProfileGenerator } = this.context;
    let { props } = this;
    let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
    let headerContent = options.dayHeaders && y(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 });
    let bodyContent = (contentArg) => y(DayTable, { ref: this.tableRef, dateProfile: props.dateProfile, dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint });
    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
  }
};
function buildDayTableModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
}
var TableDateProfileGenerator = class extends DateProfileGenerator {
  // Computes the date range that will be rendered
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);
    let { props } = this;
    return buildDayTableRenderRange({
      currentRange: renderRange,
      snapToWeek: /^(year|month)$/.test(currentRangeUnit),
      fixedWeekCount: props.fixedWeekCount,
      dateEnv: props.dateEnv
    });
  }
};
function buildDayTableRenderRange(props) {
  let { dateEnv, currentRange } = props;
  let { start, end } = currentRange;
  let endOfWeek;
  if (props.snapToWeek) {
    start = dateEnv.startOfWeek(start);
    endOfWeek = dateEnv.startOfWeek(end);
    if (endOfWeek.valueOf() !== end.valueOf()) {
      end = addWeeks(endOfWeek, 1);
    }
  }
  if (props.fixedWeekCount) {
    let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));
    let rowCnt = Math.ceil(
      // could be partial weeks due to hiddenDays
      diffWeeks(lastMonthRenderStart, end)
    );
    end = addWeeks(end, 6 - rowCnt);
  }
  return { start, end };
}
var css_248z2 = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:"";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:"";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';
injectStyles(css_248z2);

// node_modules/@fullcalendar/daygrid/index.js
var index = createPlugin({
  name: "@fullcalendar/daygrid",
  initialView: "dayGridMonth",
  views: {
    dayGrid: {
      component: DayTableView,
      dateProfileGeneratorClass: TableDateProfileGenerator
    },
    dayGridDay: {
      type: "dayGrid",
      duration: { days: 1 }
    },
    dayGridWeek: {
      type: "dayGrid",
      duration: { weeks: 1 }
    },
    dayGridMonth: {
      type: "dayGrid",
      duration: { months: 1 },
      fixedWeekCount: true
    },
    dayGridYear: {
      type: "dayGrid",
      duration: { years: 1 }
    }
  }
});

// node_modules/@fullcalendar/interaction/index.js
config2.touchMouseIgnoreWait = 500;
var ignoreMouseDepth = 0;
var listenerCnt = 0;
var isWindowTouchMoveCancelled = false;
var PointerDragging = class {
  constructor(containerEl) {
    this.subjectEl = null;
    this.selector = "";
    this.handleSelector = "";
    this.shouldIgnoreMove = false;
    this.shouldWatchScroll = true;
    this.isDragging = false;
    this.isTouchDragging = false;
    this.wasTouchScroll = false;
    this.handleMouseDown = (ev) => {
      if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {
        let pev = this.createEventFromMouse(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        if (!this.shouldIgnoreMove) {
          document.addEventListener("mousemove", this.handleMouseMove);
        }
        document.addEventListener("mouseup", this.handleMouseUp);
      }
    };
    this.handleMouseMove = (ev) => {
      let pev = this.createEventFromMouse(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleMouseUp = (ev) => {
      document.removeEventListener("mousemove", this.handleMouseMove);
      document.removeEventListener("mouseup", this.handleMouseUp);
      this.emitter.trigger("pointerup", this.createEventFromMouse(ev));
      this.cleanup();
    };
    this.handleTouchStart = (ev) => {
      if (this.tryStart(ev)) {
        this.isTouchDragging = true;
        let pev = this.createEventFromTouch(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        let targetEl = ev.target;
        if (!this.shouldIgnoreMove) {
          targetEl.addEventListener("touchmove", this.handleTouchMove);
        }
        targetEl.addEventListener("touchend", this.handleTouchEnd);
        targetEl.addEventListener("touchcancel", this.handleTouchEnd);
        window.addEventListener("scroll", this.handleTouchScroll, true);
      }
    };
    this.handleTouchMove = (ev) => {
      let pev = this.createEventFromTouch(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleTouchEnd = (ev) => {
      if (this.isDragging) {
        let targetEl = ev.target;
        targetEl.removeEventListener("touchmove", this.handleTouchMove);
        targetEl.removeEventListener("touchend", this.handleTouchEnd);
        targetEl.removeEventListener("touchcancel", this.handleTouchEnd);
        window.removeEventListener("scroll", this.handleTouchScroll, true);
        this.emitter.trigger("pointerup", this.createEventFromTouch(ev));
        this.cleanup();
        this.isTouchDragging = false;
        startIgnoringMouse();
      }
    };
    this.handleTouchScroll = () => {
      this.wasTouchScroll = true;
    };
    this.handleScroll = (ev) => {
      if (!this.shouldIgnoreMove) {
        let pageX = window.scrollX - this.prevScrollX + this.prevPageX;
        let pageY = window.scrollY - this.prevScrollY + this.prevPageY;
        this.emitter.trigger("pointermove", {
          origEvent: ev,
          isTouch: this.isTouchDragging,
          subjectEl: this.subjectEl,
          pageX,
          pageY,
          deltaX: pageX - this.origPageX,
          deltaY: pageY - this.origPageY
        });
      }
    };
    this.containerEl = containerEl;
    this.emitter = new Emitter();
    containerEl.addEventListener("mousedown", this.handleMouseDown);
    containerEl.addEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerCreated();
  }
  destroy() {
    this.containerEl.removeEventListener("mousedown", this.handleMouseDown);
    this.containerEl.removeEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerDestroyed();
  }
  tryStart(ev) {
    let subjectEl = this.querySubjectEl(ev);
    let downEl = ev.target;
    if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
      this.subjectEl = subjectEl;
      this.isDragging = true;
      this.wasTouchScroll = false;
      return true;
    }
    return false;
  }
  cleanup() {
    isWindowTouchMoveCancelled = false;
    this.isDragging = false;
    this.subjectEl = null;
    this.destroyScrollWatch();
  }
  querySubjectEl(ev) {
    if (this.selector) {
      return elementClosest(ev.target, this.selector);
    }
    return this.containerEl;
  }
  shouldIgnoreMouse() {
    return ignoreMouseDepth || this.isTouchDragging;
  }
  // can be called by user of this class, to cancel touch-based scrolling for the current drag
  cancelTouchScroll() {
    if (this.isDragging) {
      isWindowTouchMoveCancelled = true;
    }
  }
  // Scrolling that simulates pointermoves
  // ----------------------------------------------------------------------------------------------------
  initScrollWatch(ev) {
    if (this.shouldWatchScroll) {
      this.recordCoords(ev);
      window.addEventListener("scroll", this.handleScroll, true);
    }
  }
  recordCoords(ev) {
    if (this.shouldWatchScroll) {
      this.prevPageX = ev.pageX;
      this.prevPageY = ev.pageY;
      this.prevScrollX = window.scrollX;
      this.prevScrollY = window.scrollY;
    }
  }
  destroyScrollWatch() {
    if (this.shouldWatchScroll) {
      window.removeEventListener("scroll", this.handleScroll, true);
    }
  }
  // Event Normalization
  // ----------------------------------------------------------------------------------------------------
  createEventFromMouse(ev, isFirst) {
    let deltaX = 0;
    let deltaY = 0;
    if (isFirst) {
      this.origPageX = ev.pageX;
      this.origPageY = ev.pageY;
    } else {
      deltaX = ev.pageX - this.origPageX;
      deltaY = ev.pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: false,
      subjectEl: this.subjectEl,
      pageX: ev.pageX,
      pageY: ev.pageY,
      deltaX,
      deltaY
    };
  }
  createEventFromTouch(ev, isFirst) {
    let touches = ev.touches;
    let pageX;
    let pageY;
    let deltaX = 0;
    let deltaY = 0;
    if (touches && touches.length) {
      pageX = touches[0].pageX;
      pageY = touches[0].pageY;
    } else {
      pageX = ev.pageX;
      pageY = ev.pageY;
    }
    if (isFirst) {
      this.origPageX = pageX;
      this.origPageY = pageY;
    } else {
      deltaX = pageX - this.origPageX;
      deltaY = pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: true,
      subjectEl: this.subjectEl,
      pageX,
      pageY,
      deltaX,
      deltaY
    };
  }
};
function isPrimaryMouseButton(ev) {
  return ev.button === 0 && !ev.ctrlKey;
}
function startIgnoringMouse() {
  ignoreMouseDepth += 1;
  setTimeout(() => {
    ignoreMouseDepth -= 1;
  }, config2.touchMouseIgnoreWait);
}
function listenerCreated() {
  listenerCnt += 1;
  if (listenerCnt === 1) {
    window.addEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function listenerDestroyed() {
  listenerCnt -= 1;
  if (!listenerCnt) {
    window.removeEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function onWindowTouchMove(ev) {
  if (isWindowTouchMoveCancelled) {
    ev.preventDefault();
  }
}
var ElementMirror = class {
  constructor() {
    this.isVisible = false;
    this.sourceEl = null;
    this.mirrorEl = null;
    this.sourceElRect = null;
    this.parentNode = document.body;
    this.zIndex = 9999;
    this.revertDuration = 0;
  }
  start(sourceEl, pageX, pageY) {
    this.sourceEl = sourceEl;
    this.sourceElRect = this.sourceEl.getBoundingClientRect();
    this.origScreenX = pageX - window.scrollX;
    this.origScreenY = pageY - window.scrollY;
    this.deltaX = 0;
    this.deltaY = 0;
    this.updateElPosition();
  }
  handleMove(pageX, pageY) {
    this.deltaX = pageX - window.scrollX - this.origScreenX;
    this.deltaY = pageY - window.scrollY - this.origScreenY;
    this.updateElPosition();
  }
  // can be called before start
  setIsVisible(bool) {
    if (bool) {
      if (!this.isVisible) {
        if (this.mirrorEl) {
          this.mirrorEl.style.display = "";
        }
        this.isVisible = bool;
        this.updateElPosition();
      }
    } else if (this.isVisible) {
      if (this.mirrorEl) {
        this.mirrorEl.style.display = "none";
      }
      this.isVisible = bool;
    }
  }
  // always async
  stop(needsRevertAnimation, callback) {
    let done = () => {
      this.cleanup();
      callback();
    };
    if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work
    (this.deltaX || this.deltaY)) {
      this.doRevertAnimation(done, this.revertDuration);
    } else {
      setTimeout(done, 0);
    }
  }
  doRevertAnimation(callback, revertDuration) {
    let mirrorEl = this.mirrorEl;
    let finalSourceElRect = this.sourceEl.getBoundingClientRect();
    mirrorEl.style.transition = "top " + revertDuration + "ms,left " + revertDuration + "ms";
    applyStyle(mirrorEl, {
      left: finalSourceElRect.left,
      top: finalSourceElRect.top
    });
    whenTransitionDone(mirrorEl, () => {
      mirrorEl.style.transition = "";
      callback();
    });
  }
  cleanup() {
    if (this.mirrorEl) {
      removeElement(this.mirrorEl);
      this.mirrorEl = null;
    }
    this.sourceEl = null;
  }
  updateElPosition() {
    if (this.sourceEl && this.isVisible) {
      applyStyle(this.getMirrorEl(), {
        left: this.sourceElRect.left + this.deltaX,
        top: this.sourceElRect.top + this.deltaY
      });
    }
  }
  getMirrorEl() {
    let sourceElRect = this.sourceElRect;
    let mirrorEl = this.mirrorEl;
    if (!mirrorEl) {
      mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true);
      mirrorEl.style.userSelect = "none";
      mirrorEl.style.webkitUserSelect = "none";
      mirrorEl.style.pointerEvents = "none";
      mirrorEl.classList.add("fc-event-dragging");
      applyStyle(mirrorEl, {
        position: "fixed",
        zIndex: this.zIndex,
        visibility: "",
        boxSizing: "border-box",
        width: sourceElRect.right - sourceElRect.left,
        height: sourceElRect.bottom - sourceElRect.top,
        right: "auto",
        bottom: "auto",
        margin: 0
      });
      this.parentNode.appendChild(mirrorEl);
    }
    return mirrorEl;
  }
};
var ScrollGeomCache = class extends ScrollController {
  constructor(scrollController, doesListening) {
    super();
    this.handleScroll = () => {
      this.scrollTop = this.scrollController.getScrollTop();
      this.scrollLeft = this.scrollController.getScrollLeft();
      this.handleScrollChange();
    };
    this.scrollController = scrollController;
    this.doesListening = doesListening;
    this.scrollTop = this.origScrollTop = scrollController.getScrollTop();
    this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();
    this.scrollWidth = scrollController.getScrollWidth();
    this.scrollHeight = scrollController.getScrollHeight();
    this.clientWidth = scrollController.getClientWidth();
    this.clientHeight = scrollController.getClientHeight();
    this.clientRect = this.computeClientRect();
    if (this.doesListening) {
      this.getEventTarget().addEventListener("scroll", this.handleScroll);
    }
  }
  destroy() {
    if (this.doesListening) {
      this.getEventTarget().removeEventListener("scroll", this.handleScroll);
    }
  }
  getScrollTop() {
    return this.scrollTop;
  }
  getScrollLeft() {
    return this.scrollLeft;
  }
  setScrollTop(top) {
    this.scrollController.setScrollTop(top);
    if (!this.doesListening) {
      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
      this.handleScrollChange();
    }
  }
  setScrollLeft(top) {
    this.scrollController.setScrollLeft(top);
    if (!this.doesListening) {
      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
      this.handleScrollChange();
    }
  }
  getClientWidth() {
    return this.clientWidth;
  }
  getClientHeight() {
    return this.clientHeight;
  }
  getScrollWidth() {
    return this.scrollWidth;
  }
  getScrollHeight() {
    return this.scrollHeight;
  }
  handleScrollChange() {
  }
};
var ElementScrollGeomCache = class extends ScrollGeomCache {
  constructor(el, doesListening) {
    super(new ElementScrollController(el), doesListening);
  }
  getEventTarget() {
    return this.scrollController.el;
  }
  computeClientRect() {
    return computeInnerRect(this.scrollController.el);
  }
};
var WindowScrollGeomCache = class extends ScrollGeomCache {
  constructor(doesListening) {
    super(new WindowScrollController(), doesListening);
  }
  getEventTarget() {
    return window;
  }
  computeClientRect() {
    return {
      left: this.scrollLeft,
      right: this.scrollLeft + this.clientWidth,
      top: this.scrollTop,
      bottom: this.scrollTop + this.clientHeight
    };
  }
  // the window is the only scroll object that changes it's rectangle relative
  // to the document's topleft as it scrolls
  handleScrollChange() {
    this.clientRect = this.computeClientRect();
  }
};
var getTime = typeof performance === "function" ? performance.now : Date.now;
var AutoScroller = class {
  constructor() {
    this.isEnabled = true;
    this.scrollQuery = [window, ".fc-scroller"];
    this.edgeThreshold = 50;
    this.maxVelocity = 300;
    this.pointerScreenX = null;
    this.pointerScreenY = null;
    this.isAnimating = false;
    this.scrollCaches = null;
    this.everMovedUp = false;
    this.everMovedDown = false;
    this.everMovedLeft = false;
    this.everMovedRight = false;
    this.animate = () => {
      if (this.isAnimating) {
        let edge = this.computeBestEdge(this.pointerScreenX + window.scrollX, this.pointerScreenY + window.scrollY);
        if (edge) {
          let now = getTime();
          this.handleSide(edge, (now - this.msSinceRequest) / 1e3);
          this.requestAnimation(now);
        } else {
          this.isAnimating = false;
        }
      }
    };
  }
  start(pageX, pageY, scrollStartEl) {
    if (this.isEnabled) {
      this.scrollCaches = this.buildCaches(scrollStartEl);
      this.pointerScreenX = null;
      this.pointerScreenY = null;
      this.everMovedUp = false;
      this.everMovedDown = false;
      this.everMovedLeft = false;
      this.everMovedRight = false;
      this.handleMove(pageX, pageY);
    }
  }
  handleMove(pageX, pageY) {
    if (this.isEnabled) {
      let pointerScreenX = pageX - window.scrollX;
      let pointerScreenY = pageY - window.scrollY;
      let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
      let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
      if (yDelta < 0) {
        this.everMovedUp = true;
      } else if (yDelta > 0) {
        this.everMovedDown = true;
      }
      if (xDelta < 0) {
        this.everMovedLeft = true;
      } else if (xDelta > 0) {
        this.everMovedRight = true;
      }
      this.pointerScreenX = pointerScreenX;
      this.pointerScreenY = pointerScreenY;
      if (!this.isAnimating) {
        this.isAnimating = true;
        this.requestAnimation(getTime());
      }
    }
  }
  stop() {
    if (this.isEnabled) {
      this.isAnimating = false;
      for (let scrollCache of this.scrollCaches) {
        scrollCache.destroy();
      }
      this.scrollCaches = null;
    }
  }
  requestAnimation(now) {
    this.msSinceRequest = now;
    requestAnimationFrame(this.animate);
  }
  handleSide(edge, seconds) {
    let { scrollCache } = edge;
    let { edgeThreshold } = this;
    let invDistance = edgeThreshold - edge.distance;
    let velocity = (
      // the closer to the edge, the faster we scroll
      invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic
      this.maxVelocity * seconds
    );
    let sign = 1;
    switch (edge.name) {
      case "left":
        sign = -1;
      case "right":
        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
        break;
      case "top":
        sign = -1;
      case "bottom":
        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
        break;
    }
  }
  // left/top are relative to document topleft
  computeBestEdge(left, top) {
    let { edgeThreshold } = this;
    let bestSide = null;
    let scrollCaches = this.scrollCaches || [];
    for (let scrollCache of scrollCaches) {
      let rect = scrollCache.clientRect;
      let leftDist = left - rect.left;
      let rightDist = rect.right - left;
      let topDist = top - rect.top;
      let bottomDist = rect.bottom - top;
      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
        if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {
          bestSide = { scrollCache, name: "top", distance: topDist };
        }
        if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {
          bestSide = { scrollCache, name: "bottom", distance: bottomDist };
        }
        if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {
          bestSide = { scrollCache, name: "left", distance: leftDist };
        }
        if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {
          bestSide = { scrollCache, name: "right", distance: rightDist };
        }
      }
    }
    return bestSide;
  }
  buildCaches(scrollStartEl) {
    return this.queryScrollEls(scrollStartEl).map((el) => {
      if (el === window) {
        return new WindowScrollGeomCache(false);
      }
      return new ElementScrollGeomCache(el, false);
    });
  }
  queryScrollEls(scrollStartEl) {
    let els = [];
    for (let query of this.scrollQuery) {
      if (typeof query === "object") {
        els.push(query);
      } else {
        els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));
      }
    }
    return els;
  }
};
var FeaturefulElementDragging = class extends ElementDragging {
  constructor(containerEl, selector) {
    super(containerEl);
    this.containerEl = containerEl;
    this.delay = null;
    this.minDistance = 0;
    this.touchScrollAllowed = true;
    this.mirrorNeedsRevert = false;
    this.isInteracting = false;
    this.isDragging = false;
    this.isDelayEnded = false;
    this.isDistanceSurpassed = false;
    this.delayTimeoutId = null;
    this.onPointerDown = (ev) => {
      if (!this.isDragging) {
        this.isInteracting = true;
        this.isDelayEnded = false;
        this.isDistanceSurpassed = false;
        preventSelection(document.body);
        preventContextMenu(document.body);
        if (!ev.isTouch) {
          ev.origEvent.preventDefault();
        }
        this.emitter.trigger("pointerdown", ev);
        if (this.isInteracting && // not destroyed via pointerdown handler
        !this.pointer.shouldIgnoreMove) {
          this.mirror.setIsVisible(false);
          this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY);
          this.startDelay(ev);
          if (!this.minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
      }
    };
    this.onPointerMove = (ev) => {
      if (this.isInteracting) {
        this.emitter.trigger("pointermove", ev);
        if (!this.isDistanceSurpassed) {
          let minDistance = this.minDistance;
          let distanceSq;
          let { deltaX, deltaY } = ev;
          distanceSq = deltaX * deltaX + deltaY * deltaY;
          if (distanceSq >= minDistance * minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
        if (this.isDragging) {
          if (ev.origEvent.type !== "scroll") {
            this.mirror.handleMove(ev.pageX, ev.pageY);
            this.autoScroller.handleMove(ev.pageX, ev.pageY);
          }
          this.emitter.trigger("dragmove", ev);
        }
      }
    };
    this.onPointerUp = (ev) => {
      if (this.isInteracting) {
        this.isInteracting = false;
        allowSelection(document.body);
        allowContextMenu(document.body);
        this.emitter.trigger("pointerup", ev);
        if (this.isDragging) {
          this.autoScroller.stop();
          this.tryStopDrag(ev);
        }
        if (this.delayTimeoutId) {
          clearTimeout(this.delayTimeoutId);
          this.delayTimeoutId = null;
        }
      }
    };
    let pointer = this.pointer = new PointerDragging(containerEl);
    pointer.emitter.on("pointerdown", this.onPointerDown);
    pointer.emitter.on("pointermove", this.onPointerMove);
    pointer.emitter.on("pointerup", this.onPointerUp);
    if (selector) {
      pointer.selector = selector;
    }
    this.mirror = new ElementMirror();
    this.autoScroller = new AutoScroller();
  }
  destroy() {
    this.pointer.destroy();
    this.onPointerUp({});
  }
  startDelay(ev) {
    if (typeof this.delay === "number") {
      this.delayTimeoutId = setTimeout(() => {
        this.delayTimeoutId = null;
        this.handleDelayEnd(ev);
      }, this.delay);
    } else {
      this.handleDelayEnd(ev);
    }
  }
  handleDelayEnd(ev) {
    this.isDelayEnded = true;
    this.tryStartDrag(ev);
  }
  handleDistanceSurpassed(ev) {
    this.isDistanceSurpassed = true;
    this.tryStartDrag(ev);
  }
  tryStartDrag(ev) {
    if (this.isDelayEnded && this.isDistanceSurpassed) {
      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
        this.isDragging = true;
        this.mirrorNeedsRevert = false;
        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
        this.emitter.trigger("dragstart", ev);
        if (this.touchScrollAllowed === false) {
          this.pointer.cancelTouchScroll();
        }
      }
    }
  }
  tryStopDrag(ev) {
    this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
  }
  stopDrag(ev) {
    this.isDragging = false;
    this.emitter.trigger("dragend", ev);
  }
  // fill in the implementations...
  setIgnoreMove(bool) {
    this.pointer.shouldIgnoreMove = bool;
  }
  setMirrorIsVisible(bool) {
    this.mirror.setIsVisible(bool);
  }
  setMirrorNeedsRevert(bool) {
    this.mirrorNeedsRevert = bool;
  }
  setAutoScrollEnabled(bool) {
    this.autoScroller.isEnabled = bool;
  }
};
var OffsetTracker = class {
  constructor(el) {
    this.el = el;
    this.origRect = computeRect(el);
    this.scrollCaches = getClippingParents(el).map((scrollEl) => new ElementScrollGeomCache(scrollEl, true));
  }
  destroy() {
    for (let scrollCache of this.scrollCaches) {
      scrollCache.destroy();
    }
  }
  computeLeft() {
    let left = this.origRect.left;
    for (let scrollCache of this.scrollCaches) {
      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
    }
    return left;
  }
  computeTop() {
    let top = this.origRect.top;
    for (let scrollCache of this.scrollCaches) {
      top += scrollCache.origScrollTop - scrollCache.getScrollTop();
    }
    return top;
  }
  isWithinClipping(pageX, pageY) {
    let point = { left: pageX, top: pageY };
    for (let scrollCache of this.scrollCaches) {
      if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {
        return false;
      }
    }
    return true;
  }
};
function isIgnoredClipping(node) {
  let tagName = node.tagName;
  return tagName === "HTML" || tagName === "BODY";
}
var HitDragging = class {
  constructor(dragging, droppableStore) {
    this.useSubjectCenter = false;
    this.requireInitial = true;
    this.disablePointCheck = false;
    this.initialHit = null;
    this.movingHit = null;
    this.finalHit = null;
    this.handlePointerDown = (ev) => {
      let { dragging: dragging2 } = this;
      this.initialHit = null;
      this.movingHit = null;
      this.finalHit = null;
      this.prepareHits();
      this.processFirstCoord(ev);
      if (this.initialHit || !this.requireInitial) {
        dragging2.setIgnoreMove(false);
        this.emitter.trigger("pointerdown", ev);
      } else {
        dragging2.setIgnoreMove(true);
      }
    };
    this.handleDragStart = (ev) => {
      this.emitter.trigger("dragstart", ev);
      this.handleMove(ev, true);
    };
    this.handleDragMove = (ev) => {
      this.emitter.trigger("dragmove", ev);
      this.handleMove(ev);
    };
    this.handlePointerUp = (ev) => {
      this.releaseHits();
      this.emitter.trigger("pointerup", ev);
    };
    this.handleDragEnd = (ev) => {
      if (this.movingHit) {
        this.emitter.trigger("hitupdate", null, true, ev);
      }
      this.finalHit = this.movingHit;
      this.movingHit = null;
      this.emitter.trigger("dragend", ev);
    };
    this.droppableStore = droppableStore;
    dragging.emitter.on("pointerdown", this.handlePointerDown);
    dragging.emitter.on("dragstart", this.handleDragStart);
    dragging.emitter.on("dragmove", this.handleDragMove);
    dragging.emitter.on("pointerup", this.handlePointerUp);
    dragging.emitter.on("dragend", this.handleDragEnd);
    this.dragging = dragging;
    this.emitter = new Emitter();
  }
  // sets initialHit
  // sets coordAdjust
  processFirstCoord(ev) {
    let origPoint = { left: ev.pageX, top: ev.pageY };
    let adjustedPoint = origPoint;
    let subjectEl = ev.subjectEl;
    let subjectRect;
    if (subjectEl instanceof HTMLElement) {
      subjectRect = computeRect(subjectEl);
      adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
    }
    let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
    if (initialHit) {
      if (this.useSubjectCenter && subjectRect) {
        let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);
        if (slicedSubjectRect) {
          adjustedPoint = getRectCenter(slicedSubjectRect);
        }
      }
      this.coordAdjust = diffPoints(adjustedPoint, origPoint);
    } else {
      this.coordAdjust = { left: 0, top: 0 };
    }
  }
  handleMove(ev, forceHandle) {
    let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
      this.movingHit = hit;
      this.emitter.trigger("hitupdate", hit, false, ev);
    }
  }
  prepareHits() {
    this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings) => {
      interactionSettings.component.prepareHits();
      return new OffsetTracker(interactionSettings.el);
    });
  }
  releaseHits() {
    let { offsetTrackers } = this;
    for (let id in offsetTrackers) {
      offsetTrackers[id].destroy();
    }
    this.offsetTrackers = {};
  }
  queryHitForOffset(offsetLeft, offsetTop) {
    let { droppableStore, offsetTrackers } = this;
    let bestHit = null;
    for (let id in droppableStore) {
      let component = droppableStore[id].component;
      let offsetTracker = offsetTrackers[id];
      if (offsetTracker && // wasn't destroyed mid-drag
      offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
        let originLeft = offsetTracker.computeLeft();
        let originTop = offsetTracker.computeTop();
        let positionLeft = offsetLeft - originLeft;
        let positionTop = offsetTop - originTop;
        let { origRect } = offsetTracker;
        let width = origRect.right - origRect.left;
        let height = origRect.bottom - origRect.top;
        if (
          // must be within the element's bounds
          positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height
        ) {
          let hit = component.queryHit(positionLeft, positionTop, width, height);
          if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell
          rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && // Ensure the component we are querying for the hit is accessibly my the pointer
          // Prevents obscured calendars (ex: under a modal dialog) from accepting hit
          // https://github.com/fullcalendar/fullcalendar/issues/5026
          (this.disablePointCheck || offsetTracker.el.contains(document.elementFromPoint(
            // add-back origins to get coordinate relative to top-left of window viewport
            positionLeft + originLeft - window.scrollX,
            positionTop + originTop - window.scrollY
          ))) && (!bestHit || hit.layer > bestHit.layer)) {
            hit.componentId = id;
            hit.context = component.context;
            hit.rect.left += originLeft;
            hit.rect.right += originLeft;
            hit.rect.top += originTop;
            hit.rect.bottom += originTop;
            bestHit = hit;
          }
        }
      }
    }
    return bestHit;
  }
};
function isHitsEqual(hit0, hit1) {
  if (!hit0 && !hit1) {
    return true;
  }
  if (Boolean(hit0) !== Boolean(hit1)) {
    return false;
  }
  return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
}
function buildDatePointApiWithContext(dateSpan, context2) {
  let props = {};
  for (let transform of context2.pluginHooks.datePointTransforms) {
    Object.assign(props, transform(dateSpan, context2));
  }
  Object.assign(props, buildDatePointApi(dateSpan, context2.dateEnv));
  return props;
}
function buildDatePointApi(span, dateEnv) {
  return {
    date: dateEnv.toDate(span.range.start),
    dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
    allDay: span.allDay
  };
}
var DateClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handlePointerDown = (pev) => {
      let { dragging } = this;
      let downEl = pev.origEvent.target;
      dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));
    };
    this.handleDragEnd = (ev) => {
      let { component } = this;
      let { pointer } = this.dragging;
      if (!pointer.wasTouchScroll) {
        let { initialHit, finalHit } = this.hitDragging;
        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
          let { context: context2 } = component;
          let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context2)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context2.viewApi || context2.calendarApi.view });
          context2.emitter.trigger("dateClick", arg);
        }
      }
    };
    this.dragging = new FeaturefulElementDragging(settings.el);
    this.dragging.autoScroller.isEnabled = false;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
};
var DateSelecting = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.dragSelection = null;
    this.handlePointerDown = (ev) => {
      let { component: component2, dragging: dragging2 } = this;
      let { options: options2 } = component2.context;
      let canSelect = options2.selectable && component2.isValidDateDownEl(ev.origEvent.target);
      dragging2.setIgnoreMove(!canSelect);
      dragging2.delay = ev.isTouch ? getComponentTouchDelay$1(component2) : null;
    };
    this.handleDragStart = (ev) => {
      this.component.context.calendarApi.unselect(ev);
    };
    this.handleHitUpdate = (hit, isFinal) => {
      let { context: context2 } = this.component;
      let dragSelection = null;
      let isInvalid = false;
      if (hit) {
        let initialHit = this.hitDragging.initialHit;
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          dragSelection = joinHitsIntoSelection(initialHit, hit, context2.pluginHooks.dateSelectionTransformers);
        }
        if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context2)) {
          isInvalid = true;
          dragSelection = null;
        }
      }
      if (dragSelection) {
        context2.dispatch({ type: "SELECT_DATES", selection: dragSelection });
      } else if (!isFinal) {
        context2.dispatch({ type: "UNSELECT_DATES" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        this.dragSelection = dragSelection;
      }
    };
    this.handlePointerUp = (pev) => {
      if (this.dragSelection) {
        triggerDateSelect(this.dragSelection, pev, this.component.context);
        this.dragSelection = null;
      }
    };
    let { component } = settings;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.touchScrollAllowed = false;
    dragging.minDistance = options.selectMinDistance || 0;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
  }
  destroy() {
    this.dragging.destroy();
  }
};
function getComponentTouchDelay$1(component) {
  let { options } = component.context;
  let delay = options.selectLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let ms = [
    dateSpan0.range.start,
    dateSpan0.range.end,
    dateSpan1.range.start,
    dateSpan1.range.end
  ];
  ms.sort(compareNumbers);
  let props = {};
  for (let transformer of dateSelectionTransformers) {
    let res = transformer(hit0, hit1);
    if (res === false) {
      return null;
    }
    if (res) {
      Object.assign(props, res);
    }
  }
  props.range = { start: ms[0], end: ms[3] };
  props.allDay = dateSpan0.allDay;
  return props;
}
var EventDragging = class _EventDragging extends Interaction {
  constructor(settings) {
    super(settings);
    this.subjectEl = null;
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let origTarget = ev.origEvent.target;
      let { component: component2, dragging: dragging2 } = this;
      let { mirror } = dragging2;
      let { options: options2 } = component2.context;
      let initialContext = component2.context;
      this.subjectEl = ev.subjectEl;
      let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);
      let eventRange = this.eventRange = subjectSeg.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
      dragging2.minDistance = ev.isTouch ? 0 : options2.eventDragMinDistance;
      dragging2.delay = // only do a touch delay if touch and this event hasn't been selected yet
      ev.isTouch && eventInstanceId !== component2.props.eventSelection ? getComponentTouchDelay(component2) : null;
      if (options2.fixedMirrorParent) {
        mirror.parentNode = options2.fixedMirrorParent;
      } else {
        mirror.parentNode = elementClosest(origTarget, ".fc");
      }
      mirror.revertDuration = options2.dragRevertDuration;
      let isValid = component2.isValidSegDownEl(origTarget) && !elementClosest(origTarget, ".fc-event-resizer");
      dragging2.setIgnoreMove(!isValid);
      this.isDragging = isValid && ev.subjectEl.classList.contains("fc-event-draggable");
    };
    this.handleDragStart = (ev) => {
      let initialContext = this.component.context;
      let eventRange = this.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      if (ev.isTouch) {
        if (eventInstanceId !== this.component.props.eventSelection) {
          initialContext.dispatch({ type: "SELECT_EVENT", eventInstanceId });
        }
      } else {
        initialContext.dispatch({ type: "UNSELECT_EVENT" });
      }
      if (this.isDragging) {
        initialContext.calendarApi.unselect(ev);
        initialContext.emitter.trigger("eventDragStart", {
          el: this.subjectEl,
          event: new EventImpl(initialContext, eventRange.def, eventRange.instance),
          jsEvent: ev.origEvent,
          view: initialContext.viewApi
        });
      }
    };
    this.handleHitUpdate = (hit, isFinal) => {
      if (!this.isDragging) {
        return;
      }
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let initialContext = this.component.context;
      let receivingContext = null;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        receivingContext = hit.context;
        let receivingOptions = receivingContext.options;
        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {
          mutation = computeEventMutation(initialHit, hit, this.eventRange.instance.range.start, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
          if (mutation) {
            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
            interaction.mutatedEvents = mutatedRelevantEvents;
            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
              isInvalid = true;
              mutation = null;
              mutatedRelevantEvents = null;
              interaction.mutatedEvents = createEmptyEventStore();
            }
          }
        } else {
          receivingContext = null;
        }
      }
      this.displayDrag(receivingContext, interaction);
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (initialContext === receivingContext && // TODO: write test for this
        isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.dragging.setMirrorNeedsRevert(!mutation);
        this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector(".fc-event-mirror"));
        this.receivingContext = receivingContext;
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handlePointerUp = () => {
      if (!this.isDragging) {
        this.cleanup();
      }
    };
    this.handleDragEnd = (ev) => {
      if (this.isDragging) {
        let initialContext = this.component.context;
        let initialView = initialContext.viewApi;
        let { receivingContext, validMutation } = this;
        let eventDef = this.eventRange.def;
        let eventInstance = this.eventRange.instance;
        let eventApi = new EventImpl(initialContext, eventDef, eventInstance);
        let relevantEvents = this.relevantEvents;
        let mutatedRelevantEvents = this.mutatedRelevantEvents;
        let { finalHit } = this.hitDragging;
        this.clearDrag();
        initialContext.emitter.trigger("eventDragStop", {
          el: this.subjectEl,
          event: eventApi,
          jsEvent: ev.origEvent,
          view: initialView
        });
        if (validMutation) {
          if (receivingContext === initialContext) {
            let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
            initialContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventChangeArg = {
              oldEvent: eventApi,
              event: updatedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                  // the pre-change data
                });
              }
            };
            let transformed = {};
            for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers) {
              Object.assign(transformed, transformer(validMutation, initialContext));
            }
            initialContext.emitter.trigger("eventDrop", Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));
            initialContext.emitter.trigger("eventChange", eventChangeArg);
          } else if (receivingContext) {
            let eventRemoveArg = {
              event: eventApi,
              relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                });
              }
            };
            initialContext.emitter.trigger("eventLeave", Object.assign(Object.assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));
            initialContext.dispatch({
              type: "REMOVE_EVENTS",
              eventStore: relevantEvents
            });
            initialContext.emitter.trigger("eventRemove", eventRemoveArg);
            let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];
            let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];
            let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);
            receivingContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventAddArg = {
              event: addedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),
              revert() {
                receivingContext.dispatch({
                  type: "REMOVE_EVENTS",
                  eventStore: mutatedRelevantEvents
                });
              }
            };
            receivingContext.emitter.trigger("eventAdd", eventAddArg);
            if (ev.isTouch) {
              receivingContext.dispatch({
                type: "SELECT_EVENT",
                eventInstanceId: eventInstance.instanceId
              });
            }
            receivingContext.emitter.trigger("drop", Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));
            receivingContext.emitter.trigger("eventReceive", Object.assign(Object.assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));
          }
        } else {
          initialContext.emitter.trigger("_noEventDrop");
        }
      }
      this.cleanup();
    };
    let { component } = this;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = _EventDragging.SELECTOR;
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);
    hitDragging.useSubjectCenter = settings.useEventCenter;
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  // render a drag state on the next receivingCalendar
  displayDrag(nextContext, state) {
    let initialContext = this.component.context;
    let prevContext = this.receivingContext;
    if (prevContext && prevContext !== nextContext) {
      if (prevContext === initialContext) {
        prevContext.dispatch({
          type: "SET_EVENT_DRAG",
          state: {
            affectedEvents: state.affectedEvents,
            mutatedEvents: createEmptyEventStore(),
            isEvent: true
          }
        });
      } else {
        prevContext.dispatch({ type: "UNSET_EVENT_DRAG" });
      }
    }
    if (nextContext) {
      nextContext.dispatch({ type: "SET_EVENT_DRAG", state });
    }
  }
  clearDrag() {
    let initialCalendar = this.component.context;
    let { receivingContext } = this;
    if (receivingContext) {
      receivingContext.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
    if (initialCalendar !== receivingContext) {
      initialCalendar.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
  }
  cleanup() {
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
  }
};
EventDragging.SELECTOR = ".fc-event-draggable, .fc-event-resizable";
function computeEventMutation(hit0, hit1, eventInstanceStart, massagers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let date0 = dateSpan0.range.start;
  let date1 = dateSpan1.range.start;
  let standardProps = {};
  if (dateSpan0.allDay !== dateSpan1.allDay) {
    standardProps.allDay = dateSpan1.allDay;
    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
    if (dateSpan1.allDay) {
      date0 = startOfDay(eventInstanceStart);
    } else {
      date0 = eventInstanceStart;
    }
  }
  let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);
  if (delta.milliseconds) {
    standardProps.allDay = false;
  }
  let mutation = {
    datesDelta: delta,
    standardProps
  };
  for (let massager of massagers) {
    massager(mutation, hit0, hit1);
  }
  return mutation;
}
function getComponentTouchDelay(component) {
  let { options } = component.context;
  let delay = options.eventLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
var EventResizing = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.draggingSegEl = null;
    this.draggingSeg = null;
    this.eventRange = null;
    this.relevantEvents = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let { component: component2 } = this;
      let segEl = this.querySegEl(ev);
      let seg = getElSeg(segEl);
      let eventRange = this.eventRange = seg.eventRange;
      this.dragging.minDistance = component2.context.options.eventDragMinDistance;
      this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);
    };
    this.handleDragStart = (ev) => {
      let { context: context2 } = this.component;
      let eventRange = this.eventRange;
      this.relevantEvents = getRelevantEvents(context2.getCurrentData().eventStore, this.eventRange.instance.instanceId);
      let segEl = this.querySegEl(ev);
      this.draggingSegEl = segEl;
      this.draggingSeg = getElSeg(segEl);
      context2.calendarApi.unselect();
      context2.emitter.trigger("eventResizeStart", {
        el: segEl,
        event: new EventImpl(context2, eventRange.def, eventRange.instance),
        jsEvent: ev.origEvent,
        view: context2.viewApi
      });
    };
    this.handleHitUpdate = (hit, isFinal, ev) => {
      let { context: context2 } = this.component;
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let eventInstance = this.eventRange.instance;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains("fc-event-resizer-start"), eventInstance.range);
        }
      }
      if (mutation) {
        mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context2.getCurrentData().eventUiBases, mutation, context2);
        interaction.mutatedEvents = mutatedRelevantEvents;
        if (!isInteractionValid(interaction, hit.dateProfile, context2)) {
          isInvalid = true;
          mutation = null;
          mutatedRelevantEvents = null;
          interaction.mutatedEvents = null;
        }
      }
      if (mutatedRelevantEvents) {
        context2.dispatch({
          type: "SET_EVENT_RESIZE",
          state: interaction
        });
      } else {
        context2.dispatch({ type: "UNSET_EVENT_RESIZE" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (mutation && isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handleDragEnd = (ev) => {
      let { context: context2 } = this.component;
      let eventDef = this.eventRange.def;
      let eventInstance = this.eventRange.instance;
      let eventApi = new EventImpl(context2, eventDef, eventInstance);
      let relevantEvents = this.relevantEvents;
      let mutatedRelevantEvents = this.mutatedRelevantEvents;
      context2.emitter.trigger("eventResizeStop", {
        el: this.draggingSegEl,
        event: eventApi,
        jsEvent: ev.origEvent,
        view: context2.viewApi
      });
      if (this.validMutation) {
        let updatedEventApi = new EventImpl(context2, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
        context2.dispatch({
          type: "MERGE_EVENTS",
          eventStore: mutatedRelevantEvents
        });
        let eventChangeArg = {
          oldEvent: eventApi,
          event: updatedEventApi,
          relatedEvents: buildEventApis(mutatedRelevantEvents, context2, eventInstance),
          revert() {
            context2.dispatch({
              type: "MERGE_EVENTS",
              eventStore: relevantEvents
              // the pre-change events
            });
          }
        };
        context2.emitter.trigger("eventResize", Object.assign(Object.assign({}, eventChangeArg), { el: this.draggingSegEl, startDelta: this.validMutation.startDelta || createDuration(0), endDelta: this.validMutation.endDelta || createDuration(0), jsEvent: ev.origEvent, view: context2.viewApi }));
        context2.emitter.trigger("eventChange", eventChangeArg);
      } else {
        context2.emitter.trigger("_noEventResize");
      }
      this.draggingSeg = null;
      this.relevantEvents = null;
      this.validMutation = null;
    };
    let { component } = settings;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = ".fc-event-resizer";
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = component.context.options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  querySegEl(ev) {
    return elementClosest(ev.subjectEl, ".fc-event");
  }
};
function computeMutation(hit0, hit1, isFromStart, instanceRange) {
  let dateEnv = hit0.context.dateEnv;
  let date0 = hit0.dateSpan.range.start;
  let date1 = hit1.dateSpan.range.start;
  let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);
  if (isFromStart) {
    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
      return { startDelta: delta };
    }
  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
    return { endDelta: delta };
  }
  return null;
}
var UnselectAuto = class {
  constructor(context2) {
    this.context = context2;
    this.isRecentPointerDateSelect = false;
    this.matchesCancel = false;
    this.matchesEvent = false;
    this.onSelect = (selectInfo) => {
      if (selectInfo.jsEvent) {
        this.isRecentPointerDateSelect = true;
      }
    };
    this.onDocumentPointerDown = (pev) => {
      let unselectCancel = this.context.options.unselectCancel;
      let downEl = getEventTargetViaRoot(pev.origEvent);
      this.matchesCancel = !!elementClosest(downEl, unselectCancel);
      this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR);
    };
    this.onDocumentPointerUp = (pev) => {
      let { context: context3 } = this;
      let { documentPointer: documentPointer2 } = this;
      let calendarState = context3.getCurrentData();
      if (!documentPointer2.wasTouchScroll) {
        if (calendarState.dateSelection && // an existing date selection?
        !this.isRecentPointerDateSelect) {
          let unselectAuto = context3.options.unselectAuto;
          if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {
            context3.calendarApi.unselect(pev);
          }
        }
        if (calendarState.eventSelection && // an existing event selected?
        !this.matchesEvent) {
          context3.dispatch({ type: "UNSELECT_EVENT" });
        }
      }
      this.isRecentPointerDateSelect = false;
    };
    let documentPointer = this.documentPointer = new PointerDragging(document);
    documentPointer.shouldIgnoreMove = true;
    documentPointer.shouldWatchScroll = false;
    documentPointer.emitter.on("pointerdown", this.onDocumentPointerDown);
    documentPointer.emitter.on("pointerup", this.onDocumentPointerUp);
    context2.emitter.on("select", this.onSelect);
  }
  destroy() {
    this.context.emitter.off("select", this.onSelect);
    this.documentPointer.destroy();
  }
};
var OPTION_REFINERS = {
  fixedMirrorParent: identity2
};
var LISTENER_REFINERS = {
  dateClick: identity2,
  eventDragStart: identity2,
  eventDragStop: identity2,
  eventDrop: identity2,
  eventResizeStart: identity2,
  eventResizeStop: identity2,
  eventResize: identity2,
  drop: identity2,
  eventReceive: identity2,
  eventLeave: identity2
};
config2.dataAttrPrefix = "";
var index2 = createPlugin({
  name: "@fullcalendar/interaction",
  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
  calendarInteractions: [UnselectAuto],
  elementDraggingImpl: FeaturefulElementDragging,
  optionRefiners: OPTION_REFINERS,
  listenerRefiners: LISTENER_REFINERS
});

// src/app/calendar/calendar.component.ts
var _c03 = ["calendar"];
var _CalendarComponent = class _CalendarComponent {
  constructor() {
    this.calendarOptions = {
      initialView: "dayGridMonth",
      plugins: [index, index2],
      editable: true,
      selectable: true,
      events: [
        { title: "Event 1", date: "2024-06-20" },
        { title: "Event 2", date: "2024-06-21" }
      ],
      dateClick: this.handleDateClick.bind(this),
      // Obligatorio para el contexto de `this`
      eventClick: this.handleEventClick.bind(this)
    };
  }
  ngOnInit() {
  }
  handleDateClick(arg) {
    const title = prompt("Enter event title:");
    const calendarApi = this.calendarComponent.getApi();
    if (title) {
      calendarApi.addEvent({
        title,
        start: arg.date,
        allDay: arg.allDay
      });
    }
  }
  handleEventClick(arg) {
    const deleteConfirm = confirm(`Are you sure you want to delete the event '${arg.event.title}'?`);
    if (deleteConfirm) {
      arg.event.remove();
    }
  }
};
_CalendarComponent.\u0275fac = function CalendarComponent_Factory(t3) {
  return new (t3 || _CalendarComponent)();
};
_CalendarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _CalendarComponent, selectors: [["app-calendar"]], viewQuery: function CalendarComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c03, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.calendarComponent = _t.first);
  }
}, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 1, consts: [["calendar", ""], [3, "options"]], template: function CalendarComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "full-calendar", 1, 0);
  }
  if (rf & 2) {
    \u0275\u0275property("options", ctx.calendarOptions);
  }
}, dependencies: [CommonModule, FullCalendarModule, FullCalendarComponent] });
var CalendarComponent = _CalendarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(CalendarComponent, { className: "CalendarComponent", filePath: "src\\app\\calendar\\calendar.component.ts", lineNumber: 16 });
})();

// src/app/ubicacion/ubicacion.component.ts
var import_mapbox_gl = __toESM(require_mapbox_gl());

// src/app/geocode.service.ts
var _GeocodingService = class _GeocodingService {
  constructor(http) {
    this.http = http;
    this.geocodeBaseUrl = "https://api.mapbox.com/geocoding/v5/mapbox.places/";
    this.accessToken = "pk.eyJ1IjoibGFlenJhIiwiYSI6ImNseG1jOTBqbjA5Ynkya3NldThoY3JhYWwifQ.WDeqMoFRVHX-Xwnfvj9LMQ";
  }
  // Mtodo para geocodificacin inversa (coordenadas a direccin)
  reverseGeocode(coordinates) {
    const url = `${this.geocodeBaseUrl}${coordinates[0]},${coordinates[1]}.json?access_token=${this.accessToken}`;
    return this.http.get(url).pipe(map((response) => {
      const features = response.features;
      if (features.length > 0) {
        return features[0].place_name;
      } else {
        throw new Error("No se encontraron resultados para las coordenadas proporcionadas.");
      }
    }));
  }
};
_GeocodingService.\u0275fac = function GeocodingService_Factory(t3) {
  return new (t3 || _GeocodingService)(\u0275\u0275inject(HttpClient));
};
_GeocodingService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _GeocodingService, factory: _GeocodingService.\u0275fac, providedIn: "root" });
var GeocodingService = _GeocodingService;

// src/app/ubicacion/ubicacion.component.ts
function UbicacionComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 8)(1, "p");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "button", 9);
    \u0275\u0275listener("click", function UbicacionComponent_div_7_Template_button_click_3_listener() {
      const ubicacion_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.eliminarUbicacion(ubicacion_r2.id));
    });
    \u0275\u0275text(4, "Eliminar Ubicaci\xF3n");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ubicacion_r2 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("Direcci\xF3n: ", ubicacion_r2.name, "");
  }
}
var _UbicacionComponent = class _UbicacionComponent {
  constructor(servicioService, geocodingService) {
    this.servicioService = servicioService;
    this.geocodingService = geocodingService;
    this.markers = [];
    this.ubicaciones = [];
    this.loading = false;
    this.error = "";
  }
  ngOnInit() {
    import_mapbox_gl.default.accessToken = environment.mapbox.accessToken;
    this.map = new import_mapbox_gl.default.Map({
      container: "map",
      style: "mapbox://styles/mapbox/streets-v11",
      center: [2.1734, 41.3851],
      // Coordenadas de Barcelona
      zoom: 12
    });
    this.map.on("load", () => {
      console.log("Map loaded");
    });
    this.map.on("click", (event) => __async(this, null, function* () {
      const { lng, lat } = event.lngLat;
      const marker = new import_mapbox_gl.default.Marker().setLngLat([lng, lat]).addTo(this.map);
      this.markers.push(marker);
      try {
        this.loading = true;
        const address = yield this.getAddressFromCoordinates(lng, lat);
        const ubicacion = { latitude: lat, longitude: lng, name: address };
        yield this.guardarUbicacion(ubicacion);
        this.loading = false;
        this.error = "";
      } catch (error) {
        this.loading = false;
        this.error = "Error al guardar ubicaci\xF3n";
        console.error("Error al obtener la direcci\xF3n o guardar la ubicaci\xF3n:", error);
      }
    }));
    this.cargarUbicaciones();
  }
  ngOnDestroy() {
    if (this.map) {
      this.map.remove();
    }
  }
  getAddressFromCoordinates(lng, lat) {
    return __async(this, null, function* () {
      try {
        const address = yield this.geocodingService.reverseGeocode([lng, lat]).toPromise();
        if (address !== void 0) {
          return address;
        } else {
          throw new Error("No se pudo obtener la direcci\xF3n desde las coordenadas proporcionadas.");
        }
      } catch (error) {
        console.error("Error al obtener la direcci\xF3n:", error);
        throw new Error("No se pudo obtener la direcci\xF3n desde las coordenadas proporcionadas.");
      }
    });
  }
  guardarUbicacion(ubicacion) {
    return __async(this, null, function* () {
      try {
        yield this.servicioService.saveLocation(ubicacion).toPromise();
        this.cargarUbicaciones();
        console.log("Ubicaci\xF3n guardada:", ubicacion);
      } catch (error) {
        throw new Error("Error al guardar ubicaci\xF3n en el servidor.");
      }
    });
  }
  cargarUbicaciones() {
    this.servicioService.getLocations().subscribe((ubicaciones) => {
      this.ubicaciones = ubicaciones.map((ubicacion) => __spreadProps(__spreadValues({}, ubicacion), {
        name: ubicacion.name
        // Aseguramos que 'name' corresponde a la propiedad correcta
      }));
      this.markers.forEach((marker) => marker.remove());
      this.markers = [];
      ubicaciones.forEach((ubicacion) => {
        const marker = new import_mapbox_gl.default.Marker().setLngLat([ubicacion.longitude, ubicacion.latitude]).addTo(this.map);
        this.markers.push(marker);
      });
    }, (error) => {
      console.error("Error al cargar ubicaciones:", error);
    });
  }
  eliminarUbicacion(id) {
    this.servicioService.deleteLocation(id).subscribe(() => {
      console.log("Ubicaci\xF3n eliminada exitosamente.");
      this.markers.forEach((marker) => marker.remove());
      this.markers = [];
      this.cargarUbicaciones();
    }, (error) => {
      console.error("Error al eliminar ubicaci\xF3n:", error);
    });
  }
};
_UbicacionComponent.\u0275fac = function UbicacionComponent_Factory(t3) {
  return new (t3 || _UbicacionComponent)(\u0275\u0275directiveInject(ServicioService), \u0275\u0275directiveInject(GeocodingService));
};
_UbicacionComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _UbicacionComponent, selectors: [["app-ubicacion"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 8, vars: 1, consts: [[1, "container"], [1, "row"], [1, "col-md-8"], [1, "map-container"], ["id", "map", 1, "mapboxgl-map"], [1, "col-md-4"], [1, "ubicaciones-list"], ["class", "ubicacion-item mb-3", 4, "ngFor", "ngForOf"], [1, "ubicacion-item", "mb-3"], [1, "btn", "btn-info", 3, "click"]], template: function UbicacionComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3);
    \u0275\u0275element(4, "div", 4);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "div", 5)(6, "div", 6);
    \u0275\u0275template(7, UbicacionComponent_div_7_Template, 5, 1, "div", 7);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(7);
    \u0275\u0275property("ngForOf", ctx.ubicaciones);
  }
}, dependencies: [CommonModule, NgForOf, HttpClientModule], styles: ["\n\n.map-container[_ngcontent-%COMP%] {\n  display: flex;\n  height: 500px;\n  width: 100%;\n}\n.mapboxgl-map[_ngcontent-%COMP%] {\n  height: 100%;\n  width: 100%;\n  margin: 0 auto;\n}\n/*# sourceMappingURL=ubicacion.component.css.map */"] });
var UbicacionComponent = _UbicacionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(UbicacionComponent, { className: "UbicacionComponent", filePath: "src\\app\\ubicacion\\ubicacion.component.ts", lineNumber: 16 });
})();

// src/app/app.routes.ts
var routes = [
  { path: "", redirectTo: "/home", pathMatch: "full" },
  // Ruta por defecto
  { path: "add", component: AddeditComponent },
  { path: "edit/:id", component: AddeditComponent },
  { path: "home", component: HomeComponent },
  { path: "lista", component: ListComponent },
  { path: "calendario", component: CalendarComponent },
  { path: "ubicacion", component: UbicacionComponent }
];

// src/main.ts
bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes),
    provideHttpClient()
  ]
}).catch((err) => console.error(err));
/*! Bundled license information:

mapbox-gl/dist/mapbox-gl.js:
  (**
   * tiny-lru
   *
   * @copyright 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 11.2.6
   *)

@angular/core/fesm2022/primitives/signals.mjs:
  (**
   * @license Angular v18.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/core.mjs:
  (**
   * @license Angular v18.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/common/fesm2022/common.mjs:
  (**
   * @license Angular v18.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/common/fesm2022/http.mjs:
  (**
   * @license Angular v18.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/platform-browser/fesm2022/platform-browser.mjs:
  (**
   * @license Angular v18.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/router/fesm2022/router.mjs:
  (**
   * @license Angular v18.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v18.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=main.js.map
